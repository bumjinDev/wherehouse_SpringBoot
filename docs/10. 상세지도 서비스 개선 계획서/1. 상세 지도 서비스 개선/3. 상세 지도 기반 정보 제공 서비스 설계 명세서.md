
---

## 문서 정보

**프로젝트명:** 위치 기반 생활 안전·편의 분석 시스템  
**문서 버전:** 1.2  
**작성일:** 2025년 10월 10일  
**작성자:** 정범진

---

## 목차

1. [개요](#1-개요)
2. [일반 요구사항](#2-일반-요구사항)
3. [엔드포인트 명세](#3-엔드포인트-명세)
4. [상태 코드 및 예외 처리](#4-상태-코드-및-예외-처리)
5. [데이터베이스 스키마 및 테이블 구조](#5-데이터베이스-스키마-및-테이블-구조)
6. [점수 산출 상세 로직](#6-점수-산출-상세-로직)
7. [핵심 기능 상세 명세 (F001 ~ F010)](#7-핵심-기능-상세-명세-f001--f010)
8. [주요 구현 특징](#8-주요-구현-특징)
9. [B-Tree 인덱스 활용 아키텍처 설계](#9-b-tree-인덱스-활용-아키텍처-설계)
10. [지오해시 정밀도(Precision) 설계](#10-지오해시-정밀도precision-설계)
11. [비즈니스 기능 구현 - 배치 및 실시간 처리](#11-비즈니스-기능-구현---배치-및-실시간-처리)
12. [구현 기술 스택 및 설정](#12-구현-기술-스택-및-설정)
13. [외부 API 연동 상세](#13-외부-api-연동-상세)
14. [부록 (Appendix)](#14-부록-appendix)

---

## 1. 개요

### 1.1 목적

본 문서는 사용자가 선택한 임의의 지리적 위치에 대한 생활 안전 및 편의성 수준을 종합적으로 분석하고, 데이터 기반의 분석 모델을 통해 객관적인 점수를 제공하는 단일 통합 API 엔드포인트의 기술 명세를 정의한다. 

서버 내부적으로 병렬 데이터 조회, 점수 계산 등 모든 비즈니스 로직을 수행하며, 클라이언트는 좌표 정보만 전달하고 완성된 분석 결과를 수신한다.

### 1.2 범위

본 명세서는 클라이언트가 요청한 단일 좌표에 대해, 서버가 내부 데이터베이스 및 외부 API를 활용하여 안전성 및 편의성을 분석하고 최종 리포트를 제공하는 단일 통합 API 엔드포인트에 대한 요구사항을 다룬다. 

다음 항목을 포함한다:
- API의 요청 파라미터
- 응답 데이터 구조
- 상태 코드
- 예외 처리 방안

---

## 2. 일반 요구사항

### 2.1 데이터 형식
모든 API 요청과 응답의 데이터 형식은 **JSON**(application/json)을 사용한다.

### 2.2 문자 인코딩
모든 데이터는 **UTF-8**로 인코딩한다.

### 2.3 인증
(본 명세서 범위 외)

### 2.4 기본 URL
```
https://{your-domain}
```

---

## 3. 엔드포인트 명세

### 3.1 API 개요

본 시스템은 사용자가 요청한 단일 좌표에 대한 모든 분석 정보를 처리하는 단일 통합 엔드포인트를 제공한다.

| 항목 | 내용 |
|------|------|
| **기능 설명** | 사용자가 요청한 좌표(위도, 경도)를 기반으로, 해당 위치의 생활 안전성 및 편의성을 종합 분석하여 상세 리포트를 제공한다. 서버 내부적으로 병렬 데이터 조회, 점수 계산, 캐싱 등 모든 비즈니스 로직을 수행한다. |
| **HTTP Method** | POST |
| **Endpoint URL** | /api/location-analysis |

### 3.2 요청 명세 (Request)

#### 3.2.1 Request Body Fields

| 필드 | 타입 | 필수 | 설명 | 예시 |
|------|------|------|------|------|
| latitude | Double | ✓ | 분석을 원하는 지점의 위도 | 37.5665 |
| longitude | Double | ✓ | 분석을 원하는 지점의 경도 | 126.9780 |
| radius | Integer | X | 분석 반경 (단위: 미터). 기본값: 500 | 500 |

#### 3.2.2 Request Body 예시

```json
{
  "latitude": 37.5665,
  "longitude": 126.9780,
  "radius": 500
}
```

### 3.3 응답 명세 (Response)

#### 3.3.1 성공 응답: 200 OK

요청이 성공적으로 처리되었을 때 반환되는 JSON 객체.

#### 3.3.2 Response Body 예시

```json
{
  "analysisStatus": "SUCCESS",
  "coordinate": {
    "latitude": 37.5665,
    "longitude": 126.9780
  },
  "address": {
    "roadAddress": "서울특별시 중구 세종대로 110",
    "jibunAddress": "서울특별시 중구 태평로1가 31"
  },
  "safetyScore": {
    "total": 85,
    "policeDistance": 450,
    "cctvCount": 23,
    "cctvList": [
      {
        "address": "서울특별시 중구 세종대로 99",
        "latitude": 37.5658,
        "longitude": 126.9775,
        "cameraCount": 2
      },
      {
        "address": "서울특별시 중구 태평로1가 60",
        "latitude": 37.5662,
        "longitude": 126.9785,
        "cameraCount": 3
      }
    ],
    "arrestRate": 0.87
  },
  "convenienceScore": {
    "total": 72,
    "amenityDetails": [
      {
        "categoryCode": "CS2",
        "categoryName": "편의점",
        "count": 8,
        "closestDistance": 120,
        "places": [
          {
            "name": "GS25 서소문점",
            "latitude": 37.5658,
            "longitude": 126.9775,
            "distance": 120
          },
          {
            "name": "CU 시청역점",
            "latitude": 37.5662,
            "longitude": 126.9785,
            "distance": 180
          }
        ]
      },
      {
        "categoryCode": "CE7",
        "categoryName": "카페",
        "count": 15,
        "closestDistance": 85,
        "places": [
          {
            "name": "스타벅스 시청역점",
            "latitude": 37.5655,
            "longitude": 126.9781,
            "distance": 85
          }
        ]
      }
    ]
  },
  "overallScore": 78,
  "recommendations": [
    "반경 500m 내 CCTV 23대 설치되어 야간 안전성 우수",
    "지하철역 도보 3분 거리로 대중교통이 편리합니다"
  ],
  "warnings": []
}
```

### 3.4 응답 데이터 구조 상세

#### 3.4.1 최상위 응답 구조 (LocationAnalysisResponseDTO)

| 필드 | 타입 | 설명 |
|------|------|------|
| analysisStatus | String | 분석 결과 상태 코드 (4.1 상태 코드 표 참조) |
| coordinate | Object | 요청된 원본 좌표 정보 |
| address | Object | 변환된 주소 정보 |
| safetyScore | Object | 안전성 분석 결과 |
| convenienceScore | Object | 편의성 분석 상세 결과 |
| overallScore | Integer | 안전성과 편의성을 종합한 최종 점수 (0-100) |
| recommendations | Array | 분석 결과를 바탕으로 생성된 추천 근거 문장 목록 (String 배열) |
| warnings | Array | 데이터 조회 시 발생한 부분적 실패에 대한 경고 메시지 목록 (String 배열) |

#### 3.4.2 좌표 구조 (coordinate)

| 필드 | 타입 | 설명 |
|------|------|------|
| latitude | Double | 위도 |
| longitude | Double | 경도 |

#### 3.4.3 주소 구조 (address)

| 필드 | 타입 | 설명 |
|------|------|------|
| roadAddress | String | 도로명 주소 |
| jibunAddress | String | 지번 주소 |

#### 3.4.4 안전성 점수 구조 (safetyScore)

| 필드 | 타입 | 설명 |
|------|------|------|
| total | Integer | 종합 안전성 점수 (0-100) |
| policeDistance | Integer | 가장 가까운 파출소까지의 거리 (미터) |
| cctvCount | Integer | 반경 내 CCTV 총 개수 |
| cctvList | Array | 반경 내 모든 CCTV 상세 정보 배열 (CctvDetailDto 목록) |
| arrestRate | Double | 해당 지역의 평균 검거율 (0.0 ~ 1.0) |
| nearestPoliceOffice | Object | 가장 가까운 파출소의 상세 정보 (PoliceOfficeDto) |

#### 3.4.4.1 CCTV 상세 구조 (cctvList 배열의 각 요소)

| 필드 | 타입 | 설명 |
|------|------|------|
| address | String | CCTV 설치 주소 |
| latitude | Double | CCTV 위치의 위도 |
| longitude | Double | CCTV 위치의 경도 |
| cameraCount | Integer | 해당 위치의 카메라 대수 |

#### 3.4.4.2 파출소 상세 구조 (nearestPoliceOffice)

| 필드 | 타입 | 설명 |
|------|------|------|
| address | String | 파출소 주소 |
| latitude | Double | 파출소 위치의 위도 |
| longitude | Double | 파출소 위치의 경도 |
| distance | Integer | 요청 좌표로부터 파출소까지의 거리 (미터) |

#### 3.4.5 편의성 점수 구조 (convenienceScore)

| 필드 | 타입 | 설명 |
|------|------|------|
| total | Integer | 종합 편의성 점수 (0-100) |
| amenityDetails | Array | 카테고리별 편의시설 상세 정보 배열 |

#### 3.4.6 편의시설 상세 구조 (amenityDetails 배열의 각 요소)

| 필드 | 타입 | 설명 |
|------|------|------|
| categoryCode | String | 카테고리 코드 (예: CS2) |
| categoryName | String | 카테고리 이름 (예: 편의점) |
| count | Integer | 해당 카테고리의 총 장소 개수 |
| closestDistance | Integer | 해당 카테고리 내 가장 가까운 장소까지의 거리 (미터) |
| places | Array | 해당 카테고리에 속한 모든 장소의 상세 정보 배열 |

#### 3.4.7 개별 장소 구조 (places 배열의 각 요소)

| 필드 | 타입 | 설명 |
|------|------|------|
| name | String | 장소 이름 (예: GS25 서소문점) |
| latitude | Double | 장소의 위도 |
| longitude | Double | 장소의 경도 |
| distance | Integer | 요청 좌표로부터 해당 장소까지의 거리 (미터) |

---

## 4. 상태 코드 및 예외 처리

### 4.1 분석 상태 코드 (analysisStatus)

HTTP 상태 코드와 별개로, API 응답 본문 내에 분석 결과의 상세한 상태를 나타내는 `analysisStatus` 코드를 포함한다. 클라이언트는 이 코드를 통해 성공, 부분 성공, 실패 여부를 명확히 구분할 수 있다.

| 코드 | 의미 | 설명 |
|------|------|------|
| SUCCESS | 전체 분석 성공 | 모든 데이터 소스로부터 데이터를 성공적으로 조회하여 완전한 리포트를 생성 |
| PARTIAL_SUCCESS | 부분 분석 성공 | 일부 데이터 조회(예: 편의시설 API)에 실패했으나, 가용한 데이터만으로 부분적인 리포트를 생성. warnings 필드에 실패 사유가 포함됨 |
| ANALYSIS_FAILED | 분석 불가 | 핵심 데이터 조회에 실패하여 유의미한 분석 리포트를 생성할 수 없음 |

### 4.2 HTTP 상태 코드

| HTTP 코드 | 상황 | 응답 Body 예시 |
|-----------|------|----------------|
| 200 OK | 요청 성공 (분석 결과 반환) | analysisStatus가 SUCCESS, PARTIAL_SUCCESS, ANALYSIS_FAILED 중 모든 경우에 해당 |
| 400 Bad Request | 요청 파라미터 오류 | `{"errorCode": "INVALID_PARAMETER", "message": "latitude 파라미터는 -90과 90 사이의 값이어야 합니다."}` |
| 500 Internal Server Error | 서버 내부 로직 오류 | `{"errorCode": "SERVER_ERROR", "message": "요청 처리 중 내부 서버 오류가 발생했습니다."}` |

### 4.3 예외 상황(Edge Case) 처리 방안

#### 4.3.1 상황 1: 일부 데이터 조회 실패 (부분 성공)

**발생 조건**

F002 병렬 데이터 조회 과정에서 어떤 데이터 소스 중 하나 이상(예: 외부 편의시설 API)이 타임아웃 등으로 실패한 경우

**서버 처리**

1. 실패한 작업의 예외를 기록하고, 해당 부분의 점수 계산 로직을 건너뛴다 (예: convenienceScore 계산 생략)
2. `analysisStatus: PARTIAL_SUCCESS`로 설정
3. warnings 배열에 사용자 친화적인 메시지를 추가 (예: "편의시설 정보를 불러오지 못해 편의성 점수는 계산되지 않았습니다.")
4. overallScore 와 실패한 부분의 점수(convenienceScore.total 등)는 null 또는 0으로 처리
5. 성공적으로 조회된 데이터(safetyScore 등)는 정상적으로 포함하여 200 OK로 응답

**클라이언트 처리**

warnings 배열의 내용을 사용자에게 alert 등으로 안내하고, null 값은 화면에 '-' 등으로 표시

#### 4.3.2 상황 2: 핵심 데이터 조회 실패 (분석 불가)

**발생 조건**

점수 계산에 필수적인 핵심 데이터(예: CCTV, 파출소 정보) 조회에 모두 실패하여 유의미한 분석이 불가능한 경우

**서버 처리**

1. `analysisStatus: ANALYSIS_FAILED`로 설정
2. recommendations, safetyScore, convenienceScore 등의 분석 결과 필드는 빈 객체 또는 null로 제공
3. warnings 배열에 분석이 불가능했던 메시지를 포함하여 200 OK로 응답

**클라이언트 처리**

"해당 위치의 정보를 분석할 수 없습니다. 다른 위치를 선택해 주세요." 와 같은 안내 메시지를 표시

---

## 5. 데이터베이스 스키마 및 테이블 구조

### 5.1 CCTV 데이터

**원본 테이블: CCTV**

- **목적**: CCTV 위치 원본 데이터를 저장한다.
- **특징**: 데이터의 최초 출처 (Source of Truth) 역할을 하며, 이 테이블의 데이터를 배치 프로세스에 의해 수정되지 않는다.

| 컬럼명 | 데이터 타입 | NULLABLE | 설명 |
|--------|-------------|----------|------|
| NUMBERS | NUMBER | No | CCTV 관리 번호 (PK) |
| ADDRESS | VARCHAR2(255) | Yes | 주소 |
| LATITUDE | NUMBER | No | 위도 |
| LONGITUDE | NUMBER | No | 경도 |
| CAMERACOUNT | NUMBER | Yes | 카메라 대수 |

**목적 테이블: CCTV_GEO**

- **목적**: 실시간 서비스에서 빠른 조회를 위해 지오해시 인덱싱이 적용된 CCTV 데이터를 저장한다.
- **특징**: 배치 프로세스에 의해 주기적으로 전체 데이터가 삭제(TRUNCATE)되고 재삽입(INSERT)된다.

| 컬럼명 | 데이터 타입 | NULLABLE | 설명 |
|--------|-------------|----------|------|
| NUMBERS | NUMBER | No | CCTV 관리 번호 (PK) |
| ADDRESS | VARCHAR2(255) | Yes | 주소 |
| LATITUDE | NUMBER | No | 위도 |
| LONGITUDE | NUMBER | No | 경도 |
| CAMERACOUNT | NUMBER | Yes | 카메라 대수 |
| geohash_id | VARCHAR2(12) | No | 계산된 지오해시 ID (인덱스) |

※ geohash_id 컬럼 값은 기반으로 B-Tree 인덱스가 생성되어 탐색에 사용된다.

**응답 DTO 매핑:**
- 조회된 CCTV_GEO 테이블의 모든 행(row)은 `SafetyScoreDto.cctvList` 배열의 `CctvDetailDto` 객체로 변환된다.
- 각 CCTV의 ADDRESS, LATITUDE, LONGITUDE, CAMERACOUNT 값이 그대로 응답에 포함되어 클라이언트가 카카오맵에 마커를 표시할 수 있다.

**실제 조회 쿼리 예시:**
```sql
-- 9-Block 그리드 기반 CCTV 전체 정보 조회
SELECT NUMBERS, ADDRESS, LATITUDE, LONGITUDE, CAMERACOUNT, geohash_id
FROM CCTV_GEO
WHERE geohash_id IN ('wydm7p1', 'wydm7p2', 'wydm7p3', 'wydm7p4', 'wydm7p5', 
                     'wydm7p6', 'wydm7p0', 'wydm7nx', 'wydm7nz');

-- 결과: 9개 격자 내 모든 CCTV의 상세 정보 반환
-- 이후 애플리케이션 레이어에서 정확한 반경(500m) 필터링 수행
```

### 5.2 경찰서 데이터

**원본 테이블: POLICE_OFFICE**

- **목적**: 경찰서 위치 원본 데이터를 저장한다.
- **특징**: 데이터의 최초 출처 (Source of Truth) 역할을 하며, 이 테이블은 배치 프로세스에 의해 수정되지 않는다.

| 컬럼명 | 데이터 타입 | NULLABLE | 설명 |
|--------|-------------|----------|------|
| ADDRESS | VARCHAR2(255) | No | 주소 (PK) |
| LATITUDE | NUMBER | No | 위도 |
| LONGITUDE | NUMBER | No | 경도 |

**목적 테이블: POLICE_OFFICE_GEO**

- **목적**: 실시간 서비스에서 빠른 조회를 위해 지오해시 인덱싱이 적용된 경찰서 데이터를 저장한다.
- **특징**: 배치 프로세스에 의해 주기적으로 전체 데이터가 삭제(TRUNCATE)되고 재삽입(INSERT)된다.

| 컬럼명 | 데이터 타입 | NULLABLE | 설명 |
|--------|-------------|----------|------|
| ADDRESS | VARCHAR2(255) | No | 주소 (PK) |
| LATITUDE | NUMBER | No | 위도 |
| LONGITUDE | NUMBER | No | 경도 |
| geohash_id | VARCHAR2(12) | No | 계산된 지오해시 ID (인덱스) |

※ geohash_id 컬럼 값은 기반으로 B-Tree 인덱스가 생성되어 탐색에 사용된다.

### 5.3 ARRESTRATE 테이블 (검거율 데이터)

**테이블명: ARRESTRATE**

| 컬럼명 | 데이터 타입 | NULLABLE | 설명 |
|--------|-------------|----------|------|
| ADDR | VARCHAR2(50) | No | 서울시 구 이름 (예: 종로구, 중구 등) |
| RATE | NUMBER | No | 검거율 (0.0 ~ 1.0 사이의 소수) |

**데이터 예시:**
```
종로구: 0.939777079
중구: 0.866910799
용산구: 0.752969402
...
```

**검거율 산출 근거 (빅데이터 분석 보고서):**
- 검거율 = 5대 범죄 검거 수 소계 / 5대 범죄 발생 건수 소계
- 5대 범죄: 살인, 강도, 강간·강제추행, 절도, 폭력
- 회귀 분석 결과: 시내 주요 기관 수, 인구 수, 인구 밀집도와 상관관계
- Adjusted R²: 0.5097 (50.97% 설명력)
- p-value: 0.0005745 (통계적으로 유의미)

**검거율 조회 방식:**
1. 사용자 좌표 → 주소 변환 (카카오맵 API)
2. 주소에서 '구' 추출 (예: "서울특별시 중구 세종대로 110" → "중구")
3. ARRESTRATE 테이블에서 해당 구의 검거율 조회
4. 조회된 검거율을 안전성 점수 계산에 사용 (가중치 10%)

---

## 6. 점수 산출 상세 로직

본 로직은 기능 F003 (안전성 점수 계산)과 F004 (편의성 점수 계산)의 상세 실행 계획이다.

### 6.1 1단계: 개별 항목 점수화 (0~100점 척도 정규화)

각기 다른 단위(미터, 개수)를 가진 원본 데이터들을, 비교 가능한 0~100점 척도의 점수로 변환(정규화)한다.

### 6.2 안전성 점수 계산

**최종 안전성 점수 (0-100점):**
```
안전성 점수 = (파출소 거리 점수 × 0.3) + (CCTV 개수 점수 × 0.4) + (검거율 × 100 × 0.3)
```

**1) 파출소 거리 점수 (distanceScore)**

실제 구현된 공식:
```javascript
if (distance <= 800) {
    distanceScore = (800 - distance) / 800 × 100
} else {
    distanceScore = 0
}
```
- 800m 이하일 때만 점수 부여
- 거리가 가까울수록 높은 점수 (선형 감소)
- 800m 초과 시 0점

**2) CCTV 개수 점수 (cctvScore)**
```javascript
cctvScore = Math.min(cctvCount / 30, 1) × 100
```
- 최대 임계값: 30개
- 30개 이상이면 만점(100점) 처리

**3) 검거율 점수**
```
검거율 점수 = arrestRate × 100
```
- arrestRate는 0.0 ~ 1.0 사이의 값
- 100을 곱하여 0-100점 척도로 변환

### 6.3 편의성 점수 계산

**카테고리별 가중치 및 최소 개수 (minCount):**

실제 구현에서는 카테고리별로 다른 계산 방식을 적용:

| 카테고리 | 코드 | 계산 방식 | 설명 |
|----------|------|----------|------|
| 지하철역 | SW8 | 거리 기반 (500m 이내 100점) | 대중교통 접근성 |
| 편의점 | CS2 | 인구 만명당 개수 × 10 | 24시간 편의성 |
| 음식점 | FD6 | 개수 × 1 | 외식 편의성 |
| 카페 | CE7 | 개수 × 2 | 문화생활 |
| 대형마트 | MT1 | 개수 × 10 | 대량 구매 |
| 은행 | BK9 | 개수 × 5 | 금융 업무 |
| 공공기관 | PO3 | 개수 × 3 | 행정 업무 |
| 문화시설 | CT1 | 개수 × 4 | 여가 활동 |
| 병원 | HP8 | 거리 + 개수 복합 | 의료 접근성 |
| 약국 | PM9 | 개수 × 8 | 건강 관리 |
| 주차장 | PK6 | 개수 × 3 | 주차 편의 |
| 주유소 | OL7 | 개수 × 5 | 차량 편의 |
| 학교 | SC4 | 개수 × 2 | 교육 시설 |
| 학원 | AC5 | 개수 × 1 | 교육 시설 |
| 관광명소 | AT4 | 개수 × 3 | 관광 자원 |

**점수 계산 상세:**

1. **편의점 (CS2)**
   ```javascript
   categoryScore = Math.min((count / (population / 10000.0)) × 10, 100)
   ```
   - 현재 구의 인구수 기반 계산
   - 인구 만명당 개수를 10배수로 환산

2. **지하철역 (SW8)**
   ```javascript
   if (closestDistance <= 500) {
       categoryScore = 100;
   } else if (closestDistance <= 1000) {
       categoryScore = 100 - ((closestDistance - 500) / 500.0 × 50);
   } else {
       categoryScore = Math.max(0, 50 - ((closestDistance - 1000) / 1000.0 × 50));
   }
   ```

3. **병원 (HP8)**
   ```javascript
   double distanceScore = closestDistance <= 1000 ? 50 : 25;
   double countScore = Math.min(count × 10, 50);
   categoryScore = distanceScore + countScore;
   ```

4. **기타 카테고리**
   ```javascript
   categoryScore = Math.min(count × [카테고리별 상수], 100)
   ```

**종합 편의성 점수:**
```
편의성 점수 = Σ(각 카테고리 점수) / 카테고리 수
```

**구별 인구 데이터:**
- 실제 구현에서는 25개 서울시 구별 인구수가 하드코딩되어 있음
- 기본값: 400,000명 (구 정보를 찾을 수 없는 경우)

### 6.4 종합 점수 (overallScore)

기존 클라이언트 코드(`mouseEvent.js`)의 `(results[0]+results[1])/2` 로직을 그대로 따른다.

```
종합 점수 = (안전성 점수 + 편의성 점수) / 2
```

- 안전성과 편의성을 50:50 비율로 결합
- 최종 점수: 0-100점

**설정 파일 외부화 권장:**
```yaml
# application.yml
scores:
  weights:
    safety: 0.5
    convenience: 0.5
```

---

## 7. 핵심 기능 상세 명세 (F001 ~ F010)

### 7.1 F001: 통합 API 엔드포인트

**구현 위치:** `LocationAnalysisController.java`

**주요 어노테이션**
- `@RestController`: RESTful 웹 서비스 컨트롤러 선언
- `@RequestMapping("/api")`: 기본 경로 설정
- `@RequiredArgsConstructor`: 의존성 주입
- `@Slf4j`: 로깅 처리

**API 구현**
```java
@PostMapping("/location-analysis")
public ResponseEntity<LocationAnalysisResponseDTO> getLocationAnalysis(
    @Valid @RequestBody LocationAnalysisRequestDTO request)
{
    LocationAnalysisResponseDTO response = locationAnalysisService.analyzeLocation(request);
    return ResponseEntity.ok(response);
}
```

**주요 특징**
- `@Valid`: LocationAnalysisRequestDTO에 정의된 Bean Validation 규칙(좌표 범위 등)을 자동으로 검증한다.
- `@RequestBody`: HTTP 요청 본문의 JSON 데이터를 LocationAnalysisRequestDTO 객체로 자동 변환한다.

### 7.2 F002: 병렬 데이터 조회 / F005: 외부 API 서버 통합

이 두 가지 기능의 실제 구현은 `LocationAnalysisServiceImpl.java` 클래스 내 `analyzeLocation` 메서드에서 `CompletableFuture`를 사용하여 구현된다.

**구현 방식:** `CompletableFuture.supplyAsync()`를 사용하여 각 데이터 조회(파출소, CCTV, 주소 변환, 편의시설) 작업을 병렬로 실행한다.

**통합:** `CompletableFuture.allOf()`를 사용하여 모든 비동기 작업이 완료될 때까지 대기 후, 각 결과를 취합하여 최종 응답 DTO를 조립한다.

**외부 API 호출:** 기존에 `amenity.js`에서 클라이언트가 직접 호출했던 카카오맵 API는, 서버에서 Spring의 `WebClient` (또는 `RestTemplate`)를 사용하여 비동기 방식으로 호출한다.

**예시 코드 구조**
```java
// LocationAnalysisServiceImpl.java 예시 코드
public LocationAnalysisResponseDTO analyzeLocation(LocationAnalysisRequestDTO request) {
    // F006: 주소 변환 서비스 (비동기)
    CompletableFuture<AddressDto> addressFuture = CompletableFuture.supplyAsync(() -> 
        kakaoApiService.getAddress(request.getLatitude(), request.getLongitude())
    );
    
    // F002: 내부 데이터 병렬 조회 (비동기)
    CompletableFuture<PoliceOfficeVO> policeFuture = CompletableFuture.supplyAsync(() -> 
        policeOfficeRepository.getClosestPO(request.getLatitude(), request.getLongitude())
    );
    
    // CCTV 전체 정보 조회 (ADDRESS, LATITUDE, LONGITUDE, CAMERACOUNT 포함)
    CompletableFuture<List<CctvVO>> cctvFuture = CompletableFuture.supplyAsync(() -> 
        cctvRepository.getCctv(request.getLatitude(), request.getLongitude())
    );
    
    // F005: 외부 편의시설 API 병렬 호출 (비동기)
    CompletableFuture<List<AmenityDto>> amenityFuture = CompletableFuture.supplyAsync(() -> 
        kakaoApiService.getAmenities(request.getLatitude(), request.getLongitude())
    );
    
    // 모든 비동기 작업이 완료될 때까지 대기
    CompletableFuture.allOf(addressFuture, policeFuture, cctvFuture, amenityFuture);
    
    // 결과 취합 및 점수 계산 로직...
}
```

### 7.3 F003: 안전성 점수 계산 서비스 / F004: 편의성 점수 계산 서비스

점수 계산 로직은 섹션 6에서 정의한 공식을 그대로 구현한다.

### 7.4 F005: 외부 API 연동 상세 (카카오맵 API)

**정확한 엔드포인트 URL:**

- **편의시설 검색:** `https://dapi.kakao.com/v2/local/search/category.json`
- **주소 변환:** `https://dapi.kakao.com/v2/local/geo/coord2address.json`

**인증 방법:**

HTTP Authorization 헤더에 REST API 키를 포함하여 요청한다.

**형식:** `Authorization: KakaoAK ${REST_API_KEY}`

**요청/응답 형식:**

- **요청:** URL 쿼리 파라미터(Query Parameter)를 사용한다.
  - **편의시설 검색 예시:** `GET /v2/local/search/category.json?category_group_code=CS2&x=127.0277&y=37.4980&radius=500`
- **응답:** JSON 형식으로, 응답 데이터는 `documents` 배열 필드에 포함된다.

**에러 핸들링 방법:**

- HTTP 상태 코드로 1차적인 실패를 확인한다 (예: `400 Bad Request`, `401 Unauthorized`).
- 정상 응답(200 OK)이 아닌 경우, 응답 본문의 JSON 객체에 포함된 `errorType`과 `message` 필드를 파싱하여 예외 처리를 수행한다.

### 7.5 F006: 주소 변환 서비스

F005와 동일한 카카오맵 API를 사용하며, coord2address 엔드포인트를 호출한다.

### 7.6 F007: 추천 근거 생성기

점수 계산 로직과 연동하여, 특정 조건을 충족할 때 생성될 메시지 템플릿을 명시한다.

| 조건 | 생성 메시지 템플릿 |
|------|-------------------|
| `safetyScore.policeDistance < 500` | "가장 가까운 파출소까지 **{policeDistance}m**로 치안 접근성이 양호합니다." |
| `safetyScore.cctvCount > 20` | "반경 500m 내 CCTV가 **{cctvCount}대** 설치되어 야간 안전성이 우수합니다." |
| `convenienceScore` 내 지하철역(SW8) 데이터 존재 | "가장 가까운 지하철역까지 **{distance / 80}분** 거리로 대중교통이 편리합니다." (도보 속도 80m/분 기준) |
| `convenienceScore` 내 편의점(CS2) 개수 > 5 | "주변에 **{count}개**의 편의점이 있어 생활 편의성이 높습니다." |

### 7.7 F008: 그리드 기반 응답 캐싱

캐시의 TTL(Time To Live)과 키 구조를 구체적으로 정의한다.

#### 7.7.1 1단계 캐시 (최종 응답 DTO 캐싱)

**TTL: 5분.** 사용자가 동일 지역을 반복적으로 클릭하는 짧은 시간 내의 요청에 대응한다.

**키 구조:** `"dto:" + 7자리 정밀도 지오해시 ID` (예: `"dto:wydm7p1"`)

#### 7.7.2 2단계 캐시 (개별 데이터 캐싱)

**TTL: 24시간.** CCTV, 파출소 등 공공 데이터는 자주 변경되지 않으므로 캐시 유효기간을 길게 설정한다.

**키 구조:** `"data:" + 7자리 정밀도 지오해시 ID + ":" + 데이터 종류` (예: `"data:wydm7p1:cctv"`)

### 7.8 F009: 에러 처리 및 부분 실패 관리

전역 예외 처리는 `GlobalExceptionHandler` 클래스에서 중앙 집중식으로 관리한다.

- `@RestControllerAdvice` 어노테이션으로 클래스 전역의 예외를 중앙에서 처리한다.
- GlobalExceptionHandler에서 예외별로 적절한 HTTP 상태 코드와 에러 메시지를 포함한 JSON 응답을 생성한다.
- `MethodArgumentNotValidException` 발생 시 400 Bad Request 와 함께 `{"errorCode": "INVALID_PARAMETER", ...}` 형태의 응답을 반환한다.
- 그 외 예측하지 못한 서버 오류 발생 시 500 Internal Server Error 와 함께 `{"errorCode": "SERVER_ERROR", ...}` 형태의 응답을 반환한다.

### 7.9 F010: 로깅 및 모니터링

#### 7.9.1 요청 로깅

- 요청 시작: `log.info("=== 위치 분석 요청 시작 (POST /api/location-analysis) ===");`
- 요청 파라미터: `log.info("Request DTO: {}", request);`
- 완료 로깅: `log.info("위치 분석 요청 처리 완료. Status: {}", response.getAnalysisStatus());`

#### 7.9.2 오류 로깅

- GlobalExceptionHandler 에서 예외 발생 시 전체 스택 트레이스를 ERROR 레벨로 로깅한다.
- F010 명세에 따라, 부분 실패 발생 시 WARN 레벨로 실패한 서비스, 입력값, 상세 로깅 전략을 적용한다.

---

## 8. 주요 구현 특징

본 시스템은 높은 성능과 유지보수성을 동시에 확보하기 위해 다음과 같은 주요 구현 특징을 가진다.

### 8.1 실시간 서비스 (Real-time Service)

#### 8.1.1 단일 통합 API

클라이언트의 모든 분석 요청을 처리하는 단일 엔드포인트(POST /api/location-analysis)를 제공하여, 아키텍처를 단순화하고 클라이언트의 복잡성을 최소화한다.

#### 8.1.2 그리드 기반 검색 (Geohash)

사용자의 임의 좌표 요청을 처리하기 위해, 고정된 행정구역이 아닌 수학적인 '9-Block' 그리드를 동적으로 설정하여 데이터 조회 범위를 한정한다. 이는 F008 그리드 기반 캐싱 전략의 핵심 기반이다.

#### 8.1.3 단계별 캐싱 전략

전체 응답(DTO)을 캐싱하는 1단계 캐시와, 각 그리드 셀의 개별 데이터(CCTV 목록 등)를 캐싱하는 2단계 캐시를 조합하여 캐시 적중률과 데이터 재사용성을 극대화한다.

#### 8.1.4 비동기 병렬 처리

CompletableFuture를 사용하여 내부 데이터베이스 조회와 외부 API 호출을 동시에(병렬적으로) 실행함으로써, 전체 응답 대기 시간을 가장 오래 걸리는 단일 작업 시간에 가깝게 최적화한다.

#### 8.1.5 중앙화된 장애 처리

일부 데이터 소스(예: 외부 API)의 조회 실패가 전체 서비스 중단으로 이어지지 않도록 하는 장애 격리 메커니즘을 구현하고, 문제 추적을 위한 상세 로깅 전략을 적용한다.

### 8.2 배치 데이터 처리 (Batch Process)

#### 8.2.1 데이터 사전 처리

배치 프로세스는 원본 테이블(CCTV, POLICE_OFFICE)을 읽어, 모든 위치 데이터에 **geohash_id**를 사전에 계산하여 추가한다.

#### 8.2.2 읽기 최적화 테이블 생성

원본 테이블을 직접 수정하는 대신, geohash_id가 추가된 별도의 읽기 전용 최적화 테이블(CCTV_GEO, POLICE_OFFICE_GEO)을 생성하여 운영 안정성을 확보한다.

#### 8.2.3 B-Tree 인덱싱

생성된 최적화 테이블의 geohash_id 컬럼에 B-Tree 인덱스를 적용하여, 실시간 서비스에서의 빠른 기반 검색 성능을 극대화한다.

### 8.3 데이터 모델 및 비즈니스 로직

#### 8.3.1 데이터 기반 점수 모델

'빅데이터 분석 보고서'에 근거하여 안전성 및 편의성 점수를 산출하는 객관적인 로직을 구현한다.

#### 8.3.2 규칙의 외부화

점수 계산에 사용되는 가중치, 임계값, 추천 근거 메시지 템플릿 등을 별도의 설정 파일로 분리하여, 비즈니스 로직의 유연성과 확장성을 확보한다.

#### 8.3.3 상세 응답 DTO

단순 결과값뿐만 아니라, 클라이언트의 복잡한 UI(개별 마커 표시, 최근접 거리 안내 등)를 완벽하게 지원하기 위한 상세한 데이터 구조를 포함하여 응답한다.

---

## 9. B-Tree 인덱스 활용 아키텍처 설계

### 9.1 아키텍처 목표

수백만 건 이상의 위치 데이터를 대상으로 하는 반복적인 **'근처 찾기'** 연산의 성능을 **데이터 양에 거의 영향을 받지 않는 수준**으로 보장하는 것을 목표로 한다. 이를 위해, 데이터베이스가 가장 효율적으로 처리할 수 있는 B-Tree 인덱스 스캔(Index Scan)을 유도하도록 데이터 모델과 쿼리 전략을 설계한다.

### 9.2 핵심 설계 결정 (상세 명세)

#### 9.2.1 인덱스 대상 컬럼 설계: geohash_id

**데이터 타입:** `VARCHAR2(12)`

**설계 결정:** 지오해시 ID를 저장할 컬럼의 데이터 타입을 가변 길이 문자열인 `VARCHAR2`로 정의하고, 최대 길이를 `12`로 설정한다.

**기술적 근거:**

1. **타입 선택 (`VARCHAR2`):** 지오해시 알고리즘의 결과물은 영문 소문자와 숫자로 구성된 문자열이므로, `VARCHAR2`가 가장 적합한 데이터 타입이다.

2. **길이 설정 (`12`):** 지오해시는 길이에 따라 정밀도가 결정된다. 본 시스템의 핵심 분석 반경인 500m를 고려할 때, 약 150m x 150m 영역을 나타내는 **7자리 정밀도**가 기본 검색 단위로 가장 적합하다. 그러나 국가 전체 데이터(예: 37cm x 18cm의 초정밀 영역)로 확장될 수 있는 유연성을 확보하기 위해, 향후 더 정밀한 분석 기능(예: 메뉴리 케이싱 레벨에서 유명하게 대응할 수 있는 확장성을 확보한다. 실제 검색에 사용되는 정밀도는 애플리케이션 레이어에서 유연하게 제어할 수 있다.

**NULL 제약 조건:** `NOT NULL`

**설계 결정:** 읽기 최적화 데이터(`CCTV_GEO` 등)의 `geohash_id` 컬럼에 `NOT NULL` 제약 조건을 명시한다.

**기술적 근거:** 이 컬럼은 실시간 서비스 애플리케이션 검색의 핵심 조건(Key)으로 사용된다. `NULL` 값이 존재할 경우 인덱스 사용에 예외가 발생할 수 있으며, 데이터의 정합성을 보장하기 위해 모든 행(Row)이 유효한 지오해시 주소를 갖도록 강제한다.

#### 9.2.2 인덱스 종류 선택 및 전략

**인덱스 종류: B-Tree 인덱스**

**설계 결정:** `geohash_id` 컬럼에 표준 **B-Tree 인덱스**를 생성한다.

**기술적 근거 및 대안 분석:**

1. **B-Tree 선택 이유:** 본 시스템의 핵심 쿼리는 `WHERE geohash_id IN (...)` (정확히 일치) 또는 `WHERE geohash_id LIKE 'wydm7%'` (접두사 일치) 형태가 될 것이다. B-Tree 인덱스는 이 두 가지 형태의 조건(Equality and Range Scans)에 대해 매우 효율적으로 동작하므로 가장 적절한 선택이다.

2. **Hash 인덱스와의 비교:** Hash 인덱스는 오직 `=` 연산자를 사용한 정확한 일치 검색에만 특화되어 있다. 향후 더 넓은 지역을 검색하기 위해 `LIKE 'wydm%'` 와 같은 접두사 기반 검색이 필요할 수 있으므로, Hash 인덱스는 본 설계의 요구사항을 충족하지 못한다.

3. **공간 인덱스(Spatial Index)와의 비교:** 본 아키텍처의 핵심 목표는 비용이 높은 2차원 공간 연산을 회피하는 것이다. 공간 인덱스를 직접 사용하는 대신, 지오해시를 통해 공간 문제를 1차원 문자열 문제로 변환(Transform)하고, 이 변환된 문제에 가장 효율적인 B-Tree 인덱스를 사용하는 것이 본 설계의 핵심 전략이다.

**인덱스 고유성(Uniqueness): 비고유 인덱스(Non-Unique Index)**

**설계 결정:** B-Tree 인덱스를 비고유(Non-Unique) 인덱스로 생성한다.

**기술적 근거:** 하나의 지오해시 격자 영역(예: `wydm7p`)안에는 다수의 데이터(예: 여러 개의 CCTV)가 존재할 수 있다. 따라서 `geohash_id` 컬럼의 값은 중복이 허용되어야 하므로, 고유 인덱스가 아닌 비고유 인덱스로 설계한다.

### 9.3 인덱스 스캔 유도 쿼리 전략

#### 9.3.1 정확히 일치 검색 (Equality Scan)

**쿼리 패턴:**
```sql
SELECT * FROM CCTV_GEO WHERE geohash_id = 'wydm7p';
```

**동작 원리:**
- 데이터베이스 옵티마이저는 `geohash_id` 컬럼의 B-Tree 인덱스를 자동으로 사용한다.
- 인덱스의 루트 노드부터 시작하여 이진 탐색(Binary Search) 방식으로 `'wydm7p'` 값을 가진 리프 노드를 찾는다.
- 리프 노드에서 해당 값을 가진 모든 행의 ROWID를 수집한 후, 실제 데이터 블록에서 행을 조회한다.

**최적화 포인트:**
- `geohash_id` 컬럼에 인덱스가 없을 경우, 데이터베이스는 전체 테이블 스캔(Full Table Scan)을 수행하여 성능이 크게 저하된다.
- 인덱스를 사용하면 수백만 건의 데이터에서도 수십 ms 이내로 응답 시간을 보장할 수 있다.

#### 9.3.2 접두사 일치 검색 (Range Scan / LIKE 패턴)

**쿼리 패턴:**
```sql
SELECT * FROM CCTV_GEO WHERE geohash_id LIKE 'wydm7%';
```

**동작 원리:**
- `LIKE 'wydm7%'` 패턴은 B-Tree 인덱스에서 **Range Scan**으로 최적화된다.
- 데이터베이스는 `'wydm7'`로 시작하는 첫 번째 키를 인덱스에서 찾은 후, `'wydm7'`로 시작하지 않는 첫 번째 키를 만날 때까지 순차적으로 인덱스를 스캔한다.

**주의사항:**
- `LIKE '%wydm7'` 또는 `LIKE '%wydm7%'` 와 같이 와일드카드가 접두사에 위치하면 인덱스를 사용할 수 없다.
- 본 시스템의 검색 패턴은 항상 **접두사 일치**이므로, 이러한 문제는 발생하지 않는다.

#### 9.3.3 IN 절을 이용한 다중 격자 검색

**쿼리 패턴:**
```sql
SELECT * FROM CCTV_GEO 
WHERE geohash_id IN ('wydm7p', 'wydm7n', 'wydm7q', ...);
```

**동작 원리:**
- 데이터베이스는 IN 절의 각 값에 대해 개별적으로 인덱스 검색을 수행한다.
- 각 격자 ID마다 효율적으로 해당 데이터를 찾고, 결과를 통합한다.
- 9-Block 그리드 검색에서 최대 9번의 인덱스 스캔이 발생하지만, 각각이 매우 빠르게 수행되므로 전체적으로 여전히 매우 효율적이다.

**최적화 포인트:**
- IN 절의 값 개수가 적을수록(예: 9개) 성능이 우수하다.
- 데이터베이스 옵티마이저는 IN 절을 여러 개의 OR 조건으로 변환하여 처리하며, B-Tree 인덱스를 효율적으로 활용한다.

### 9.4 인덱스 생성 및 관리 전략

#### 9.4.1 인덱스 생성 시점

**배치 프로세스에서 생성:**
- ETL 프로세스(GeohashIndexingEtlProcessor)가 `_GEO` 테이블에 모든 데이터를 적재한 후, `CREATE INDEX` 구문을 실행하여 인덱스를 생성한다.
- 데이터 삽입 후 인덱스를 생성하는 것이 데이터 삽입 중 인덱스를 유지하는 것보다 효율적이다.

**인덱스 생성 DDL 예시:**
```sql
CREATE INDEX idx_cctv_geo_geohash 
ON CCTV_GEO(geohash_id);
```

#### 9.4.2 인덱스 재구성 전략

**주기적 재생성:**
- 배치 프로세스가 실행될 때마다 `_GEO` 테이블을 TRUNCATE하고 데이터를 재삽입한 후, 인덱스를 재생성한다.
- 이는 인덱스의 단편화(Fragmentation)를 방지하고 최적의 성능을 유지한다.

**인덱스 검증:**
- 배치 프로세스는 인덱스 생성 전에 기존 인덱스의 존재 여부를 확인한다.
- 인덱스가 이미 존재하는 경우, DROP 후 재생성하거나 REBUILD 명령을 사용할 수 있다.

#### 9.4.3 인덱스 모니터링

**성능 지표:**
- 인덱스 스캔 시간
- 인덱스 블록 읽기 횟수
- 인덱스 크기 및 단편화 수준

**로깅 전략:**
- 배치 프로세스는 인덱스 생성 완료 시 다음 정보를 로깅한다:
  - 인덱스 이름
  - 대상 테이블
  - 생성 소요 시간
  - 인덱스 크기

### 9.5 예상 성능 및 확장성

#### 9.5.1 성능 예측

**데이터 규모별 예상 응답 시간:**

| 전체 데이터 수 | 인덱스 없이 (Full Scan) | B-Tree 인덱스 사용 |
|----------------|-------------------------|-------------------|
| 10만 건 | ~100ms | ~5ms |
| 100만 건 | ~1초 | ~10ms |
| 1000만 건 | ~10초 | ~15ms |
| 1억 건 | ~100초 | ~20ms |

※ 위 수치는 일반적인 데이터베이스 환경을 가정한 이론적 예측값이다.

#### 9.5.2 확장성 보장

**수평적 확장:**
- 지오해시 기반 설계는 지역별 데이터 샤딩(Sharding)을 용이하게 한다.
- 예: 서울 지역 데이터(`wy`로 시작)와 부산 지역 데이터(`wyd`로 시작)를 별도 데이터베이스에 분산 저장 가능

**수직적 확장:**
- B-Tree 인덱스는 데이터가 증가해도 안정적인 성능을 유지하므로, 단일 데이터베이스 내에서도 수억 건 규모까지 확장 가능하다.

### 9.6 설계 트레이드오프 및 제약사항

#### 9.6.1 장점

1. **예측 가능한 성능:** 데이터 규모와 관계없이 일정한 응답 시간 보장
2. **표준 기술 활용:** 모든 관계형 데이터베이스가 지원하는 B-Tree 인덱스 사용
3. **유지보수 용이성:** 복잡한 공간 인덱스 대신 단순한 문자열 인덱스 사용
4. **확장성:** 샤딩 및 수평 확장이 용이한 구조

#### 9.6.2 단점 및 제약사항

1. **경계 문제:** 격자 경계 근처의 데이터는 여러 격자를 조회해야 하는 오버헤드 발생 (9-Block 전략으로 해결)
2. **저장 공간:** `geohash_id` 컬럼과 인덱스를 위한 추가 저장 공간 필요
3. **배치 의존성:** 인덱스 생성을 위해 배치 프로세스가 정상적으로 실행되어야 함

#### 9.6.3 완화 전략

- **경계 문제:** 9-Block 그리드 검색으로 경계 데이터 누락 방지
- **저장 공간:** 현대 스토리지 비용 대비 성능 향상 효과가 월등히 큼
- **배치 의존성:** 배치 실패 시 알림 및 자동 재시도 메커니즘 구현

---

## 10. 지오해시 정밀도(Precision) 설계

### 10.1 설계 결정

본 시스템의 모든 지오해시 ID는 **7자리**의 정밀도를 기준으로 생성 및 검색한다.

### 10.2 기술적 근거 및 트레이드오프 분석

지오해시의 정밀도(문자열 길이)는 검색 범위의 크기와 직접적인 관련이 있으며, 이는 **검색의 정확성(Relevance)**과 **성능(Performance)** 사이의 중요한 트레이드오프 관계를 가진다. 7자리 정밀도는 본 시스템의 핵심 요구사항인 **500m 반경 분석**에 가장 적적합된 균형점을 제공한다.

#### 10.2.1 정밀도 6자리 검토 (격자 크기: 약 1.2km x 0.6km)

**장점:** `IN` 절에 포함될 ID 개수가 적어 쿼리가 단순해진다.

**치명적 단점:** 단일 격자의 크기가 분석 반경(500m)보다 훨씬 크다. 이 경우, 9-Block 그리드는 수 킬로미터에 달하는 너무 넓은 범위를 포함하게 된다. 이는 분석과 관련 없는 너무 많은 데이터를 데이터베이스에서 조회하게 만들며, 애플리케이션의 최종 반경 필터링 단계에서 대부분의 데이터를 버려야 하는 심각한 비효율을 초래한다.

#### 10.2.2 정밀도 8자리 검토 (격자 크기: 약 38m x 19m)

**장점:** 매우 정밀한 위치 식별이 가능하다.

**치명적 단점:** 격자의 크기가 너무 작아, 500m 반경을 포함하려면 수십~수백 개의 격자 ID가 필요하게 된다. `WHERE geohash_id IN (...)` 절에 과도하게 많은 ID가 포함될 경우, 데이터베이스의 인덱스 스캔 효율이 저하될 수 있으며 쿼리 자체가 너무 길고 복잡해진다.

#### 10.2.3 정밀도 7자리 선택 (격자 크기: 약 150m x 150m)

**최적의 균형:** 7자리 정밀도는 **'도시의 한 블록'** 또는 **'도보 1-2분 거리'**에 해당하는 인간적인 척도와 가장 유사하다.

**'9-Block' 그리드와의 시너지:** 7자리 격자 9개로 구성된 3x3 그리드는 대략 450m x 450m 크기의 정사각형 영역을 형성한다. 이 영역은 최종적으로 필요한 500m 반경의 원형 영역과 매우 근사하여, 불필요한 데이터의 조회를 최소화하면서도 필요한 데이터는 대부분 포함하는 가장 효율적인 1차 필터링 역할을 수행한다.

**결론:** 7자리 정밀도는 **'검색 대상 격자의 수(9개)'**와 **'조회된 데이터의 관련성'** 사이에서 최적의 균형을 이루는 설계 결정이다.

---

## 11. 비즈니스 기능 구현 - 배치 및 실시간 처리

본 시스템은 사용자에게 빠른 응답 속도를 제공하고 서버 자원을 효율적으로 사용하기 위해, **실시간 서비스**와 **배치 데이터 처리 프로세스**를 명확히 분리하여 시스템의 응답성과 안정성을 동시에 확보한다.

### 11.1 아키텍처 개요

#### 11.1.1 배치 처리 (데이터 사전 처리 및 그리드 인덱싱)

주기적으로 (예: 매일 새벽 또는 데이터 변경 시) 실행되는 배치 프로세스는:

1. **지오해시(Geohash) ID 사전 계산**: CCTV, 경찰서 등 모든 위치 기반 데이터에 대해 지오해시 ID를 사전에 계산하여 geohash_id 컬럼에 저장하고, 해당 컬럼에 B-Tree 인덱스를 생성한다.
2. 이 과정은 실시간 서비스에서 발생할 수 있는 비싼 공간 쿼리를 회피하고, 빠른 인덱스 기반 조회(F008)를 가능하게 한다.

#### 11.1.2 실시간 서비스 처리 (사용자 요청 시)

사용자의 `POST /api/location-analysis` 요청을 처리하는 API 서비스이다. 이 서비스는 성능 극대화를 위해, 사전에 배치 처리로 통해 인덱싱된 데이터만을 사용하여 동적 조회를 최소화하고, B-Tree 인덱스를 활용한 빠른 조회와 그리드 기반 캐싱(F008)을 통해 극적으로 빠른 분석 결과 제공에 최적화된 구조를 가진다.

### 11.2 배치 데이터 처리 (ETL Process)

#### 11.2.1 구현 클래스

```
com.wherehouse.batch.GeohashIndexingEtlProcessor
```

**클래스 어노테이션**
- `@Component`
- `@RequiredArgsConstructor`
- `@Slf4j`

**실행 주기**
- `@Scheduled(cron = "0 0 4 * * ?")` - 매일 새벽 4시에 실행, 또는 수동 실행 엔드포인트 제공

#### 11.2.2 핵심 역할

원본 데이터 테이블(CCTV, POLICE_OFFICE)을 읽어, 지오해시 ID를 추가하고 B-Tree 인덱스를 생성한 별도의 읽기 최적화 테이블(CCTV_GEO, POLICE_OFFICE_GEO)을 생성 및 갱신한다.

#### 11.2.3 의존성 주입

- JdbcTemplate 또는 JPA EntityManager - 대용량 데이터 처리
- GeohashLibrary - 지오해시 계산

#### 11.2.4 ETL 처리 단계

| 기능 ID | 기능명 | 상세 구현 내용 |
|---------|--------|----------------|
| B-01 | ETL 대상 테이블 정의 | 1. 원본 소스 테이블과, 데이터를 적재할 목적지 테이블을 매핑하여 정의<br>- CCTV (Source) → CCTV_GEO (Destination)<br>- POLICE_OFFICE (Source) → POLICE_OFFICE_GEO (Destination) |
| B-02 | 목적 테이블 검증 및 초기화 | 1. 배치 프로세스가 시작되면, 목적 테이블(예: CCTV_GEO)이 존재하는지 데이터베이스 스키마를 통해 검증<br>2. 테이블이 존재할 경우: TRUNCATE TABLE 명령을 실행하여 기존 데이터를 모두 삭제하고, 새로운 데이터를 적재할 준비<br>3. 테이블이 존재하지 않을 경우: 원본 테이블의 모든 컬럼과 geohash_id VARCHAR(12) 컬럼을 포함하는 CREATE TABLE 구문을 실행하여 신규 테이블을 생성 |
| B-03 | 데이터 추출 및 변환 (Extract & Transform) | 1. 원본 테이블(예: CCTV)의 모든 데이터를 일정 단위(예: 10000)로 스트리밍하여 읽어옴<br>2. 읽어온 각 데이터의 위도(LATITUDE), 경도(LONGITUDE)값을 사용하여 지오해시 ID를 계산 |
| B-04 | 데이터 적재 (Load) | 1. B-03에서 변환된 데이터(원본 데이터 + 지오해시 ID)를 목적 테이블(예: CCTV_GEO)에 삽입<br>2. 데이터베이스 부하를 최소화하기 위해 배치 삽입(Batch Insert) 방식을 사용 |
| B-05 | B-Tree 인덱스 생성 | 1. 모든 데이터가 목적 테이블에 적재된 후, geohash_id 컬럼에 B-Tree 인덱스가 존재하는지 검증<br>2. 인덱스가 존재하지 않을 경우, CREATE INDEX 구문을 실행하여 목적 테이블에 인덱스를 생성 |
| B-06 | 처리 결과 로깅 | 1. 모든 작업이 완료되면, 최종 처리 결과를 로그로 기록<br>2. 로그에는 처리 대상 테이블, 총 처리 건수, 테이블 생성/초기화 여부, 인덱스 생성 여부, 총 소요 시간 등이 포함 |

### 11.3 실시간 서비스 (Real-time Service)

#### 11.3.1 구현 위치

```
LocationAnalysisServiceImpl.java
```

F001 ~ F010 기능 요구사항의 실제 구현부

#### 11.3.2 호출 시점

`POST /api/location-analysis` 엔드포인트 요청 시

#### 11.3.3 핵심 역할

사전 처리된 데이터베이스와 캐시, 외부 API를 효율적으로 사용하여 사용자에게 빠른 시간 내에 정확한 위치 분석 리포트를 제공한다. 느린 연산은 최대한 회피하고, 빠른 조회와 캐시에 집중한다.

#### 11.3.4 실시간 서비스 처리 단계

| 기능 ID | 기능명 | 상세 구현 내용 |
|---------|--------|----------------|
| R-01 | '9-Block' 그리드 범위 계산 | 1. 사용자가 요청한 좌표를 기반으로 중심 셀의 지오해시 ID를 계산<br>2. 중심 셀을 포함하여, 주변 8개 셀의 지오해시 ID를 계산 (총 9개)<br>3. 계산된 9개 셀의 지오해시 ID 목록을 다음 단계에 전달<br>※ 이 과정은 사용자의 분석 반경이 여러 격자에 걸쳐 있을 가능성을 해결한다. |
| R-02 | 단계별 캐시 조회 | 1. (1단계 캐시) R-01에서 계산한 중심 셀의 지오해시 ID를 키로 하여, 최종 응답(DTO) 전체가 캐시에 있는지 확인. 캐시 히트 시 즉시 반환하고 절차 종료<br>2. (2단계 캐시) 1단계에서 캐시 미스가 발생하면, 9개의 격자 ID 각각에 대해 개별 데이터(예: CCTV 목록, 파출소 정보)가 캐시에 있는지 확인<br>3. (2단계 캐시 히트) 해당 격자의 데이터는 캐시된 값을 사용<br>4. (2단계 캐시 미스) DB 조회로 전환 (R-03 단계) |
| R-03 | 선택된 데이터베이스 조회 | 1. R-02에서 2단계 캐시 미스가 발생한 격자에 대해서만, _GEO 테이블(CCTV_GEO, POLICE_OFFICE_GEO 등)에서 데이터 조회<br>2. 조회 시, B-Tree 인덱스가 적용된 geohash_id 컬럼으로 빠른 조회를 수행: WHERE geohash_id = '격자_ID'<br>3. CCTV_GEO 조회 시에는 ADDRESS, LATITUDE, LONGITUDE, CAMERACOUNT 등 모든 컬럼을 포함하여 조회<br>4. DB에서 새로 조회한 데이터(전체 컬럼 포함)는 즉시 해당 격자 ID를 키로 하여 캐시에 저장 |
| R-04 | 외부 API 호출 및 개별 데이터 캐싱 | 1. F005와 F006의 명세에 따라, 외부 API(카카오맵: 주소 변환, 편의시설 등) 호출<br>2. 외부 API 호출은 CompletableFuture를 사용하여 병렬 처리로 실행<br>3. 반경 내 편의시설 조회 시, 9-Block 격자별로 편의시설을 필터링하여 선택한 서비스(예: 주소 변환)는 API 호출 전 캐시 먼저 확인<br>4. 각 격자 데이터를 독립적으로 캐싱(Component 캐시). F008의 2단계 캐시 전략에 기반 |
| R-05 | 데이터 통합, 필터링, 최종 응답 생성 대기 | 1. R-03(내부 DB 조회)과 R-04(외부 API 조회) 의 모든 비동기 작업들이 완료될 때까지 대기하는 것을 첫 단계로 한다<br>2. 모든 데이터(내부 DB, 외부 API 캐시)를 하나의 목록으로 통합<br>3. 이 통합된 9개 격자로부터 수집한 데이터에서, 사용자의 최초 클릭 좌표 기준 정확한 반경(500m) 내에 포함되는 데이터만을 최종 필터링하여 다음 단계로 전달 |
| R-06 | 최종 점수 계산 | 1. R-05에서 최종 필터링된 데이터를 F003과 F004 점수 계산 서비스에 전달<br>2. 점수 계산 시 비즈니스 로직(점수 산출 공식, 가중치 적용 등)에 따라 안전성 점수와 편의성 점수를 산출 |
| R-07 | 최종 응답 생성 및 캐싱 | 1. R-06에서 계산된 점수와 모든 데이터를 조합하여 최종 LocationAnalysisResponseDTO를 생성<br>2. F007: 추천 근거 생성기를 통해 recommendations 배열 생성<br>3. F010: 부분 실패가 있었다면 warnings 필드를 추가<br>4. 완성된 DTO를 다음 요청을 위해 1단계 캐시(중심 격자 ID를 키로)에 저장하여, 사용자에게 반환 |

#### 11.3.5 파출소 조회 방식

가장 가까운 파출소 1개만을 직접 조회한다.

**구현된 방식:**
```java
// 공간 쿼리를 사용한 직접 조회
List<PoliceOfficeGeo> nearestPoliceList = policeOfficeGeoRepository
    .findNearestPoliceStations(userLatitude, userLongitude, 1);
```

**설계 근거:**
- 파출소는 CCTV에 비해 개수가 적고 분포가 희소함
- 9-Block 그리드 내에 파출소가 없는 경우가 빈번함
- 직접 조회가 더 효율적

#### 11.3.5 캐싱 전략 수정사항

파출소 데이터는 희소성으로 인해 Geohash 기반 캐싱이 부적합하므로, 2단계 캐시에서 제외된다. CCTV 데이터만 격자별 캐싱을 수행한다.

**캐시 전략:**
- CCTV: 2단계 캐시 적용 (격자별 캐싱)
- 파출소: 캐싱하지 않고 매번 DB 조회


---

## 12. 구현 기술 스택 및 설정

### 12.1 기술 스택

#### 12.1.1 Spring Boot 버전: 3.1.x (Java 17 기반)

**선정 이유:** 현재 널리 사용되는 안정적인 Long-Term Support(LTS) 버전으로, 안정성과 기술 지원 측면에서 가장 표준적인 선택입니다.

#### 12.1.2 캐시 구현체: Caffeine

**선정 이유:** 분산 설치가 필요 없는 Java 기반의 고성능 로컬 캐시입니다. Redis와 같은 외부 캐시 서버는 분산 환경에서는 유리하지만, 현재 단일 서버 아키텍처에서는 Caffeine을 사용하는 것이 설정이 간단하고 매우 빠릅니다.

#### 12.1.3 지오해시 라이브러리: ch.hsr.geohash.GeoHash

**선정 이유:** Java 진영에서 가장 널리 사용되고 검증된 지오해시 라이브러리입니다.

#### 12.1.4 데이터베이스: Oracle (또는 PostgreSQL)

**선정 이유:** 
- **Oracle**: 현재 프로젝트에서 사용 중인 엔터프라이즈급 관계형 데이터베이스이며, 공간 쿼리 기반 쿼리 코드를 위해 공간 데이터를 처리하는 확장 기능인 **PostGIS**와의 연계가 용이합니다.
- **PostgreSQL**: 오픈소스 대안으로, PostGIS를 통해 공간 데이터 처리가 가능합니다.

**본 프로젝트는 Oracle을 사용합니다.**

### 12.2 설정값 명세 (application.yml 기반)

#### 12.2.1 데이터베이스 연결 정보

```yaml
spring:
  datasource:
    driver-class-name: oracle.jdbc.OracleDriver
    url: jdbc:oracle:thin:@127.0.0.1:1521:xe
    username: SCOTT
    password: tiger
    hikari:
      connection-timeout: 30000  # 30초
```

**근거:** `application.yml` 파일 내 `spring.datasource.driver-class-name`이 `oracle.jdbc.OracleDriver`로 명시되어 있습니다.

#### 12.2.2 API 타임아웃 설정

**제공된 설정:**
- 제공된 `application.yml` 파일에는 외부 API(카카오맵) 호출을 위한 전용 타임아웃 설정이 명시되어 있지 않습니다.

**해결 방안:**
- 이러한 설정은 보통 `.yml` 파일이 아니면, `WebClient` 또는 `RestTemplate` Bean을 생성하는 Java 설정 클래스에서 직접 구성합니다.
- **권장 설정:** 연결 타임아웃 3초, 읽기 타임아웃 5초의 타임아웃을 코드 레벨에서 명시적으로 설정하는 것을 권장합니다.

```java
@Bean
public WebClient webClient() {
    return WebClient.builder()
        .clientConnector(new ReactorClientHttpConnector(
            HttpClient.create()
                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 3000)
                .responseTimeout(Duration.ofSeconds(5))
        ))
        .build();
}
```

#### 12.2.3 기타 주요 설정

**서버 포트:**
```yaml
server:
  port: 8185
```

**Context Path:**
```yaml
server:
  servlet:
    context-path: /wherehouse
```

**JSON 네이밍 전략:**
```yaml
spring:
  jackson:
    property-naming-strategy: SNAKE_CASE
```

Java의 `camelCase` 필드명을 JSON의 `snake_case`로 자동 변환하도록 설정되어 있습니다. 이는 API 응답 DTO설계 시 반영되어야 합니다.

**JPA/Hibernate 설정:**
```yaml
spring:
  jpa:
    hibernate:
      ddl-auto: none
    properties:
      hibernate:
        dialect: org.hibernate.dialect.OracleDialect
```

`ddl-auto`는 `none`으로 설정되어 있으며, Oracle 전용 `OracleDialect`를 사용합니다.

---

## 13. 외부 API 연동 상세

### 13.1 카카오맵 API

**필수 설정: REST API 키**

```yaml
# application.yml
kakao:
  api:
    key: ${KAKAO_REST_API_KEY}  # 환경변수로 주입
    base-url: https://dapi.kakao.com
```

**환경변수 설정 방법:**
```bash
# Linux/Mac
export KAKAO_REST_API_KEY="your_api_key_here"

# Windows
set KAKAO_REST_API_KEY=your_api_key_here
```

**API 키 발급:**
1. https://developers.kakao.com 접속
2. 내 애플리케이션 → 앱 생성
3. 앱 설정 → 앱 키 → REST API 키 복사

**엔드포인트:**

1. **편의시설 검색**
   - URL: `GET https://dapi.kakao.com/v2/local/search/category.json`
   - 파라미터:
     - `category_group_code`: CS2, CE7, FD6 등
     - `x`: 경도 (longitude)
     - `y`: 위도 (latitude)
     - `radius`: 반경 (미터, 최대 20000)
   - 헤더: `Authorization: KakaoAK ${REST_API_KEY}`

2. **주소 변환 (좌표 → 주소)**
   - URL: `GET https://dapi.kakao.com/v2/local/geo/coord2address.json`
   - 파라미터:
     - `x`: 경도
     - `y`: 위도
   - 헤더: `Authorization: KakaoAK ${REST_API_KEY}`

**응답 형식:**
```json
{
  "documents": [
    {
      "place_name": "스타벅스 시청역점",
      "x": "126.9781",
      "y": "37.5655",
      "distance": "85"
    }
  ],
  "meta": {
    "total_count": 15
  }
}
```

**에러 처리:**
- HTTP 400: 잘못된 파라미터
- HTTP 401: API 키 인증 실패
- HTTP 429: 요청 할당량 초과
- HTTP 500: 카카오 서버 오류

### 13.2 WebClient 설정 (타임아웃)

```java
@Configuration
public class WebClientConfig {
    
    @Bean
    public WebClient kakaoWebClient(@Value("${kakao.api.key}") String apiKey) {
        return WebClient.builder()
            .baseUrl("https://dapi.kakao.com")
            .defaultHeader("Authorization", "KakaoAK " + apiKey)
            .clientConnector(new ReactorClientHttpConnector(
                HttpClient.create()
                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 3000)  // 연결 타임아웃: 3초
                    .responseTimeout(Duration.ofSeconds(5))  // 읽기 타임아웃: 5초
            ))
            .build();
    }
}
```

---

## 14. 부록 (Appendix)

### 14.1 배치 프로세스 상세

#### 14.1.1 실행 주기

**기본 설정: 매일 새벽 4시**
```java
@Scheduled(cron = "0 0 4 * * ?")
public void executeEtlProcess() {
    // ETL 로직
}
```

**크론 표현식 설명:**
- `0 0 4 * * ?`: 매일 새벽 4시 0분 0초
- 변경 가능: `0 0 2 * * ?` (새벽 2시), `0 0 */6 * * ?` (6시간마다)

#### 14.1.2 수동 실행 엔드포인트 (선택사항)

```java
@PostMapping("/admin/etl/execute")
public ResponseEntity<String> manualEtl() {
    geohashIndexingEtlProcessor.executeEtlProcess();
    return ResponseEntity.ok("ETL 프로세스 수동 실행 완료");
}
```

### 14.2 9-Block 그리드 계산 라이브러리

#### 14.2.1 사용 라이브러리

```xml
<!-- pom.xml -->
<dependency>
    <groupId>ch.hsr</groupId>
    <artifactId>geohash</artifactId>
    <version>1.4.0</version>
</dependency>
```

#### 14.2.2 9-Block 계산 로직

```java
import ch.hsr.geohash.GeoHash;

public List<String> calculate9BlockGeohashes(double latitude, double longitude, int precision) {
    // 중심 셀
    GeoHash centerHash = GeoHash.withCharacterPrecision(latitude, longitude, precision);
    
    List<String> nineBlocks = new ArrayList<>();
    nineBlocks.add(centerHash.toBase32());
    
    // 8방향 인접 셀
    GeoHash[] adjacents = centerHash.getAdjacent();
    for (GeoHash adjacent : adjacents) {
        nineBlocks.add(adjacent.toBase32());
    }
    
    return nineBlocks;  // 총 9개 반환
}
```

**예시 결과 (precision = 7):**
```
중심: wydm7p1
북쪽: wydm7p4
북동: wydm7p5
동쪽: wydm7p3
남동: wydm7p2
남쪽: wydm7nz
남서: wydm7nx
서쪽: wydm7p0
북서: wydm7p6
```

### 14.3 용어 정의

| 용어 | 정의 |
|------|------|
| **DTO (Data Transfer Object)** | 계층 간 데이터 전송을 위한 객체 |
| **CompletableFuture** | Java의 비동기 프로그래밍을 위한 클래스 |
| **Geohash** | 지리적 좌표를 문자열로 인코딩하는 알고리즘 |
| **B-Tree Index** | 데이터베이스 검색 성능을 향상시키는 인덱스 구조 |
| **Fault Isolation** | 부분 장애가 전체 시스템에 전파되지 않도록 격리하는 설계 기법 |
| **TTL (Time To Live)** | 캐시 데이터의 유효 기간 |
| **ETL (Extract, Transform, Load)** | 데이터를 추출, 변환, 적재하는 프로세스 |
| **9-Block Grid** | 중심 격자와 주변 8개 격자를 포함한 총 9개의 격자 영역 |
| **검거율 (Arrest Rate)** | 발생한 범죄 중 검거된 비율 (검거 수 / 발생 수) |
| **MZ세대** | 1980년대 초~2000년대 초 출생한 밀레니얼 세대와 1990년대 중반~2000년대 초반 출생한 Z세대를 통칭 |

### 14.4 문서 변경 이력

| 버전 | 작성일 | 작성자 | 변경 내용 |
|------|--------|--------|----------|
| 1.0 | 2025-10-10 | 정범진 | 초안 작성 |
| 1.1 | 2025-10-10 | 정범진 | 중복 제거 및 문서 구조 재편성. 모든 기술적 세부사항은 그대로 보존 |

### 14.5 참조 문서

- **기술 명세서**: F001 ~ F010 핵심 기능 요구사항 명세서
- **빅데이터 분석 보고서**:
  - 4조_1팀: 편의성 점수 계산 로직 및 가중치 근거
  - 4조_2팀: 검거율 분석 및 상관관계 분석 결과
- **데이터 출처**: 서울 열린 데이터 광장
  - 서울시 5대 범죄 발생 현황 통계
  - 서울시 시내주요기관(경찰·소방관서) 통계
  - 서울시 자치구 연도별 CCTV 설치 현황
- **카카오맵 API 문서**: https://developers.kakao.com/docs/latest/ko/local/dev-guide

---

## 문서 종료

본 문서는 '상세 지도 기반 정보 제공 서비스'의 백엔드 중심 아키텍처 전환 프로젝트에서 구현해야 할 API 명세 및 비즈니스 로직 구현 방안에 대한 완전한 기술 명세를 제공한다.

**문서 작성 완료일:** 2025년 10월 10일  
**총 기능 수:** F001 ~ F010 (10개 핵심 기능)  
**주요 외부 의존성:** 카카오맵 REST API, Geohash 라이브러리

---

**© 2025 위치 기반 생활 안전·편의 분석 시스템. All rights reserved.**