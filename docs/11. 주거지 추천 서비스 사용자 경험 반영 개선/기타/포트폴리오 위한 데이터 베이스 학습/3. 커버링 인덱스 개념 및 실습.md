# 데이터베이스 I/O 아키텍처와 인덱스 전략

## 목차

1. [이론적 기초: I/O 아키텍처](#1-이론적-기초-io-아키텍처)
   - 1.1 [핵심 문제 정의: 디스크 I/O 병목](#11-핵심-문제-정의-디스크-io-병목)
   - 1.2 [물리적 저장 구조](#12-물리적-저장-구조)
   - 1.3 [데이터 접근 경로의 진화](#13-데이터-접근-경로의-진화)
   - 1.4 [엔지니어링 결론](#14-엔지니어링-결론)
2. [실증적 검증: B-Tree 인덱스 성능 최적화](#2-실증적-검증-b-tree-인덱스-성능-최적화)
   - 2.1 [개요 및 테스트 환경](#21-개요-및-테스트-환경)
   - 2.2 [스키마 구성 및 데이터 적재](#22-스키마-구성-및-데이터-적재)
   - 2.3 [성능 실험 및 실행 계획 분석](#23-성능-실험-및-실행-계획-분석)
   - 2.4 [포트폴리오 관찰 증명 가이드](#24-포트폴리오-관찰-증명-가이드)
3. [참조 문서](#3-참조-문서)

---

## 1. 이론적 기초: I/O 아키텍처

### 1.1 핵심 문제 정의: 디스크 I/O 병목

데이터베이스 성능 튜닝의 시작과 끝은 물리적 디스크 I/O 비용의 통제에 있다. CPU나 메모리의 연산 속도에 비해 디스크(HDD/SSD)의 접근 속도는 현저히 느리며, 데이터베이스 성능 저하의 90% 이상은 랜덤 I/O가 과도하게 발생할 때 일어난다. 따라서 백엔드 엔지니어링의 핵심 목표는 원하는 데이터를 얻기 위해 읽어야 할 물리적 블록의 수를 최소화하는 것으로 정의된다.

### 1.2 물리적 저장 구조

데이터베이스는 데이터를 크게 두 가지의 물리적 공간에 분리하여 저장한다.

힙 테이블은 모든 컬럼 데이터가 저장된 거대한 원본 저장소이다. 정렬되어 있지 않으며, 데이터가 무작위로 쌓여 있다. 특정 행을 찾으려면 전체를 읽거나 주소인 ROWID를 알아야 한다.

B-Tree 인덱스는 빠른 검색을 위해 특정 컬럼과 해당 행의 주소만을 복사하여 별도로 저장한 공간이다. 정렬되어 있으며, 트리 구조를 통해 탐색 비용을 O(log N)으로 줄인다. 인덱스 리프 노드에는 Key 값과 ROWID가 물리적으로 기록되어 있다.

### 1.3 데이터 접근 경로의 진화

I/O 비용 관점에서 데이터 접근 방식은 3단계로 구분된다.

**Level 1: Full Table Scan**

테이블의 첫 블록부터 끝 블록까지 모든 데이터를 순차적으로 읽는다. 비용은 데이터 양에 비례하여 처리 시간이 선형적으로 증가한다. 단 1건의 데이터를 찾기 위해 100만 건의 데이터를 읽는 낭비가 발생한다.

**Level 2: Index Range Scan**

인덱스 트리 탐색을 통해 리프 노드에서 ROWID를 획득한 후, ROWID를 이용해 테이블 블록으로 점프하여 나머지 컬럼 데이터를 가져온다. 비용은 인덱스 탐색 비용과 테이블 랜덤 액세스 비용의 합이다. 검색 대상이 많아질수록 테이블로 점프하는 랜덤 I/O 횟수가 늘어나 성능이 저하된다.

**Level 3: Covering Index**

쿼리가 요구하는 모든 컬럼이 인덱스 리프 노드에 포함된 상태이다. 인덱스 트리 탐색 후 리프 노드 도달 시점에서 필요한 데이터가 이미 존재하므로, 테이블 블록 접근을 생략하고 즉시 반환한다. 테이블 랜덤 액세스 비용이 0이 되며 가장 빠른 응답 속도를 보장한다.

### 1.4 엔지니어링 결론

인덱스는 단순한 포인터가 아니다. 인덱스는 테이블 데이터의 일부를 복제하여 정렬해 둔 또 다른 저장소다.

옵티마이저는 단순히 인덱스가 있어서 쓰는 것이 아니라, 테이블을 다 읽는 비용과 인덱스를 거쳐서 테이블을 띄엄띄엄 읽는 비용을 계산하여 더 저렴한 쪽을 선택한다.

SELECT *의 사용은 커버링 인덱스의 활용 기회를 박탈하고 불필요한 I/O를 유발한다. 따라서 쿼리 작성 시 필요한 컬럼만 명시하고, 이를 지원하는 복합 인덱스를 설계하는 것이 성능 최적화의 핵심이다.

---

## 2. 실증적 검증: B-Tree 인덱스 성능 최적화

### 2.1 개요 및 테스트 환경

본 문서는 대용량 데이터 환경(100만 건)에서 인덱스 유무 및 조회 전략에 따른 물리적 I/O 비용의 변화를 정량적으로 검증한 기록이다.

- DBMS: Oracle Database
- Target Table: REVIEW_LAB (Heap Organized Table)
- Data Volume: 1,000,000 Rows (Random Generated Data)
- Test Metric: Elapsed Time (Sec) & Execution Plan (Access Path)

**인덱스 생성:**

```sql
-- WRITER 컬럼에 인덱스 생성
CREATE INDEX IDX_REVIEW_LAB_WRITER ON REVIEW_LAB(WRITER);
```

### 2.2 스키마 구성 및 데이터 적재

데이터 분포의 무작위성을 보장하기 위해 DBMS_RANDOM 패키지를 사용하여 더미 데이터를 생성하였다.

**테이블 생성:**

```sql
CREATE TABLE REVIEW_LAB (
    REVIEW_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    PROPERTY_ID NUMBER NOT NULL,
    WRITER VARCHAR2(50),
    SCORE NUMBER(3, 1),
    CONTENT VARCHAR2(1000),
    CREATED_AT DATE DEFAULT SYSDATE
);
```

**100만 건 데이터 벌크 인서트:**

트랜잭션 커밋 주기는 10,000건 단위로 설정하였다.

```sql
BEGIN
    FOR i IN 1..1000000 LOOP
        INSERT INTO REVIEW_LAB (PROPERTY_ID, WRITER, SCORE, CONTENT, CREATED_AT)
        VALUES (
            ROUND(DBMS_RANDOM.VALUE(1, 10000)),
            'user_' || ROUND(DBMS_RANDOM.VALUE(1, 100000)),
            ROUND(DBMS_RANDOM.VALUE(1, 5), 1),
            DBMS_RANDOM.STRING('A', 50),
            SYSDATE - ROUND(DBMS_RANDOM.VALUE(1, 365))
        );
        IF MOD(i, 10000) = 0 THEN COMMIT; END IF;
    END LOOP;
    COMMIT;
END;
/
```

### 2.3 성능 실험 및 실행 계획 분석

**Scenario A. 인덱스 미적용 (Baseline)**

- Test Query: `SELECT * FROM REVIEW_LAB WHERE WRITER = 'user_77777';`
- Elapsed Time: 0.342 sec
- Execution Plan: TABLE ACCESS FULL

물리적 분석: WRITER 컬럼에 대한 물리적 주소 정보가 부재하다. 엔진은 데이터 파일의 고수위 지점까지 모든 블록을 순차적으로 읽는 Sequential I/O를 수행한다. 데이터 양 증가 시 성능이 선형적으로 저하된다.

**Scenario B. 일반 인덱스 스캔 (Index Range Scan)**

- Optimization: IDX_REVIEW_LAB_WRITER 인덱스 활용
- Test Query: `SELECT * FROM REVIEW_LAB WHERE WRITER = 'user_77777';`
- Elapsed Time: 0.023 sec (약 15배 향상)
- Execution Plan: INDEX RANGE SCAN → TABLE ACCESS BY INDEX ROWID

물리적 분석: 인덱스 트리 탐색을 통해 대상 ROWID를 즉시 확보한다. 하지만 인덱스에 없는 컬럼(CONTENT 등)을 조회하기 위해 테이블 힙 블록으로 이동하는 Random I/O가 발생한다. Full Scan 대비 월등히 빠르나, 조회 건수가 많아지면 Random I/O 부하로 인해 성능 저하 가능성이 존재한다.

**Scenario C. 커버링 인덱스 (Covering Index Strategy)**

- Test Query: `SELECT WRITER FROM REVIEW_LAB WHERE WRITER = 'user_77777';`
- Elapsed Time: 0.002 sec (Scenario A 대비 170배, Scenario B 대비 11배 향상)
- Execution Plan: INDEX RANGE SCAN (Note: Table Access 단계가 없음)

물리적 분석: 쿼리가 요구하는 데이터(WRITER)가 인덱스 리프 노드에 물리적으로 복제되어 있다. 옵티마이저는 테이블 블록 접근 비용이 불필요하다고 판단하여 Random I/O 단계를 생략한다. 디스크 I/O 비용을 최소화한 가장 이상적인 조회 형태이다.

### 2.4 포트폴리오 관찰 증명 가이드

실제 면접이나 문서화 과정에서 단순한 시간 기록보다 신뢰성 있는 것은 실행 계획 캡처이다. 아래 SQL을 통해 시스템이 보고하는 실행 경로를 직접 추출할 수 있다.

```sql
-- 실행 계획 생성
EXPLAIN PLAN FOR
SELECT * FROM REVIEW_LAB WHERE WRITER = 'user_77777';

-- 생성된 계획 출력
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

**포트폴리오 체크포인트:**

- Operation 컬럼에 TABLE ACCESS FULL이 찍히면 → 인덱스 누락
- Operation 컬럼에 TABLE ACCESS BY INDEX ROWID가 찍히면 → 일반 인덱스
- Operation 컬럼에 테이블 관련 내용 없이 INDEX만 찍히면 → 커버링 인덱스 적용 성공

---

## 3. 참조 문서

### Couchbase Covering Indexes 공식 문서

**참조 URL:** https://docs.couchbase.com/server/current/indexes/covering-indexes.html

Couchbase Server 공식 문서는 커버링 인덱스를 "인덱스가 쿼리에서 지정된 모든 필드의 실제 값을 포함하여, 데이터 서비스로부터 실제 값을 가져오는 추가 단계가 필요하지 않은 경우"로 정의한다. 이는 본 문서에서 설명한 Oracle 환경의 원리와 동일하다.

Couchbase는 N1QL 쿼리 언어를 통해 커버링 인덱스를 지원하며, EXPLAIN 구문을 통해 실행 계획을 확인할 수 있다. 커버링 인덱스가 적용된 경우 실행 계획에 "covers" 객체가 출력되어 인덱스가 커버하는 데이터 범위를 명시한다.

Couchbase 문서는 다음과 같은 제약과 특징을 명시한다. 커버링 인덱스는 secondary index scan에 적용 가능하며 GSI와 함께 사용할 수 있다. 표현식과 집계를 포함한 쿼리도 커버링 인덱스의 이점을 얻을 수 있다. 단, 여러 GSI 인덱스를 조합하여 쿼리를 커버할 수 없으며, 쿼리 엔진이 GSI로 커버하고 데이터 노드에서 문서를 읽지 않으려면 필요한 모든 필드를 포함한 복합 인덱스를 생성해야 한다.

본 문서와 Couchbase 공식 문서를 함께 참조하면, 커버링 인덱스가 관계형 데이터베이스와 문서형 데이터베이스 모두에서 일관되게 적용되는 범용적 최적화 원칙임을 확인할 수 있다.