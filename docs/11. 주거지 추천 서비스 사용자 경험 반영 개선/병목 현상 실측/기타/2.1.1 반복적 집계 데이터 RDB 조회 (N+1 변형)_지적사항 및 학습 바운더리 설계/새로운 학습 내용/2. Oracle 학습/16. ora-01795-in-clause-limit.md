# ORA-01795: IN절 1000개 제한의 본질과 실행계획과의 관계

## 개요

Oracle 데이터베이스에서 `ORA-01795: maximum number of expressions in a list is 1000` 에러는 IN절에 1000개를 초과하는 값을 전달할 때 발생한다. 이 문서는 해당 제한이 적용되는 정확한 시점과 조건, 그리고 실행계획 수립 과정과의 관계를 분석한다.

---

## ORA-01795의 발생 조건

### 제한이 적용되는 레이어

ORA-01795는 **하드 파싱(Hard Parsing)의 구문 분석 단계**에서 발생하는 구문론적 제약이다. SQL 문이 데이터베이스에 도달하면 다음 순서로 하드 파싱이 진행된다.

| 단계 | 처리 내용 | 1000개 제한 적용 |
|------|----------|------------------|
| 1. 구문 분석 (Syntax Check) | SQL 문법 검증, IN절 요소 개수 카운트 | **적용 - 초과 시 즉시 중단** |
| 2. 의미 분석 (Semantic Check) | 테이블/컬럼 존재 확인, 권한 검사 | 무관 |
| 3. 쿼리 변환 (Query Transformation) | 논리적으로 동일한 효율적 형태로 변환 | 무관 |
| 4. 최적화 (Optimization) | 실행계획 수립, 비용 계산 | 무관 |
| 5. 실행 (Execution) | 실제 데이터 접근 및 처리 | 무관 |

파서는 1단계 구문 분석에서 `IN (...)` 리스트 내의 요소 개수를 카운트하며, 1000개를 초과하면 즉시 ORA-01795를 발생시키고 파싱을 중단한다. 실행계획을 생성하는 4단계 최적화에 도달하기 전에 거부되므로, 인덱스 유형이나 테이블 구조와 무관하게 적용된다.

### 제한의 기술적 배경

이 제한은 Oracle SQL 파서의 내부 자료구조 설계와 자원 관리 정책에서 비롯된다.

**메모리 스택 관리**: SQL 파서는 IN절 내부의 리터럴들을 처리하기 위해 내부적인 메모리 스택(Stack)이나 배열을 사용한다. 리스트가 무한정 길어질 경우, 파싱 과정에서 과도한 메모리 점유가 발생하여 전체 인스턴스의 안정성을 해칠 수 있다.

**재귀 호출 깊이 제한**: 파서가 구문을 분석할 때 재귀적인 함수 호출을 사용하는데, 표현식이 너무 많으면 스택 오버플로(Stack Overflow)가 발생할 위험이 있다. 1000개 제한은 이러한 재귀 깊이를 안전한 범위 내로 유지한다.

**비정상적 SQL 방어**: 수만 개의 리터럴이 포함된 SQL은 그 자체로 파싱 부하가 매우 크다. Oracle은 이를 시스템적인 위협으로 간주하여 1000개라는 임계치를 하드코딩된 규칙(Hard-coded Rule)으로 설정했다.

서브쿼리 형태의 IN절(`IN (SELECT ...)`)에는 이 제한이 적용되지 않는다. 파서 입장에서 서브쿼리는 단일 expression이며, 실제 반환되는 값의 개수는 런타임에 결정되기 때문이다. 반면 리터럴 목록은 파싱 시점에 모든 값이 구문 트리에 노드로 등록되어야 하므로 제한이 걸린다.

### 발생 및 미발생 사례

```sql
-- ORA-01795 발생: 단일 IN절에 1001개 이상 리터럴
SELECT * FROM REVIEW_STATISTICS 
WHERE PROPERTY_ID IN ('val1', 'val2', ... , 'val1001');

-- 정상 실행: OR로 분리하여 각 IN절이 1000개 이하
SELECT * FROM REVIEW_STATISTICS 
WHERE PROPERTY_ID IN ('val1', ... , 'val1000') 
   OR PROPERTY_ID IN ('val1001');

-- 정상 실행: 서브쿼리 사용 (단일 expression으로 취급)
SELECT * FROM REVIEW_STATISTICS 
WHERE PROPERTY_ID IN (SELECT id FROM TEMP_IDS);

-- 정상 실행: JOIN 사용
SELECT r.* FROM REVIEW_STATISTICS r
JOIN TEMP_IDS t ON r.PROPERTY_ID = t.id;
```

### EXPLAIN PLAN으로 검증

```sql
-- 파싱 단계에서 즉시 실패 (EXPLAIN PLAN 자체 불가)
EXPLAIN PLAN FOR
SELECT * FROM REVIEW_STATISTICS 
WHERE PROPERTY_ID IN ('v1', 'v2', ... , 'v1001');
-- 결과: ORA-01795 발생

-- OR 분리 시 파싱 성공
EXPLAIN PLAN FOR
SELECT * FROM REVIEW_STATISTICS 
WHERE PROPERTY_ID IN ('v1', ... , 'v1000') 
   OR PROPERTY_ID IN ('v1001');
-- 결과: 성공, 실행계획 수립됨
```

EXPLAIN PLAN 명령 자체가 실패한다는 점이 핵심이다. 실행계획 수립 이전에 파싱 단계에서 거부당하기 때문이다.

---

## 실행계획과의 관계

### 실제 사례 분석

Hibernate가 생성한 다음 쿼리를 분석한다.

```sql
SELECT PROPERTY_ID, AVG_RATING, LAST_CALCED, NEGATIVE_KEYWORD_COUNT, 
       POSITIVE_KEYWORD_COUNT, REVIEW_COUNT 
FROM REVIEW_STATISTICS  
WHERE (PROPERTY_ID IN (... 1000개 ...) 
    OR PROPERTY_ID IN (... 276개 ...));
```

이 쿼리는 총 1276개의 파라미터를 전달하지만, 각 IN절이 1000개 이하이므로 파싱을 통과한다. 실행계획은 다음과 같이 수립되었다.

| OPERATION | OBJECT_NAME | OPTIONS | CARDINALITY | COST |
|-----------|-------------|---------|-------------|------|
| SELECT STATEMENT | | | 1276 | 649 |
| └ INLIST ITERATOR | | | | |
| &emsp;└ TABLE ACCESS | REVIEW_STATISTICS | BY INDEX ROWID | 1276 | 649 |
| &emsp;&emsp;└ INDEX | PK_REVIEW_STATISTICS | UNIQUE SCAN | 1276 | 460 |

### INLIST ITERATOR가 선택된 이유

파싱을 통과한 SQL은 쿼리 변환(Query Transformation) 단계에서 논리적으로 동일한 더 효율적인 형태로 변환될 수 있다. 이 사례에서 옵티마이저는 SQL 텍스트상의 OR 분리 구조와 무관하게, 두 IN절을 **논리적 OR 조건의 집합**으로 인식하고 단일 INLIST ITERATOR로 통합 처리했다.

INLIST ITERATOR는 값 목록을 반복 구조로 처리하면서 각 값에 대해 인덱스 탐색을 수행하는 방식이다. 이 방식이 선택된 조건은 다음과 같다.

1. **동일 컬럼 조건**: 두 IN절 모두 PROPERTY_ID 컬럼에 대한 것이므로, Oracle은 이를 1276개의 값을 가진 단일 조건처럼 취급할 수 있다.

2. **동일 인덱스 경로**: 두 IN절 모두 PK_REVIEW_STATISTICS 인덱스를 통해 접근하므로, 별도의 실행 경로로 분리할 이유가 없다.

3. **비용 효율성**: CONCATENATION으로 분리하면 각 브랜치에 대해 별도의 실행 계획 노드가 생성되고 결과 병합을 위한 추가 연산이 필요하다. 동일 인덱스에 대한 반복 접근이라면 INLIST ITERATOR로 통합하는 편이 오버헤드가 적다.

### CONCATENATION이 선택되는 조건

OR 조건이 CONCATENATION으로 분리되려면 옵티마이저가 "분리 실행이 비용상 유리하다"고 판단해야 한다. 주로 다음 조건에서 선택된다.

```sql
-- CONCATENATION 가능성 높음: 서로 다른 컬럼, 서로 다른 인덱스
SELECT * FROM REVIEW_STATISTICS 
WHERE PROPERTY_ID IN ('val1', 'val2', ... , 'val500') 
   OR REGION_ID IN ('region1', 'region2', ... , 'region300');
```

위 쿼리에서 PROPERTY_ID는 PK 인덱스를, REGION_ID는 별도의 인덱스를 사용한다면, Oracle은 각 조건을 독립된 실행 경로로 분리하고 UNION ALL로 결합하는 CONCATENATION 계획을 선택할 수 있다.

반면 동일 컬럼에 대한 동일 인덱스 조건에서는 CONCATENATION의 실익이 없다. SQL 텍스트가 OR로 분리되어 있어도 옵티마이저는 이를 통합하여 처리한다.

---

## Hibernate의 IN절 처리 전략

### OR 분해 방식

Hibernate는 Oracle의 1000개 제한을 우회하기 위해 IN절을 자동으로 분해한다. `hibernate.query.in_clause_parameter_padding` 설정과 관계없이, 1000개를 초과하는 파라미터는 `IN(...) OR IN(...)` 구조로 변환된다.

```java
// 1276개의 ID를 전달하는 경우
List<String> propertyIds = ...; // 1276개
List<ReviewStatistics> results = repository.findAllById(propertyIds);

// 생성되는 SQL
// WHERE PROPERTY_ID IN (... 1000개 ...) OR PROPERTY_ID IN (... 276개 ...)
```

### 설계적 의의

Hibernate의 OR 분해는 ORA-01795 파싱 에러를 회피하기 위한 것이지, 실행계획 최적화를 유도하기 위한 것이 아니다. 파싱만 통과하면 옵티마이저는 원본 의도(1276개 값에 대한 조회)를 파악하고 최적의 실행계획을 수립한다.

이 사례에서 확인되듯, SQL 텍스트상의 분리 구조가 실행계획에 그대로 반영되지는 않는다. 옵티마이저는 논리적 의미를 기준으로 계획을 수립하며, 구문적 분리는 파서 통과를 위한 형식적 요건일 뿐이다.

---

## 요약

| 구분 | 적용 시점 | 제한 내용 | 인덱스 영향 |
|------|----------|----------|-------------|
| ORA-01795 | 하드 파싱 - 구문 분석 | 단일 IN절 내 리터럴 1000개 | 무관 |
| INLIST ITERATOR | 최적화 - 실행계획 수립 | 제한 없음 | 동일 인덱스 시 통합 |
| CONCATENATION | 최적화 - 실행계획 수립 | 비용 기반 판단 | 서로 다른 인덱스 시 분리 가능 |

ORA-01795는 실행 효율의 문제가 아니라 **SQL 파싱 엔진이 허용하는 메모리 및 자원 할당 한계치에 의한 구문 거부**다. 인덱스 전략에 의해 실행계획이 어떻게 구성되는지와 관계없이, 하나의 IN 괄호 안에 들어가는 값의 개수가 1000개를 넘는 순간 데이터베이스는 쿼리 실행 자체를 거부한다.

Hibernate 등의 ORM이 OR로 쿼리를 분할하는 것은 이 구문적 제약을 우회하기 위한 것이며, 파싱을 통과한 이후에는 옵티마이저가 논리적 의미를 기준으로 최적의 실행계획을 수립한다.
