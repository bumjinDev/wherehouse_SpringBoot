[2번 테스트 결과로써 1번 테스트 결과 보다 수치가 안 좋아진 근거 정립]

1. 하드 파싱과 소프트 파싱 차이 = 1000 건 고정 분할이 효율적인 근거
2. hibernate 는 oracle 자체의 in 구문 한계상 1000 건 단위로 분할하는데 이때 발생하는 비용 계산
3. select 쿼리 시 다수의 조건 데이터가 포함되면 인덱스 조회 보다 full scan 이 더 빠르다고 판단되는 근거.
4. 동시 접속자 50명 중 10명이 커넥션을 잡고 1.7초간 버티면, 나머지 40명은 그 시간 동안 아무것도 못 하고 대기해야 되는 상황
[4번에 대한 구체적인 척도]
1. 컨텍스트 스위칭(Context Switching)에 의한 CPU 낭비단순한 오버헤드가 아니라, CPU가 실제 업무를 처리하지 못하고 '전환'하는 데 시간을 허비하는 현상입니다.상황: CPU 코어 개수(예: 4~8개)보다 훨씬 많은 스레드(50개)가 동시에 실행(Runnable) 상태가 되면, 운영체제(OS) 스케줄러는 각 스레드에 아주 짧은 시간(Time Slice)을 할당하고 번갈아 가며 실행합니다.비용 발생 원리: 스위칭이 발생할 때마다 레지스터 저장, 커널 모드 전환, TCB(Thread Control Block) 로드 등의 작업이 수행됩니다.캐시 오염(Cache Thrashing): 더 심각한 문제는 L1/L2 캐시 적중률(Hit Rate) 하락입니다. 스레드가 바뀔 때마다 CPU 캐시에 저장된 데이터가 무효화되고, 새로운 스레드의 데이터를 RAM에서 다시 읽어와야 합니다.결과: 총량 $Work_{total}$은 같지만, 이를 처리하는 CPU의 효율($Efficiency$)이 급감하여 실제 소요 시간 $T$가 증가합니다.$$T = \frac{Work_{total}}{CPU_{power} \times Efficiency}$$2. 리소스 경합(Resource Contention)과 락 대기 시간사용자가 '배제'하라고 했던 SQLTransientConnectionException은 결과일 뿐이며, 그 에러가 발생하기 직전까지의 **'대기 시간'**이 실행 시간을 늘리는 주범입니다.DB 커넥션 풀(DBCP) 병목:가정: DB 커넥션 풀의 최대 크기(Max Pool Size)가 10개, 요청 스레드가 50개.현상: 10개의 스레드가 커넥션을 점유하면, 나머지 40개 스레드는 커넥션을 얻기 위해 Block 상태로 진입합니다.비용: 이 40개의 스레드는 단순히 멈춰있는 것이 아니라, 커넥션이 반환되었는지 주기적으로 확인하거나, 락(Lock)을 획득하기 위해 CPU 사이클을 소모하며 경쟁합니다(Spin-lock 등).임계 구역(Critical Section) 직렬화:내부적으로 동기화(Synchronization)가 필요한 코드 영역(예: ArrayList 추가, 로깅 기록, 트랜잭션 매니저 등)에 50개의 스레드가 동시에 접근하려 하면, 한 번에 하나의 스레드만 통과시키는 **직렬화(Serialization)**가 발생합니다.병렬 처리를 위해 스레드를 늘렸으나, 실제로는 줄을 서서 기다리는 시간이 추가되어 전체 응답 시간이 늘어납니다.3. 유니버설 확장성 법칙 (Universal Scalability Law, USL) 적용이 현상은 컴퓨터 공학의 Universal Scalability Law 공식으로 설명됩니다.$$C(N) = \frac{N}{1 + \alpha(N-1) + \beta N(N-1)}$$$N$: 스레드(동시 사용자) 수$\alpha$: 직렬화 비용 (Serialization, 리소스 경합)$\beta$: 일관성 지연 비용 (Coherency, 데이터 교환 및 락 오버헤드)사용자의 상황은 **$\beta$ 값(스레드 간의 통신 및 조정 비용)**이 급격히 커지는 구간입니다. 스레드 $N$이 증가할 때, 분모의 $\beta N(N-1)$ 항이 $N^2$에 비례하여 커지기 때문에, 어느 임계점을 넘으면 성능($C(N)$)이 평탄화되는 것을 넘어 **오히려 하락(Retrograde)**합니다.결론: 실행 시간이 늘어난 진짜 이유사용자가 지적한 대로 "1번~3번 근거(컨텍스트 스위칭, 리소스 경합)"를 찾는 것이 정확한 접근입니다.총 작업량의 관점 변화: 논리적인 업무량(데이터 25건 조회)은 고정이지만, 물리적인 CPU 인스트럭션 총량은 [업무 로직] + [스레드 스케줄링 비용] + [락 획득/해제 비용] + [메모리 스왑 비용]으로 인해 증가했습니다.대기 시간의 포함: 실행 시간 측정 시, 스레드가 DB 커넥션을 얻기 위해 대기했던 시간(Wait Time)도 총 소요 시간에 포함됩니다. 50개 스레드가 좁은 문(DB 커넥션)을 통과하려다 발생한 병목 현상이 전체 완료 시간을 지연시킨 것입니다.따라서 단순히 "오버헤드가 추가되었다"가 아니라, "과도한 스레드 생성으로 인해 시스템이 처리 능력보다 '조정(Coordination)'과 '대기(Waiting)'에 더 많은 자원을 쓰게 되었다"고 해석해야 합니다.Next Step이 이론을 검증하기 위해, 현재 코드에서 **DB Connection Pool의 모니터링 지표(Active Connections, Idle Connections, Pending Threads)**를 로깅하여, 50개 스레드 실행 시 Pending 상태의 대기 시간이 얼마나 발생하는지 확인할까요?