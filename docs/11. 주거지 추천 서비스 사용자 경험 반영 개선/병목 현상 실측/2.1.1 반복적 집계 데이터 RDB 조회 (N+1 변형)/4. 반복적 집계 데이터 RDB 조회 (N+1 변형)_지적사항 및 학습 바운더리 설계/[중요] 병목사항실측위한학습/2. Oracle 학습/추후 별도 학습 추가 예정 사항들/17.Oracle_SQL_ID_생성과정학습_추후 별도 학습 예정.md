# Oracle SQL_ID 생성 메커니즘 기술 백서

## 1. 서론: SQL_ID란 무엇인가

### 1.1 정의

SQL_ID는 Oracle 10g부터 도입된 SQL 문장의 고유 식별자다. 13자리 영숫자 문자열로 표현되며, SQL 텍스트의 MD5 해시를 기반으로 생성된다. V$SQL, V$SQLAREA, AWR 리포트 등 Oracle의 모든 성능 진단 인터페이스에서 SQL 문장을 식별하는 기본 키로 사용된다.

### 1.2 도입 배경

Oracle 9i까지는 HASH_VALUE(32비트)만으로 SQL을 식별했다. 그러나 32비트는 약 43억 개의 고유 값만 표현할 수 있어, 대규모 시스템에서 해시 충돌 가능성이 존재했다. 10g에서 SQL_ID(64비트 기반)를 도입하여 충돌 가능성을 사실상 제거했다.

### 1.3 SQL_ID의 역할

1. **Library Cache 식별자**: Shared Pool 내 커서를 고유하게 식별
2. **성능 진단 키**: AWR, ASH, SQL Monitoring에서 SQL 추적
3. **SQL Plan Baseline**: 실행 계획을 SQL_ID와 연결하여 관리
4. **SQL Patch/Profile**: 특정 SQL에 힌트나 조정 적용

---

## 2. SQL_ID 생성 알고리즘

### 2.1 알고리즘 개요

```
SQL 텍스트 → [NULL 바이트 추가] → [MD5 해시] → [64비트 추출] → [Base32 인코딩] → SQL_ID
```

### 2.2 단계별 상세

#### 단계 1: 입력 준비

Oracle은 SQL 텍스트 끝에 NULL 종료 문자(0x00)를 추가한다.

```
입력 데이터 = SQL텍스트(UTF-8 바이트) + 0x00
```

**중요**: 세미콜론(`;`)은 SQL 텍스트에 포함되지 않는다. SQL*Plus나 JDBC에서 문장 종결자로 사용되지만, Oracle 내부적으로 저장되는 SQL 텍스트에는 세미콜론이 없다.

#### 단계 2: MD5 해시 계산

표준 RFC 1321 MD5 알고리즘을 적용하여 128비트(16바이트) 다이제스트를 생성한다.

```
MD5 다이제스트 구조 (16바이트):
┌────────────────────────────────────────────────────────────────┐
│ Byte 0-7 (상위 64비트)  │ Byte 8-11 (블록1) │ Byte 12-15 (블록2) │
│       [미사용]          │    [n1 원천]      │     [n2 원천]      │
└────────────────────────────────────────────────────────────────┘
```

#### 단계 3: 64비트 해시값 추출 (핵심)

이 단계의 엔디안 처리가 SQL_ID 계산의 핵심이다. Oracle은 **단순히 8바이트를 통째로 리틀 엔디안으로 읽지 않는다**. 대신 각 4바이트 블록을 개별적으로 엔디안 변환한다.

**올바른 추출 방식**:

```
1. 블록1 (바이트 8-11)
   - 원본: [B8][B9][B10][B11]
   - 엔디안 변환: [B11][B10][B9][B8]
   - 결과: n1 (32비트 정수)

2. 블록2 (바이트 12-15)
   - 원본: [B12][B13][B14][B15]
   - 엔디안 변환: [B15][B14][B13][B12]
   - 결과: n2 (32비트 정수)

3. 64비트 결합
   - hash_64 = (n1 × 2³²) + n2
   - 즉, n1이 상위 32비트, n2가 하위 32비트
```

**잘못된 방식 (주의)**:

8바이트를 통째로 리틀 엔디안 64비트로 해석하면 완전히 다른 값이 나온다. 이는 Oracle이 내부적으로 32비트 단위로 해시값을 처리하기 때문이다.

#### 단계 4: HASH_VALUE 도출

V$SQL.HASH_VALUE는 64비트 해시값의 하위 32비트다:

```
HASH_VALUE = hash_64 AND 0xFFFFFFFF
           = n2 (블록2에서 추출한 값)
```

이 값은 Library Cache 해시 테이블의 버킷 결정에 사용된다.

#### 단계 5: Base32 인코딩

64비트 값을 13자리 문자열로 인코딩한다. Oracle은 표준 Base32(RFC 4648)가 아닌 **커스텀 알파벳**을 사용한다.

**Oracle SQL_ID 알파벳 (32자)**:
```
0 1 2 3 4 5 6 7 8 9 a b c d f g h j k m n p q r s t u v w x y z
```

**제외된 문자**: `e`, `i`, `l`, `o`

| 제외 문자 | 제외 이유 |
|-----------|-----------|
| `e` | 명확하지 않음 (추정: 일관성 유지) |
| `i` | 숫자 `1`과 혼동 가능 |
| `l` | 숫자 `1`과 혼동 가능 |
| `o` | 숫자 `0`과 혼동 가능 |

이는 DBA가 AWR 리포트나 터미널에서 SQL_ID를 육안으로 식별할 때의 가독성을 위한 설계 결정이다.

**인코딩 과정**:

```
1. 64비트 값을 32로 나눈 나머지 → 알파벳 인덱스 → 문자 추출
2. 64비트 값을 32로 나눔
3. 13회 반복 (64비트 / 5비트 = 12.8 → 올림하여 13자리)
4. 문자들을 역순으로 결합 → SQL_ID
```

---

## 3. SQL_ID와 Library Cache 아키텍처

### 3.1 Library Cache 구조

Library Cache는 Shared Pool 내에 위치하며, 해시 테이블 구조로 구현되어 있다.

```
┌─────────────────────────────────────────────────────────────────┐
│                        Shared Pool                               │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                    Library Cache                           │  │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐       ┌─────────┐   │  │
│  │  │Bucket 0 │ │Bucket 1 │ │Bucket 2 │ . . . │Bucket N │   │  │
│  │  │  ↓      │ │  ↓      │ │  ↓      │       │  ↓      │   │  │
│  │  │[Cursor] │ │[Cursor] │ │[Cursor] │       │[Cursor] │   │  │
│  │  │  ↓      │ │  ↓      │ │         │       │  ↓      │   │  │
│  │  │[Cursor] │ │[Cursor] │ │         │       │[Cursor] │   │  │
│  │  └─────────┘ └─────────┘ └─────────┘       └─────────┘   │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 버킷 결정 메커니즘

SQL이 실행되면 Oracle은 다음 과정을 거친다:

1. SQL 텍스트로부터 HASH_VALUE 계산
2. HASH_VALUE를 버킷 수로 모듈러 연산 → 버킷 번호 결정
3. 해당 버킷의 연결 리스트에서 정확한 SQL_ID 매칭

```
버킷 번호 = HASH_VALUE MOD (버킷 수)
```

### 3.3 SQL_ID 기반 조회

V$SQL을 SQL_ID로 조회할 때도 Oracle은 내부적으로 SQL_ID에서 HASH_VALUE를 역추출하여 해시 룩업을 수행한다. SQL_ID의 하위 비트들이 HASH_VALUE와 직접 연관되어 있기 때문에 이 변환이 가능하다.

---

## 4. Hard Parse와 Soft Parse

### 4.1 Parse 유형 비교

| 구분 | Hard Parse | Soft Parse |
|------|------------|------------|
| 조건 | SQL_ID가 Library Cache에 없음 | SQL_ID가 Library Cache에 있음 |
| 수행 작업 | 구문 분석, 의미 분석, 최적화, 실행 계획 생성 | 기존 커서 참조, 권한 확인 |
| CPU 비용 | 높음 | 낮음 |
| Library Cache Latch | 장시간 보유 | 단시간 보유 |
| Shared Pool 메모리 | 새 커서 할당 | 기존 커서 재사용 |

### 4.2 Hard Parse의 비용

Hard Parse는 다음 단계를 모두 수행한다:

1. **구문 분석 (Syntax Analysis)**: SQL 문법 검증
2. **의미 분석 (Semantic Analysis)**: 객체 존재 확인, 권한 검증
3. **뷰 확장 (View Expansion)**: 뷰를 기본 테이블로 변환
4. **쿼리 변환 (Query Transformation)**: 서브쿼리 언네스팅, 조인 제거 등
5. **비용 기반 최적화 (Cost-Based Optimization)**: 통계 기반 최적 실행 계획 도출
6. **실행 계획 생성**: 최종 실행 계획 결정 및 저장

### 4.3 SQL_ID 동일성의 중요성

**핵심 원리**: 동일한 SQL 텍스트 → 동일한 SQL_ID → Soft Parse 가능

따라서 SQL_ID를 동일하게 유지하는 것이 성능 최적화의 핵심이다.

---

## 5. 바인드 변수와 SQL_ID

### 5.1 리터럴 SQL의 문제

```sql
-- 매번 다른 SQL_ID 생성 → 매번 Hard Parse
SELECT * FROM USERS WHERE ID = 'user001';
SELECT * FROM USERS WHERE ID = 'user002';
SELECT * FROM USERS WHERE ID = 'user003';
```

각 SQL은 텍스트가 다르므로 서로 다른 SQL_ID가 생성된다. 결과적으로:
- Hard Parse 반복 → CPU 낭비
- Library Cache에 유사 SQL 대량 적재 → 메모리 낭비
- Library Cache Latch 경합 → 확장성 저하

### 5.2 바인드 변수 SQL의 이점

```sql
-- 동일한 SQL_ID 유지 → 첫 실행만 Hard Parse, 이후 Soft Parse
SELECT * FROM USERS WHERE ID = :1;
```

값이 달라도 SQL 텍스트는 동일하므로:
- SQL_ID 동일 → 커서 재사용
- Hard Parse 1회 → CPU 절약
- Library Cache 메모리 효율적 사용

### 5.3 JDBC PreparedStatement의 동작

애플리케이션 레벨에서:
```java
PreparedStatement ps = conn.prepareStatement(
    "SELECT * FROM USERS WHERE ID = ?"
);
ps.setString(1, "user001");
```

Oracle V$SQL에 저장되는 형태:
```sql
SELECT * FROM USERS WHERE ID = :1
```

JDBC 드라이버가 `?`를 Oracle 바인드 변수 형식(`:1`, `:2`, ...)으로 변환하여 전송한다.

### 5.4 IN절 바인드 변수의 특성

**애플리케이션 로그**:
```sql
SELECT * FROM T WHERE ID IN ('a', 'b', 'c')
```

**V$SQL에 저장되는 형태**:
```sql
SELECT * FROM T WHERE ID IN (:1 ,:2 ,:3 )
```

**중요**: 바인드 변수 **개수**가 다르면 SQL 텍스트가 달라지므로 SQL_ID도 달라진다.

```sql
-- SQL_ID: abc123...
SELECT * FROM T WHERE ID IN (:1 ,:2 ,:3 )

-- SQL_ID: xyz789... (다름!)
SELECT * FROM T WHERE ID IN (:1 ,:2 ,:3 ,:4 ,:5 )
```

이것이 IN절 최적화에서 바인드 개수 패딩(padding)이나 고정 크기 청킹(chunking)이 논의되는 이유다.

---

## 6. Oracle IN절 1000개 제한

### 6.1 제한의 실체

Oracle은 단일 IN절에 최대 **1000개**의 표현식만 허용한다.

```sql
-- ORA-01795: maximum number of expressions in a list is 1000
SELECT * FROM T WHERE ID IN (:1, :2, ..., :1001)
```

이는 Oracle SQL 파서의 하드코딩된 제한이다.

### 6.2 Hibernate의 OR 분해 방식

Hibernate 6.2+에서는 `hibernate.query.in_clause_parameter_padding`과 함께 1000개 초과 시 자동으로 OR 분해를 수행한다.

```sql
-- 1500개 항목 처리
SELECT * FROM T 
WHERE ID IN (:1 ,:2 ,...,:1000 ) 
   OR ID IN (:1001 ,:1002 ,...,:1500 )
```

**실행 계획**: CONCATENATION
- 각 IN절이 별도로 처리된 후 결과가 UNION ALL로 결합
- 인덱스를 사용할 경우 각 IN절마다 INDEX RANGE SCAN 발생

### 6.3 애플리케이션 레벨 Chunking 방식

애플리케이션에서 1000개 단위로 분할하여 여러 쿼리로 실행:

```sql
-- 쿼리 1: 1000개
SELECT * FROM T WHERE ID IN (:1 ,:2 ,...,:1000 )

-- 쿼리 2: 500개
SELECT * FROM T WHERE ID IN (:1 ,:2 ,...,:500 )
```

**실행 계획**: INLIST ITERATOR
- IN절 내 값들을 순회하며 인덱스 접근
- 각 쿼리가 독립적으로 최적화

### 6.4 두 방식의 SQL_ID 관점 비교

| 항목 | OR 분해 | Chunking |
|------|---------|----------|
| 1500개 처리 시 SQL_ID 개수 | 1개 | 2개 |
| Hard Parse | 해당 패턴 최초 1회 | 각 청크 크기 패턴별 최초 1회 |
| 캐시 재사용 | 동일 총 개수일 때만 | 동일 청크 크기면 재사용 가능 |
| 네트워크 왕복 | 1회 | 청크 수만큼 |

**Chunking의 잠재적 이점**: 1000개 청크는 다른 요청에서도 재사용 가능
**OR 분해의 잠재적 이점**: 네트워크 왕복 최소화, 트랜잭션 일관성

---

## 7. 대소문자와 공백의 영향

### 7.1 SQL_ID는 텍스트에 민감하다

SQL_ID는 SQL 텍스트의 MD5 해시이므로, 대소문자와 공백이 모두 영향을 미친다.

```sql
-- 모두 다른 SQL_ID 생성
SELECT * FROM DUAL          -- SQL_ID: 9g6pyx7qz035v
select * from dual          -- SQL_ID: a5ks9fhw2v9s1
SELECT  *  FROM  DUAL       -- SQL_ID: 6cw806pf3sngj (공백 2개)
```

### 7.2 실무적 함의

1. **코딩 표준 필요**: 팀 내 SQL 작성 규칙 통일
2. **ORM 사용 권장**: Hibernate 등이 일관된 SQL 생성
3. **CURSOR_SHARING 파라미터**: FORCE 설정 시 리터럴을 바인드로 자동 변환

### 7.3 CURSOR_SHARING 파라미터

```sql
ALTER SESSION SET CURSOR_SHARING = FORCE;
```

| 값 | 동작 |
|----|------|
| EXACT (기본값) | SQL 텍스트가 정확히 일치해야 커서 공유 |
| FORCE | 리터럴을 시스템 생성 바인드 변수로 자동 변환 |

**주의**: CURSOR_SHARING=FORCE는 부작용이 있을 수 있으므로 신중히 사용해야 한다.

---

## 8. MD5 선택의 아키텍처적 근거

### 8.1 왜 MD5인가

SQL_ID의 목적은 **암호학적 보안이 아니라 빠른 식별**이다.

| 알고리즘 | 출력 크기 | 상대 속도 |
|----------|-----------|-----------|
| MD5 | 128비트 | 빠름 |
| SHA-1 | 160비트 | 중간 |
| SHA-256 | 256비트 | 느림 |

MD5는 암호학적으로는 취약하지만, 해시 충돌을 의도적으로 만들어내는 공격이 SQL 성능 최적화 맥락에서는 무의미하다. 따라서 계산 속도가 빠른 MD5가 적절한 선택이다.

### 8.2 64비트 절단의 의미

128비트 MD5에서 64비트만 사용하는 이유:

1. **충분한 고유성**: 64비트 = 1.8 × 10¹⁹ 개의 고유 값
2. **메모리 효율**: V$SQL 등의 뷰에서 컬럼 크기 절약
3. **Base32 인코딩 효율**: 64비트 → 13자리 (적절한 길이)

단일 데이터베이스에서 동시에 존재하는 고유 SQL 수가 10억 개라고 가정해도, 충돌 확률은 무시할 수 있는 수준이다.

### 8.3 32비트 블록 처리의 이유

Oracle이 8바이트를 통째로 읽지 않고 4바이트씩 처리하는 이유는 **HASH_VALUE와의 호환성** 때문으로 추정된다.

- Oracle 9i까지: HASH_VALUE (32비트)만 사용
- Oracle 10g+: SQL_ID (64비트) 도입, HASH_VALUE는 하위 32비트

기존 32비트 기반 구조와의 호환성을 유지하면서 64비트로 확장하기 위해, 두 개의 32비트 블록을 결합하는 방식을 채택한 것으로 보인다.

---

## 9. 참고 문헌

### 9.1 Oracle 공식 문서

1. **Oracle Database Reference 19c - V$SQL**
   - https://docs.oracle.com/en/database/oracle/oracle-database/19/refrn/V-SQL.html
   - SQL_ID, HASH_VALUE, FULL_HASH_VALUE 컬럼 정의

2. **Oracle Database Reference 19c - V$SQLAREA**
   - https://docs.oracle.com/en/database/oracle/oracle-database/19/refrn/V-SQLAREA.html
   - Library Cache 내 SQL 영역 뷰

3. **Oracle Database Performance Tuning Guide - Reducing Parse Overhead**
   - https://docs.oracle.com/en/database/oracle/oracle-database/19/tgdba/instance-tuning-using-performance-views.html
   - Hard Parse 감소를 위한 바인드 변수 사용 권장

4. **Oracle Database SQL Language Reference - Expression Lists**
   - https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Expression-Lists.html
   - IN절 1000개 제한 명시

### 9.2 기술 분석 자료

1. **Tanel Poder - "SQL_ID is just a fancy representation of hash value" (2009)**
   - https://tanelpoder.com/2009/02/22/sql_id-is-just-a-fancy-representation-of-hash-value/
   - SQL_ID가 MD5 해시 기반임을 최초로 공개 분석
   - 인용: "Oracle takes last 32 bits of the MD5 hash and this will be the hash value"

2. **Tanel Poder - "Calculate SQL_ID and SQL_HASH_VALUE from SQL text" (2010)**
   - https://tanelpoder.com/2010/03/31/calculate-sql_id-and-sql_hash_value-from-sql-text/
   - SQL_ID 계산 알고리즘 공개

3. **Perumal.org - "Computing Oracle SQL_ID and HASH_VALUE"**
   - https://www.perumal.org/computing-oracle-sql_id-and-hash_value/
   - Java 구현 및 상세 알고리즘
   - 인용: "Oracle passes SQL text with null terminator to standard MD5 hash function"

4. **GitHub: jkstill/oracle-demos - SQL-Hashing.md**
   - https://github.com/jkstill/oracle-demos/blob/master/sql-hash-value/SQL-Hashing.md
   - Bash/PL/SQL 구현 및 Base32 알파벳 분석
   - 인용: "Notably absent are the characters 'e', 'i', 'l' and 'o'"

### 9.3 표준 문서

1. **RFC 1321 - The MD5 Message-Digest Algorithm**
   - https://www.rfc-editor.org/rfc/rfc1321
   - Oracle이 사용하는 MD5 알고리즘의 공식 명세

2. **RFC 4648 - Base Encodings (Base32)**
   - https://www.rfc-editor.org/rfc/rfc4648
   - 표준 Base32 (Oracle은 변형 사용)

---

## 10. 핵심 요약

| 항목 | 내용 |
|------|------|
| SQL_ID 길이 | 13자리 영숫자 |
| 기반 알고리즘 | MD5 해시 |
| 해시 입력 | SQL 텍스트 + NULL 바이트(0x00) |
| 사용 비트 | MD5 128비트 중 하위 64비트 |
| HASH_VALUE | 64비트 중 하위 32비트 |
| Base32 알파벳 | 0-9, a-d, f-h, j-k, m-n, p-z (e,i,l,o 제외) |
| 대소문자 민감 | 예 |
| 공백 민감 | 예 |
| 세미콜론 | V$SQL에 포함되지 않음 |
| IN절 제한 | 1000개 |

---

*문서 버전: 1.0*
*최종 수정: 2026년 1월 8일*
