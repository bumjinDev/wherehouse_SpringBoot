1단계: 테스트 바운더리 정의 및 논리적 근거 (Test Boundaries & Rationale)본 프로젝트는 데이터베이스의 내부 실행 계획(Execution Plan)이나 옵티마이저 비용(Optimizer Cost)을 직접 분석할 수 있는 심층적인 DBA 레벨의 역량이 부재한 상황을 전제합니다.따라서 불확실한 추측에 의존하기보다, **애플리케이션 레벨에서 확실하게 관측 가능한 데이터(Log, Metrics)**를 기반으로 DB의 병목 현상을 역추적(Back-tracing)하는 '블랙박스 테스트(Black-box Testing)' 접근 방식을 채택합니다.1. 관측 가능한 영역과 선정 근거 (Observable Boundaries & Rationale)다음의 데이터들은 포트폴리오에서 성능 개선의 **'확실한 증거(Evidence)'**로 활용됩니다.A. Spring Boot & Hibernate Logs (Query Execution Analysis)애플리케이션 로그는 코드가 DB에 요청하는 **'입력값(Input)'**의 형태를 가장 투명하게 보여주는 지표입니다.관측 지표 1: 트랜잭션 당 쿼리 발생 횟수 (Query Count per Transaction)내용: API 1회 호출 시 발생하는 SELECT 쿼리의 총 횟수를 카운트합니다.선정 근거:Origin Code에서 발생하는 N+1 문제는 단순히 쿼리가 많이 나가는 것이 문제가 아니라, **네트워크 왕복 비용(Network Round Trip Time, RTT)**이 N번 누적된다는 점이 핵심 병목입니다.로그 상에서 쿼리 횟수가 25회에서 1회(Bulk), 혹은 3회(Chunk)로 줄어드는 것은 물리적인 네트워크 I/O 지연을 제거했음을 입증하는 정량적 근거가 됩니다.관측 지표 2: 생성된 SQL의 구조적 형태 (SQL Structure)내용: Hibernate가 생성한 SQL의 WHERE 절이 OR 연산자로 연결되어 있는지, 단일 IN 절로 묶여 있는지, 혹은 IN 절 내부의 파라미터 개수가 몇 개인지 텍스트 로그로 확인합니다.선정 근거:수백 개의 OR 연산자가 포함된 쿼리는 DB 옵티마이저가 인덱스를 효율적으로 사용하기 어렵게 만들어 Full Table Scan을 유발할 가능성이 높습니다.반면, Bulk나 Chunk 방식에서 생성되는 IN 절의 형태를 확인함으로써, 의도한 대로 쿼리가 생성되었는지 검증할 수 있습니다.관측 지표 3: 애플리케이션 로직 수행 시간 (Total Task Time)내용: 코드 내 StopWatch를 사용하여 비즈니스 로직의 시작과 끝을 측정한 시간입니다.선정 근거:순수 애플리케이션 연산 속도와 DB I/O 대기 시간을 분리하여, 성능 저하의 원인이 DB 응답 지연에 있음을 명확히 하기 위함입니다.B. HikariCP Logs (Database Bottleneck Evidence)HikariCP 로그는 DB가 요청을 제때 처리하지 못할 때 발생하는 **'애플리케이션 측의 비명(Symptom)'**입니다.관측 지표 1: Connection Timeout (연결 타임아웃)내용: HikariPool-1 - Connection is not available, request timed out after 30000ms 에러 로그의 발생 여부 및 빈도입니다.선정 근거:DB의 CPU 사용량을 직접 보지 못하더라도, 타임아웃 로그는 **"DB가 쿼리를 처리하는 데 시간이 너무 오래 걸려서, 커넥션이 제때 반환되지 않고 있다"**는 사실을 증명합니다.이는 DB 내부의 처리 속도가 요청 유입 속도를 따라가지 못해 발생하는 **병목(Bottleneck)**의 가장 확실한 증거입니다.관측 지표 2: Pending Threads (대기 스레드)내용: 커넥션 풀이 고갈되어 커넥션을 얻기 위해 대기 줄(Queue)에 서 있는 스레드의 개수입니다.선정 근거:사용자 요청이 급증했을 때(JMeter 부하), 이 수치가 증가한다면 시스템이 큐잉(Queuing) 상태에 빠졌음을 의미하며, 이는 곧 사용자 입장에서의 응답 지연(Latency)으로 직결됩니다.C. JMeter Report (User Experience Metrics)최종 사용자 관점에서의 서비스 품질을 나타내는 **'결과값(Output)'**입니다.관측 지표: TPS (초당 처리량), Latency (평균 및 95% 응답 시간), Error Rate (에러율).선정 근거:모든 튜닝의 목적은 결국 "더 많은 사용자를 더 빠르게 처리하는 것"입니다.특히 Error Rate는 Bulk Fetch 방식에서 **Oracle의 IN 절 1000개 제한(ORA-01795)**에 걸려 요청이 실패했음을 잡아내는 중요한 지표로 활용됩니다.2. 배제 영역 및 추론 논리 (Excluded Boundaries & Inference Logic)이 영역은 기술적/환경적 제약으로 인해 직접 측정하지 않지만, 위의 '관측 가능한 데이터'를 통해 합리적으로 유추하는 영역입니다.A. 분석에서 철저히 배제하는 항목나의 분석 역량을 넘어서거나 접근 권한이 없는 항목들입니다.DB 내부 실행 계획 (Execution Plan):Explain Plan을 떠서 인덱스 스캔 여부(Index Range Scan vs Table Access Full)나 조인 방식(Nested Loop vs Hash Join)을 직접 확인하지 않습니다.이유: 실행 계획을 잘못 해석하여 잘못된 결론을 내릴 위험을 배제하고, 확실한 현상(Latency)에 집중하기 위함입니다.옵티마이저 비용 (Cost):DB가 계산한 쿼리 코스트(Cost) 수치를 비교 분석하지 않습니다.하드웨어 리소스 (H/W Resources):DB 서버나 WAS 서버의 CPU, Memory, Disk I/O 사용률은 측정 범위에서 제외합니다.B. 관측 데이터를 통한 내부 동작 추론 (Inference Logic)"보이지 않는 DB 내부"를 "보이는 데이터"로 설명하는 논리적 연결 고리입니다.추론 1: Full Table Scan 발생 의심관측: Origin 코드(단건 조회) 대비, OR 조건이 수천 개 붙은 쿼리의 응답 속도가 현저히 느리고, 데이터 양이 늘어날수록 Latency가 선형적으로 급증함.논리: 인덱스를 탔다면 데이터 양과 무관하게 일정 속도를 유지해야 함. 속도가 데이터 양에 비례해 느려지는 현상은 옵티마이저가 인덱스 효율이 떨어진다고 판단하여 Full Table Scan을 선택했을 확률이 매우 높음.추론 2: Connection Pool 고갈의 원인 (Holding Time)관측: HikariCP 로그에서 Connection Timeout 발생.논리: 커넥션 풀 설정(Size)이 동일한데 타임아웃이 발생했다는 것은, 개별 쿼리의 DB 점유 시간(Connection Holding Time)이 길어졌기 때문임. 즉, 쿼리 튜닝이 안 되어 DB 처리 시간이 길어졌고, 이로 인해 커넥션 회전율이 떨어져 풀이 고갈된 것임.추론 3: Oracle 1000건 제한 (ORA-01795)관측: Bulk Fetch 코드 실행 시 JMeter에서 500 Internal Server Error가 발생하거나, Hibernate 로그에서 쿼리가 비정상적으로 쪼개지는 현상.논리: Oracle DB는 IN 절에 1000개 이상의 파라미터를 허용하지 않는 하드 코딩된 제약이 있음. 로그상의 에러는 이 제약 조건에 충돌했음을 의미함.3. 코드 버전별 예상 관측 시나리오 (Scenario Definition)구분1. Origin Code (N+1)2. Bulk Fetch Code (Risk)3. Chunk Code (Optimization)Hibernate LogSELECT 쿼리가 25회 반복 출력됨.SELECT ... IN (?, ? ...) 형태의 거대한 쿼리가 1회 출력됨.SELECT ... IN (...) 쿼리가 정확히 1000개 단위로 3~4회 분할 출력됨.HikariCP Log트래픽 증가 시 Timeout 발생 빈번. (잦은 I/O로 인한 점유 시간 누적)성공 시 빠르나, 조건에 따라 SQL Error 발생 가능성 존재.Timeout 없음. 안정적인 커넥션 획득 및 반환 사이클 유지.JMeter ResultLatency 높음, TPS 낮음.성공 시 TPS 가장 높음 / 실패 시 Error Rate 급증.Latency 낮음, TPS 높음, Error 0%.분석 결론 (추론)"N+1 문제로 인한 네트워크 I/O 오버헤드가 주요 병목 원인이다.""성능은 좋으나 Oracle의 제약 사항(1000건)을 고려하지 않아 시스템 안정성을 해친다.""Chunking을 통해 Oracle 제약을 회피하고, 최소한의 I/O로 안정성과 성능의 균형을 맞췄다."