2단계: 테스트 계획 재정립 (Test Plan Refinement)1. 테스트 목적 및 핵심 가설 (Objective & Hypothesis)본 테스트의 목적은 단순히 "쿼리 속도"를 비교하는 것이 아니라, 제한된 리소스(Connection Pool) 환경에서 대량의 데이터 조회 전략이 시스템 전체의 가용성(Availability)에 미치는 영향을 증명하는 데 있다.특히 Bulk Fetch 방식이 단일 쿼리임에도 불구하고, 왜 고부하 상황에서 Connection Timeout과 같은 시스템 장애를 유발하는지 다음의 논리로 검증한다.[핵심 가설: Connection Holding Time과 병목 현상]Origin (N+1): 잦은 네트워크 I/O로 인해 전체 수행 시간이 길어지고, 그만큼 커넥션을 오래 점유하여 대기 큐를 유발한다.Bulk Fetch (Risk): 쿼리는 1회지만, 과도한 IN 절 처리(Parsing & Fetch)로 인해 DB 응답 시간 자체가 증가한다. 이로 인해 단일 커넥션의 점유 시간(Holding Time)이 길어지고, 제한된 풀(Pool) 환경에서 후속 요청자들이 커넥션을 얻지 못해 **연쇄적인 타임아웃(Starvation)**이 발생한다.Chunk (Optimization): 쿼리 수를 최소화하면서도 DB가 가장 효율적으로 처리할 수 있는 단위(1,000건)로 분할하여, 커넥션 점유 시간 단축과 처리량(Throughput) 극대화의 균형을 찾는다.2. 테스트 환경 및 통제 변수 (Environment & Control Variables)DB 내부를 볼 수 없는 블랙박스 환경에서, 애플리케이션 레벨의 병목 현상을 극대화하여 시각화하기 위해 다음과 같이 환경을 통제한다.A. HikariCP 커넥션 풀 설정 (Bottleneck Point)서비스의 동시 처리 능력을 의도적으로 제한하여, 쿼리 효율성이 떨어질 때 즉각적인 큐잉(Queuing) 현상이 발생하도록 유도한다.maximum-pool-size : 10개의도: 동시 접속자가 50명일 때, 물리적인 커넥션 10개를 두고 경쟁(Contention)하게 만듦.connection-timeout : 2,000ms (2초)의도: 커넥션 획득 대기가 2초 이상 길어지면 가차 없이 에러를 뱉게 하여, **"사용자가 기다리다 지쳐 떠나는 상황"**을 시뮬레이션함.B. 데이터 볼륨 및 부하 수준 (Workload)Oracle의 하드 리밋(ORA-01795)과 대량 데이터 처리 부하를 재현한다.Target Data Size : 2,000건 (매물 ID)의도: Oracle IN 절 제한(1,000개)을 2배 초과하는 데이터셋을 통해 에러 발생 및 Hibernate의 쿼리 분할 동작을 관측.JMeter Threads (Concurrent Users) : 50명의도: 커넥션 풀(10개) 대비 5배의 트래픽을 인가하여, 쿼리가 조금만 지연되어도 Pending Queue가 급증하는 상황 연출.3. 시나리오별 상세 검증 계획 (Detailed Test Scenarios)시나리오 A: Origin Code (Loop / N+1)"네트워크 I/O 누적으로 인한 커넥션 점유 지연 검증"동작 메커니즘: 25개 자치구에 대해 Loop를 돌며 25회의 SELECT 실행.예상되는 장애 패턴:DB CPU 부하는 낮으나, App-DB 간 왕복 시간(RTT) 누적으로 인해 요청 처리 시간(Latency)이 3초 이상 소요됨.요청 하나가 커넥션을 3초간 붙잡고 있으므로, 10개의 커넥션으로는 초당 3~4건의 요청밖에 처리 못함.결과적으로 대기 중인 40여 명의 사용자는 Connection Timeout 오류를 직면함.관측 포인트: Hibernate 로그(25줄) / 낮은 TPS / 높은 Timeout 비율.시나리오 B: Bulk Fetch Code (One-Shot / High Risk)"과도한 단일 쿼리 부하로 인한 리소스 고갈 및 에러 검증"동작 메커니즘: 2,000개의 ID를 단 하나의 IN 절에 담아 요청.예상되는 장애 패턴:Case 1 (Oracle 에러): 쿼리 전송 즉시 ORA-01795 (최대 1,000개 제한) 발생으로 500 에러 응답. (기능적 결함)Case 2 (Hibernate 강제 분할 시): 내부적으로 OR로 쿼리를 쪼개더라도, 복잡한 파싱(Parsing) 비용과 대량의 데이터 Fetching으로 인해 DB 응답이 지연됨.단 하나의 쿼리지만 처리 시간이 길어지므로(예: 2.5초), 커넥션이 반환되지 않고 계속 점유 상태(Active) 유지.제한된 10개의 커넥션이 모두 "무거운 쿼리"를 처리하느라 묶여 있어, 신규 진입 사용자는 커넥션을 얻지 못하고 대기하다 시스템 오류(Timeout) 발생.관측 포인트: ORA-01795 발생 여부 / 긴 SQL 파싱 시간 / Error Rate 급증.시나리오 C: Chunk Code (Partitioned / Optimization)"안정적인 커넥션 반환 주기(Turnaround) 확보"동작 메커니즘: 2,000개의 ID를 1,000개 단위로 나누어 총 2회의 쿼리 실행.기대 효과 및 검증:Soft Parse 유도: 쿼리 형태가 고정되어 DB 파싱 부하 최소화.빠른 반환: 적절한 크기(Chunk)의 데이터만 조회하므로 DB 응답이 빠름 (예: 0.2초).높은 회전율: 커넥션을 0.2초만 쓰고 반납하므로, 10개의 커넥션으로도 50명의 요청을 빠르게 순환 처리(Context Switching) 가능.큐잉 해소: 대기열이 생기더라도 금방 소진되어 Timeout 없이 모든 요청 처리 성공.관측 포인트: IN 절 파라미터 개수(1000개) / Error 0% / TPS 2배 이상 향상.4. 핵심 관측 지표 및 성공 기준 (Metrics & Success Criteria)본 테스트의 성공 여부는 단순한 '감'이 아닌 다음의 수치로 판단한다.지표 (Metric)Origin (N+1)Bulk (Risk)Chunk (Target)성공 기준 (Success Criteria)SQL Count25회1회 (or N/A)2~3회의도된 횟수만큼 쿼리 분할 확인 (로그)Error RateLow (Timeout)High (500 Error)0%ORA-01795 및 Timeout 완전 제거TPSLowHigh (Fail)Very HighOrigin 대비 200% 이상 향상Latency2,000ms+50ms (Error)200ms 내외사용자 체감 속도 80% 이상 개선Hikari StatusPending 급증Active 고착Idle 순환커넥션 고갈 없이 안정적 순환 확인