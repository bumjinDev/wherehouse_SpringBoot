3단계: 핵심 기술 지식 및 이론적 근거 (Technical Background)본 테스트 계획과 성능 튜닝의 방향성은 아래의 데이터베이스 내부 동작 원리와 애플리케이션 리소스 관리 이론에 기반을 두고 수립되었습니다.1. RDBMS의 IN vs OR 연산자 처리 메커니즘 차이A. 동작 원리의 본질적 차이OR 연산자 (Logical Disjunction):옵티마이저는 OR로 연결된 각 조건을 **개별적인 필터(Filter)**로 인식합니다.인덱스 컬럼에 OR가 과도하게 사용될 경우, 옵티마이저는 각 조건마다 인덱스를 탐색하고 결과를 합치는 비용(Bitmap Concatenation 등)이 테이블 전체를 읽는 것(Full Table Scan)보다 비싸다고 판단할 확률이 높습니다.결과: 인덱스 무시(Ignore Index) 및 Full Table Scan 유발의 주범이 됩니다.IN 연산자 (Set Membership):옵티마이저는 IN 절의 값들을 **하나의 집합(Set)**으로 취급합니다.내부적으로 'IN-List Iterator' 방식을 사용하여, 인덱스의 Root에서부터 수직 탐색을 수행하고, 정렬된 값들을 기반으로 Index Range Scan을 효율적으로 수행할 수 있습니다.결과: 인덱스를 탈 확률이 매우 높으며, I/O 비용이 획기적으로 감소합니다.B. Hibernate의 Bulk Fetch 시 쿼리 변환 위험성Hibernate는 findAllById 호출 시 파라미터 개수가 많으면, 내부적으로 이를 처리하기 위해 SQL을 생성합니다.만약 Oracle의 제약(1,000개)을 회피하기 위해 Hibernate가 (ID IN (1...1000) OR ID IN (1001...)) 형태로 쿼리를 쪼개서 OR로 연결한다면, 위에서 언급한 OR 연산자의 비효율성 때문에 **실행 계획이 Full Scan으로 퇴행(Degradation)**할 위험이 존재합니다.2. Oracle ORA-01795 제한과 내부 파싱(Parsing) 원리A. 왜 1,000개 제한이 있는가? (Hard Limit)Oracle 데이터베이스는 SQL 문장 내의 IN 절에 포함될 수 있는 리터럴(Literal) 값의 개수를 최대 1,000개로 하드 코딩하여 제한합니다.이유:파서(Parser)의 깊이 제한: SQL 파싱 트리(Parse Tree)를 구성할 때 과도한 재귀(Recursion) 호출로 인한 스택 오버플로우 방지.쿼리 최적화 비용 증가: 1,000개가 넘는 값에 대해 최적의 실행 경로를 계산하는 비용이 쿼리 실행 자체보다 커지는 것을 방지.B. Hard Parse vs Soft Parse (Chunking의 핵심 근거)Bulk Fetch(가변적 리스트)와 Chunk Fetch(고정적 리스트)의 성능 차이는 파싱 비용에서 발생합니다.Hard Parse (나쁨):SQL 문장이 단 한 글자라도 다르면(예: ID 개수가 998개일 때와 999개일 때), DB는 이를 완전히 새로운 쿼리로 인식합니다.문법 검사, 권한 확인, 실행 계획 수립을 처음부터 다시 수행하며, 이 과정에서 CPU 사용량이 급증하고 Shared Pool에 **Latch Contention(병목)**을 유발합니다.Soft Parse (좋음 - Chunking의 목적):Chunk 로직을 통해 조회 ID 개수를 항상 1,000개로 고정하면, SQL 문장의 형태가 동일하게 유지됩니다.DB는 메모리(Library Cache)에 저장된 기존 실행 계획을 재사용하므로, 파싱 비용이 거의 '0'에 수렴합니다.3. 커넥션 풀링(Connection Pooling)과 큐잉 이론(Queuing Theory)A. Connection Holding Time (점유 시간)의 치명적 영향제한된 리소스(Connection Pool Size = 10) 환경에서 시스템 장애는 **"쿼리 수행 시간(Duration)"**과 **"커넥션 점유 시간(Holding Time)"**의 누적으로 발생합니다.Transaction Start: 커넥션 풀에서 커넥션 1개를 빌림 (Active: 1, Idle: 9).Execution:Origin: 25번의 네트워크 왕복(RTT) 동안 커넥션을 계속 쥐고 있음 (예: 3초).Bulk: 거대한 데이터 파싱 및 Fetching 동안 커넥션을 쥐고 있음 (예: 2.5초).Transaction End: 커넥션 반납.[장애 발생 메커니즘]단일 요청 처리 시간($T$)이 길어지면, 리틀의 법칙($L = \lambda W$)에 의해 시스템 내 대기하는 요청($L$)이 급격히 증가합니다.커넥션 10개가 모두 2~3초짜리 "무거운 작업(Origin/Bulk)"을 처리하느라 바쁜 상태(Active)에서, 11번째 요청이 들어오면 HikariCP 큐(Queue)에 진입합니다.이 대기 시간이 connection-timeout(설정값 2초)을 초과하는 순간, 애플리케이션은 Connection Timeout 예외를 던지고 서비스 장애로 이어집니다.B. 결론: 왜 Chunking인가?Chunking은 1,000개 단위의 **가벼운 쿼리(Short Transaction)**를 수행합니다 (예: 0.2초).0.2초 만에 커넥션을 쓰고 반납하므로, **커넥션 회전율(Turnaround Rate)**이 극대화됩니다.결과적으로 동일한 10개의 커넥션으로도 대기열(Queue)을 만들지 않고 50명 이상의 동시 접속자를 안정적으로 처리할 수 있습니다.[요약] 포트폴리오에 서술할 핵심 논리 연결Problem: Origin은 RTT로 인한 Holding Time 증가, Bulk는 Oracle 제한(ORA-01795) 및 Hard Parse 부하 발생.Analysis: 이로 인해 제한된 커넥션 풀이 고갈되고, 사용자 요청이 Queuing 되다가 Timeout 장애 발생.Solution (Chunking):1,000개 제한 회피: 안정성 확보.Soft Parse 유도: CPU 및 파싱 효율 최적화.Holding Time 단축: 커넥션 회전율을 높여 동시성 이슈(Timeout) 해결.