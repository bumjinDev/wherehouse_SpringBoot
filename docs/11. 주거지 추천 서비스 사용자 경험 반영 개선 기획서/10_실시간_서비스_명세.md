## 10. 실시간 서비스 명세 (Real-time Service Specification)

### 10.1 개요 (Overview)

#### 10.1.1 목적 (Purpose)

본 서비스 명세는 사용자의 주거 조건(예산, 평수, 지역)과 우선순위(가격, 안전, 공간)를 입력받아 최적의 매물을 실시간으로 추천하는 **하이브리드 추천 엔진(Hybrid Recommendation Engine)**의 로직을 정의한다.

기존의 검증된 정량적 분석 로직(공공데이터 기반)을 훼손하지 않으면서, 실거주자의 정성적 경험 데이터(리뷰 평점 및 키워드)를 **동등한 비중(50:50)**으로 통합하여 추천 결과의 신뢰도와 사용자 만족도를 극대화하는 것을 목표로 한다. 또한, Redis 파이프라인(Pipeline) 기술을 도입하여 데이터 조회 복잡도 증가에도 불구하고 밀리초(ms) 단위의 응답 속도를 보장한다.

#### 10.1.2 서비스 범위 및 책임 (Scope & Responsibility)

* **입력 처리**: `CharterRecommendationRequestDto` 및 `MonthlyRecommendationRequestDto`를 통해 사용자의 검색 조건과 우선순위 가중치를 수신한다.
* **검색 및 필터링**: Redis의 정렬된 인덱스(Sorted Set)를 활용하여 조건에 부합하는 후보 매물군을 1차적으로 선별하고, 매물 부족 시 자동 완화(Fallback) 로직을 수행한다.
* **데이터 조회**: 선별된 후보 매물에 대해 매물 상세 정보와 리뷰 통계 정보를 Redis에서 병렬로 조회한다.
* **점수 산출 (Scoring)**: 공공데이터 기반의 기존 점수(50%)와 리뷰 기반의 신규 점수(50%)를 가중 합산하여 최종 랭킹을 산정한다.
* **응답 반환**: 최종 순위가 결정된 지역구 및 매물 리스트를 클라이언트가 요구하는 포맷(String ID 포함)으로 변환하여 반환한다.

#### 10.1.3 AS-IS vs TO-BE 비교 (Key Changes)

본 고도화 프로젝트는 기존 시스템의 검증된 로직을 기반으로 하되, 리뷰 데이터 통합을 위한 조회 대상 확장과 점수 산출 로직의 고도화에 중점을 둔다.

| 구분 | AS-IS (기존 시스템) | TO-BE (고도화 시스템) | 비고 |
|------|---------------------|---------------------|------|
| **검색 로직** | **인덱스 교집합 기반 검색**<br/><br/>사용자의 검색 조건에 따라 Redis Sorted Set 인덱스(가격, 평수, 지역) 간의 교집합 연산을 수행하며, 결과가 부족할 경우 2단계에 걸쳐 조건을 완화하는 폴백(Fallback) 로직을 수행한다. | **[유지] 기존 로직 100% 재사용**<br/><br/>이미 검증된 검색 성능과 시스템 안정성을 확보하기 위해, 매물 후보군을 추출하는 1차 검색 및 폴백 프로세스는 변경 없이 기존 로직을 그대로 계승한다. | 변경 없음 |
| **데이터 조회** | **단일 도메인 파이프라인 조회**<br/><br/>`Redis Pipeline`을 사용하여 검색된 매물 ID 리스트에 해당하는 매물 상세 정보(`property:*`)만을 조회한다. | **단계별 데이터 조회 (Phased Retrieval)**<br/><br/>Phase 1에서는 기존과 동일하게 매물 정보(`property:*`)만 조회하여 정량 점수를 산출한다. Phase 2에서는 리뷰 통계(`stats:*`)를 별도 Pipeline으로 조회하여 정성 점수를 산출한 후 통합한다. 이를 통해 기존 로직의 안정성을 보존하면서 리뷰 데이터를 비침해적으로 확장한다. | 로직 확장 (비침해적) |
| **점수 산출** | **정량적 단일 평가**<br/><br/>가격, 평수, 안전성 세 가지 정량적 지표만을 사용하여 점수를 산출하며, 이를 100% 비중으로 반영한 `LegacyScore`를 최종 점수로 사용한다. | **하이브리드 복합 평가**<br/><br/>공공데이터 기반의 정량 점수(50%)와 사용자 리뷰 기반의 정성 점수(50%)를 가중 합산한다. 단, 리뷰 개수가 5개 미만인 경우 등 통계적 유의성이 부족한 경우 리뷰 점수를 배제하고 정량 점수만을 100% 반영한다. | 알고리즘 고도화 |
| **데이터 타입/ID 체계** | **Long ID 체계**<br/><br/>매물 식별자(`propertyId`)가 숫자형(Long)으로 정의되어 있으며, 배치 실행 시마다 UUID 기반으로 새로운 ID가 생성되는 휘발성 구조를 가진다. | **String ID 체계**<br/><br/>매물 식별자 32자 길이의 문자열(String)로 변경된다. 불변 속성을 조합한 MD5 Hash 값을 직접적에 데이터의 영속성을 보장하며, 이에 따라 API 응답 명세의 타입 변경이 수반된다. | API 명세 변경<br/>(Breaking Change) |

---

### 10.2 상세 프로세스 명세 (Detailed Process Specification)

#### 10.2.1 전세 추천 서비스 (CharterRecommendationService)

본 서비스의 로직은 **기존 시스템의 안정성을 보장하는 검색 단계(Phase 1)**와 **리뷰 데이터를 통합하여 가치를 창출하는 점수 산출 단계(Phase 2)**로 명확히 구분되어 순차적으로 실행된다.

##### Phase 1: 기존 로직 기반 후보군 추출 및 기본 점수 산출

Phase 1은 기존 시스템의 검증된 로직을 100% 재사용하여 매물 후보군을 확보하고, 공공데이터 기반의 정량적 점수를 산출하는 단계이다.

| 기능 ID | 기능명 | 상세 구현 내용 |
|---------|--------|----------------|
| C-01 | 전세 전 지역구 1차 검색 (Strict) | 1. 서울시 25개 자치구를 모두 순회한다.<br/>2. 안전성 조건이 있을 경우 지역구 레벨에서 사전 필터링을 적용한다.<br/>3. 각 자치구마다 2개 인덱스 교집합을 수행한다: `idx:charterPrice:{지역구}` ∩ `idx:area:{지역구}:전세`<br/>4. 전세금과 평수 조건을 모두 만족하는 매물 ID들의 교집합을 구하여, 각 지역구별 유효 매물 ID 리스트를 생성한다. |
| C-02 | 전세 폴백(Fallback) 조건 판단 | 1. C-01에서 생성된 지역구별 매물 중 3개 미만인 지역구가 있는지 검사한다.<br/>2. 부족한 지역구가 있을 경우, C-03 확장 검색을 실행한다.<br/>3. 모든 지역구가 충족될 경우, C-04 점수 계산으로 넘어간다. |
| C-03 | 전세 2차 확장 검색 (Expanded) | 1. 매물이 부족한 지역구들만 추출한다.<br/>2. 사용자의 3순위 조건을 완화하여 부족한 지역구들만 재검색한다.<br/>3. 여전히 부족하면 2순위 조건까지 완화하여 재검색한다.<br/>4. 완화된 조건 정보를 응답 메시지에 포함한다. |
| C-04 | 전세 매물 단위 점수 계산 | 1. Redis Pipeline으로 매물 상세 정보(`property:charter:{id}`)를 일괄 조회한다.<br/>2. 정규화 범위(`bounds:{지역구}:전세`)를 조회한다.<br/>3. 각 매물의 가격/평수/안전 점수를 0~100점으로 계산한다.<br/>4. 우선순위별 가중치(60%/30%/10%)를 적용하여 최종 점수를 산출한다.<br/>5. 각 지역구 내에서 매물을 최종 점수 기준으로 내림차순 정렬한다. |
| C-05 | 전세 지역구 단위 점수 계산 | 1. 각 지역구의 대표 점수를 산출한다: `평균 finalScore × log(매물 개수 + 1)` |

---

**Phase 1 구현 참고사항**

Phase 1의 상세한 구현 로직은 "부동산 추천 시스템 비즈니스 로직 설계 명세서.md"에 완전히 명세되어 있다. 본 섹션에서는 Phase 2와의 연계를 위해 필요한 최소한의 정보만 기술한다.

**Phase 2 연계를 위한 핵심 사항**

Phase 1은 `List<DistrictWithScore>` 타입의 정렬된 지역구 리스트를 반환한다. 이 리스트의 각 지역구 객체는 `propertiesWithScores` 필드를 포함하며, 이 필드는 `List<PropertyWithScore>` 타입으로 해당 지역구의 모든 매물 정보를 담고 있다.

**매물 레벨 데이터 구조**

각 `PropertyWithScore` 객체는 다음 필드를 포함한다:
- `propertyId`: MD5 Hash 기반 String 타입 식별자 (Phase 2에서 Redis `stats:charter:{id}` 조회 시 사용)
- `propertyDetail`: 매물 상세 정보 (Phase 2에서 재사용, 재조회 불필요)
- `priceScore`: 전세금 점수 (0~100점)
- `spaceScore`: 평수 점수 (0~100점)
- `safetyScore`: 안전 점수 (0~100점)
- `finalScore`: Phase 1 종료 시점의 최종 매물 점수 (LegacyScore와 동일, Phase 2에서 덮어쓰기 대상)

**지역구 레벨 데이터 구조**

각 `DistrictWithScore` 객체는 다음 필드를 포함한다:
- `districtName`: 지역구명
- `propertiesWithScores`: 해당 지역구의 매물 리스트
- `averageFinalScore`: 지역구 내 모든 매물의 평균 finalScore
- `districtRepresentativeScore`: 지역구 대표 점수 = `평균 finalScore × log(매물 개수 + 1)` (Phase 2에서 재계산 대상)

Phase 2는 이 데이터 구조를 직접 수정한다. 새로운 객체를 생성하지 않고, Phase 1이 반환한 객체의 필드 값만 변경하는 방식이다.



**Phase 1 종료 및 Phase 2 전환점**

Phase 1은 C-05의 지역구별 대표 점수 산출 및 정렬까지 수행된다. 기존 시스템에서는 이 정렬된 결과를 그대로 응답으로 변환했으나, 고도화 시스템에서는 **Phase 2에서 리뷰 점수를 통합하여 재정렬**한다.

Phase 1이 종료되는 시점에는 다음 정보를 포함한 지역구 리스트가 생성된다:
- 각 지역구명과 해당 지역구의 매물 리스트
- 각 매물의 상세 정보 (MD5 Hash 기반 propertyId, 아파트명, 평수, 층수, 주소 등)
- 각 매물의 정량 점수 (priceScore, spaceScore, safetyScore)
- 각 매물의 최종 점수 (finalScore, 이 시점에서는 LegacyScore와 동일)
- 각 지역구의 평균 점수 및 대표 점수

Phase 2는 위 리스트를 그대로 입력으로 받아, 각 매물의 propertyId를 사용하여 리뷰 통계를 조회한 후, reviewScore를 산출하여 finalScore를 재계산한다. 그 후 변경된 점수를 기준으로 매물과 지역구를 재정렬한다.

---

##### Phase 2: 리뷰 데이터 통합 및 최종 랭킹 산출 (Review Integration & Final Ranking)

**정의**: 기존 로직(Phase 1)을 통해 산출된 정량 데이터에 사용자 리뷰 데이터를 결합하고, 하이브리드 알고리즘을 적용하여 최종 순위를 확정하는 확장 단계이다.

**설계 원칙**: 네트워크 비용(RTT)을 최소화하는 **데이터 집계 패턴(Aggregation Pattern)**을 적용하고, **관심사 분리(SoC)**를 통해 리뷰 로직을 독립적으로 관리한다.

| 기능 ID | 기능명 | 상세 구현 내용 |
|---------|--------|----------------|
| C-06 | 통합 데이터 파이프라인 조회 (Aggregation) | 1. **파이프라인 생성**: Phase 1에서 전달받은 매물 ID 리스트를 추출하여 `Redis Pipeline`을 생성한다.<br/>2. **리뷰 통계 조회**: 리뷰 통계 정보(`stats:charter:{id}`)를 일괄 조회한다. (매물 상세 정보는 Phase 1에서 이미 조회 완료되어 재사용)<br/>3. **Null Object 처리**: 신규 매물이라 리뷰 통계 키(`stats`)가 존재하지 않는 경우, 시스템 안정성을 위해 `{reviewCount: 0, avgRating: 0.0, positiveKeywordCount: 0, negativeKeywordCount: 0}`으로 초기화된 기본 객체(Default Value)를 할당한다. |
| C-07 | 하이브리드 점수 산출 및 통합 (Hybrid Scoring) | **1. Review Score 산출 (정성 50%)**:<br/>- 평점 점수: `(AvgRating / 5.0) * 100`<br/>- 키워드 점수: `(PositiveCnt / (PositiveCnt + NegativeCnt)) * 100` (분모가 0일 경우 50점 기본값)<br/>- 중간 통합: `(평점 점수 * 0.5) + (키워드 점수 * 0.5)`<br/><br/>**2. Final Score 확정 (Cold Start 방어)**: 통계적 신뢰도 확보를 위해 리뷰 개수에 따라 가중치를 차등 적용한다.<br/>- Case A (`reviewCount >= 5`): `(LegacyScore * 0.5) + (ReviewScore * 0.5)`<br/>- Case B (`reviewCount < 5`): `LegacyScore * 1.0` (기존 정량 점수 100% 반영) |
| C-08 | 최종 랭킹 및 정렬 (Final Ranking) | 1. **정렬 기준**: C-07에서 산출된 `FinalScore`를 기준으로 전체 매물 리스트를 내림차순 정렬한다.<br/>2. **동점 처리 전략(Tie-breaking)**: 점수가 동일한 경우 다음의 우선순위 규칙을 순차적으로 적용한다.<br/>- 1순위: `ReviewCount` (리뷰가 많은 순)<br/>- 2순위: `AptName` (가나다순) |
| C-09 | 최종 응답 생성 및 반환 (Response Generation) | 1. **상위 추출(Top-N)**: 정렬된 결과에서 상위 3개 지역구를 선정하고, 각 지역구 내 상위 3개 매물을 추출한다.<br/>2. **DTO 매핑(Data Transfer)**: `TopCharterPropertyDto` 객체에 데이터를 매핑한다.<br/>- ID 매핑: 배치 단계에서 생성된 불변의 **MD5 Hash ID(String)**를 `propertyId` 필드에 매핑한다.<br/>- 리뷰 데이터 주입: `reviewCount`(Integer), `avgRating`(Double) 필드를 포함시킨다.<br/>3. **반환**: 최종 구성된 데이터를 `CharterRecommendationResponseDto`에 담아 컨트롤러로 반환한다. |

---

**Phase 2 구현 참고사항**

**Phase 1 출력의 직접 수정 패턴**

Phase 2는 Phase 1이 반환한 `List<DistrictWithScore>` 객체를 새로운 변수로 복사하거나 변환하지 않고, **메모리 상의 동일한 객체를 직접 수정**한다. 이는 다음과 같은 이유에서 선택된 설계이다:

첫째, Phase 1의 코드를 전혀 수정하지 않는다. Phase 1은 독립적으로 실행 완료되어 결과를 반환하고, Phase 2는 그 반환값을 받아 후처리한다. Phase 1의 메서드 시그니처, 반환 타입, 내부 로직 중 어떤 것도 변경하지 않는다.

둘째, 메모리 효율성을 확보한다. 수천 개의 매물 객체를 복사하지 않고 기존 객체의 필드만 갱신함으로써, 추가 메모리 할당을 최소화한다.

셋째, 데이터 구조의 일관성을 유지한다. Phase 1과 Phase 2 모두 동일한 `finalScore` 필드를 사용하므로, 이후 정렬 및 응답 생성 로직이 단일 필드만 참조하면 된다.

---

#### 10.2.2 월세 추천 서비스 (MonthlyRecommendationService)

본 서비스의 로직은 **기존 시스템의 안정성을 보장하는 검색 단계(Phase 1)**와 **리뷰 데이터를 통합하여 가치를 창출하는 점수 산출 단계(Phase 2)**로 명확히 구분되어 순차적으로 실행된다.

##### Phase 1: 기존 로직 기반 후보군 추출 및 기본 점수 산출

Phase 1은 기존 시스템의 검증된 로직을 100% 재사용하여 매물 후보군을 확보하고, 공공데이터 기반의 정량적 점수를 산출하는 단계이다.

| 기능 ID | 기능명 | 상세 구현 내용 |
|---------|--------|----------------|
| M-01 | 월세 전 지역구 1차 검색 (Strict) | 1. 서울시 25개 자치구를 모두 순회한다.<br/>2. 안전성 조건이 있을 경우 지역구 레벨에서 사전 필터링을 적용한다.<br/>3. 각 자치구마다 3개 인덱스 교집합을 수행한다: `idx:deposit:{지역구}` ∩ `idx:monthlyRent:{지역구}:월세` ∩ `idx:area:{지역구}:월세`<br/>4. 보증금, 월세금, 평수 조건을 모두 만족하는 매물 ID들의 교집합을 구하여, 각 지역구별 유효 매물 ID 리스트를 생성한다. |
| M-02 | 월세 폴백(Fallback) 조건 판단 | 1. M-01에서 생성된 지역구별 매물 중 3개 미만인 지역구가 있는지 검사한다.<br/>2. 부족한 지역구가 있을 경우, M-03 확장 검색을 실행한다.<br/>3. 모든 지역구가 충족될 경우, M-04 점수 계산으로 넘어간다. |
| M-03 | 월세 2차 확장 검색 (Expanded) | 1. 매물이 부족한 지역구들만 추출한다.<br/>2. 사용자의 3순위 조건을 완화하여 부족한 지역구들만 재검색한다.<br/>3. 여전히 부족하면 2순위 조건까지 완화하여 재검색한다.<br/>4. 완화된 조건 정보를 응답 메시지에 포함한다. |
| M-04 | 월세 매물 단위 점수 계산 | 1. Redis Pipeline으로 매물 상세 정보(`property:monthly:{id}`)를 일괄 조회한다.<br/>2. 정규화 범위(`bounds:{지역구}:월세`)를 조회한다.<br/>3. 각 매물의 보증금/월세금/평수/안전 점수를 0~100점으로 계산한다.<br/>4. PRICE 가중치를 보증금과 월세금에 50%씩 분배하여 적용한다.<br/>5. 우선순위별 가중치(60%/30%/10%)를 적용하여 최종 점수를 산출한다.<br/>6. 각 지역구 내에서 매물을 최종 점수 기준으로 내림차순 정렬한다. |
| M-05 | 월세 지역구 단위 점수 계산 | 1. 각 지역구의 대표 점수를 산출한다: `평균 finalScore × log(매물 개수 + 1)` |

---

**Phase 1 구현 참고사항**

Phase 1의 상세한 구현 로직은 "부동산 추천 시스템 비즈니스 로직 설계 명세서.md"에 완전히 명세되어 있다. 본 섹션에서는 Phase 2와의 연계를 위해 필요한 최소한의 정보만 기술한다.

**Phase 2 연계를 위한 핵심 사항**

Phase 1은 `List<DistrictWithScore>` 타입의 정렬된 지역구 리스트를 반환한다. 이 리스트의 각 지역구 객체는 `propertiesWithScores` 필드를 포함하며, 이 필드는 `List<PropertyWithScore>` 타입으로 해당 지역구의 모든 매물 정보를 담고 있다.

**매물 레벨 데이터 구조**

각 `PropertyWithScore` 객체는 다음 필드를 포함한다:
- `propertyId`: MD5 Hash 기반 String 타입 식별자 (Phase 2에서 Redis `stats:monthly:{id}` 조회 시 사용)
- `propertyDetail`: 매물 상세 정보 (Phase 2에서 재사용, 재조회 불필요)
- `depositScore`: 보증금 점수 (0~100점)
- `monthlyRentScore`: 월세금 점수 (0~100점)
- `spaceScore`: 평수 점수 (0~100점)
- `safetyScore`: 안전 점수 (0~100점)
- `finalScore`: Phase 1 종료 시점의 최종 매물 점수 (LegacyScore와 동일, Phase 2에서 덮어쓰기 대상)

**지역구 레벨 데이터 구조**

각 `DistrictWithScore` 객체는 다음 필드를 포함한다:
- `districtName`: 지역구명
- `propertiesWithScores`: 해당 지역구의 매물 리스트
- `averageFinalScore`: 지역구 내 모든 매물의 평균 finalScore
- `districtRepresentativeScore`: 지역구 대표 점수 = `평균 finalScore × log(매물 개수 + 1)` (Phase 2에서 재계산 대상)

Phase 2는 이 데이터 구조를 직접 수정한다. 새로운 객체를 생성하지 않고, Phase 1이 반환한 객체의 필드 값만 변경하는 방식이다.



**Phase 1 종료 및 Phase 2 전환점**

Phase 1은 M-05의 지역구별 대표 점수 산출 및 정렬까지 수행된다. 기존 시스템에서는 이 정렬된 결과를 그대로 응답으로 변환했으나, 고도화 시스템에서는 **Phase 2에서 리뷰 점수를 통합하여 재정렬**한다.

Phase 1이 종료되는 시점에는 다음 정보를 포함한 지역구 리스트가 생성된다:
- 각 지역구명과 해당 지역구의 매물 리스트
- 각 매물의 상세 정보 (MD5 Hash 기반 propertyId, 아파트명, 평수, 층수, 주소 등)
- 각 매물의 정량 점수 (depositScore, monthlyRentScore, spaceScore, safetyScore)
- 각 매물의 최종 점수 (finalScore, 이 시점에서는 LegacyScore와 동일)
- 각 지역구의 평균 점수 및 대표 점수

Phase 2는 위 리스트를 그대로 입력으로 받아, 각 매물의 propertyId를 사용하여 리뷰 통계를 조회한 후, reviewScore를 산출하여 finalScore를 재계산한다. 그 후 변경된 점수를 기준으로 매물과 지역구를 재정렬한다.

---

##### Phase 2: 리뷰 데이터 통합 및 최종 랭킹 산출 (Review Integration & Final Ranking)

**정의**: 기존 로직(Phase 1)을 통해 산출된 정량 데이터에 사용자 리뷰 데이터를 결합하고, 하이브리드 알고리즘을 적용하여 최종 순위를 확정하는 확장 단계이다.

**설계 원칙**: 네트워크 비용(RTT)을 최소화하는 **데이터 집계 패턴(Aggregation Pattern)**을 적용하고, **관심사 분리(SoC)**를 통해 리뷰 로직을 독립적으로 관리한다.

| 기능 ID | 기능명 | 상세 구현 내용 |
|---------|--------|----------------|
| M-06 | 통합 데이터 파이프라인 조회 (Aggregation) | 1. **파이프라인 생성**: Phase 1에서 전달받은 매물 ID 리스트를 추출하여 `Redis Pipeline`을 생성한다.<br/>2. **리뷰 통계 조회**: 리뷰 통계 정보(`stats:monthly:{id}`)를 일괄 조회한다. (매물 상세 정보는 Phase 1에서 이미 조회 완료되어 재사용)<br/>3. **Null Object 처리**: 신규 매물이라 리뷰 통계 키(`stats`)가 존재하지 않는 경우, 시스템 안정성을 위해 `{reviewCount: 0, avgRating: 0.0, positiveKeywordCount: 0, negativeKeywordCount: 0}`으로 초기화된 기본 객체(Default Value)를 할당한다. |
| M-07 | 하이브리드 점수 산출 및 통합 (Hybrid Scoring) | **1. Review Score 산출 (정성 50%)**:<br/>- 평점 점수: `(AvgRating / 5.0) * 100`<br/>- 키워드 점수: `(PositiveCnt / (PositiveCnt + NegativeCnt)) * 100` (분모가 0일 경우 50점 기본값)<br/>- 중간 통합: `(평점 점수 * 0.5) + (키워드 점수 * 0.5)`<br/><br/>**2. Final Score 확정 (Cold Start 방어)**: 통계적 신뢰도 확보를 위해 리뷰 개수에 따라 가중치를 차등 적용한다.<br/>- Case A (`reviewCount >= 5`): `(LegacyScore * 0.5) + (ReviewScore * 0.5)`<br/>- Case B (`reviewCount < 5`): `LegacyScore * 1.0` (기존 정량 점수 100% 반영) |
| M-08 | 최종 랭킹 및 정렬 (Final Ranking) | 1. **정렬 기준**: M-07에서 산출된 `FinalScore`를 기준으로 전체 매물 리스트를 내림차순 정렬한다.<br/>2. **동점 처리 전략(Tie-breaking)**: 점수가 동일한 경우 다음의 우선순위 규칙을 순차적으로 적용한다.<br/>- 1순위: `ReviewCount` (리뷰가 많은 순)<br/>- 2순위: `AptName` (가나다순) |
| M-09 | 최종 응답 생성 및 반환 (Response Generation) | 1. **상위 추출(Top-N)**: 정렬된 결과에서 상위 3개 지역구를 선정하고, 각 지역구 내 상위 3개 매물을 추출한다.<br/>2. **DTO 매핑(Data Transfer)**: `TopMonthlyPropertyDto` 객체에 데이터를 매핑한다.<br/>- ID 매핑: 배치 단계에서 생성된 불변의 **MD5 Hash ID(String)**를 `propertyId` 필드에 매핑한다.<br/>- 리뷰 데이터 주입: `reviewCount`(Integer), `avgRating`(Double) 필드를 포함시킨다.<br/>3. **반환**: 최종 구성된 데이터를 `MonthlyRecommendationResponseDto`에 담아 컨트롤러로 반환한다. |

---

**Phase 2 구현 참고사항**

**Phase 1 출력의 직접 수정 패턴**

Phase 2는 Phase 1이 반환한 `List<DistrictWithScore>` 객체를 새로운 변수로 복사하거나 변환하지 않고, **메모리 상의 동일한 객체를 직접 수정**한다. 이는 다음과 같은 이유에서 선택된 설계이다:

첫째, Phase 1의 코드를 전혀 수정하지 않는다. Phase 1은 독립적으로 실행 완료되어 결과를 반환하고, Phase 2는 그 반환값을 받아 후처리한다. Phase 1의 메서드 시그니처, 반환 타입, 내부 로직 중 어떤 것도 변경하지 않는다.

둘째, 메모리 효율성을 확보한다. 수천 개의 매물 객체를 복사하지 않고 기존 객체의 필드만 갱신함으로써, 추가 메모리 할당을 최소화한다.

셋째, 데이터 구조의 일관성을 유지한다. Phase 1과 Phase 2 모두 동일한 `finalScore` 필드를 사용하므로, 이후 정렬 및 응답 생성 로직이 단일 필드만 참조하면 된다.