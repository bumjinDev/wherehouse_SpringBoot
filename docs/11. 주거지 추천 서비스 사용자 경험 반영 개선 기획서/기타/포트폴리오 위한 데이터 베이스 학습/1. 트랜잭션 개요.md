# 트랜잭션 아키텍처: 데이터 정합성과 영속성의 물리적 구현

## 1. 서론: 트랜잭션의 엔지니어링 정의

본 명세는 주거지 추천 서비스 리뷰 시스템(FR-RV-01) 구축 시 적용된 데이터베이스 트랜잭션 아키텍처를 기술한다.

엔지니어링 관점에서 트랜잭션은 논리적 작업 단위를 넘어선, 물리적 재난 상황 하에서의 데이터 보전 메커니즘이다. 서버 전원 차단, 디스크 I/O 지연, 운영체제 커널 패닉 등 통제 불가능한 하드웨어 레벨 장애 발생 시에도 비즈니스 데이터의 완전성(Atomicity)과 영속성(Durability)을 보장하는 시스템 차원 안전장치로 정의된다. 본 문서는 COMMIT/ROLLBACK 시그널 발생 시 데이터베이스 엔진 내부의 메모리(Buffer)와 디스크(Disk) 간 발생하는 물리적 상호작용을 규명한다.

## 2. 원자성(Atomicity)의 아키텍처: 논리적 회복(Logical Recovery)

### 2.1 원자성의 기술적 목표

원자성은 트랜잭션 내 모든 연산이 데이터베이스에 완전 반영(All) 또는 완전 미반영(Nothing) 상태로만 존재하도록 강제하는 성질이다. 리뷰 작성 프로세스 중 예외 발생 시, 시스템 내부에 파편화된 데이터(Fragmented Data) 또는 고아 데이터(Orphaned Data)가 잔존하는 상황을 아키텍처 레벨에서 원천 차단한다.

### 2.2 핵심 구현체: Undo Log (Rollback Segment)

데이터베이스 엔진은 Undo Log 기반 역방향 복구(Reverse Recovery) 전략으로 원자성을 구현한다.

**Before Image의 선행 기록**

데이터베이스 엔진은 INSERT, UPDATE, DELETE 연산 수행 직전, 대상 데이터의 변경 전 원본 값(Before Image)을 Undo Log라는 별도 물리적 세그먼트에 선행 복사한다. 이 과정은 엔진 레벨 강제 선행 작업으로, 선택 사항이 아니다. 시스템은 이를 통해 변경 사항 취소 및 과거 상태 복원을 위한 복원 지점(Restore Point)을 확보한다.

### 2.3 롤백(Rollback) 메커니즘의 내부 동작

명시적 롤백 요청 또는 타임아웃/에러로 인한 세션 비정상 종료 시, 데이터베이스 엔진은 다음 논리적 회복 프로세스를 실행한다.

**Undo Segment Scan**

해당 트랜잭션 ID에 매핑된 Undo Log 레코드를 역순(LIFO: Last-In, First-Out)으로 스캔하여, 트랜잭션이 수행한 모든 변경 내역을 추적한다.

**Inverse Operation (역연산 수행)**

기록된 Before Image를 사용하여 실행된 작업의 역연산을 수행한다.

- INSERT된 레코드: 물리적 DELETE 수행 및 공간 회수
- UPDATE된 레코드: Undo Log 보관 이전 값으로 덮어쓰기(Restore)
- DELETE된 레코드: 삭제 마킹 해제 및 복구

**Atomic Completion**

모든 역연산 완료 시, 트랜잭션은 시작되지 않았던 상태와 물리적 비트(Bit) 단위까지 동일해지며, 데이터 무결성이 확보된다.

## 3. 일관성(Consistency)의 아키텍처: 제약 조건 기반 무결성 검증

### 3.1 일관성의 기술적 목표

일관성은 트랜잭션이 데이터베이스를 하나의 유효한 상태(Valid State)에서 다른 유효한 상태로만 전이시키도록 강제하는 성질이다. 리뷰 작성 프로세스에서 존재하지 않는 사용자 ID 참조, 평점 범위 위반(1~5점 외 값), 필수 컬럼 누락 등 비즈니스 규칙 위반을 데이터베이스 엔진 차원에서 사전 차단하여, 논리적으로 불가능한 데이터가 물리적 저장 매체에 영구 기록되는 상황을 원천 방지한다.

### 3.2 핵심 구현체: Constraint Validation Engine

데이터베이스는 스키마 정의 시 선언된 제약 조건(Constraint)을 통해 일관성을 강제한다.

**Primary Key / Unique Constraint**

테이블 내 레코드의 유일성(Uniqueness)을 보장하기 위해, 데이터베이스는 삽입/수정 연산 시 B-Tree 또는 Hash Index를 스캔하여 중복 키 존재 여부를 검증한다. 중복 발견 시 엔진은 즉시 연산을 거부하고 트랜잭션을 롤백한다.

**Foreign Key Constraint**

참조 무결성(Referential Integrity) 위반 방지를 위해, 자식 테이블(리뷰)에 레코드 삽입 시 부모 테이블(사용자, 주거지) 내 참조 키 존재 여부를 물리적으로 조회한다. 부재 시 연산 거부 및 에러 반환으로 고아 레코드(Orphaned Record) 생성을 차단한다. DELETE 연산 시에는 ON DELETE CASCADE 정책에 따라 자식 레코드 자동 삭제 또는 연산 거부를 수행한다.

**Check Constraint**

비즈니스 규칙의 데이터베이스 레벨 강제를 위해, 컬럼 값이 특정 조건식(평점 BETWEEN 1 AND 5)을 만족하는지 실시간 검증한다. 조건 위반 시 트랜잭션을 즉시 롤백하여, 애플리케이션 레벨 검증 누락에 따른 불량 데이터 유입을 최종 차단한다.

## 4. 격리성(Isolation)의 아키텍처: 동시성 제어와 트랜잭션 간 가시성 관리

### 4.1 격리성의 기술적 목표

격리성은 동시 실행되는 복수의 트랜잭션이 상호 간섭 없이 독립적으로 실행되는 것처럼 동작하도록 보장하는 성질이다. 대량 동시 리뷰 작성 환경에서, 한 트랜잭션의 중간 상태(Uncommitted Data)가 다른 트랜잭션에 노출되어 발생하는 데이터 불일치(Dirty Read, Non-Repeatable Read, Phantom Read)를 통제한다. 이는 순차 실행과 동일한 결과를 보장하면서도 병렬 처리를 통한 처리량(Throughput) 극대화를 달성하는 아키텍처 균형점이다.

**Dirty Read**

트랜잭션 A가 데이터를 변경했으나 아직 커밋하지 않은 상태에서, 트랜잭션 B가 해당 변경 사항을 읽는 현상이다. A가 이후 롤백될 경우, B는 실제로 존재하지 않았던 데이터를 기반으로 작업을 수행하게 되어 논리적 불일치가 발생한다. 리뷰 시스템에서 작성 중인 리뷰(아직 커밋 전)를 다른 트랜잭션이 조회하여 통계에 반영했으나, 작성자가 작업을 취소할 경우 통계 데이터가 왜곡되는 상황이 이에 해당한다.

**Non-Repeatable Read**

트랜잭션 A가 동일한 레코드를 두 번 읽는 사이, 트랜잭션 B가 해당 레코드를 수정하고 커밋하여, A의 두 번째 읽기 결과가 첫 번째와 달라지는 현상이다. A는 단일 트랜잭션 내에서 데이터 일관성을 기대했으나, 중간에 타 트랜잭션의 개입으로 인해 동일 쿼리가 다른 값을 반환한다. 리뷰 평점 집계 중 동일 리뷰를 재조회했을 때 평점이 변경되어 있어, 집계 로직 내부에서 불일치가 발생하는 경우가 대표적이다.

**Phantom Read**

트랜잭션 A가 특정 조건의 레코드 집합을 두 번 조회하는 사이, 트랜잭션 B가 해당 조건을 만족하는 새 레코드를 삽입하거나 기존 레코드를 삭제하여, A의 두 번째 조회에서 레코드 개수가 달라지는 현상이다. Non-Repeatable Read가 기존 레코드의 값 변경인 반면, Phantom Read는 레코드 자체의 출현/소멸을 다룬다. 평점 4점 이상 리뷰 목록을 조회 후 집계하는 도중, 타 트랜잭션이 새 4점 리뷰를 삽입하여 재조회 시 레코드가 추가되어 있는 상황이 해당한다.

### 4.2 핵심 구현체: 비관적 락(Pessimistic Lock)과 낙관적 락(Optimistic Lock)

데이터베이스는 동시성 충돌 발생 가능성에 대한 가정에 따라 두 가지 상이한 제어 전략을 제공한다. 비관적 락은 "충돌이 빈번히 발생할 것"이라는 전제 하에 트랜잭션 시작 시점에 즉시 데이터를 잠그는 방식이며, 낙관적 락은 "충돌이 드물게 발생할 것"이라는 전제 하에 커밋 시점에만 충돌을 검증하는 방식이다.

**비관적 락 (Pessimistic Lock)**

비관적 락은 트랜잭션이 데이터에 접근하는 순간 Lock을 획득하여, 다른 트랜잭션의 접근을 사전 차단함으로써 충돌 가능성 자체를 제거하는 전략이다. 데이터베이스 엔진은 두 가지 타입의 Lock을 통해 이를 구현한다.

Shared Lock(S-Lock, 공유 잠금)은 읽기 연산 수행 시 획득되며, 여러 트랜잭션이 동시에 동일 데이터를 읽는 것을 허용한다. 읽기 연산은 데이터를 변경하지 않으므로 상호 간섭이 없으며, S-Lock 간에는 충돌이 발생하지 않는다. Exclusive Lock(X-Lock, 배타적 잠금)은 쓰기 연산(INSERT, UPDATE, DELETE) 수행 시 획득되며, 해당 레코드에 대한 모든 접근을 배타적으로 차단한다. X-Lock 보유 트랜잭션만이 데이터를 변경할 수 있으며, 다른 트랜잭션은 읽기조차 수행할 수 없다.

비관적 락의 장점은 데이터 일관성을 강력히 보장한다는 점이다. 충돌이 빈번한 환경에서 트랜잭션 간 간섭을 원천 차단하여, 데이터 무결성을 확실히 유지한다. 금융 거래, 재고 차감, 좌석 예약 등 충돌 시 비즈니스 손실이 발생하는 시스템에 적합하다. 그러나 단점도 명확하다. Lock 보유 시간 동안 다른 트랜잭션이 대기해야 하므로 동시 처리 성능이 저하되며, 트랜잭션 A와 B가 상호 간 Lock을 요구하는 순환 대기 상태인 교착상태(Deadlock)가 발생할 위험이 존재한다. 대규모 동시 접속 환경에서는 Lock 경합으로 인한 병목 현상이 심화될 수 있다.

**낙관적 락 (Optimistic Lock)**

낙관적 락은 트랜잭션 실행 중에는 Lock을 획득하지 않고, 커밋 시점에 데이터가 다른 트랜잭션에 의해 변경되지 않았는지 검증하는 전략이다. 충돌이 실제로 발생하지 않는 한 Lock 오버헤드를 전혀 발생시키지 않으며, PostgreSQL과 MySQL(InnoDB)은 MVCC(Multi-Version Concurrency Control)를 통해 이를 구현한다.

MVCC에서 각 트랜잭션은 시작 시점의 데이터베이스 스냅샷(Snapshot)을 기준으로 동작한다. 데이터 변경 시 기존 버전을 보존하고 새 버전을 생성하여, 동일 레코드에 대해 시간축을 따라 여러 버전이 공존한다. 읽기 트랜잭션은 자신의 스냅샷 시점에 유효한 버전만 조회하므로, 쓰기 트랜잭션이 새 버전을 생성하는 동안에도 Lock 없이 병렬 실행된다. 커밋 시점에 데이터베이스는 버전 번호(Version Number) 또는 타임스탬프를 비교하여, 읽기 시점과 쓰기 시점 사이에 타 트랜잭션이 데이터를 변경했는지 검증한다. 변경이 감지되면 트랜잭션은 롤백되며, 애플리케이션은 재시도 또는 에러 처리를 수행한다.

낙관적 락의 장점은 읽기 처리량 극대화이다. 읽기 연산이 Lock을 획득하지 않으므로 Lock 경합이 발생하지 않으며, 교착상태 위험이 존재하지 않는다. SNS 게시물 조회, 상품 목록 검색 등 읽기 위주 시스템에서 탁월한 성능을 제공한다. 그러나 단점은 충돌 빈도가 높은 환경에서 트랜잭션 실패율이 증가한다는 점이다. 반복적 재시도로 인한 성능 저하가 발생할 수 있으며, 애플리케이션 레벨에서 충돌 처리 로직을 구현해야 하는 부담이 존재한다.

## 5. ACID: 트랜잭션 신뢰성의 4대 보장 속성

### 5.1 ACID의 정의와 아키텍처적 역할

ACID는 트랜잭션이 데이터베이스 시스템에서 신뢰성 있게 처리되기 위해 만족해야 하는 4가지 필수 속성의 약어이다. Atomicity(원자성), Consistency(일관성), Isolation(격리성), Durability(영속성)의 첫 글자를 조합한 이 개념은, 1983년 Andreas Reuter와 Theo Härder가 처음 정립했다. 이 4가지 속성은 개별적으로 작동하는 것이 아니라, 상호 보완적으로 결합되어 비즈니스 데이터의 완전성(Integrity)과 일관성(Consistency)을 물리적 시스템 레벨에서 보장한다.

### 5.2 ACID 4대 속성의 정의

**Atomicity (원자성)**

트랜잭션 내 모든 연산이 완전히 실행되거나(All) 완전히 실행되지 않는(Nothing) 두 가지 상태만 존재하도록 보장하는 속성이다. 트랜잭션 중간에 장애가 발생하면, 이미 실행된 연산들을 모두 취소(Rollback)하여 트랜잭션 시작 전 상태로 복원한다. 데이터베이스는 Undo Log를 통해 변경 전 데이터를 보관하고, 실패 시 이를 기반으로 역연산을 수행하여 원자성을 구현한다. 이를 통해 시스템 내부에 파편화된 중간 상태 데이터가 잔존하는 상황을 원천 차단한다.

**Consistency (일관성)**

트랜잭션이 데이터베이스를 하나의 유효한 상태에서 다른 유효한 상태로만 전이시키도록 강제하는 속성이다. 데이터베이스 스키마에 정의된 모든 제약 조건(Primary Key, Foreign Key, Check Constraint 등)이 트랜잭션 전후로 항상 만족되어야 한다. 데이터베이스 엔진은 각 DML 연산 시 실시간으로 제약 조건을 검증하며, 위반 발견 시 즉시 트랜잭션을 롤백한다. 이를 통해 비즈니스 규칙에 어긋나는 논리적으로 불가능한 데이터가 물리적 저장 매체에 영구 기록되는 것을 방지한다.

**Isolation (격리성)**

동시 실행되는 복수의 트랜잭션이 상호 간섭 없이 독립적으로 실행되는 것처럼 동작하도록 보장하는 속성이다. 한 트랜잭션의 중간 상태가 다른 트랜잭션에 노출되지 않으며, 각 트랜잭션은 마치 시스템에서 홀로 실행되는 것과 동일한 결과를 얻는다. 데이터베이스는 Lock 또는 MVCC(Multi-Version Concurrency Control)를 통해 격리성을 구현하며, 이는 Dirty Read, Non-Repeatable Read, Phantom Read와 같은 동시성 이상 현상을 차단한다. 격리성은 병렬 처리를 통한 처리량 극대화와 데이터 일관성 보장 간 균형점을 제공한다.

**Durability (영속성)**

성공적으로 커밋된 트랜잭션의 결과는 시스템 장애(전원 차단, 디스크 손상 등) 발생에도 영구적으로 보존되어야 한다는 속성이다. 커밋 완료 응답을 받은 클라이언트는 해당 데이터가 어떠한 물리적 재난 상황에서도 유실되지 않음을 신뢰할 수 있어야 한다. 데이터베이스는 Write-Ahead Logging(WAL)을 통해 변경 내역을 먼저 Redo Log에 기록한 후 커밋을 완료하며, 장애 복구 시 이 로그를 재실행(Replay)하여 커밋된 데이터를 복원한다. 영속성은 하드웨어 레벨 장애에서도 데이터 유실 가능성을 0으로 수렴시킨다.

### 5.3 ACID 속성 간 상호작용

**원자성과 일관성의 결합**

원자성은 트랜잭션 내 모든 연산의 완전 성공 또는 완전 실패를 보장하며, 일관성은 트랜잭션 전후로 데이터베이스가 항상 유효한 상태를 유지하도록 강제한다. 원자성이 "부분 실행 상태"를 제거한다면, 일관성은 "완전 실행된 결과가 비즈니스 규칙을 위반하지 않는다"는 것을 보장한다. 리뷰 작성 트랜잭션에서 평점 저장은 성공했으나 리뷰 텍스트 저장이 실패한 경우, 원자성은 평점 저장까지 롤백하여 부분 반영을 방지하고, 일관성은 롤백 후 데이터베이스가 여전히 모든 제약 조건을 만족함을 검증한다.

**격리성과 일관성의 결합**

격리성은 동시 실행 트랜잭션 간 간섭을 차단하며, 일관성은 각 트랜잭션이 데이터베이스를 유효한 상태에서 다른 유효한 상태로만 전이시키도록 한다. 격리성이 없다면, 트랜잭션 A가 제약 조건을 위반하는 중간 상태를 트랜잭션 B가 읽어 B도 잘못된 연산을 수행할 수 있다. 격리성은 이러한 "오염된 읽기(Dirty Read)"를 차단하여, 각 트랜잭션이 독립적으로 일관성을 유지하도록 보장한다.

**원자성과 영속성의 결합**

원자성은 트랜잭션의 논리적 완전성을, 영속성은 커밋된 트랜잭션의 물리적 보존을 담당한다. 원자성이 Undo Log를 통해 "실패 시 이전 상태로 복원"을 구현한다면, 영속성은 Redo Log를 통해 "성공 시 장애에도 데이터 유지"를 구현한다. 이 두 속성은 Write-Ahead Logging(WAL) 아키텍처 위에서 함께 작동하며, 트랜잭션 결과가 메모리에서 디스크로 안전하게 전이되는 과정을 제어한다.

### 5.4 ACID의 설계 트레이드오프

ACID 속성의 완전한 보장은 성능 비용을 수반한다. Undo/Redo Log 기록은 추가 디스크 I/O를 발생시키고, Lock 및 MVCC는 CPU와 메모리 오버헤드를 유발하며, 제약 조건 검증은 연산 지연을 초래한다. 그러나 이러한 비용은 데이터 정합성 보장이라는 명확한 가치와 교환된다. 금융 거래, 재고 관리, 의료 기록 등 데이터 신뢰성이 핵심인 시스템에서 ACID는 협상 불가능한 요구사항이다. 반면 로그 수집, 캐시 갱신 등 일시적 불일치가 허용되는 시스템에서는 성능 최적화를 위해 ACID 속성을 완화할 수 있다.

## 6. 영속성(Durability)의 아키텍처: WAL 및 I/O 최적화 전략

### 6.1 영속성의 기술적 목표

영속성은 "성공적으로 커밋된 트랜잭션의 결과는 시스템 장애(Power Failure) 발생에도 영구 보존되어야 한다"는 원칙이다. 대량 리뷰 트래픽 유입 환경에서 디스크 I/O의 물리적 한계를 극복하고 데이터 유실(Data Loss)을 방지한다.

### 6.2 핵심 구현체: WAL (Write-Ahead Logging)

데이터 파일(Data File) 직접 기록 방식은 디스크 헤드의 임의 위치 이동을 요구하는 랜덤 I/O(Random I/O)를 유발하며, 이는 심각한 쓰기 지연(Latency)의 원인이 된다. 데이터베이스는 로그 선행 기입(WAL) 전략으로 이를 해결한다.

**WAL 원칙**

"데이터 파일(Table Space)에 변경 사항을 영구 기록하기 전, 반드시 로그 파일(Redo Log)에 변경 내역을 선행 기록해야 한다"는 아키텍처 대원칙이다.

### 6.3 Redo Log와 Sequential I/O의 상관관계

데이터베이스는 저장 매체의 물리적 특성을 활용하여 트랜잭션의 성능과 안정성을 동시 확보한다.

**Sequential Write (순차 기록)**

COMMIT 요청 시, 데이터베이스 엔진은 변경된 데이터의 새로운 값(After Image)을 Redo Log 파일 끝에 순차적으로 이어 붙인다(Append). 이 과정은 디스크 헤드의 물리적 이동을 최소화하는 순차 I/O(Sequential I/O) 방식을 사용하며, 랜덤 I/O 대비 압도적으로 빠른 기록 속도를 제공한다.

**Fast Commit (고속 커밋)**

데이터베이스 엔진은 실제 데이터 파일(Table Space) 변경 여부와 무관하게, Redo Log 버퍼가 디스크에 안전하게 내려써진(Flush) 시점을 커밋 완료로 간주하고 클라이언트에 성공 응답을 송신한다. 실제 데이터 파일로의 반영은 백그라운드 프로세스(Checkpoint)에 의해 비동기적으로 수행된다.

### 6.4 장애 복구 (Crash Recovery) 메커니즘

커밋 완료되었으나 실제 데이터 파일에 미반영된 상태(Dirty Page)에서 서버 전원 차단 시, 데이터베이스는 재기동 시 인스턴스 복구(Instance Recovery)를 수행한다.

**Redo Log Analysis**

마지막 체크포인트 이후의 Redo Log를 스캔하여, 커밋 완료 표시는 존재하나 데이터 파일에 부재한 트랜잭션을 식별한다.

**Roll Forward**

식별된 변경 내역을 순차적으로 재실행(Replay)하여, 유실될 뻔한 데이터를 메모리와 디스크에 복원한다. 이를 통해 시스템은 하드웨어 장애 상황에서도 데이터 유실 가능성을 0으로 수렴시킨다.

## 7. 핵심 기술 키워드 (Architecture Glossary)

본 시스템의 데이터 신뢰성을 구성하는 핵심 아키텍처 용어이다.

### 원자성 (Atomicity)

- **Undo Log (Rollback Segment)**: 트랜잭션 롤백 및 복구를 위한 변경 전 데이터 저장 논리적/물리적 공간
- **Logical Recovery**: 물리적 손상이 아닌 트랜잭션 철회에 따른 논리적 데이터 복구 과정
- **Before Image**: 데이터 변경 연산 수행 전 원본 데이터 상태

### 일관성 (Consistency)

- **Constraint**: 데이터베이스 스키마에 선언된 데이터 무결성 규칙 (Primary Key, Foreign Key, Check 등)
- **Referential Integrity**: 외래 키를 통한 테이블 간 참조 관계의 논리적 정합성

### 격리성 (Isolation)

- **Lock**: 동시성 제어를 위한 데이터 접근 배타 제어 메커니즘 (Shared Lock, Exclusive Lock)
- **MVCC (Multi-Version Concurrency Control)**: 데이터 다중 버전 관리를 통한 읽기-쓰기 충돌 회피 기법
- **Snapshot**: 특정 시점의 데이터베이스 일관된 상태를 나타내는 논리적 뷰

### 영속성 (Durability)

- **WAL (Write-Ahead Logging)**: 데이터 무결성을 위한 데이터 파일보다 로그 파일 선행 기록 기법
- **Redo Log**: 커밋된 트랜잭션의 영속성 보장 및 장애 복구 시 재실행(Replay)을 위한 로그
- **Sequential I/O**: 디스크 헤드 이동 최소화를 통한 연속적 데이터 기록 입출력 방식
- **Roll Forward**: 장애 발생 시 Redo Log 기반 커밋된 데이터 복원 과정