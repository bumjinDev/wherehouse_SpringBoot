# 트랜잭션 동시성 제어와 데이터 정합성 아키텍처

## 목차

1. [핵심 문제 정의: 동시성과 일관성의 딜레마](#1-핵심-문제-정의-동시성과-일관성의-딜레마)
2. [읽기 일관성과 Undo Log](#2-읽기-일관성과-undo-log)
   - 2.1 [물리적 작동 원리](#21-물리적-작동-원리)
3. [쓰기 제어와 Row-Level Locking](#3-쓰기-제어와-row-level-locking)
   - 3.1 [물리적 작동 원리](#31-물리적-작동-원리)
4. [실증적 검증](#4-실증적-검증)
   - 4.1 [개요](#41-개요)
   - 4.2 [실험 1: 읽기 일관성 검증](#42-실험-1-읽기-일관성-검증)
   - 4.3 [실험 2: 쓰기 제어 및 블로킹 검증](#43-실험-2-쓰기-제어-및-블로킹-검증)
   - 4.4 [결론](#44-결론)

---

## 1. 핵심 문제 정의: 동시성과 일관성의 딜레마

엔터프라이즈 시스템 트랜잭션 설계의 핵심 난제는 성능과 정확성 사이의 물리적 충돌이다.

동시성은 다수의 사용자가 동시에 시스템을 사용할 수 있어야 함을 의미하며, 이는 처리량과 직결된다. 일관성은 다수의 사용자가 동시에 같은 데이터를 수정하더라도 데이터가 오염되지 않아야 함을 의미하며, 이는 무결성과 직결된다.

데이터베이스는 이 상충되는 요구사항을 만족시키기 위해 MVCC(Multi-Version Concurrency Control)와 Locking이라는 상호 보완적인 두 가지 물리적 기제를 사용한다.

## 2. 읽기 일관성과 Undo Log

읽기 테스트에서 확인한 "세션 A는 5.0(최신값)을 보고, 세션 B는 4.4(과거값)를 보는 현상"은 데이터베이스의 논리적 회복 메커니즘인 Undo Log에 의해 구현된다.

### 2.1 물리적 작동 원리

트랜잭션이 데이터를 수정하는 순간, DB 엔진은 변경 전의 값(Before Image)을 Undo Segment라는 별도 디스크 영역에 복사한다.

세션 B가 데이터를 조회할 때, 해당 데이터 블록의 헤더를 확인하여 현재 수정 중 상태임을 감지한다.

엔진은 테이블의 현재 값이 아닌, Undo Segment에 피신된 과거 버전을 읽어와서 세션 B에게 반환한다.

이를 통해 "Writers do not block Readers" 원칙이 성립되며, 락 없이도 높은 읽기 성능과 격리성(Read Committed)을 동시에 보장한다.

## 3. 쓰기 제어와 Row-Level Locking

쓰기 테스트에서 경험한 "31초 간의 멈춤(Blocking)"은 데이터 무결성을 위해 동시성을 의도적으로 희생하는 직렬화 과정이다.

### 3.1 물리적 작동 원리

선행 트랜잭션(세션 A)이 UPDATE를 수행하면, 해당 행의 헤더에 트랜잭션 ID를 기록하고 TX Lock(배타적 잠금)을 획득한다.

후행 트랜잭션(세션 B)이 동일 행에 접근하면, 엔진은 Row Header를 스캔하여 이미 활성화된 Lock이 존재함을 감지한다.

엔진은 세션 B의 프로세스를 즉시 대기 큐로 이동시키고, 세션 상태를 ACTIVE에서 LOCK WAIT로 변경한다. 이는 애플리케이션 레벨에서 멈춤으로 관측된다.

세션 A가 COMMIT을 수행하여 Lock을 해제해야만, 대기 큐에 있던 세션 B가 깨어나 락을 획득하고 작업을 수행한다. 즉, 물리적으로 동시 요청을 순차 처리로 강제 변환한다.

## 4. 실증적 검증

### 4.1 개요

본 문서는 다중 사용자 환경에서 발생할 수 있는 데이터 정합성 문제(Dirty Read, Lost Update)를 해결하기 위해, 데이터베이스 엔진이 제공하는 물리적 방어 기제인 MVCC(Multi-Version Concurrency Control)와 Row-Level Locking의 동작을 실험을 통해 검증한 기록이다.

- DBMS: Oracle Database
- Target Table: REVIEW_LAB
- Test Scenario: 동일 데이터(REVIEW_ID=10)에 대한 2개 세션(Session A, Session B)의 동시 접근 및 수정 시도

### 4.2 실험 1: 읽기 일관성 검증

**테스트 시나리오**

선행 트랜잭션이 데이터를 수정했으나 아직 확정(Commit)하지 않은 상태에서, 후행 트랜잭션이 해당 데이터를 조회할 때 발생할 수 있는 Dirty Read(오염된 읽기) 방지 메커니즘을 확인한다.

**실행 쿼리 및 로그**

| 순서 | 주체 | 실행 쿼리 (SQL) | 관측 결과 |
|------|------|----------------|-----------|
| 1 | Session A | `SELECT SCORE FROM REVIEW_LAB WHERE REVIEW_ID = 10;` | 초기 값: 3.5 확인 |
| 2 | Session A | `UPDATE REVIEW_LAB SET SCORE = 5.0 WHERE REVIEW_ID = 10;` | 수정 완료 (아직 COMMIT 미수행) |
| 3 | Session A | `SELECT SCORE FROM REVIEW_LAB WHERE REVIEW_ID = 10;` | 변경된 값: 5.0 확인 (본인의 변경 사항) |
| 4 | Session B | `SELECT SCORE FROM REVIEW_LAB WHERE REVIEW_ID = 10;` | 조회 값: 4.4 (또는 초기값) 확인 |

**기술적 분석**

현상: Session B는 Session A가 수정한 5.0이 아닌, 수정 전의 값(4.4)을 조회하였다.

원인 (Undo Log): 오라클은 격리 수준(Read Committed) 준수를 위해, 아직 커밋되지 않은 데이터 블록 대신 Undo Segment에 보관된 Before Image(변경 전 데이터)를 읽어 반환하였다.

검증: 데이터베이스는 "Writers do not block Readers" 원칙에 따라 락을 사용하지 않고도 읽기 일관성(Consistent Read)을 보장함을 입증하였다.

### 4.3 실험 2: 쓰기 제어 및 블로킹 검증

**테스트 시나리오**

두 개의 트랜잭션이 동일한 행(Row)을 동시에 수정하려 할 때, 데이터베이스가 데이터 덮어쓰기(Lost Update)를 방지하기 위해 수행하는 물리적 직렬화(Serialization) 과정을 확인한다.

**실행 쿼리 및 로그**

| 순서 | 주체 | 실행 쿼리 (SQL) | 관측 결과 |
|------|------|----------------|-----------|
| 1 | Session A | (상태 유지: UPDATE 후 커밋 안 함) | REVIEW_ID=10 행에 대한 TX Lock(배타적 잠금) 보유 중 |
| 2 | Session B | `UPDATE REVIEW_LAB SET SCORE = 1.0 WHERE REVIEW_ID = 10;` | 쿼리 실행 즉시 멈춤(Hang/Blocking) 발생. 응답 없음 |
| 3 | Session B | (대기 상태 지속) | 31.308초 동안 대기함 (Session A가 커밋할 때까지) |
| 4 | Session A | `COMMIT;` | 커밋 완료 메시지 출력. Lock 해제 |
| 5 | Session B | (자동 재개) | Session A의 커밋 직후, 멈춰있던 쿼리가 실행 완료됨 (1 행 업데이트) |

**기술적 분석**

현상: Session B의 UPDATE 요청이 즉시 처리되지 않고, Session A가 종료될 때까지 대기 큐(Wait Queue)에서 블로킹되었다.

원인 (Row-Level Locking): Session A가 해당 행의 헤더에 트랜잭션 ID를 기록하고 TX Lock을 획득하였다. Session B는 락 획득에 실패하여 오라클 엔진에 의해 대기 상태(LOCK WAIT)로 강제 전환되었다. 이때 대기 이벤트 enq: TX - row lock contention이 발생하였다.

검증: 데이터베이스는 동시 수정 요청을 물리적으로 줄 세워(Serialization), 선행 트랜잭션이 완료되기 전까지 후행 트랜잭션의 데이터 변경을 원천 차단함을 입증하였다.

### 4.4 결론

본 실험을 통해, 주거지 추천 서비스의 리뷰 통계 데이터 정합성을 보장하기 위한 아키텍처적 근거를 확보하였다.

동시성 제어 전략: 다수의 사용자가 동시에 리뷰를 작성할 때 발생할 수 있는 경쟁 조건(Race Condition)을 해결하기 위해, 애플리케이션 레벨의 제어가 아닌 데이터베이스 레벨의 비관적 락(Pessimistic Locking)을 적용해야 한다.

설계 반영: UPDATE 문이 수행되는 동안 타 트랜잭션은 물리적으로 대기(Blocking)하므로, 시스템 전체의 처리량(Throughput) 저하를 막기 위해 트랜잭션 내에서 락 점유 시간을 최소화하는 설계를 적용한다.