# 주거지 추천 서비스 고도화 설계 명세서 검증 보고서

**문서 번호**: REVIEW-DESIGN-001  
**작성 일자**: 2025-11-28  
**검토 대상**: 주거지 추천 서비스 사용자 경험 반영 설계 명세서 v1.0  
**검토자**: Claude (AI Technical Reviewer)  
**작성자**: 정범진 (Back-end Engineer)

---

## 1. 검토 개요

### 1.1 검토 목적

본 보고서는 '주거지 추천 서비스 고도화 (Phase 2: Review System Integration)' 프로젝트의 설계 명세서가 기획서 및 요구사항 명세서의 의도를 정확히 반영하고 있는지, 그리고 기술적으로 구현 가능한 수준인지를 종합적으로 검증한다.

### 1.2 검토 범위

| 검토 대상 문서 | 버전 | 비고 |
|---------------|------|------|
| 부동산 추천 시스템 비즈니스 로직 설계 명세서 | v2.0 | 현재 운용 중인 기존 시스템 |
| 주거지 추천 서비스 사용자 경험 반영 개선 기획서 | - | 고도화 방향성 정의 |
| 주거지 추천 서비스 고도화 요구사항 명세서 | - | 기능/비기능 요구사항 |
| 주거지 추천 서비스 사용자 경험 반영 설계 명세서 | v1.0 | **검토 대상** |
| 기술 명세서: 매물 식별자 생성 전략 | SPEC-DATA-001 | 식별자 생성 규칙 |

### 1.3 검토 방법론

1. **문서 간 정합성 검증**: 기획서 → 요구사항 → 설계 간 일관성 확인
2. **아키텍처 타당성 검증**: 설계 패턴, 데이터 흐름, 동시성 제어 평가
3. **데이터 모델 검증**: 스키마 설계, 식별자 전략, 인덱스 효율성 평가
4. **비즈니스 로직 검증**: 점수 산출, 키워드 추출, 예외 처리 평가
5. **API 명세 검증**: RESTful 원칙, Breaking Change, 하위 호환성 평가

---

## 2. 문서 간 일관성 검증

### 2.1 점수 가중치 정의

#### 2.1.1 문서별 정의 현황

| 문서 | 정의 | 상태 |
|------|------|------|
| 기획서 | `최종점수 = (기존 로직 결과 × 70%) + (리뷰 점수 × 30%)` | 무시 대상 (명시됨) |
| 요구사항 명세서 | `최종 점수 = (기존 로직 점수 × 0.7) + (리뷰 복합 점수 × 0.3)` | ⚠️ 업데이트 필요 |
| 설계 명세서 | `FinalScore = (LegacyScore × 0.5) + (ReviewScore × 0.5)` | ✅ 최종 결정 |

#### 2.1.2 검증 결과

기획서에서 "점수 70:30 항목은 무시하라"고 명시하였으므로, **설계 명세서의 50:50 비율이 최종 결정사항**으로 판단된다.

#### 2.1.3 조치 필요 사항

요구사항 명세서(FR-RC-02)의 점수 비율을 70:30에서 50:50으로 수정하여 문서 간 정합성을 확보해야 한다.

---

### 2.2 리뷰 복합 점수 산출 공식

| 문서 | 정의 |
|------|------|
| 요구사항 명세서 (FR-RC-02) | `리뷰 점수 = (평점 점수 × 0.5) + (키워드 점수 × 0.5)` |
| 설계 명세서 (8.1.3절) | `ReviewScore = (RatingScore × 0.5) + (KeywordScore × 0.5)` |

**검증 결과**: ✅ 일치

---

### 2.3 Cold Start 임계값

| 문서 | 정의 |
|------|------|
| 기획서 | 리뷰 5개 미만 시 기존 로직 100% 반영 |
| 요구사항 명세서 | 리뷰 개수 임계값 5개 미만 시 리뷰 가중치 0 |
| 설계 명세서 | `reviewCount < 5` 시 `LegacyScore * 1.0` 반영 |

**검증 결과**: ✅ 일치

---

### 2.4 문서 정합성 종합 평가

| 항목 | 평가 | 비고 |
|------|------|------|
| 점수 비율 | ⚠️ 부분 불일치 | 요구사항 명세서 수정 필요 |
| 리뷰 복합 점수 공식 | ✅ 일치 | - |
| Cold Start 임계값 | ✅ 일치 | - |
| 데이터 모델 정의 | ✅ 일치 | 엔티티 구조 동일 |
| API 인터페이스 | ✅ 일치 | 엔드포인트, 파라미터 동일 |

---

## 3. 아키텍처 설계 타당성 검증

### 3.1 하이브리드 저장소 전략

#### 3.1.1 설계 구조

```
┌─────────────────────────────────────────────────────────────────┐
│                    하이브리드 저장소 아키텍처                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Write Layer (Oracle RDB)                                       │
│  ├── Source of Truth (원본 데이터)                               │
│  ├── ACID 트랜잭션 보장                                          │
│  ├── 참조 무결성 (FK) 관리                                        │
│  └── 비관적 락(Pessimistic Lock) 지원                            │
│                         │                                       │
│                         │ Write-Through Sync                    │
│                         ▼                                       │
│  Read Layer (Redis)                                             │
│  ├── 고속 캐시 (Millisecond 응답)                                │
│  ├── 검색 인덱스 (Sorted Set)                                    │
│  └── 리뷰 통계 캐시 (Hash)                                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 3.1.2 검증 결과

| 검증 항목 | 평가 | 근거 |
|----------|------|------|
| 역할 분리 명확성 | ✅ 적합 | RDB는 트랜잭션/무결성, Redis는 고속 조회 전담 |
| 동기화 전략 | ✅ 적합 | Write-Through 패턴으로 RDB 커밋 즉시 Redis 갱신 |
| 장애 복구 메커니즘 | ✅ 적합 | 캐시 웜업(Warm-up) 프로세스 명세됨 (2.4절) |
| 데이터 일관성 | ✅ 적합 | 최종 일관성(Eventual Consistency) 보장 설계 |

#### 3.1.3 잠재 이슈

Redis 동기화 실패 시 보상 로직(Compensation Flow)이 명세되어 있으나, 다음 항목의 구체적 정의가 누락됨:

- 재시도 주기 (Retry Interval)
- 최대 시도 횟수 (Max Retry Count)
- 백오프 전략 (Backoff Strategy)

**권고사항**: 구현 시 상수 정의 또는 설정 파일화 필요

---

### 3.2 이벤트 기반 파이프라인

#### 3.2.1 설계 구조

```
┌─────────────────────────────────────────────────────────────────┐
│                   이벤트 기반 배치 파이프라인                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  BatchScheduler                                                 │
│  ├── 국토부 API 데이터 수집                                       │
│  ├── MD5 Hash 기반 식별자 생성                                    │
│  └── DataCollectionCompletedEvent 발행                          │
│                         │                                       │
│                         │ @EventListener                        │
│                         ▼                                       │
│  RdbSyncListener                                                │
│  ├── [Tx Phase] B-04: RDB 매물 Upsert                           │
│  ├── [Tx Phase] B-05: 신규 매물 통계 초기화                       │
│  ├── [Tx Phase] B-06: 리뷰 데이터 전수 집계                       │
│  ├── [Tx Phase] B-07: 통계 테이블 현행화                          │
│  │              ─────── [COMMIT] ───────                        │
│  ├── [Post-Commit] B-08: Redis 캐시 동기화                       │
│  ├── [Post-Commit] B-09: 정규화 범위 재계산                       │
│  └── [Post-Commit] B-10: 리뷰 통계 캐시 동기화                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 3.2.2 검증 결과

| 검증 항목 | 평가 | 근거 |
|----------|------|------|
| 결합도 감소 | ✅ 적합 | BatchScheduler는 이벤트 발행만 담당 |
| 트랜잭션 경계 | ✅ 적합 | B-04~B-07 단일 트랜잭션, B-08~B-10 커밋 후 실행 |
| 비동기 처리 | ⚠️ 우려 | 기본 `@EventListener`는 동기 실행 |

#### 3.2.3 비동기 처리 이슈

**문제점**: Spring의 `@EventListener`는 기본적으로 **동기 실행**된다. 설계 명세서에서 "비동기로 수신"이라고 기술했으나, 실제 비동기 처리를 위해서는 추가 설정이 필요하다.

**권고 구현**:

```java
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {
    
    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(5);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("batch-sync-");
        executor.initialize();
        return executor;
    }
}

@Component
@RequiredArgsConstructor
public class RdbSyncListener {

    @Async
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleDataCollectionCompleted(DataCollectionCompletedEvent event) {
        // 비동기 처리 로직
    }
}
```

---

### 3.3 동시성 제어 전략

#### 3.3.1 비관적 락 적용

**적용 대상**: `REVIEW_STATISTICS` 테이블

```sql
SELECT * FROM REVIEW_STATISTICS 
WHERE PROPERTY_ID = :propertyId 
FOR UPDATE
```

#### 3.3.2 검증 결과

| 검증 항목 | 평가 | 근거 |
|----------|------|------|
| Race Condition 방지 | ✅ 적합 | FOR UPDATE로 배타적 락 획득 |
| 데드락 가능성 | ⚠️ 주의 필요 | 배치와 실시간 서비스 동시 갱신 시 발생 가능 |

#### 3.3.3 데드락 방지 권고사항

배치 처리(B-07)와 실시간 리뷰 서비스가 동일 row를 갱신할 때 데드락 발생 가능. 다음 전략 중 하나 적용 권고:

| 전략 | 구현 방법 |
|------|----------|
| 트랜잭션 타임아웃 | `@Transactional(timeout = 30)` |
| 갱신 순서 통일 | 항상 `PROPERTY_ID` 오름차순으로 갱신 |
| 실행 시간대 격리 | 배치는 새벽 시간대 유지 (현재 04:00:40) |

---

## 4. 데이터 모델 검증

### 4.1 식별자 생성 전략

#### 4.1.1 MD5 Hash 기반 Business Key

```
PropertyID = MD5(sggCd + "|" + jibun + "|" + aptNm + "|" + floor + "|" + excluUseAr)

예시:
Input:  "11680|123-4|래미안그레이튼|10|84.99"
Output: "5d41402abc4b2a76b9719d911017c592"
```

#### 4.1.2 검증 결과

| 검증 항목 | 평가 | 근거 |
|----------|------|------|
| 불변성 | ✅ 적합 | 해시 입력값이 모두 불변 속성으로 구성 |
| 유일성 | ⚠️ 제한적 | 동일 건물/층/면적 복수 매물 구분 불가 (설계 의도) |
| 충돌 확률 | ✅ 무시 가능 | MD5 충돌 확률 ≈ 1/2^128 |
| 인덱스 효율 | ✅ 적합 | 32자 고정 길이, B-Tree 균형 유지 |
| URL 안전성 | ✅ 적합 | 영숫자만 사용, RFC 3986 준수 |

#### 4.1.3 기술 명세서와의 정합성

SPEC-DATA-001 문서와 설계 명세서 간 식별자 생성 규칙이 **완전히 일치**함을 확인.

---

### 4.2 RDB 스키마 검증

#### 4.2.1 매물 테이블 (PROPERTIES_CHARTER / PROPERTIES_MONTHLY)

| 검증 항목 | 평가 | 근거 |
|----------|------|------|
| PK 타입 | ✅ 적합 | `CHAR(32)` - MD5 Hash 길이와 일치 |
| NOT NULL 제약 | ✅ 적합 | 해시 구성 요소에 적용됨 |
| 인덱스 설계 | ✅ 적합 | PK 인덱스 + DISTRICT_NAME 인덱스 |
| 전세/월세 분리 | ✅ 적합 | 스키마 차이(MONTHLY_RENT) 명확 |

#### 4.2.2 리뷰 테이블 그룹

**REVIEWS 테이블**:

| 검증 항목 | 평가 | 근거 |
|----------|------|------|
| PK 설계 | ✅ 적합 | Sequence 기반 REVIEW_ID |
| FK 참조 | ✅ 적합 | PROPERTY_ID → PROPERTIES |
| 인덱스 | ✅ 적합 | IDX_REVIEW_PROP_DT (커버링 인덱스) |

**REVIEW_STATISTICS 테이블**:

| 검증 항목 | 평가 | 근거 |
|----------|------|------|
| 1:1 관계 | ✅ 적합 | PROPERTY_ID가 PK이자 FK |
| 키워드 통계 분리 | ✅ 적합 | POSITIVE/NEGATIVE_KEYWORD_COUNT |
| 반정규화 설계 | ✅ 적합 | COUNT/AVG 연산 제거 목적 |

#### 4.2.3 누락된 DDL

설계 명세서 8.5.2절에서 **복합 유니크 인덱스**가 언급되었으나 실제 DDL이 명시되지 않음.

**필요한 DDL**:

```sql
-- 리뷰 중복 작성 방지 유니크 제약
ALTER TABLE REVIEWS ADD CONSTRAINT UK_REVIEW_PROPERTY_USER 
    UNIQUE (PROPERTY_ID, USER_ID);

-- 키워드 통계 집계용 인덱스
CREATE INDEX IDX_KEYWORD_REVIEW_SCORE 
    ON REVIEW_KEYWORDS (REVIEW_ID, SCORE);
```

---

### 4.3 Redis 데이터 구조 검증

#### 4.3.1 키 패턴 일관성

| 키 패턴 | 용도 | RDB 대응 | 검증 |
|---------|------|----------|------|
| `property:charter:{id}` | 전세 매물 상세 | PROPERTIES_CHARTER | ✅ |
| `property:monthly:{id}` | 월세 매물 상세 | PROPERTIES_MONTHLY | ✅ |
| `stats:charter:{id}` | 전세 리뷰 통계 | REVIEW_STATISTICS | ✅ |
| `stats:monthly:{id}` | 월세 리뷰 통계 | REVIEW_STATISTICS | ✅ |
| `idx:charterPrice:{district}` | 전세금 인덱스 | - | ✅ |
| `idx:deposit:{district}` | 보증금 인덱스 | - | ✅ |
| `idx:monthlyRent:{district}:월세` | 월세금 인덱스 | - | ✅ |
| `idx:area:{district}:전세` | 전세 평수 인덱스 | - | ✅ |
| `idx:area:{district}:월세` | 월세 평수 인덱스 | - | ✅ |
| `bounds:{district}:전세` | 전세 정규화 범위 | - | ✅ |
| `bounds:{district}:월세` | 월세 정규화 범위 | - | ✅ |
| `safety:{district}` | 안전성 점수 | ANALYSIS_* | ✅ |

#### 4.3.2 리뷰 통계 필드 구조

| 필드명 | 타입 | 용도 |
|--------|------|------|
| propertyId | String | 매물 식별자 |
| reviewCount | String | 총 리뷰 수 |
| avgRating | String | 평균 별점 |
| positiveKeywordCount | String | 긍정 키워드 수 |
| negativeKeywordCount | String | 부정 키워드 수 |
| lastCalced | String | 최종 집계 일시 |

**검증 결과**: 설계 명세서 7.2.5절과 요구사항 명세서 간 일치 확인.

---

## 5. 비즈니스 로직 검증

### 5.1 하이브리드 점수 산출

#### 5.1.1 처리 흐름

```
┌─────────────────────────────────────────────────────────────────┐
│                    하이브리드 점수 산출 흐름                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Phase 1: 기존 로직 (LegacyScore 산출)                           │
│  ├── 1. 인덱스 교집합 검색 (Sorted Set)                          │
│  ├── 2. 폴백 조건 판단 (3개 미만 시)                              │
│  ├── 3. 매물 상세 조회 (property:*)                              │
│  └── 4. 정량 점수 산출                                           │
│         └── LegacyScore = (가격×w1) + (평수×w2) + (안전×w3)       │
│                         │                                       │
│                         ▼                                       │
│  Phase 2: 리뷰 통합 (ReviewScore 산출)                           │
│  ├── 1. 리뷰 통계 조회 (stats:*)                                 │
│  ├── 2. RatingScore = (avgRating / 5.0) × 100                   │
│  ├── 3. KeywordScore = (positive / total) × 100                 │
│  ├── 4. ReviewScore = (Rating×0.5) + (Keyword×0.5)              │
│  ├── 5. Cold Start 방어 (reviewCount < 5)                       │
│  │       └── True: FinalScore = LegacyScore                     │
│  │       └── False: FinalScore = (Legacy×0.5) + (Review×0.5)    │
│  └── 6. 재정렬 및 응답 생성                                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 5.1.2 검증 결과

| 검증 항목 | 평가 | 근거 |
|----------|------|------|
| Phase 분리 설계 | ✅ 적합 | 기존 로직 블랙박스화, 비침해적 확장 |
| 점수 정규화 | ✅ 적합 | 모든 점수 0~100점 척도 통일 |
| Cold Start 방어 | ✅ 적합 | 5개 미만 시 LegacyScore 100% |
| Zero Division 방어 | ✅ 적합 | 키워드 합계 0일 시 50점 기본값 |

#### 5.1.3 Phase 1 → Phase 2 데이터 전달

설계 명세서에서 "Phase 1이 반환한 객체를 직접 수정"한다고 명시. 

**우려사항**: 불변 객체(Immutable Object) 패턴 위반 가능성

**권고사항**: 코드 리뷰 시 사이드 이펙트 주의. 필요 시 별도 wrapper 객체 도입 검토.

---

### 5.2 키워드 추출 로직

#### 5.2.1 명세된 내용

| 단계 | 설명 |
|------|------|
| 토크나이징 | 특수문자 제거, 공백 기준 토큰화 |
| 사전 매칭 | 카테고리별 키워드 사전과 대조 |
| 점수화 | 긍정 +1, 부정 -1 |

#### 5.2.2 키워드 카테고리

| 카테고리 | 예시 키워드 |
|----------|------------|
| 소음 (Noise) | 방음, 층간, 조용, 시끄럽 |
| 채광 (Light) | 남향, 햇빛, 채광, 밝다, 어둡다 |
| 교통 (Traffic) | 역세권, 버스, 지하철, 언덕, 평지 |

#### 5.2.3 누락된 상세 설계

| 누락 항목 | 설명 | 영향도 |
|----------|------|--------|
| 형태소 분석기 선택 | Komoran, Hannanum, 단순 공백 분리 중 선택 | HIGH |
| 키워드 사전 구조 | 데이터 구조 및 저장 위치 정의 | HIGH |
| 감성 분류 알고리즘 | 규칙 기반 vs ML 기반 결정 | MEDIUM |
| 복합 표현 처리 | "별로 좋지 않다" → 부정 변환 규칙 | MEDIUM |

**권고사항**: 키워드 추출 알고리즘 상세 설계 문서 별도 작성 필요. 초기에는 규칙 기반 단순 구현으로 시작하여 데이터 축적 후 ML 모델로 고도화하는 로드맵 수립 권고.

---

### 5.3 리뷰 트랜잭션 및 동시성

#### 5.3.1 트랜잭션 흐름

```
┌─────────────────────────────────────────────────────────────────┐
│                    리뷰 작성 트랜잭션 흐름                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 중복 검증 (Fail-Fast)                                        │
│     └── EXISTS (PROPERTY_ID, USER_ID) → 409 Conflict            │
│                                                                 │
│  [Transaction Start]                                            │
│  2. 리뷰 저장                                                    │
│     └── INSERT INTO REVIEWS                                     │
│                                                                 │
│  3. 비관적 락 획득                                                │
│     └── SELECT * FROM REVIEW_STATISTICS FOR UPDATE              │
│                                                                 │
│  4. 통계 재계산 (커버링 인덱스 활용)                                │
│     └── COUNT(*), AVG(RATING) FROM REVIEWS                      │
│                                                                 │
│  5. 키워드 집계                                                   │
│     └── SUM(CASE WHEN SCORE > 0...) FROM REVIEW_KEYWORDS        │
│                                                                 │
│  6. 통계 테이블 갱신                                              │
│     └── UPDATE REVIEW_STATISTICS                                │
│  [Transaction Commit]                                           │
│                                                                 │
│  7. Redis 캐시 동기화 (Write-Through)                            │
│     └── HSET stats:{type}:{id}                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 5.3.2 커버링 인덱스 활용

**인덱스 정의**:
```sql
CREATE INDEX IDX_REVIEW_PROPERTY_RATING ON REVIEWS (PROPERTY_ID, RATING);
```

**효과**: 쿼리에 필요한 모든 컬럼이 인덱스에 포함되어 테이블 랜덤 액세스(Table Access by ROWID) 없이 인덱스만으로 결과 반환.

#### 5.3.3 중복 작성 방지 이중 방어

| 레이어 | 방어 메커니즘 | 시점 |
|--------|-------------|------|
| Application | EXISTS 쿼리 검증 | 트랜잭션 시작 전 |
| Database | UK 제약조건 | INSERT 시점 |

**검증 결과**: ✅ 적합한 이중 방어 설계

---

## 6. API 명세 검증

### 6.1 Breaking Change 분석

#### 6.1.1 propertyId 타입 변경

| 항목 | 변경 전 | 변경 후 |
|------|--------|--------|
| 타입 | Long | String |
| 값 예시 | `12345` | `"5d41402abc4b2a76b9719d911017c592"` |

**영향도**: ⚠️ HIGH

**영향 받는 클라이언트**:
- TypeScript 타입 정의 수정 필요
- 숫자 연산 로직 수정 필요
- 타입 체크 로직 제거 필요

#### 6.1.2 신규 필드 추가

| DTO | 추가 필드 | 영향도 |
|-----|----------|--------|
| TopCharterPropertyDto | reviewCount, avgRating | ✅ LOW |
| TopMonthlyPropertyDto | reviewCount, avgRating | ✅ LOW |

**영향도**: ✅ LOW (기존 클라이언트 무시 가능, 하위 호환 유지)

---

### 6.2 리뷰 API 엔드포인트

| 엔드포인트 | Method | 인증 | 기능 |
|-----------|--------|------|------|
| `/api/v1/reviews` | POST | Protected | 리뷰 작성 |
| `/api/v1/reviews` | GET | Public | 리뷰 목록 조회 (통합) |
| `/api/v1/reviews/{reviewId}` | GET | Public | 리뷰 상세 조회 |
| `/api/v1/reviews/{reviewId}` | PUT | Protected | 리뷰 수정 |
| `/api/v1/reviews/{reviewId}` | DELETE | Protected | 리뷰 삭제 |

**검증 결과**: ✅ RESTful 원칙 준수

---

### 6.3 API 버전 관리

신규 API는 `/api/v1` 경로 사용으로 버전 관리 체계 적용됨.

**검증 결과**: ✅ 적합

---

## 7. 누락 항목 및 보완 권고

### 7.1 Critical (구현 전 필수 보완)

| 항목 | 설명 | 위치 | 담당 |
|------|------|------|------|
| REVIEWS 테이블 UK 인덱스 DDL | 중복 작성 방지용 복합 유니크 인덱스 | 7.1.2절 | DBA |
| 키워드 추출 상세 알고리즘 | 형태소 분석, 감성 분류 로직 | 8.2절 | Backend |
| 비동기 이벤트 처리 설정 | @Async 또는 @TransactionalEventListener 구성 | 9.3.2절 | Backend |
| 요구사항 명세서 점수 비율 수정 | 70:30 → 50:50 반영 | FR-RC-02 | PM |

### 7.2 High (구현 초기 보완 권고)

| 항목 | 설명 | 위치 |
|------|------|------|
| Redis 동기화 실패 재시도 정책 | 재시도 주기, 최대 시도 횟수, 백오프 전략 | 2.5절 |
| 배치-실시간 데드락 방지 전략 | 타임아웃, 갱신 순서 규칙 | 9.4.1절 |
| DataCollectionCompletedEvent DTO 정의 | 이벤트 클래스 상세 명세 | 7.3.8절 |
| 키워드 사전 데이터 구조 | JSON/DB 저장 방식 결정 | 8.2절 |

### 7.3 Medium (운영 안정화 단계 보완)

| 항목 | 설명 |
|------|------|
| 캐시 웜업 배치 스크립트 | Redis 재기동 시 RDB 기반 복구 절차 |
| 통계 정합성 검증 배치 | RDB vs Redis 주기적 비교 검증 |
| 키워드 사전 관리 인터페이스 | 운영자 키워드 추가/수정 기능 |
| 리뷰 스팸 방지 로직 | 동일 IP/짧은 시간 내 다중 작성 제한 |

---

## 8. 종합 평가

### 8.1 영역별 평가

| 영역 | 평가 | 점수 | 주요 의견 |
|------|------|------|----------|
| 아키텍처 설계 | ✅ 우수 | 9/10 | 하이브리드 저장소, 이벤트 파이프라인 적절 |
| 데이터 모델 | ✅ 양호 | 8/10 | 식별자 전략 타당, 일부 DDL 누락 |
| 비즈니스 로직 | ⚠️ 보통 | 7/10 | 점수 산출 명확, 키워드 추출 상세 부족 |
| API 설계 | ✅ 우수 | 9/10 | RESTful 준수, Breaking Change 관리됨 |
| 문서 정합성 | ⚠️ 보통 | 7/10 | 점수 비율 불일치(의도적), 일부 수정 필요 |

### 8.2 전체 점수

**종합 점수: 8.0 / 10**

### 8.3 최종 판정

```
┌─────────────────────────────────────────────────────────────────┐
│                         최종 판정                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ✅ 설계 명세서는 전반적으로 타당하며 구현 가능한 수준이다.           │
│                                                                 │
│  단, Critical로 표시된 4개 항목은 구현 착수 전 반드시 보완해야 한다.  │
│                                                                 │
│  특히 키워드 추출 알고리즘은 별도 설계 문서 작성이 필요하며,          │
│  초기에는 규칙 기반 단순 구현으로 시작하여 점진적으로 고도화하는       │
│  전략을 권고한다.                                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 9. 후속 조치 계획

### 9.1 즉시 조치 (구현 착수 전)

| 순번 | 조치 항목 | 담당 | 예상 소요 |
|------|----------|------|----------|
| 1 | 요구사항 명세서 점수 비율 수정 | PM | 0.5일 |
| 2 | REVIEWS 테이블 UK 인덱스 DDL 추가 | DBA | 0.5일 |
| 3 | 키워드 추출 알고리즘 상세 설계 | Backend | 2일 |
| 4 | 비동기 이벤트 처리 설정 명세 추가 | Backend | 0.5일 |

### 9.2 구현 초기 (1주차)

| 순번 | 조치 항목 | 담당 | 예상 소요 |
|------|----------|------|----------|
| 1 | DataCollectionCompletedEvent DTO 정의 | Backend | 0.5일 |
| 2 | Redis 동기화 실패 재시도 정책 정의 | Backend | 1일 |
| 3 | 데드락 방지 전략 적용 | Backend | 0.5일 |

### 9.3 운영 안정화 (출시 후)

| 순번 | 조치 항목 | 담당 | 우선순위 |
|------|----------|------|----------|
| 1 | 캐시 웜업 배치 스크립트 작성 | DevOps | HIGH |
| 2 | 통계 정합성 검증 배치 구현 | Backend | MEDIUM |
| 3 | 키워드 사전 관리 UI 구현 | Frontend | LOW |

---

## 10. 부록

### 10.1 참조 문서

| 문서명 | 버전 | 위치 |
|--------|------|------|
| 부동산 추천 시스템 비즈니스 로직 설계 명세서 | v2.0 | 프로젝트 문서 저장소 |
| 주거지 추천 서비스 사용자 경험 반영 개선 기획서 | - | 프로젝트 문서 저장소 |
| 주거지 추천 서비스 고도화 요구사항 명세서 | - | 프로젝트 문서 저장소 |
| 기술 명세서: 매물 식별자 생성 전략 | SPEC-DATA-001 | 프로젝트 문서 저장소 |

### 10.2 용어 정의

| 용어 | 정의 |
|------|------|
| Business Key | 불변 속성 조합으로 생성된 논리적 식별자 |
| Cold Start | 리뷰 데이터 부족으로 통계적 신뢰도가 확보되지 않은 상태 |
| Covering Index | 쿼리에 필요한 모든 컬럼을 포함하는 인덱스 |
| Write-Through | 원본 저장소 기록 즉시 캐시 갱신하는 동기화 패턴 |
| Upsert | UPDATE + INSERT의 합성어, 존재하면 갱신/없으면 생성 |

### 10.3 변경 이력

| 버전 | 일자 | 변경 내용 | 작성자 |
|------|------|----------|--------|
| 1.0 | 2025-11-28 | 최초 작성 | Claude (AI Reviewer) |

---

**문서 끝**