# 주거지 추천 서비스 리뷰 시스템 - 기술 고려 사항

## 1. 기술 구현 계획

### 1.1 복잡한 DBMS 설계 (JPA 연관관계)

**구현 목적**
- 단순 CRUD를 넘어선 복잡한 도메인 연관관계 설계 역량 증명
- N:M 관계 모델링을 통한 실무 수준의 DB 설계 능력 입증

**핵심 기술**
- User ↔ Review ↔ Building 다대다(N:M) 관계 설계
- Review ↔ Keyword 다대다(N:M) 관계를 중간 테이블로 해소
- JPA @ManyToOne, @OneToMany, @ManyToMany 활용
- ReviewKeywordMapping 조인 테이블 설계

**기대 효과**
- 표준적인 게시판 CRUD(1:N)와 차별화된 복잡한 연관관계 경험
- 실무에서 요구되는 도메인 모델링 능력 증명

### 1.2 성능 최적화 (비정규화 및 인덱싱)

**구현 목적**
- 대량 데이터 조회 시 발생하는 성능 저하 문제 해결
- 읽기/쓰기 성능 균형을 고려한 설계 능력 증명

**핵심 기술**
- Building_Review_Stats 통계 테이블 설계 (Materialized View 개념)
- 비정규화를 통한 JOIN/GROUP BY 연산 제거
- 전략적 인덱싱 (building_id, review_id, keyword_id)
- 읽기 최적화와 쓰기 일관성의 트레이드오프 관리

**기대 효과**
- Full Scan 방지 및 응답 시간 단축 (목표: 100ms 이하)
- 실무에서 요구되는 성능 튜닝 경험 축적

### 1.3 비동기 처리 (이벤트 기반 아키텍처)

**구현 목적**
- 사용자 응답 속도와 데이터 정확성의 균형 확보
- 시스템 확장성을 고려한 아키텍처 설계 능력 증명

**핵심 기술**
- Spring @Async 또는 @EventListener 활용
- Write-Through 패턴: 리뷰 저장 후 즉시 응답 반환
- 백그라운드 통계 업데이트 처리 (Building_Review_Stats 갱신)
- 트랜잭션 분리를 통한 응답 시간 최적화

**기대 효과**
- 사용자 체감 성능 향상 (응답 속도 < 100ms)
- 비동기 처리의 실전 적용 경험

### 1.4 데이터 가공 (ETL 파이프라인)

**구현 목적**
- 비정형 텍스트 데이터를 정형 점수로 변환하는 능력 증명
- 데이터 파싱 및 가공 로직 구현 경험

**핵심 기술**
- 리뷰 텍스트에서 키워드 추출 ("소음", "교통", "채광" 등)
- 긍정/부정 키워드별 점수 부여 (+1/-1)
- Keyword 테이블 조회/생성 로직
- ReviewKeywordMapping 자동 생성

**기대 효과**
- 비정형 → 정형 데이터 변환 프로세스 구축
- 백엔드 개발자의 핵심 역량인 데이터 처리 능력 입증

### 1.5 비즈니스 로직 고도화 (신뢰도 기반 추천)

**구현 목적**
- 데이터 희소성(Sparsity) 문제를 고려한 알고리즘 설계
- 통계적 신뢰도를 반영한 비즈니스 로직 구현

**핵심 기술**
- 최소 리뷰 수 기준 설정 (5개 이상)
- 조건부 점수 반영 로직
  - 리뷰 5개 미만: 기존 점수 유지
  - 리뷰 5개 이상: (기존 점수 × 70%) + (리뷰 점수 × 30%)
- 가중치 기반 최종 점수 산출

**기대 효과**
- 소수 리뷰로 인한 편향 방지
- 실무 수준의 비즈니스 로직 설계 능력 증명

---

## 2. 상세 구현 계획

### 2.1 DB/Entity 설계

**구현 목적**
- 두 도메인(Building, Review) 연결을 통한 시스템 통합
- 복잡한 연관관계 설계 역량 증명

**Entity 연관관계**
- User (기존): 사용자
- Building (기존): 매물
- Review (신규): 매물 후기
- ReviewComment (활용): 후기 댓글
- Keyword (신규): 키워드 마스터 테이블
- ReviewKeywordMapping (신규): Review-Keyword 조인 테이블

**JPA 관계 설계**
- User 1 → N Review
- Building 1 → N Review
- Review 1 → N ReviewComment
- Review N ↔ M Keyword (ReviewKeywordMapping으로 해소)

**기대 효과**
- N:M 관계 실전 구현 경험
- 단순 게시판(1:N)을 넘어선 복잡한 도메인 모델링

### 2.2 통계 테이블 설계

**구현 목적**
- JOIN/GROUP BY 연산 제거를 통한 조회 성능 개선
- 비정규화 설계 전략 적용 경험

**테이블 구조: Building_Review_Stats**
- building_id (PK)
- total_review_count
- avg_star_rating
- avg_noise_score
- avg_transport_score
- (추가 키워드 점수)

**설계 전략**
- Materialized View 개념 적용
- 읽기 최적화를 위한 의도적 비정규화
- 비동기 업데이트를 통한 데이터 일관성 유지

**기대 효과**
- Full Scan 방지
- 실시간 통계 조회 성능 향상

### 2.3 인덱싱 전략

**구현 목적**
- 쿼리 성능 최적화
- 데이터베이스 튜닝 역량 증명

**인덱스 설계**
- Review.building_id (FK 인덱스)
- ReviewKeywordMapping.review_id
- ReviewKeywordMapping.keyword_id

**기대 효과**
- 조회 쿼리 응답 시간 단축
- 대용량 데이터 처리 대비

---

## 3. 비즈니스 로직 및 API 설계

### 3.1 API 엔드포인트

**구현 목적**
- RESTful API 설계 원칙 적용
- 표준 CRUD 구현 및 확장

**엔드포인트 목록**
- POST `/api/buildings/{buildingId}/reviews` - 리뷰 작성
- GET `/api/buildings/{buildingId}/reviews` - 리뷰 목록 조회 (Paging)
- PUT `/api/reviews/{reviewId}` - 리뷰 수정
- DELETE `/api/reviews/{reviewId}` - 리뷰 삭제
- GET `/api/location-analysis` - 추천 분석 (includeReviews 파라미터 추가)

**기대 효과**
- API 설계 및 구현 역량 증명
- 기존 시스템과의 통합 경험

### 3.2 리뷰 작성 로직 (Write-Through + 비동기)

**구현 목적**
- 사용자 응답 속도와 데이터 정확성 균형
- 비동기 처리 패턴 적용 경험

**처리 흐름**

**[Sync] 트랜잭션 1 - 즉시 응답**
- Review Entity 생성 및 저장
- 키워드 추출 및 매핑
- 사용자 응답 반환 (목표: < 100ms)

**[Async] 트랜잭션 2 - 백그라운드**
- @EventListener 또는 @Async 활용
- ReviewStatsService 호출
- Building_Review_Stats 테이블 업데이트

**기대 효과**
- Write 성능 최적화
- 이벤트 기반 아키텍처 구현 경험

### 3.3 추천 로직 고도화 (Read)

**구현 목적**
- 리뷰 데이터를 추천 알고리즘에 통합
- 신뢰도 기반 가중치 적용

**처리 흐름**
- 기존 추천 로직 수행 (API 호출, DB 조회)
- Building_Review_Stats 테이블 LEFT JOIN
- 신뢰도 기준 적용 (리뷰 5개 이상)
- 최종 점수 계산
  - 리뷰 5개 이상: (기존 점수 × 70%) + (리뷰 점수 × 30%)
  - 리뷰 5개 미만: 기존 점수 유지

**기대 효과**
- 데이터 희소성 문제 해결
- 비즈니스 로직 고도화 경험

---

## 4. 포트폴리오 차별화 전략

### 4.1 시스템 연동 경험

**차별화 포인트**
- 독립적인 두 프로젝트 → 통합된 하나의 고도화 프로젝트
- Before: 주거지 추천 서비스 + 게시판 (별개)
- After: 사용자 평가 기반 추천 시스템 (통합)

**효과**
- 신입 포트폴리오에서 보기 드문 시스템 통합 경험
- 단순 기능 나열을 넘어선 프로젝트 심화

### 4.2 복잡한 DBMS 설계

**차별화 포인트**
- 표준 게시판 CRUD(1:N) 수준을 넘어선 설계
- N:M 관계를 포함한 복잡한 도메인 모델링
- JPA 연관관계 활용 (@ManyToOne, @OneToMany, @ManyToMany)

**효과**
- 실무 수준의 DB 설계 역량 증명
- 중간 테이블(ReviewKeywordMapping) 설계 경험

### 4.3 성능 최적화 역량

**차별화 포인트**
- 비정규화 전략 (Building_Review_Stats)
- 읽기/쓰기 성능 트레이드오프 고려
- 전략적 인덱싱 적용

**효과**
- 이론이 아닌 실전 성능 튜닝 경험
- Full Scan 방지 및 응답 시간 개선

### 4.4 비동기 아키텍처 구현

**차별화 포인트**
- @Async / @EventListener 활용
- Write-Through 패턴 적용
- 사용자 체감 성능과 데이터 일관성 균형

**효과**
- 이벤트 기반 아키텍처 실전 적용
- 확장 가능한 시스템 설계 경험

### 4.5 데이터 파이프라인 구축

**차별화 포인트**
- 비정형(텍스트) → 정형(점수) 데이터 변환
- 키워드 추출 및 점수화 로직
- ETL 프로세스 구현

**효과**
- 데이터 가공 역량 증명
- 백엔드 핵심 역량 강조

---

## 5. 구현 우선순위 및 일정

### 5.1 Phase 1: 핵심 CRUD (1주)

**구현 목표**
- 기본 리뷰 시스템 구축
- Entity 설계 및 연관관계 매핑
- API 엔드포인트 구현

**세부 작업**
- Review Entity 설계 및 저장
- 기본 API (작성/조회/수정/삭제) 구현
- 키워드 추출 로직 (문자열 파싱)

### 5.2 Phase 2: 통계 및 성능 (1주)

**구현 목표**
- 성능 최적화 적용
- 추천 시스템 통합
- 비동기 처리 구현

**세부 작업**
- Building_Review_Stats 테이블 설계
- 비동기 통계 업데이트 (@Async)
- 추천 로직에 리뷰 점수 통합

### 5.3 Phase 3: 최적화 및 검증 (3일)

**구현 목표**
- 시스템 안정화
- 성능 검증
- 산출물 정리

**세부 작업**
- 인덱스 적용
- 성능 테스트
- 문서화

---

## 6. 기술 스택

### 6.1 Backend

**선정 이유**
- Spring 생태계 기반 안정적인 서비스 구축
- JPA를 통한 객체 지향적 DB 설계
- 비동기 처리 및 이벤트 기반 아키텍처 지원

**기술 목록**
- Spring Boot 2.7+
- Spring Data JPA
- Spring Async
- Hibernate

### 6.2 Database

**선정 이유**
- 관계형 데이터 무결성 보장
- 복잡한 연관관계 지원
- 트랜잭션 관리 및 성능 최적화 기능

**기술 목록**
- Oracle Database 21c
- Redis (선택적, 통계 캐싱용)

### 6.3 테스트

**선정 이유**
- 단위 테스트 환경 구축
- 코드 품질 및 안정성 확보

**기술 목록**
- JUnit 5