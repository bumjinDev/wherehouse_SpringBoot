# 부동산 추천 시스템 종합 설계서

프로젝트명: 사용자 맞춤형 부동산 추천 엔진  
문서 버전: 1.0  
작성일: 2025년 9월 12일  
작성자: 정범진

---

## API 요구사항 명세서

### 1. 개요

#### 1.1. 목적

본 문서는 사용자 맞춤형 부동산 추천 시스템의 백엔드 API에 대한 기능적 요구사항과 인터페이스를 정의하는 것을 목적으로 한다.

#### 1.2. 범위

본 명세서는 사용자의 조건에 맞는 상위 지역구를 추천하는 단일 API 엔드포인트(POST /api/recommendations/districts)에 대한 요구사항을 다룬다. API의 요청 파라미터, 응답 데이터 구조, 상태 코드, 그리고 예외 처리 방안을 포함한다.

### 2. 일반 요구사항

- 데이터 형식: 모든 API 요청과 응답의 데이터 형식은 JSON(Application/json)을 사용한다.
- 문자 인코딩: 모든 데이터는 UTF-8로 인코딩한다.
- 인증: API 호출 시 발급된 인증 토큰을 HTTP 헤더에 포함해야 한다. (본 명세서 범위 외)
- 기본 URL: https://{your-domain}

### 3. 엔드포인트 명세: 지역구 추천 API

#### 3.1. API 개요

| 항목 | 내용 |
|------|------|
| 기능 설명 | 사용자의 조건(예산, 평수)과 우선순위(가격, 안전, 공간)를 기반으로 서울시 내 최적의 지역구를 순위별로 추천한다. 조건에 맞는 매물이 부족할 경우, 사용자가 설정한 완화 기준에 따라 자동으로 검색 범위를 확장하는 2단계 폴백 시스템을 적용한다. |
| HTTP Method | POST |
| Endpoint URL | /api/recommendations/districts |

#### 3.2. 요청 (Request)

Request Body Fields

| 필드 | 타입 | 필수 | 설명 | 예시 |
|------|------|------|------|------|
| leaseType | String | ✓ | 임대 유형. CHARTER(전세) 또는 MONTHLY(월세) | CHARTER |
| budgetMin | Integer | ✓ | 최소 예산 (단위: 만원) | 20000 |
| budgetMax | Integer | ✓ | 최대 예산 (단위: 만원) | 30000 |
| areaMin | Double | ✓ | 최소 평수 (단위: 평) | 20 |
| areaMax | Double | ✓ | 최대 평수 (단위: 평) | 30 |
| priority1 | String | ✓ | 1순위 중요도. PRICE, SAFETY, SPACE 중 선택 | PRICE |
| priority2 | String | ✓ | 2순위 중요도 | SAFETY |
| priority3 | String | ✓ | 3순위 중요도 | SPACE |
| budgetFlexibility | Integer | ✗ | 예산 유연성 (%). 2단계 확장 시 최대 예산을 이 비율만큼 초과 허용. (기본값: 0) | 10 |
| minSafetyScore | Integer | ✗ | 최소 안전 점수. 2단계 확장 시 이 점수까지 허용. (기본값: 0) | 70 |
| absoluteMinArea | Double | ✗ | 절대 최소 평수. 2단계 확장 시 이 평수까지 허용. (기본값: 0) | 15 |

Request Body 예시:
```json
{
  "leaseType": "CHARTER",
  "budgetMin": 20000,
  "budgetMax": 30000,
  "areaMin": 20.0,
  "areaMax": 30.0,
  "priority1": "PRICE",
  "priority2": "SAFETY",
  "priority3": "SPACE",
  "budgetFlexibility": 10,
  "minSafetyScore": 70,
  "absoluteMinArea": 15.0
}
```

#### 3.3. 응답 (Response)

성공: 200 OK

요청이 성공적으로 처리되었을 때 반환되는 JSON 객체.

Response Body 예시:
```json
{
  "searchStatus": "SUCCESS_EXPANDED",
  "message": "원하시는 조건의 매물이 부족하여, 평수 조건을 15평으로 완화하여 찾았어요.",
  "recommendedDistricts": [
    {
      "rank": 1,
      "districtName": "강남구",
      "summary": "가격 1순위 조건에 가장 부합하며, 조건 내 추천 매물이 12건 있습니다.",
      "topProperties": [
        {
          "propertyId": 101,
          "propertyName": "은마",
          "address": "서울특별시 강남구 대치동 316",
          "price": 60000,
          "leaseType": "전세",
          "area": 23.2,
          "floor": 14,
          "buildYear": 1979,
          "finalScore": 82.5
        }
      ]
    }
  ]
}
```

Response Body Fields

| 필드 | 타입 | 설명 |
|------|------|------|
| searchStatus | String | 검색 결과 상태 코드. 아래 4.1. 상태 코드 표 참조 |
| message | String | 사용자 안내 메시지. 검색 상태에 대한 부가 설명을 제공 |
| recommendedDistricts[] | Array | 추천 지역구 목록. rank 순으로 정렬됨 |
| recommendedDistricts[].rank | Integer | 지역구 추천 순위 |
| recommendedDistricts[].districtName | String | 지역구 이름 |
| recommendedDistricts[].summary | String | 이 지역구를 추천하는 핵심 요약 근거 |
| recommendedDistricts[].topProperties[] | Array | 해당 지역구 내에서 가장 점수가 높은 대표 매물 목록 |
| ...topProperties[].propertyId | String | 매물 고유 ID (UUID) |
| ...topProperties[].propertyName | String | 아파트/오피스텔 이름 |
| ...topProperties[].address | String | 법정동과 지번을 조합한 주소 |
| ...topProperties[].price | Integer | 보증금 또는 전세금 (단위: 만원) |
| ...topProperties[].leaseType | String | '전세' 또는 '월세' |
| ...topProperties[].area | Double | 전용 면적 (단위: 평) |
| ...topProperties[].floor | Integer | 층수 |
| ...topProperties[].buildYear | Integer | 건축 연도 |
| ...topProperties[].finalScore | Double | 매물의 최종 추천 점수 (0~100점) |

### 4. 상태 코드 및 예외 처리

#### 4.1. searchStatus 상태 코드

| 코드 | 의미 | 설명 |
|------|------|------|
| SUCCESS_NORMAL | 기본 검색 성공 | 사용자의 초기 조건을 만족하는 지역구를 성공적으로 추천했습니다. |
| SUCCESS_EXPANDED | 확장 검색 성공 | 초기 조건으로는 매물이 부족하여, 3순위 또는 2순위 조건을 완화한 후 지역구를 추천했습니다. |
| NO_RESULTS | 결과 없음 | 모든 조건을 최대한 완화했음에도 불구하고 추천할 지역구를 찾지 못했습니다. |

#### 4.2. HTTP 상태 코드

| HTTP 코드 | 상황 | 응답 Body 예시 |
|-----------|------|-------------|
| 200 OK | 요청 성공 | (3.3. 응답 섹션 참조) |
| 400 Bad Request | 요청 파라미터 오류 (필수값 누락, 타입 불일치 등) | {"errorCode": "INVALID_PARAMETER", "message": "budgetMin 파라미터는 필수입니다."} |
| 500 Internal Server Error | 서버 내부 로직 오류 | {"errorCode": "SERVER_ERROR", "message": "요청 처리 중 오류가 발생했습니다."} |

#### 4.3. 예외 상황(Edge Case) 처리 방안

상황 1: 최종 결과 없음
- 2단계 확장 검색까지 모두 수행했음에도 추천할 매물이 0개인 경우
- searchStatus: NO_RESULTS
- message: "아쉽지만 조건에 맞는 매물을 찾을 수 없었어요. 조건을 변경하여 다시 시도해 보세요."
- recommendedDistricts: 빈 배열 반환

상황 2: 동점(Tie-breaking) 처리
- 두 지역구의 '대표 점수'가 완전히 동일한 경우
- 2차 정렬 기준: 유효 매물 개수가 더 많은 지역구를 우선
- 3차 정렬 기준: 지역구명 알파벳 순서

기술적 구현 참고사항  
파라미터 검증은 Spring Boot의 @Valid 어노테이션을 사용하여 처리한다.

---

## 비즈니스 기능 구현 명세서

### 1. 아키텍처 개요

시스템은 성능과 안정성을 위해 '배치(Batch) 데이터 처리'와 '실시간(Real-time) 서비스' 두 부분으로 나뉘어 동작한다.
- 배치 처리: 주기적으로 외부 API에서 최신 매물 데이터를 수집, 가공하여 Redis에 최적화된 형태로 저장한다.
- 실시간 서비스: 사용자 요청 시, 사전 처리된 Redis 데이터만을 사용하여 매우 빠른 속도로 추천 결과를 생성한다.

### 2. 기능 명세: 배치 데이터 처리 (Batch Process)

- 구현 위치: BatchScheduler.java (가칭)
- 실행 주기: 매일 새벽 4시, Spring @Scheduled를 통해 실행
- 핵심 역할: 국토교통부 API의 데이터를 조회 가능한 형태로 Redis에 적재

| 기능 ID | 기능명 | 상세 구현 내용 |
|---------|--------|----------------|
| B-01 | 전 지역구 매물 데이터 수집 | 1. 서울시 25개 자치구를 순회한다. <br> 2. 각 자치구별로 국토교통부 전월세 API를 호출한다. <br> 3. 페이징 처리를 고려하여 해당 지역구의 모든 매물을 수집한다. |
| B-02 | 데이터 정제 및 객체 변환 | 1. API 응답의 각 매물 정보를 파싱하여 매물 객체로 변환한다. <br> 2. 가격은 정수형으로, 평수는 면적 단위 변환을 통해 평수로 변환한다. |
| B-03 | Redis 데이터 적재 | 1. 매물 상세 정보: 각 매물 정보를 고유 키를 가진 구조화된 데이터로 저장한다. <br> 2. 검색 인덱스: 빠른 범위 검색을 위해 자치구별로 가격과 평수를 기준으로 정렬된 인덱스를 생성한다. <br> 3. 기존 데이터를 초기화한 후 새로운 데이터를 적재한다. |
| B-04 | 지역구별 정규화 범위 계산 및 저장 | 1. 지역구별 + 임대유형별로 데이터를 그룹핑한다. <br> 2. 각 그룹의 가격(전세금 또는 보증금+월세×24) 최소/최대값을 계산한다. <br> 3. 각 그룹의 평수 최소/최대값을 계산한다. <br> 4. bounds:{지역구명}:{임대유형} 키로 Redis에 저장한다. |
| B-05 | 지역구별 안전성 점수 계산 및 저장 | 1. 지역구별 범죄 발생 건수를 수집한다. <br> 2. 지역구별 인구수와 유흥업소 수를 수집한다. <br> 3. 분석 보고서 공식을 적용하여 안전성 점수를 계산한다. <br> 4. safety:{지역구명} 키로 Redis에 저장한다. |

#### 2.1. 배치 처리 대상 테이블 구조

**매물 원본 데이터 테이블 (property_data)**
- 목적: API로부터 수집된 매물의 모든 상세 정보를 저장
- 저장 위치: Redis Hash 구조
- 키 패턴: `property:{매물고유ID}`

| 필드명 | 데이터타입 | 설명 | API 매핑 |
|--------|-----------|------|----------|
| propertyId | String | 매물 고유 식별자 | 자동생성 |
| aptNm | String | 아파트명 | aptNm |
| excluUseAr | Double | 전용면적(㎡) | excluUseAr |
| floor | Integer | 층수 | floor |
| buildYear | Integer | 건축연도 | buildYear |
| dealDate | String | 계약일자(YYYY-MM-DD) | dealYear+dealMonth+dealDay |
| deposit | Integer | 보증금/전세금(만원) | deposit |
| monthlyRent | Integer | 월세금(만원) | monthlyRent |
| leaseType | String | 임대유형(전세/월세) | monthlyRent 기반 판단 |
| umdNm | String | 법정동명 | umdNm |
| jibun | String | 지번 | jibun |
| sggCd | String | 시군구코드 | sggCd |
| address | String | 전체 주소 | umdNm + jibun 조합 |
| areaInPyeong | Double | 전용면적(평) | excluUseAr * 0.3025 |
| rgstDate | String | 등록일자 | rgstDate |

**가격 기준 인덱스 테이블 (price_index)**
- 목적: 가격 범위 검색을 위한 정렬된 인덱스 제공
- 저장 위치: Redis Sorted Set 구조
- 키 패턴: `idx:price:{지역구명}:{임대유형}`

| 구성요소 | 설명 |
|----------|------|
| Score | 가격(보증금 또는 전세금, 만원 단위) |
| Member | 매물고유ID |
| 정렬기준 | 가격 오름차순 |

**평수 기준 인덱스 테이블 (area_index)**
- 목적: 평수 범위 검색을 위한 정렬된 인덱스 제공
- 저장 위치: Redis Sorted Set 구조
- 키 패턴: `idx:area:{지역구명}:{임대유형}`

| 구성요소 | 설명 |
|----------|------|
| Score | 전용면적(평 단위) |
| Member | 매물고유ID |
| 정렬기준 | 평수 오름차순 |

**정규화 범위 테이블 (normalization_bounds)**
- 목적: 실시간 점수 계산을 위한 지역구별 정규화 범위 제공
- 저장 위치: Redis Hash 구조
- 키 패턴: `bounds:{지역구명}:{임대유형}`

| 필드명 | 설명 |
|--------|------|
| minPrice | 해당 지역구+임대유형의 최저 가격 |
| maxPrice | 해당 지역구+임대유형의 최고 가격 |
| minArea | 해당 지역구+임대유형의 최소 평수 |
| maxArea | 해당 지역구+임대유형의 최대 평수 |
| propertyCount | 계산에 사용된 매물 개수 |
| lastUpdated | 마지막 업데이트 일시 |

**안전성 점수 테이블 (safety_scores)**
- 목적: 지역구별 사전 계산된 안전성 점수 제공
- 저장 위치: Redis Hash 구조
- 키 패턴: `safety:{지역구명}`

| 필드명 | 설명 |
|--------|------|
| districtName | 지역구명 |
| safetyScore | 안전성 점수 (0~100점) |
| lastUpdated | 마지막 업데이트 일시 |
| version | 계산 공식 버전 |

### 3. 기능 명세: 실시간 추천 서비스 (Real-time Service)

- 구현 위치: RecommendationService.java (가칭)
- 호출 시점: POST /api/recommendations/districts 엔드포인트 요청 시
- 핵심 역할: Redis 데이터를 기반으로 사용자 맞춤형 지역구 및 매물 추천

| 기능 ID | 기능명 | 상세 구현 내용 |
|---------|--------|----------------|
| S-01 | 전 지역구 1차 검색 (Strict) | 1. 서울시 25개 자치구를 모두 순회한다. <br> 2. 각 자치구마다, 사용자의 요청 조건을 기준으로 매물 검색 인덱스를 쿼리한다. <br> 3. 가격과 평수 조건을 모두 만족하는 매물들의 교집합을 구하여, 각 자치구별 유효 매물 목록을 생성한다. |
| S-02 | 폴백(Fallback) 조건 판단 | 1. S-01에서 생성된 모든 자치구의 유효 매물 총합이 3개 미만인지 검사한다.<br> 2. 3개 미만일 경우, S-03 확장 검색을 실행한다.<br> 3. 3개 이상일 경우, S-04 점수 계산으로 넘어간다. |
| S-03 | 2차 확장 검색 (Expanded) | 1. 사용자의 3순위에 해당하는 조건을 완화된 임계값으로 변경한다.<br> 2. 완화된 조건으로 S-01 과정을 다시 수행한다.<br> 3. 그래도 매물이 부족하면 2순위 조건을 완화하여 한 번 더 수행한다.<br> 4. 어떤 조건이 완화되었는지 응답 메시지에 기록한다. |
| S-04 | 매물 단위 점수 계산 | 1. 각 자치구의 유효 매물 목록에 대해, 사용자의 우선순위에 따라 60%/30%/10% 가중치를 적용한다.<br> 2. 가중치 합산 공식을 사용해 각 매물의 최종 점수를 계산한다.<br> 3. 각 자치구 내에서 매물을 최종 점수 기준으로 내림차순 정렬한다. |
| S-05 | 지역구 단위 점수 계산 및 정렬 | 1. 각 자치구의 대표 점수를 산출한다. 지역구 대표 점수 = (해당 지역구의 유효 매물 전체의 평균 finalScore) × log(매물 개수 + 1) <br> 2. 산출된 대표 점수를 기준으로 자치구 목록을 내림차순 정렬하여 최종 순위를 결정한다. <br> 3. 동점 처리: 대표 점수가 동일할 경우, 유효 매물 개수가 더 많은 지역구를 우선한다. |
| S-06 | 최종 응답 생성 | 1. 정렬된 지역구 목록에서 상위 3개를 선택한다. <br> 2. 각 지역구별로 순위, 지역구명, 추천 요약 메시지, 그리고 해당 지역구의 상위 매물들을 추출한다. <br> 3. API 응답 형태로 가공하여 반환한다. |

---

## 매물 점수 산출 및 지역구 순위 결정 상세 로직

이 로직은 기능 S-04 (매물 단위 점수 계산)와 S-05 (지역구 단위 점수 계산)를 통합한 상세 실행 계획이다.

### 1단계: 각 지역구별 유효 매물 목록 확보

입력: 1차(Strict) 또는 2차(Fallback) 검색을 통해 확보된 자치구별 유효 매물 목록.

### 2단계: 지역구별 '매물 단위' 점수 계산

모든 지역구를 순회하며, 각 지역구에 포함된 모든 유효 매물의 최종 점수를 계산한다.

1. 매물 상세 정보 조회: Redis에서 각 매물에 해당하는 상세 정보(가격, 평수, 안전점수 등)를 모두 조회한다.

2. 점수 정규화:
   - 이 기준값을 사용하여 해당 지역구의 모든 매물에 대해 가격 점수와 공간 점수를 0~100점 척도로 변환한다.

3. 최종 점수 산출:
   - 사용자의 우선순위(1순위: 60%, 2순위: 30%, 3순위: 10%) 가중치를 적용하여 각 매물의 최종 점수를 계산한다.

4. 매물 정렬:
   - 계산이 완료되면, 각 지역구의 매물 리스트를 최종 점수가 높은 순으로 내림차순 정렬한다.

출력: 자치구별 정렬된 매물 목록.

### 3단계: '지역구 단위' 대표 점수 계산

모든 개별 매물의 점수 계산이 완료된 후, 이 데이터를 바탕으로 지역구의 순위를 매긴다.

#### 3.1. 개선된 지역구 대표 점수 계산 공식

**매물의 평균적인 퀄리티를 기본으로 하되, 매물의 개수가 많을수록 가산점을 주는 방식**을 적용한다.

```
최종 지역구 대표 점수 = (해당 지역구의 유효 매물 전체의 평균 finalScore) × log(매물 개수 + 1)
```

#### 3.2. 공식 구성 요소

**유효 매물 전체의 평균 finalScore**
- 해당 지역구 매물들의 전반적인 **퀄리티**를 나타냄
- 상위 5개가 아닌 전체 평균을 사용하여 지역구의 보편적인 수준을 반영
- 0~100점 척도의 평균값

**log(매물 개수 + 1)**
- 매물 개수가 많을수록 점수가 올라가지만, 그 증가폭이 점차 줄어들어 **선택의 폭**을 적절히 반영
- +1은 매물이 1개일 때 log값이 0이 되는 것을 방지
- 자연로그(ln) 사용

#### 3.3. 계산 예시

**시나리오 1: 퀄리티 vs 선택의 폭**
- A구역: 평균 점수 90점, 매물 3개 → 90 × log(4) ≈ 54.2점
- B구역: 평균 점수 80점, 매물 30개 → 80 × log(31) ≈ 119.3점
- 결과: 퀄리티는 조금 낮아도 선택의 폭이 훨씬 넓은 B구역이 더 높게 평가

**시나리오 2: 극단적인 매물 개수 차이**
- C구역: 평균 점수 90점, 매물 10개 → 90 × log(11) ≈ 93.5점
- D구역: 평균 점수 60점, 매물 100개 → 60 × log(101) ≈ 120.1점
- 결과: 매물 개수가 압도적으로 많다면 퀄리티 차이를 극복하고 더 높게 평가

#### 3.4. 지역구 정렬 및 동점 처리

1. **1차 정렬**: 계산된 대표 점수를 기준으로 내림차순 정렬
2. **동점 처리**: 대표 점수가 동일할 경우 다음 순서로 우선순위 결정
   - 2차 기준: 유효 매물 개수가 더 많은 지역구 우선
   - 3차 기준: 지역구명 알파벳 순서

출력: 최종 정렬된 지역구 순위 목록.

---

## 시스템 아키텍처 및 비즈니스 로직

### 전체 시스템 구조

시스템은 실시간 서비스 처리와 배치 처리로 구분되며, 총 3단계로 구성된다:

실시간 서비스 처리 (사용자 요청 시)
2. 사용자 요청 실시간 처리: Redis에서 고속 검색 및 폴백 구조 적용
3. 최종 점수 계산 및 응답: 우선순위 기반 점수 계산 및 정렬

배치 처리 (사전 준비)
1. API 데이터 사전 처리 및 Redis 캐싱: 매물 데이터 수집 및 인덱스 생성

### 2단계 (서비스): 사용자 요청 실시간 처리

사용자가 API를 요청했을 때 실행되는 로직이다. 이 단계에서는 느린 외부 API를 절대 직접 호출하지 않고, 오직 빠른 Redis 하고만 통신한다.

#### 2.1 Redis에서 1차 검색 (Strict Search)
- 사용자가 요청한 지역구, 임대유형(전세 또는 월세), 평수 조건을 받는다.
- 전세의 경우: 전세금 범위
- 월세의 경우: 보증금 범위와 월세 범위
- Redis의 검색 인덱스를 사용해 각 조건을 만족하는 매물 목록을 각각 조회한다.
- 가져온 매물 목록들의 교집합을 구해 모든 조건을 동시에 만족하는 최종 매물 목록을 확정한다.

#### 2.2 폴백(Fallback) 구조 적용
- 1차 검색으로 찾은 매물 개수가 3개 미만이면 확장 검색을 시작한다.
- 사용자의 우선순위(3순위→2순위 순)와 완화 임계값을 바탕으로 검색 범위를 넓혀서 1번 과정을 다시 수행한다.

### 3단계 (서비스): 최종 점수 계산 및 응답

#### 3.1 매물 상세 정보 조회
2단계를 통해 확정된 최종 매물 목록을 가지고, Redis에서 각 매물의 전체 상세 정보를 조회한다.

#### 3.2 점수 계산 및 정렬
조회된 매물 목록을 대상으로, 정의된 60%/30%/10% 고정 가중치 기반 점수 계산 로직을 실행하여 최종 점수를 계산하고 내림차순으로 정렬한다.

#### 3.3 API 응답 생성
정렬된 최종 결과를 API 응답 명세에 맞춰 가공하여 사용자에게 반환한다.

### 1단계 (배치): API 데이터 사전 처리 및 Redis 캐싱

이 단계는 사용자 요청과 상관없이, 서버가 주기적으로(예: 매일 새벽) 실행하여 최신 매물 데이터를 미리 Redis에 가공하여 저장하는 과정이다.

#### 1.1 전 지역구 데이터 수집
서울시 25개 자치구 코드를 순회하며 국토교통부 전월세 API를 호출한다. API 응답의 페이징 정보를 확인하여 해당 지역구의 모든 매물 데이터를 빠짐없이 가져온다.

#### 1.2 데이터 가공 및 보강
API로부터 받은 데이터를 매물 객체로 파싱한다. 이 과정에서 각 매물별 안전성 점수를 계산하여 함께 저장한다.

#### 1.3 Redis에 인덱스 형태로 저장
가공된 매물 데이터를 Redis에 저장할 때, 단순 캐시가 아닌 아래와 같이 여러 자료구조를 조합하여 저장한다. 이는 Redis를 인메모리 검색 엔진처럼 사용하기 위함이다.

매물 원본 데이터: 각 매물 정보를 구조화된 형태로 저장한다.
- 특정 매물 정보를 매우 빠르게 조회할 수 있다.

검색을 위한 인덱스: 사용자의 핵심 검색 조건(가격, 평수)을 빠르게 필터링하기 위해 자치구별로 정렬된 인덱스를 생성한다.
- 가격 인덱스: 지역구별 가격 기준 정렬
- 평수 인덱스: 지역구별 평수 기준 정렬
- 매우 빠른 속도로 특정 범위에 해당하는 모든 매물을 즉시 찾아낼 수 있다.

#### 1.4 정규화 범위 계산 및 저장 (B-04)
실시간 점수 계산 시 사용할 지역구별 정규화 범위를 사전 계산하여 저장한다.
- 지역구별 + 임대유형별로 데이터 그룹핑
- 가격 범위(최소/최대) 및 평수 범위(최소/최대) 계산
- Redis Hash 구조로 저장: `bounds:{지역구명}:{임대유형}`

#### 1.5 안전성 점수 계산 및 저장 (B-05)
지역구별 안전성 점수를 사전 계산하여 저장한다.
- 범죄 발생 건수, 인구수, 유흥업소 수 데이터 수집
- 분석 보고서 기반 공식 적용하여 안전성 점수 계산
- Redis Hash 구조로 저장: `safety:{지역구명}`

### 우선순위별 점수 계산 시스템

#### 개별 항목 점수화 (0~100점 척도)
각기 다른 단위의 값들을 동일한 척도로 정규화:

1. **가격 점수**
   ```
   가격_점수 = 100 - ((현재_가격 - 최저_가격) / (최고_가격 - 최저_가격) × 100)
   ```
   
   가격 점수는 해당 지역구 내에서의 상대적 가성비를 반영하며, 두 단계로 계산된다. 첫 번째 단계에서 `((현재_가격 - 최저_가격) / (최고_가격 - 최저_가격)) × 100`을 통해 매물이 지역구 내에서 얼마나 비싼 편인지를 0~100점으로 산출한다. 여기서 `(최고_가격 - 최저_가격)`는 해당 지역구의 전체 가격 범위이고, `(현재_가격 - 최저_가격)`는 현재 매물이 최저가 대비 얼마나 더 비싼지를 나타낸다. 이 비율 계산의 결과는 0.0에서 1.0 사이 값으로 가격 범위 내 위치를 나타내며, 100을 곱해 0점(최저가)부터 100점(최고가)까지의 '비싼 정도' 점수가 된다.

   두 번째 단계에서는 `100 - (1단계 결과)`를 통해 점수를 선호도 기준으로 변환한다. 최저가 매물은 `100 - 0점 = 100점`으로 최고 선호도를, 최고가 매물은 `100 - 100점 = 0점`으로 최저 선호도를 받게 된다.

   **계산 예시**: 강남구에서 최저가 20,000만원, 최고가 30,000만원, 평가대상 26,000만원인 경우
   - 1단계: `((26,000 - 20,000) / (30,000 - 20,000)) × 100 = 60점` (비싼 정도)
   - 2단계: `100 - 60 = 40점` (최종 가격 점수)
   
   이를 통해 해당 매물은 지역구 내 가격 경쟁력에서 40점을 획득하며, 지역구별 상대적 가성비가 정확히 반영된다.

2. **공간 점수**
   ```
   공간_점수 = ((현재_평수 - 최소_평수) / (최대_평수 - 최소_평수) × 100)
   ```
   - 넓은 평수일수록 높은 점수

3. **안전 점수**
   - 유흥주점 밀도와 인구밀도 기반 사전 계산된 점수 활용
   - 이미 0~100점 척도로 표준화된 값

#### 우선순위별 가중치 적용
사용자가 선택한 우선순위에 따른 고정 가중치:

| 우선순위 | 가중치 |
|---------|--------|
| 1순위   | 60%    |
| 2순위   | 30%    |
| 3순위   | 10%    |

#### 최종 점수 산출
```
최종_점수 = (항목1_점수 × 가중치1) + (항목2_점수 × 가중치2) + (항목3_점수 × 가중치3)
```

계산 예시: 가격 1순위, 안전 2순위, 공간 3순위인 경우
```
최종_점수 = (가격_점수 × 0.6) + (안전_점수 × 0.3) + (공간_점수 × 0.1)
```

### 폴백 시스템 상세 설계

#### 확장 원칙
- 확장 순서: 3순위 → 2순위 → 1순위 (1순위는 원칙적으로 완화하지 않음)
- 사용자 가치 보존: 핵심 우선순위 조건은 최대한 유지
- 투명성 확보: 완화된 조건을 사용자에게 명확히 고지

#### 확장 프로세스

예시: 가격 1순위, 안전 2순위, 평수 3순위인 경우
1. 1차 확장: 평수 조건 완화 (3순위)
2. 2차 확장: 안전 조건 완화 (2순위)  
3. 가격 조건은 절대 완화하지 않음 (1순위)

#### 조건 완화 적용
1. **1차 확장**
   - 3순위 조건의 완화 임계값 적용
   - 재검색 후 매물 수 확인
   - 충분한 매물 확보 시 확장 중단

2. **2차 확장** (1차 확장으로 부족한 경우)
   - 2순위 조건의 완화 임계값 추가 적용
   - 재검색 후 최종 매물 목록 확보

### 시스템 특징 및 장점

#### 적응적 복잡도 관리
- 평상시: 단순한 기본 검색으로 빠른 응답
- 매물 부족 시: 지능적 확장 검색으로 대안 제시

#### 사용자 중심 설계
- 명시적 우선순위 설정을 통한 개인화
- 핵심 가치 보존 원칙 (1순위 조건 유지)
- 투명한 추천 근거 제공

#### 확장 가능성
- 새로운 평가 항목 추가 용이
- 가중치 체계 조정 가능
- 다양한 완화 전략 적용 가능

### 구현 시 고려사항

#### 성능 최적화
- 기본 검색 결과 캐싱 적용
- 인덱스 최적화를 통한 검색 속도 향상
- 단계별 조건 검증으로 불필요한 연산 방지

#### 사용자 경험
- 확장 검색 적용 시 명확한 안내 메시지 제공
- 각 단계별 처리 시간 모니터링
- 추천 근거의 이해하기 쉬운 표현

#### 확장성 및 유지보수
- 모듈화된 설계로 각 단계 독립적 수정 가능
- 가중치 및 임계값의 설정값 외부화
- 로그 수집을 통한 시스템 성능 모니터링