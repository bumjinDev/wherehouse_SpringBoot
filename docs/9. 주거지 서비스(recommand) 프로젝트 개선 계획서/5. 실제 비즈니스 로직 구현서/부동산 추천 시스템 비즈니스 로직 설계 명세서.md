# 부동산 추천 시스템 API 명세서

프로젝트명: 사용자 맞춤형 부동산 추천 엔진  
문서 버전: 2.0 (실제 구현 반영)  
작성일: 2025년 9월 19일  
작성자: 정범진

---

## 1. 개요

### 1.1. 목적

본 문서는 사용자 맞춤형 부동산 추천 시스템의 백엔드 API에 대한 기능적 요구사항과 인터페이스를 정의하는 것을 목적으로 한다.

### 1.2. 범위

본 명세서는 사용자의 조건에 맞는 상위 지역구를 추천하는 전세/월세 분리된 API 엔드포인트들에 대한 요구사항을 다룬다. API의 요청 파라미터, 응답 데이터 구조, 상태 코드, 그리고 예외 처리 방안을 포함한다.

## 2. 일반 요구사항

- 데이터 형식: 모든 API 요청과 응답의 데이터 형식은 JSON(Application/json)을 사용한다.
- 문자 인코딩: 모든 데이터는 UTF-8로 인코딩한다.
- 인증: API 호출 시 발급된 인증 토큰을 HTTP 헤더에 포함해야 한다. (본 명세서 범위 외)
- 기본 URL: https://{your-domain}

## 3. 엔드포인트 명세: 지역구 추천 API

### 3.1. API 개요

본 시스템은 전세와 월세 추천 로직을 완전히 분리하여 각각 전용 엔드포인트를 제공한다.

**전세 지역구 추천 API**

| 항목 | 내용 |
|------|------|
| 기능 설명 | 사용자의 전세 조건(전세금, 평수)과 우선순위(가격, 안전, 평수)를 기반으로 서울시 내 최적의 지역구를 순위별로 추천한다. 조건에 맞는 매물이 부족할 경우, 사용자가 설정한 완화 기준에 따라 자동으로 검색 범위를 확장하는 2단계 폴백 시스템을 적용한다. |
| HTTP Method | POST |
| Endpoint URL | /api/recommendations/charter-districts |

**월세 지역구 추천 API**

| 항목 | 내용 |
|------|------|
| 기능 설명 | 사용자의 월세 조건(보증금, 월세금, 평수)과 우선순위(가격, 안전, 평수)를 기반으로 서울시 내 최적의 지역구를 순위별로 추천한다. 조건에 맞는 매물이 부족할 경우, 사용자가 설정한 완화 기준에 따라 자동으로 검색 범위를 확장하는 2단계 폴백 시스템을 적용한다. |
| HTTP Method | POST |
| Endpoint URL | /api/recommendations/monthly-districts |

### 3.2. 전세 추천 API 요청 (Request)

**Request Body Fields**

| 필드 | 타입 | 필수 | 설명 | 예시 |
|------|------|------|------|------|
| budgetMin | Integer | ✓ | 최소 전세금 (단위: 만원) | 20000 |
| budgetMax | Integer | ✓ | 최대 전세금 (단위: 만원) | 30000 |
| areaMin | Double | ✓ | 최소 평수 (단위: 평) | 20 |
| areaMax | Double | ✓ | 최대 평수 (단위: 평) | 30 |
| priority1 | String | ✓ | 1순위 중요도. PRICE, SAFETY, SPACE 중 선택 | PRICE |
| priority2 | String | ✓ | 2순위 중요도 | SAFETY |
| priority3 | String | ✓ | 3순위 중요도 | SPACE |
| budgetFlexibility | Integer | ✗ | 예산 유연성 (%). 2단계 확장 시 최대 전세금을 이 비율만큼 초과 허용. (기본값: 0) | 10 |
| minSafetyScore | Integer | ✗ | 최소 안전 점수. 2단계 확장 시 이 점수까지 허용. (기본값: 0) | 70 |
| absoluteMinArea | Double | ✗ | 절대 최소 평수. 2단계 확장 시 이 평수까지 허용. (기본값: 0.0) | 15 |

**Request Body 예시:**
```json
{
  "budgetMin": 20000,
  "budgetMax": 30000,
  "areaMin": 20.0,
  "areaMax": 30.0,
  "priority1": "PRICE",
  "priority2": "SAFETY",
  "priority3": "SPACE",
  "budgetFlexibility": 10,
  "minSafetyScore": 70,
  "absoluteMinArea": 15.0
}
```

### 3.3. 월세 추천 API 요청 (Request)

**Request Body Fields**

| 필드 | 타입 | 필수 | 설명 | 예시 |
|------|------|------|------|------|
| budgetMin | Integer | ✓ | 최소 보증금 (단위: 만원) | 5000 |
| budgetMax | Integer | ✓ | 최대 보증금 (단위: 만원) | 10000 |
| monthlyRentMin | Integer | ✓ | 최소 월세 (단위: 만원) | 50 |
| monthlyRentMax | Integer | ✓ | 최대 월세 (단위: 만원) | 100 |
| areaMin | Double | ✓ | 최소 평수 (단위: 평) | 15 |
| areaMax | Double | ✓ | 최대 평수 (단위: 평) | 25 |
| priority1 | String | ✓ | 1순위 중요도. PRICE, SAFETY, SPACE 중 선택 | PRICE |
| priority2 | String | ✓ | 2순위 중요도 | SAFETY |
| priority3 | String | ✓ | 3순위 중요도 | SPACE |
| budgetFlexibility | Integer | ✗ | 예산 유연성 (%). 2단계 확장 시 최대 보증금을 이 비율만큼 초과 허용. (기본값: 0) | 10 |
| minSafetyScore | Integer | ✗ | 최소 안전 점수. 2단계 확장 시 이 점수까지 허용. (기본값: 0) | 70 |
| absoluteMinArea | Double | ✗ | 절대 최소 평수. 2단계 확장 시 이 평수까지 허용. (기본값: 0.0) | 12 |

**Request Body 예시:**
```json
{
  "budgetMin": 5000,
  "budgetMax": 10000,
  "monthlyRentMin": 50,
  "monthlyRentMax": 100,
  "areaMin": 15.0,
  "areaMax": 25.0,
  "priority1": "PRICE",
  "priority2": "SAFETY",
  "priority3": "SPACE",
  "budgetFlexibility": 10,
  "minSafetyScore": 70,
  "absoluteMinArea": 12.0
}
```

### 3.4. 전세 추천 API 응답 (Response)

**성공: 200 OK**

요청이 성공적으로 처리되었을 때 반환되는 JSON 객체.

**Response Body 예시:**
```json
{
  "searchStatus": "SUCCESS_EXPANDED",
  "message": "원하시는 조건의 매물이 부족하여, 평수 조건을 15평으로 완화하여 찾았어요.",
  "recommendedDistricts": [
    {
      "rank": 1,
      "districtName": "강남구",
      "summary": "가격 1순위 조건에 가장 부합하며, 조건 내 추천 매물이 12건 있습니다.",
      "topProperties": [
        {
          "propertyId": "101",
          "propertyName": "은마아파트",
          "address": "서울특별시 강남구 대치동 316",
          "price": 60000,
          "leaseType": "전세",
          "area": 23.2,
          "floor": 14,
          "buildYear": 1979,
          "finalScore": 82.5
        }
      ],
      "averagePriceScore": 75.3,  // 매물 비용 점수 평균
      "averageSpaceScore": 68.7,  // 평수 점수 평균
      "districtSafetyScore": 82.1,  // 주거지 안전 점수
      "averageFinalScore": 78.9,  // 최종 점수 평균
      "representativeScore": 85.4  // 지역구 자체 추천 점수
    }
  ]
}
```

### 3.5. 월세 추천 API 응답 (Response)

**성공: 200 OK**

요청이 성공적으로 처리되었을 때 반환되는 JSON 객체.

**Response Body 예시:**
```json
{
  "searchStatus": "SUCCESS_NORMAL",
  "message": "조건에 맞는 지역구를 성공적으로 찾았어요.",
  "recommendedDistricts": [
    {
      "rank": 1,
      "districtName": "마포구",
      "summary": "가격 1순위 조건에 가장 부합하며, 조건 내 추천 매물이 8건 있습니다.",
      "topProperties": [
        {
          "propertyId": "201",
          "propertyName": "신촌아파트",
          "address": "서울특별시 마포구 신촌동 123",
          "price": 8000,
          "monthlyRent": 80,
          "leaseType": "월세",
          "area": 18.5,
          "floor": 7,
          "buildYear": 2010,
          "finalScore": 79.3
        }
      ],
      "averagePriceScore": 72.1,  // 매물 비용 점수 평균
      "averageSpaceScore": 71.8,  // 평수 점수 평균
      "districtSafetyScore": 78.5,  // 주거지 안전 점수
      "averageFinalScore": 74.2,  // 최종 점수 평균
      "representativeScore": 81.7  // 지역구 자체 추천 점수
    }
  ]
}
```

**Response Body Fields**

**최상위 응답 구조**

| 필드 | 타입 | 설명 |
|------|------|------|
| searchStatus | String | 검색 결과 상태 코드. 아래 4.1. 상태 코드 표 참조 |
| message | String | 사용자 안내 메시지. 검색 상태에 대한 부가 설명을 제공 |
| recommendedDistricts | Array | 추천 지역구 목록. rank 순으로 정렬됨 (RecommendedCharterDistrictDto[] 또는 RecommendedMonthlyDistrictDto[]) |

**지역구 정보 구조 (RecommendedCharterDistrictDto / RecommendedMonthlyDistrictDto)**

| 필드 | 타입 | 설명 |
|------|------|------|
| rank | Integer | 지역구 추천 순위 |
| districtName | String | 지역구 이름 |
| summary | String | 이 지역구를 추천하는 핵심 요약 근거 |
| topProperties | Array | 해당 지역구 내에서 가장 점수가 높은 대표 매물 목록 (TopCharterPropertyDto[] 또는 TopMonthlyPropertyDto[]) |
| averagePriceScore | Double | 해당 지역구 유효 매물 전체의 가격 점수 평균값 (0~100점) |
| averageSpaceScore | Double | 해당 지역구 유효 매물 전체의 평수 점수 평균값 (0~100점) |
| districtSafetyScore | Double | 해당 지역구의 사전 계산된 안전성 점수 (0~100점) |
| averageFinalScore | Double | 해당 지역구 유효 매물 전체의 최종 점수 평균값 (0~100점) |
| representativeScore | Double | 지역구 대표 점수 (평균 점수 × log(매물 개수 + 1)) |

**전세 매물 정보 구조 (TopCharterPropertyDto)**

| 필드 | 타입 | 설명 |
|------|------|------|
| propertyId | String | 매물 고유 ID (UUID) |
| propertyName | String | 아파트/오피스텔 이름 |
| address | String | 법정동과 지번을 조합한 주소 |
| price | Integer | 전세금 (단위: 만원) |
| leaseType | String | "전세" 고정값 |
| area | Double | 전용 면적 (단위: 평) |
| floor | Integer | 층수 |
| buildYear | Integer | 건축 연도 |
| finalScore | Double | 매물의 최종 추천 점수 (0~100점) |

**월세 매물 정보 구조 (TopMonthlyPropertyDto)**

| 필드 | 타입 | 설명 |
|------|------|------|
| propertyId | String | 매물 고유 ID (UUID) |
| propertyName | String | 아파트/오피스텔 이름 |
| address | String | 법정동과 지번을 조합한 주소 |
| price | Integer | 보증금 (단위: 만원) |
| monthlyRent | Integer | 월세금 (단위: 만원) |
| leaseType | String | "월세" 고정값 |
| area | Double | 전용 면적 (단위: 평) |
| floor | Integer | 층수 |
| buildYear | Integer | 건축 연도 |
| finalScore | Double | 매물의 최종 추천 점수 (0~100점) |

## 4. 상태 코드 및 예외 처리

### 4.1. searchStatus 상태 코드

| 코드 | 의미 | 설명 |
|------|------|------|
| SUCCESS_NORMAL | 기본 검색 성공 | 사용자의 초기 조건을 만족하는 지역구를 성공적으로 추천했습니다. |
| SUCCESS_EXPANDED | 확장 검색 성공 | 초기 조건으로는 매물이 부족하여, 3순위 또는 2순위 조건을 완화한 후 지역구를 추천했습니다. |
| NO_RESULTS | 결과 없음 | 모든 조건을 최대한 완화했음에도 불구하고 추천할 지역구를 찾지 못했습니다. |

### 4.2. HTTP 상태 코드

| HTTP 코드 | 상황 | 응답 Body 예시 |
|-----------|------|-------------|
| 200 OK | 요청 성공 | (3.4, 3.5 응답 섹션 참조) |
| 400 Bad Request | 요청 파라미터 오류 (필수값 누락, 타입 불일치 등) | {"errorCode": "INVALID_PARAMETER", "message": "budgetMin 파라미터는 필수입니다."} |
| 500 Internal Server Error | 서버 내부 로직 오류 | {"errorCode": "SERVER_ERROR", "message": "요청 처리 중 오류가 발생했습니다."} |

### 4.3. 예외 상황(Edge Case) 처리 방안

**상황 1: 최종 결과 없음**
- 2단계 확장 검색까지 모두 수행했음에도 추천할 매물이 0개인 경우
- searchStatus: NO_RESULTS
- message: "아쉽지만 조건에 맞는 매물을 찾을 수 없었어요. 조건을 변경하여 다시 시도해 보세요."
- recommendedDistricts: 빈 배열 반환

**상황 2: 동점(Tie-breaking) 처리**
- 두 지역구의 '대표 점수'가 완전히 동일한 경우
- 2차 정렬 기준: 유효 매물 개수가 더 많은 지역구를 우선
- 3차 정렬 기준: 지역구명 알파벳 순서

## 5. 실제 구현 코드 기반 상세 명세

### 5.1. 컨트롤러 구현 (RecommendationController.java)

**클래스 구조:**
- @RestController, @RequestMapping("/api/recommendations")
- @RequiredArgsConstructor: CharterRecommendationService, MonthlyRecommendationService 의존성 주입
- @Slf4j: 로깅 처리
- @CrossOrigin(origins = "*")

**전세 API 구현:**
```java
@PostMapping("/charter-districts")
public ResponseEntity<CharterRecommendationResponseDto> getCharterDistrictRecommendations(
        @Valid @RequestBody CharterRecommendationRequestDto request)
```

**월세 API 구현:**
```java
@PostMapping("/monthly-districts")
public ResponseEntity<MonthlyRecommendationResponseDto> getMonthlyDistrictRecommendations(
        @Valid @RequestBody MonthlyRecommendationRequestDto request)
```

**예외 처리:**
- try-catch 블록으로 모든 Exception 캐치
- 오류 발생 시 NO_RESULTS 상태의 기본 응답 반환
- 빈 recommendedDistricts 배열과 함께 사용자 친화적 메시지 제공

### 5.2. DTO 클래스 구조 상세

#### 5.2.1. CharterRecommendationRequestDto
**주요 어노테이션:**
- @Data, @Builder, @NoArgsConstructor, @AllArgsConstructor
- @JsonProperty: JSON 필드명 명시적 매핑
- @NotNull, @Min, @Max, @DecimalMin: Bean Validation
- @Pattern: 우선순위 값 정규표현식 검증

**커스텀 검증 메소드:**
- isBudgetValid(): 최대 전세금 >= 최소 전세금
- isAreaValid(): 최대 평수 >= 최소 평수
- isPriorityUnique(): 우선순위 중복 방지

#### 5.2.2. MonthlyRecommendationRequestDto  
**추가 필드:**
- monthlyRentMin/monthlyRentMax: 월세 범위 (필수)

**추가 검증:**
- isMonthlyRentValid(): 최대 월세 >= 최소 월세

#### 5.2.3. 응답 DTO 계층 구조

**최상위 응답:**
- CharterRecommendationResponseDto → RecommendedCharterDistrictDto[] 
- MonthlyRecommendationResponseDto → RecommendedMonthlyDistrictDto[]

**지역구 DTO:**
- RecommendedCharterDistrictDto → TopCharterPropertyDto[]
- RecommendedMonthlyDistrictDto → TopMonthlyPropertyDto[]

**매물 DTO 차이점:**
- TopCharterPropertyDto: price (전세금), leaseType ("전세")
- TopMonthlyPropertyDto: price (보증금) + monthlyRent (월세금), leaseType ("월세")

#### 5.2.4. 상세 점수 데이터 필드

**RecommendedCharterDistrictDto/RecommendedMonthlyDistrictDto 공통:**
```java
@JsonProperty("averagePriceScore")
private Double averagePriceScore;

@JsonProperty("averageSpaceScore")
private Double averageSpaceScore;

@JsonProperty("districtSafetyScore")
private Double districtSafetyScore;

@JsonProperty("averageFinalScore")
private Double averageFinalScore;

@JsonProperty("representativeScore")
private Double representativeScore;
```

### 5.3. 서비스 호출 구조

**전세 추천:**
```java
CharterRecommendationResponseDto response = 
    charterRecommendationService.getCharterDistrictRecommendations(request);
```

**월세 추천:**
```java
MonthlyRecommendationResponseDto response = 
    monthlyRecommendationService.getMonthlyDistrictRecommendations(request);
```

### 5.4. 로깅 및 모니터링

**요청 로깅:**
- 요청 시작: "=== 전세/월세 지역구 추천 요청 시작 (POST) ==="
- 요청 파라미터: request 객체 전체 로깅
- 완료 로깅: 응답 상태와 함께 완료 메시지

**오류 로깅:**
- Exception 발생 시 전체 스택트레이스 로깅
- 사용자에게는 친화적 메시지 제공

### 5.5. 기타 구현 상세

#### 5.5.1. PropertyDto (범용)
**용도:** 내부 데이터 처리용 범용 매물 DTO
**특징:** 전세/월세 모든 필드 포함, 편의 메소드 제공

#### 5.5.2. ErrorResponseDto
**구조:** errorCode, message, timestamp
**용도:** 글로벌 예외 처리기에서 사용 (현재는 컨트롤러 내부에서 직접 처리)

#### 5.5.3. Health Check
**엔드포인트:** GET /api/recommendations/health
**응답:** "OK" (String)
**목적:** 로드밸런서 health check용

---

## 비즈니스 기능 구현 명세서

### 1. 아키텍처 개요

시스템은 성능과 안정성을 위해 '배치(Batch) 데이터 처리'와 '실시간(Real-time) 서비스' 두 부분으로 나뉘어 동작한다.
- 배치 처리: 주기적으로 외부 API에서 최신 매물 데이터를 수집, 가공하여 Redis에 최적화된 형태로 저장한다.
- 실시간 서비스: 사용자 요청 시, 사전 처리된 Redis 데이터만을 사용하여 매우 빠른 속도로 추천 결과를 생성한다.

### 2. 기능 명세: 배치 데이터 처리 (Batch Process)

- **구현 클래스**: com.wherehouse.recommand.batch.BatchScheduler.BatchScheduler
- **클래스 어노테이션**: @Component, @RequiredArgsConstructor, @Slf4j
- **실행 주기**: @Scheduled(fixedDelay = Long.MAX_VALUE, initialDelay = 5000) - 테스트용 한번만 실행 (현재 주석 처리됨)
- **수동 실행**: executeBatchProcess() 메소드 호출
- **핵심 역할**: 국토교통부 아파트 전월세 실거래가 API(/getRTMSDataSvcAptRent) 데이터를 조회 가능한 형태로 Redis에 적재
- **의존성 주입**: 
  - RedisHandler redisHandler
  - AnalysisEntertainmentRepository entertainmentRepository  
  - AnalysisPopulationDensityRepository populationRepository
  - AnalysisCrimeRepository crimeRepository
- **API 키**: private final String serviceKey = System.getenv("MOLIT_RENT_API_SERVICE_KEY")
- **기본 URL**: @Value("${molit.rent-api.base-url}") private String baseUrl

| 기능 ID | 기능명 | 상세 구현 내용 |
|---------|--------|----------------|
| B-01 | 전 지역구 매물 데이터 수집 | 1. 서울시 25개 자치구를 순회한다. <br> 2. 각 자치구별로 국토교통부 전월세 실거래가 API를 호출한다. <br> 3. 현재 날짜 기준 전월 데이터를 조회한다. <br> 4. 페이징 처리(1000건/페이지)를 통해 해당 지역구의 모든 매물을 수집한다. <br> 5. API 호출 간격 조절(200ms)로 Rate Limit 방지한다. |
| B-02 | 데이터 정제 및 객체 변환 | 1. XML 응답을 파싱하여 개별 매물 정보를 Property 객체로 변환한다. <br> 2. 가격은 정수형으로, 평수는 면적 단위 변환(㎡ × 0.3025)을 통해 평수로 변환한다. <br> 3. 월세금 존재 여부로 임대유형(전세/월세) 자동 판단한다. <br> 4. 법정동명과 지번을 조합하여 전체 주소를 생성한다. <br> 5. 계약일자는 연/월/일을 조합하여 YYYY-MM-DD 형식으로 변환한다. |
| B-03 | Redis 데이터 적재 | 1. redisHandler.clearCurrentRedisDB()로 기존 Redis 데이터 전체 초기화 <br> 2. **전세/월세 완전 분리 저장 구조**: <br> - 전세: property:charter:{ID} Hash, idx:charterPrice:{지역구} SortedSet, idx:area:{지역구}:전세 SortedSet <br> - 월세: property:monthly:{ID} Hash, idx:deposit:{지역구} SortedSet, idx:monthlyRent:{지역구}:월세 SortedSet, idx:area:{지역구}:월세 SortedSet <br> 3. Hash 저장 시 모든 필드를 String 타입으로 변환(toString()) 후 putAll() 사용 <br> 4. SortedSet 저장 시 add(key, member, score) 방식 사용 <br> 5. 임대유형별 통계: 각 인덱스별 생성 Key 개수를 Set<String>으로 추적하여 출력 <br> 6. 지역구별 매물 수 통계를 Map<String, Integer>로 집계하여 출력 <br> 7. "알 수 없는 임대유형" 발견 시 경고 로그 출력 후 해당 매물 건너뛰기 |
| B-04 | 지역구별 정규화 범위 계산 및 저장 | 1. 지역구명 + 임대유형별로 데이터를 그룹핑한다. <br> 2. **전세**: 전세금 최소/최대값과 평수 최소/최대값 계산 <br> 3. **월세**: 보증금과 월세금을 각각 별도 계산하여 저장 <br> 4. **전세**: bounds:{지역구명}:전세 (minPrice, maxPrice, minArea, maxArea) <br> 5. **월세**: bounds:{지역구명}:월세 (minDeposit, maxDeposit, minMonthlyRent, maxMonthlyRent, minArea, maxArea) <br> 6. 제로 분산 방지 로직 적용 (동일값일 경우 강제 차이 생성) |
| B-05 | 지역구별 안전성 점수 계산 및 저장 | 1. **범죄 데이터 수집**: crimeRepository.findCrimeCount()로 DistrictCrimeCountDto 리스트 조회하여 지역구별 totalOccurrence 추출 <br> 2. **인구 데이터 수집**: populationRepository.findPopulationCountByDistrict()로 Object[] 형태 결과를 Number.longValue()로 변환 <br> 3. **유흥업소 데이터 수집**: entertainmentRepository.findActiveEntertainmentCountByDistrict()로 Object[] 결과를 Number.doubleValue()로 변환 <br> 4. **범죄율 계산**: crimeRateMap에 (범죄발생건수 / 인구수) × 100000.0 저장 (인구가 0일 경우 1L로 처리하여 0 나누기 방지) <br> 5. **정규화 범위 계산**: 유흥업소 수와 인구수 각각의 min/max 값을 Collections.min/max로 계산 <br> 6. **서울시 25개 자치구 순회**: SEOUL_DISTRICT_CODES.values()로 모든 지역구에 대해 처리 <br> 7. **독립변수 정규화**: (현재값 - 최소값) / (최대값 - 최소값) 공식으로 0~1 구간 변환 (분모가 0일 경우 0.0 처리) <br> 8. 통계 분석으로 도출된 공식을 바탕으로 각 지역의 **'범죄 위험도'**를 계산한다. 이는 정규화된 유흥주점 수에 가중치(1.0229)를, 인구 밀도에 가중치(-0.0034)를 각각 곱하여 산출하는 방식이다. 다음으로, 계산된 범죄 위험도를 이용해 **'초기 안전성 점수'**를 매긴다. 기준 점수 100점에서 해당 지역의 위험도 점수(10을 곱해 스케일 조정)를 차감하여 구한다.마지막으로, 모든 지역구의 초기 점수들을 상호 비교하여 0점에서 100점 사이의 상대적인 최종 점수로 변환한다. 이 과정을 통해 각 지역의 안전 수준을 직관적으로 비교할 수 있는 최종 점수가 완성된다. <br> 9. **Redis 저장**: safety:{지역구명} Hash에 districtName, safetyScore, lastUpdated, version("1.0") 저장 <br> 10. **상세 통계 출력**: 범죄율/안전성점수의 최고/최저/평균값, 상위/하위 3개 지역구 순위 포함 |

#### 2.1. 배치 처리 대상 테이블 구조

**전세 매물 원본 데이터 테이블 (charter_property_data)**
- 목적: API로부터 수집된 전세 매물의 모든 상세 정보를 저장
- 저장 위치: Redis Hash 구조
- 키 패턴: `property:charter:{매물고유ID}`

| 필드명 | 데이터타입 | 설명 | API 매핑 |
|--------|-----------|------|----------|
| propertyId | String | 매물 고유 식별자 | UUID.randomUUID() 자동생성 |
| aptNm | String | 아파트명 | aptNm |
| excluUseAr | String | 전용면적(㎡) | excluUseAr |
| floor | String | 층수 | floor |
| buildYear | String | 건축연도 | buildYear |
| dealDate | String | 계약일자(YYYY-MM-DD) | dealYear+dealMonth+dealDay 조합 |
| deposit | String | 전세금(만원) | deposit |
| leaseType | String | "전세" 고정값 | monthlyRent 기반 판단 |
| umdNm | String | 법정동명 | umdNm |
| jibun | String | 지번 | jibun |
| sggCd | String | 시군구코드 | sggCd |
| address | String | 전체 주소 | umdNm + " " + jibun 조합 |
| areaInPyeong | String | 전용면적(평) | excluUseAr * 0.3025 |
| rgstDate | String | 등록일자 | rgstDate |
| districtName | String | 지역구명 | 자치구 코드 매핑값 |

**월세 매물 원본 데이터 테이블 (monthly_property_data)**
- 목적: API로부터 수집된 월세 매물의 모든 상세 정보를 저장
- 저장 위치: Redis Hash 구조
- 키 패턴: `property:monthly:{매물고유ID}`

| 필드명 | 데이터타입 | 설명 | API 매핑 |
|--------|-----------|------|----------|
| propertyId | String | 매물 고유 식별자 | UUID.randomUUID() 자동생성 |
| aptNm | String | 아파트명 | aptNm |
| excluUseAr | String | 전용면적(㎡) | excluUseAr |
| floor | String | 층수 | floor |
| buildYear | String | 건축연도 | buildYear |
| dealDate | String | 계약일자(YYYY-MM-DD) | dealYear+dealMonth+dealDay 조합 |
| deposit | String | 보증금(만원) | deposit |
| monthlyRent | String | 월세금(만원) | monthlyRent |
| leaseType | String | "월세" 고정값 | monthlyRent > 0 기준 판단 |
| umdNm | String | 법정동명 | umdNm |
| jibun | String | 지번 | jibun |
| sggCd | String | 시군구코드 | sggCd |
| address | String | 전체 주소 | umdNm + " " + jibun 조합 |
| areaInPyeong | String | 전용면적(평) | excluUseAr * 0.3025 |
| rgstDate | String | 등록일자 | rgstDate |
| districtName | String | 지역구명 | 자치구 코드 매핑값 |

**전세금 기준 인덱스 테이블 (charter_price_index)**
- 목적: 전세금 범위 검색을 위한 정렬된 인덱스 제공
- 저장 위치: Redis Sorted Set 구조
- 키 패턴: `idx:charterPrice:{지역구명}`

| 구성요소 | 설명 |
|----------|------|
| Score | 전세금(만원 단위) |
| Member | 매물고유ID |
| 정렬기준 | 전세금 오름차순 |

**보증금 기준 인덱스 테이블 (deposit_index)**
- 목적: 월세 보증금 범위 검색을 위한 정렬된 인덱스 제공
- 저장 위치: Redis Sorted Set 구조
- 키 패턴: `idx:deposit:{지역구명}`

| 구성요소 | 설명 |
|----------|------|
| Score | 보증금(만원 단위) |
| Member | 매물고유ID |
| 정렬기준 | 보증금 오름차순 |

**월세금 기준 인덱스 테이블 (monthly_rent_index)**
- 목적: 월세금 범위 검색을 위한 정렬된 인덱스 제공
- 저장 위치: Redis Sorted Set 구조
- 키 패턴: `idx:monthlyRent:{지역구명}:월세`

| 구성요소 | 설명 |
|----------|------|
| Score | 월세금(만원 단위) |
| Member | 매물고유ID |
| 정렬기준 | 월세금 오름차순 |

**전세 평수 기준 인덱스 테이블 (charter_area_index)**
- 목적: 전세 평수 범위 검색을 위한 정렬된 인덱스 제공
- 저장 위치: Redis Sorted Set 구조
- 키 패턴: `idx:area:{지역구명}:전세`

| 구성요소 | 설명 |
|----------|------|
| Score | 전용면적(평 단위) |
| Member | 매물고유ID |
| 정렬기준 | 평수 오름차순 |

**월세 평수 기준 인덱스 테이블 (monthly_area_index)**
- 목적: 월세 평수 범위 검색을 위한 정렬된 인덱스 제공
- 저장 위치: Redis Sorted Set 구조
- 키 패턴: `idx:area:{지역구명}:월세`

| 구성요소 | 설명 |
|----------|------|
| Score | 전용면적(평 단위) |
| Member | 매물고유ID |
| 정렬기준 | 평수 오름차순 |

**전세 정규화 범위 테이블 (charter_normalization_bounds)**
- 목적: 전세 실시간 점수 계산을 위한 지역구별 정규화 범위 제공
- 저장 위치: Redis Hash 구조
- 키 패턴: `bounds:{지역구명}:전세`

| 필드명 | 설명 |
|--------|------|
| minPrice | 해당 지역구 전세의 최저 전세금 |
| maxPrice | 해당 지역구 전세의 최고 전세금 |
| minArea | 해당 지역구 전세의 최소 평수 |
| maxArea | 해당 지역구 전세의 최대 평수 |
| propertyCount | 계산에 사용된 전세 매물 개수 |
| lastUpdated | 마지막 업데이트 일시 |

**월세 정규화 범위 테이블 (monthly_normalization_bounds)**
- 목적: 월세 실시간 점수 계산을 위한 지역구별 정규화 범위 제공
- 저장 위치: Redis Hash 구조
- 키 패턴: `bounds:{지역구명}:월세`

| 필드명 | 설명 |
|--------|------|
| minDeposit | 해당 지역구 월세의 최저 보증금 |
| maxDeposit | 해당 지역구 월세의 최고 보증금 |
| minMonthlyRent | 해당 지역구 월세의 최저 월세금 |
| maxMonthlyRent | 해당 지역구 월세의 최고 월세금 |
| minArea | 해당 지역구 월세의 최소 평수 |
| maxArea | 해당 지역구 월세의 최대 평수 |
| propertyCount | 계산에 사용된 월세 매물 개수 |
| lastUpdated | 마지막 업데이트 일시 |

**안전성 점수 테이블 (safety_scores)**
- 목적: 지역구별 사전 계산된 안전성 점수 제공
- 저장 위치: Redis Hash 구조
- 키 패턴: `safety:{지역구명}`

| 필드명 | 설명 |
|--------|------|
| districtName | 지역구명 |
| safetyScore | 안전성 점수 (0~100점, 분석 보고서 공식 적용) |
| lastUpdated | 마지막 업데이트 일시 |
| version | 계산 공식 버전 ("1.0") |

### 3. 실제 구현 상세

#### 3.1. 서울시 25개 자치구 코드 매핑
```java
private static final Map<String, String> SEOUL_DISTRICT_CODES;
// "11110" -> "종로구", "11140" -> "중구", ... (25개 구 전체)
```

#### 3.2. API 호출 설정
- **기본 URL**: `${molit.rent-api.base-url}` 설정값 사용
- **엔드포인트**: `/getRTMSDataSvcAptRent` (아파트 전월세 실거래가)
- **페이지당 조회 건수**: 1000건 고정
- **조회 기준 날짜**: 현재 날짜 기준 전월 (LocalDate.now().minusMonths(1))
- **Rate Limit 방지**: API 호출 간 200ms 대기

#### 3.3. 데이터 검증 및 예외 처리
- **XML 파싱 오류**: 개별 매물 파싱 실패 시 해당 매물만 건너뛰고 계속 처리
- **필수 필드 검증**: districtName, leaseType, deposit, monthlyRent, areaInPyeong null 체크
- **숫자 파싱 오류**: 쉼표 제거 후 파싱, 실패 시 null 처리
- **무한루프 방지**: 페이지 수 50개 초과 시 강제 중단

#### 3.4. Redis 저장 최적화
- **전체 DB 초기화**: `redisHandler.clearCurrentRedisDB()` 호출
- **배치 저장**: Hash putAll, Sorted Set add 연산 사용
- **인덱스 키 추적**: Map<String, Set<String>>으로 각 인덱스별 생성된 Key 개수 통계 출력
  - charterPrice, deposit, monthlyRent, charterArea, monthlyArea 인덱스별 추적
- **저장 성공률**: 개별 매물별 저장 성공/실패 카운트 및 지역구별 매물 수 집계

#### 3.5. 안전성 점수 계산 공식 (분석 보고서 기반)
1. **범죄율 계산**: (범죄 발생 건수 ÷ 인구수) × 100,000 (0 나누기 방지: 인구수가 0일 경우 1L 사용)
2. **정규화**: 유흥주점 수와 인구수를 각각 Collections.min/max로 범위 계산 후 0~1 구간으로 정규화
3. **위험도 산출**: 1.0229 × 정규화된_유흥주점밀도 - 0.0034 × 정규화된_인구밀도
4. **원본 점수**: 100 - (위험도 × 10)
5. **최종 정규화**: 원본 점수를 0~100점 구간으로 재정규화
6. **상세 통계**: 범죄율, 안전성 점수의 최고/최저/평균값과 상위/하위 3개 지역구 순위 출력

#### 3.6. 서울시 25개 자치구 코드 매핑 (SEOUL_DISTRICT_CODES)
```java
private static final Map<String, String> SEOUL_DISTRICT_CODES;
static {
    Map<String, String> codes = new HashMap<>();
    codes.put("11110", "종로구"); codes.put("11140", "중구"); codes.put("11170", "용산구");
    codes.put("11200", "성동구"); codes.put("11215", "광진구"); codes.put("11230", "동대문구");
    codes.put("11260", "중랑구"); codes.put("11290", "성북구"); codes.put("11305", "강북구");
    codes.put("11320", "도봉구"); codes.put("11350", "노원구"); codes.put("11380", "은평구");
    codes.put("11410", "서대문구"); codes.put("11440", "마포구"); codes.put("11470", "양천구");
    codes.put("11500", "강서구"); codes.put("11530", "구로구"); codes.put("11545", "금천구");
    codes.put("11560", "영등포구"); codes.put("11590", "동작구"); codes.put("11620", "관악구");
    codes.put("11650", "서초구"); codes.put("11680", "강남구"); codes.put("11710", "송파구");
    codes.put("11740", "강동구");
    SEOUL_DISTRICT_CODES = Collections.unmodifiableMap(codes);
}
```

#### 3.7. 주요 유틸리티 메소드
- **extractResultCode(String xmlResponse)**: XML에서 <resultCode> 추출
- **extractResultMsg(String xmlResponse)**: XML에서 <resultMsg> 추출  
- **extractTotalCount(String xmlResponse)**: XML에서 <totalCount> 추출
- **getElementValue(Element parent, String tagName)**: XML Element에서 텍스트 값 추출
- **parseDoubleValue(String value)**: 쉼표 제거 후 Double 안전 변환
- **parseIntegerValue(String value)**: 쉼표 제거 후 Integer 안전 변환
- **isValidPropertyForNormalization(Property property)**: 정규화용 매물 유효성 검증 (현재 미사용)

#### 3.8. 내부 클래스 및 상수
- **NormalizationBounds**: 정규화 범위 데이터를 담는 내부 static 클래스
  - final double minPrice, maxPrice, minArea, maxArea 필드
- **API_ENDPOINT**: "/getRTMSDataSvcAptRent" 상수
- **NUM_OF_ROWS**: "1000" (페이지당 조회 건수) 상수

### 4. 전체 실행 흐름 (executeBatchProcess 메소드)

```java
public void executeBatchProcess() {
    log.info("=== 부동산 매물 데이터 배치 처리 시작 ===");
    
    try {
        // B-01: 전 지역구 매물 데이터 수집
        List<Property> allProperties = collectAllDistrictData();
        log.info("이 {}건의 매물 데이터를 수집했습니다.", allProperties.size());

        // B-03: Redis 데이터 적재
        storeDataToRedis(allProperties);

        // B-04: 지역구별 정규화 범위 계산 및 저장
        calculateAndStoreNormalizationBounds(allProperties);

        // B-05: 지역구별 안전성 점수 계산 및 Redis 저장
        calculateAndStoreSafetyScores();

        log.info("=== 부동산 매물 데이터 배치 처리 완료 ===");

    } catch (Exception e) {
        log.error("배치 처리 중 오류 발생", e);
    }
}
```

### 5. Property DTO 클래스 구조 (com.wherehouse.recommand.batch.dto.Property)

**클래스 어노테이션**: @Data, @Builder, @NoArgsConstructor, @AllArgsConstructor

**주요 필드**:
- String propertyId (매물 고유 식별자)
- String aptNm (아파트명) 
- Double excluUseAr (전용면적㎡)
- Integer floor, buildYear, deposit, monthlyRent
- String dealDate, leaseType, umdNm, jibun, sggCd, address, rgstDate, districtName
- Double areaInPyeong, safetyScore (계산된 값들)

**주요 메소드**:
- calculateAreaInPyeong(): excluUseAr * 0.3025 계산
- determineLeaseType(): monthlyRent > 0 기준 판단  
- generateAddress(): umdNm + " " + jibun 조합

### 6. DistrictCrimeCountDto 클래스 구조

**클래스 어노테이션**: @Data, @NoArgsConstructor, @AllArgsConstructor

**주요 필드**: 
- Long id, totalOccurrence, totalArrest
- String districtName
- Long year (의도적으로 일부 생성자에서 제외)
- 범죄 유형별 발생/검거 건수 (murder, robbery, sexualCrime, theft, violence)

**JPQL 프로젝션용 생성자**: year를 제외한 모든 필드를 받는 생성자 제공

### 3. 기능 명세: 실시간 추천 서비스 (Real-time Service)

- 구현 위치: CharterRecommendationService.java, MonthlyRecommendationService.java
- 호출 시점: 
  - 전세: POST /api/recommendations/charter 엔드포인트 요청 시
  - 월세: POST /api/recommendations/monthly 엔드포인트 요청 시
- 핵심 역할: Redis 데이터를 기반으로 사용자 맞춤형 지역구 및 매물 추천 (전세/월세 분리 서비스)

## 전세 추천 서비스 (CharterRecommendationService)

| 기능 ID | 기능명 | 상세 구현 내용 |
|---------|--------|----------------|
| C-01 | 전세 전 지역구 1차 검색 (Strict) | 1. 서울시 25개 자치구를 모두 순회한다. <br> 2. 안전성 조건이 있을 경우 지역구 레벨에서 사전 필터링을 적용한다. <br> 3. 각 자치구마다 2개 인덱스 교집합을 수행한다: `idx:charterPrice:{지역구}` + `idx:area:{지역구}:전세` <br> 4. 전세금과 평수 조건을 모두 만족하는 매물들의 교집합을 구하여, 각 자치구별 유효 매물 목록을 생성한다. |
| C-02 | 전세 폴백(Fallback) 조건 판단 | 1. C-01에서 생성된 지역구별 매물 중 3개 미만인 지역구가 있는지 검사한다.<br> 2. 부족한 지역구가 있을 경우, C-03 확장 검색을 실행한다.<br> 3. 모든 지역구가 충족될 경우, C-04 점수 계산으로 넘어간다. |
| C-03 | 전세 2차 확장 검색 (Expanded) | 1. 매물이 부족한 지역구들만 추출한다.<br> 2. 사용자의 3순위 조건을 완화하여 부족한 지역구들만 재검색한다.<br> 3. 여전히 부족하면 2순위 조건까지 완화하여 재검색한다.<br> 4. 완화된 조건 정보를 응답 메시지에 포함한다. |
| C-04 | 전세 매물 단위 점수 계산 | 1. Redis에서 `property:charter:{id}` 패턴으로 매물 상세 정보를 Pipeline 조회한다.<br> 2. `bounds:{지역구}:전세` 키에서 정규화 범위를 조회한다.<br> 3. 전세금 점수(낮을수록 높은 점수), 평수 점수(넓을수록 높은 점수), 안전 점수를 각각 0~100점으로 계산한다.<br> 4. 우선순위별 60%/30%/10% 가중치를 적용하여 최종 점수를 산출한다.<br> 5. 각 지역구 내에서 매물을 최종 점수 기준으로 내림차순 정렬한다. |
| C-05 | 전세 지역구 단위 점수 계산 및 정렬 | 1. 각 지역구의 대표 점수를 산출한다: `평균 finalScore × log(매물 개수 + 1)` <br> 2. 대표 점수 기준으로 지역구를 내림차순 정렬한다. <br> 3. 동점 처리: 대표 점수 → 매물 개수 → 지역구명 알파벳 순 |
| C-06 | 전세 최종 응답 생성 | 1. 정렬된 지역구 목록에서 상위 3개를 선택한다. <br> 2. 각 지역구별로 순위, 지역구명, 추천 요약 메시지, 상위 매물들을 추출한다. <br> 3. CharterRecommendationResponseDto 형태로 가공하여 반환한다. |

## 월세 추천 서비스 (MonthlyRecommendationService)

| 기능 ID | 기능명 | 상세 구현 내용 |
|---------|--------|----------------|
| M-01 | 월세 전 지역구 1차 검색 (Strict) | 1. 서울시 25개 자치구를 모두 순회한다. <br> 2. 안전성 조건이 있을 경우 지역구 레벨에서 사전 필터링을 적용한다. <br> 3. 각 자치구마다 3개 인덱스 교집합을 수행한다: `idx:deposit:{지역구}` + `idx:monthlyRent:{지역구}:월세` + `idx:area:{지역구}:월세` <br> 4. 보증금, 월세금, 평수 조건을 모두 만족하는 매물들의 교집합을 구하여, 각 자치구별 유효 매물 목록을 생성한다. |
| M-02 | 월세 폴백(Fallback) 조건 판단 | 1. M-01에서 생성된 지역구별 매물 중 3개 미만인 지역구가 있는지 검사한다.<br> 2. 부족한 지역구가 있을 경우, M-03 확장 검색을 실행한다.<br> 3. 모든 지역구가 충족될 경우, M-04 점수 계산으로 넘어간다. |
| M-03 | 월세 2차 확장 검색 (Expanded) | 1. 매물이 부족한 지역구들만 추출한다.<br> 2. 사용자의 3순위 조건을 완화하여 부족한 지역구들만 재검색한다.<br> 3. 여전히 부족하면 2순위 조건까지 완화하여 재검색한다.<br> 4. 완화된 조건 정보를 응답 메시지에 포함한다. |
| M-04 | 월세 매물 단위 점수 계산 | 1. Redis에서 `property:monthly:{id}` 패턴으로 매물 상세 정보를 Pipeline 조회한다.<br> 2. `bounds:{지역구}:월세` 키에서 정규화 범위를 조회한다.<br> 3. 보증금 점수(낮을수록 높은 점수), 월세금 점수(낮을수록 높은 점수), 평수 점수(넓을수록 높은 점수), 안전 점수를 각각 0~100점으로 계산한다.<br> 4. PRICE 가중치를 보증금과 월세금에 50%씩 분배하여 적용한다.<br> 5. 각 지역구 내에서 매물을 최종 점수 기준으로 내림차순 정렬한다. |
| M-05 | 월세 지역구 단위 점수 계산 및 정렬 | 1. 각 지역구의 대표 점수를 산출한다: `평균 finalScore × log(매물 개수 + 1)` <br> 2. 대표 점수 기준으로 지역구를 내림차순 정렬한다. <br> 3. 동점 처리: 대표 점수 → 매물 개수 → 지역구명 알파벳 순 |
| M-06 | 월세 최종 응답 생성 | 1. 정렬된 지역구 목록에서 상위 3개를 선택한다. <br> 2. 각 지역구별로 순위, 지역구명, 추천 요약 메시지, 상위 매물들을 추출한다. <br> 3. MonthlyRecommendationResponseDto 형태로 가공하여 반환한다. |

## 주요 구현 특징

### 1. 검색 인덱스 구조
- **전세**: 2개 인덱스 교집합 (`charterPrice` + `area`)
- **월세**: 3개 인덱스 교집합 (`deposit` + `monthlyRent` + `area`)

### 2. 안전성 점수 시스템
- **배치 처리**: 범죄 데이터, 인구수, 유흥업소 수를 기반으로 지역구별 안전성 점수 사전 계산
- **계산 공식**: 범죄위험도 = 1.0229 × 정규화된_유흥주점밀도 - 0.0034 × 정규화된_인구밀도
- **최종 점수**: 100 - (범죄위험도 × 10), 0~100점 구간으로 정규화
- **저장 구조**: Redis `safety:{지역구명}` Hash로 저장
- **실시간 활용**: 추천 서비스에서 조회하여 매물별 안전 점수로 사용

### 3. 폴백 로직
- 지역구별 매물 3개 미만 기준으로 해당 지역구만 확장 검색

### 4. Redis 데이터 구조
- **매물 데이터**: `property:{leaseType}:{id}` 패턴 (전세/월세 분리)
- **정규화 범위**: `bounds:{지역구}:{leaseType}` 패턴
- **안전성 점수**: `safety:{지역구}` 패턴

### 5. 점수 계산 로직
- **전세**: 전세금 + 평수 + 안전성 (3개 항목)
- **월세**: 보증금 + 월세금 + 평수 + 안전성 (4개 항목, PRICE 가중치 분배)

### 6. Pipeline 조회 최적화
- Redis Pipeline을 사용한 배치 조회로 성능 최적화
- 개별 매물 조회 실패 시 전체 중단 없이 계속 진행

---
## 매물 점수 산출 및 지역구 순위 결정 상세 로직

이 로직은 기능 S-04 (매물 단위 점수 계산)와 S-05 (지역구 단위 점수 계산)를 통합한 상세 실행 계획이다.

### 1단계: 각 지역구별 유효 매물 목록 확보

입력: 1차(Strict) 또는 2차(Fallback) 검색을 통해 확보된 자치구별 유효 매물 목록.

### 2단계: 지역구별 '매물 단위' 점수 계산

모든 지역구를 순회하며, 각 지역구에 포함된 모든 유효 매물의 최종 점수를 계산한다.

1. 매물 상세 정보 조회: Redis에서 각 매물에 해당하는 상세 정보(가격, 평수, 안전점수 등)를 모두 조회한다.

2. 점수 정규화:
   - 이 기준값을 사용하여 해당 지역구의 모든 매물에 대해 가격 점수와 평수 점수를 0~100점 척도로 변환한다.

3. 최종 점수 산출:
   - 사용자의 우선순위(1순위: 60%, 2순위: 30%, 3순위: 10%) 가중치를 적용하여 각 매물의 최종 점수를 계산한다.

4. 매물 정렬:
   - 계산이 완료되면, 각 지역구의 매물 리스트를 최종 점수가 높은 순으로 내림차순 정렬한다.

출력: 자치구별 정렬된 매물 목록.

### 3단계: '지역구 단위' 대표 점수 계산

모든 개별 매물의 점수 계산이 완료된 후, 이 데이터를 바탕으로 지역구의 순위를 매긴다.

#### 3.1. 개선된 지역구 대표 점수 계산 공식

**매물의 평균적인 퀄리티를 기본으로 하되, 매물의 개수가 많을수록 가산점을 주는 방식**을 적용한다.

```
최종 지역구 대표 점수 = (해당 지역구의 유효 매물 전체의 평균 finalScore) × log(매물 개수 + 1)
```

#### 3.2. 공식 구성 요소

**유효 매물 전체의 평균 finalScore**
- 해당 지역구 매물들의 전반적인 **퀄리티**를 나타냄
- 상위 5개가 아닌 전체 평균을 사용하여 지역구의 보편적인 수준을 반영
- 0~100점 척도의 평균값

**log(매물 개수 + 1)**
- 매물 개수가 많을수록 점수가 올라가지만, 그 증가폭이 점차 줄어들어 **선택의 폭**을 적절히 반영
- +1은 매물이 1개일 때 log값이 0이 되는 것을 방지
- 자연로그(ln) 사용

#### 3.3. 계산 예시

**시나리오 1: 퀄리티 vs 선택의 폭**
- A구역: 평균 점수 90점, 매물 3개 → 90 × log(4) ≈ 54.2점
- B구역: 평균 점수 80점, 매물 30개 → 80 × log(31) ≈ 119.3점
- 결과: 퀄리티는 조금 낮아도 선택의 폭이 훨씬 넓은 B구역이 더 높게 평가

**시나리오 2: 극단적인 매물 개수 차이**
- C구역: 평균 점수 90점, 매물 10개 → 90 × log(11) ≈ 93.5점
- D구역: 평균 점수 60점, 매물 100개 → 60 × log(101) ≈ 120.1점
- 결과: 매물 개수가 압도적으로 많다면 퀄리티 차이를 극복하고 더 높게 평가

#### 3.4. 지역구 정렬 및 동점 처리

1. **1차 정렬**: 계산된 대표 점수를 기준으로 내림차순 정렬
2. **동점 처리**: 대표 점수가 동일할 경우 다음 순서로 우선순위 결정
   - 2차 기준: 유효 매물 개수가 더 많은 지역구 우선
   - 3차 기준: 지역구명 알파벳 순서

출력: 최종 정렬된 지역구 순위 목록.

---

## 시스템 아키텍처 및 비즈니스 로직

### 전체 시스템 구조

시스템은 실시간 서비스 처리와 배치 처리로 구분되며, 총 3단계로 구성된다:

실시간 서비스 처리 (사용자 요청 시)
2. 사용자 요청 실시간 처리: Redis에서 고속 검색 및 폴백 구조 적용
3. 최종 점수 계산 및 응답: 우선순위 기반 점수 계산 및 정렬

배치 처리 (사전 준비)
1. API 데이터 사전 처리 및 Redis 캐싱: 매물 데이터 수집 및 인덱스 생성

### 2단계 (서비스): 사용자 요청 실시간 처리

사용자가 API를 요청했을 때 실행되는 로직이다. 이 단계에서는 느린 외부 API를 절대 직접 호출하지 않고, 오직 빠른 Redis 하고만 통신한다.

#### 2.1 Redis에서 1차 검색 (Strict Search)
- 사용자가 요청한 지역구, 임대유형(전세 또는 월세), 평수 조건을 받는다.
- 전세의 경우: 전세금 범위
- 월세의 경우: 보증금 범위와 월세 범위
- Redis의 검색 인덱스를 사용해 각 조건을 만족하는 매물 목록을 각각 조회한다.
- 가져온 매물 목록들의 교집합을 구해 모든 조건을 동시에 만족하는 최종 매물 목록을 확정한다.

#### 2.2 폴백(Fallback) 구조 적용
- 1차 검색으로 찾은 매물 개수가 3개 미만이면 확장 검색을 시작한다.
- 사용자의 우선순위(3순위→2순위 순)와 완화 임계값을 바탕으로 검색 범위를 넓혀서 1번 과정을 다시 수행한다.

### 3단계 (서비스): 최종 점수 계산 및 응답

#### 3.1 매물 상세 정보 조회
2단계를 통해 확정된 최종 매물 목록을 가지고, Redis에서 각 매물의 전체 상세 정보를 조회한다.

#### 3.2 점수 계산 및 정렬
조회된 매물 목록을 대상으로, 정의된 60%/30%/10% 고정 가중치 기반 점수 계산 로직을 실행하여 최종 점수를 계산하고 내림차순으로 정렬한다.

#### 3.3 API 응답 생성
정렬된 최종 결과를 API 응답 명세에 맞춰 가공하여 사용자에게 반환한다.

### 1단계 (배치): API 데이터 사전 처리 및 Redis 캐싱

이 단계는 사용자 요청과 상관없이, 서버가 주기적으로(예: 매일 새벽) 실행하여 최신 매물 데이터를 미리 Redis에 가공하여 저장하는 과정이다.

#### 1.1 전 지역구 데이터 수집
서울시 25개 자치구 코드를 순회하며 국토교통부 전월세 API를 호출한다. API 응답의 페이징 정보를 확인하여 해당 지역구의 모든 매물 데이터를 빠짐없이 가져온다.

#### 1.2 데이터 가공 및 보강
API로부터 받은 데이터를 매물 객체로 파싱한다. 이 과정에서는 지역구별 안전성 점수를 별도로 사전 계산하여 Redis에 저장하고, 실시간 서비스에서 해당 지역구의 안전성 점수를 조회하여 개별 매물에 적용한다.

#### 1.3 Redis에 인덱스 형태로 저장
가공된 매물 데이터를 Redis에 저장할 때, 단순 캐시가 아닌 아래와 같이 여러 자료구조를 조합하여 저장한다. 이는 Redis를 인메모리 검색 엔진처럼 사용하기 위함이다.

매물 원본 데이터: 각 매물 정보를 구조화된 형태로 저장한다.
- 특정 매물 정보를 매우 빠르게 조회할 수 있다.

검색을 위한 인덱스: 사용자의 핵심 검색 조건(가격, 평수)을 빠르게 필터링하기 위해 자치구별로 정렬된 인덱스를 생성한다.
- 가격 인덱스: 지역구별 가격 기준 정렬
- 평수 인덱스: 지역구별 평수 기준 정렬
- 매우 빠른 속도로 특정 범위에 해당하는 모든 매물을 즉시 찾아낼 수 있다.

#### 1.4 정규화 범위 계산 및 저장 (B-04)
실시간 점수 계산 시 사용할 지역구별 정규화 범위를 사전 계산하여 저장한다.
- 지역구별 + 임대유형별로 데이터 그룹핑
- 가격 범위(최소/최대) 및 평수 범위(최소/최대) 계산
- Redis Hash 구조로 저장: `bounds:{지역구명}:{임대유형}`

#### 1.5 안전성 점수 계산 및 저장 (B-05)
지역구별 안전성 점수를 사전 계산하여 저장한다.
- 범죄 발생 건수, 인구수, 유흥업소 수 데이터 수집
- 분석 보고서 기반 공식 적용하여 안전성 점수 계산
- Redis Hash 구조로 저장: `safety:{지역구명}`

### 우선순위별 점수 계산 시스템

#### 개별 항목 점수화 (0~100점 척도)
각기 다른 단위의 값들을 동일한 척도로 정규화:

1. **가격 점수**
   ```
   가격_점수 = 100 - ((현재_가격 - 최저_가격) / (최고_가격 - 최저_가격) × 100)
   ```
   
   가격 점수는 해당 지역구 내에서의 상대적 가성비를 반영하며, 두 단계로 계산된다. 첫 번째 단계에서 `((현재_가격 - 최저_가격) / (최고_가격 - 최저_가격)) × 100`을 통해 매물이 지역구 내에서 얼마나 비싼 편인지를 0~100점으로 산출한다. 여기서 `(최고_가격 - 최저_가격)`는 해당 지역구의 전체 가격 범위이고, `(현재_가격 - 최저_가격)`는 현재 매물이 최저가 대비 얼마나 더 비싼지를 나타낸다. 이 비율 계산의 결과는 0.0에서 1.0 사이 값으로 가격 범위 내 위치를 나타내며, 100을 곱해 0점(최저가)부터 100점(최고가)까지의 '비싼 정도' 점수가 된다.

   두 번째 단계에서는 `100 - (1단계 결과)`를 통해 점수를 선호도 기준으로 변환한다. 최저가 매물은 `100 - 0점 = 100점`으로 최고 선호도를, 최고가 매물은 `100 - 100점 = 0점`으로 최저 선호도를 받게 된다.

   **계산 예시**: 강남구에서 최저가 20,000만원, 최고가 30,000만원, 평가대상 26,000만원인 경우
   - 1단계: `((26,000 - 20,000) / (30,000 - 20,000)) × 100 = 60점` (비싼 정도)
   - 2단계: `100 - 60 = 40점` (최종 가격 점수)
   
   이를 통해 해당 매물은 지역구 내 가격 경쟁력에서 40점을 획득하며, 지역구별 상대적 가성비가 정확히 반영된다.

2. **평수 점수**
   ```
   평수_점수 = ((현재_평수 - 최소_평수) / (최대_평수 - 최소_평수) × 100)
   ```
   - 넓은 평수일수록 높은 점수

3. **안전 점수**
   - 지역구별로 사전 계산된 안전성 점수를 해당 매물에 적용
   - 범죄 데이터, 인구수, 유흥업소 수 기반으로 계산된 0~100점 척도 값

#### 우선순위별 가중치 적용
사용자가 선택한 우선순위에 따른 고정 가중치:

| 우선순위 | 가중치 |
|---------|--------|
| 1순위   | 60%    |
| 2순위   | 30%    |
| 3순위   | 10%    |

#### 최종 점수 산출
```
최종_점수 = (항목1_점수 × 가중치1) + (항목2_점수 × 가중치2) + (항목3_점수 × 가중치3)
```

계산 예시: 가격 1순위, 안전 2순위, 평수 3순위인 경우
```
최종_점수 = (가격_점수 × 0.6) + (안전_점수 × 0.3) + (평수_점수 × 0.1)
```

**월세의 경우**: PRICE 가중치를 보증금과 월세금에 50%씩 분배
```
최종_점수 = (보증금_점수 × 0.3) + (월세금_점수 × 0.3) + (안전_점수 × 0.3) + (평수_점수 × 0.1)
```

### 폴백 시스템 상세 설계

#### 확장 원칙
- 확장 순서: 3순위 → 2순위 → 1순위 (1순위는 원칙적으로 완화하지 않음)
- 사용자 가치 보존: 핵심 우선순위 조건은 최대한 유지
- 투명성 확보: 완화된 조건을 사용자에게 명확히 고지

#### 확장 프로세스

예시: 가격 1순위, 안전 2순위, 평수 3순위인 경우
1. 1차 확장: 평수 조건 완화 (3순위)
2. 2차 확장: 안전 조건 완화 (2순위)  
3. 가격 조건은 절대 완화하지 않음 (1순위)

#### 조건 완화 적용
1. **1차 확장**
   - 3순위 조건의 완화 임계값 적용 (`budgetFlexibility`, `absoluteMinArea`, `minSafetyScore` 파라미터 활용)
   - 재검색 후 매물 수 확인
   - 충분한 매물 확보 시 확장 중단

2. **2차 확장** (1차 확장으로 부족한 경우)
   - 2순위 조건의 완화 임계값 추가 적용 (동일한 파라미터들을 2순위에도 적용)
   - 재검색 후 최종 매물 목록 확보

### 시스템 특징 및 장점

#### 적응적 복잡도 관리
- 평상시: 단순한 기본 검색으로 빠른 응답
- 매물 부족 시: 지능적 확장 검색으로 대안 제시

#### 사용자 중심 설계
- 명시적 우선순위 설정을 통한 개인화
- 핵심 가치 보존 원칙 (1순위 조건 유지)
- 투명한 추천 근거 제공

#### 확장 가능성
- 새로운 평가 항목 추가 용이
- 가중치 체계 조정 가능
- 다양한 완화 전략 적용 가능

### 구현 시 고려사항

#### 성능 최적화
- 기본 검색 결과 캐싱 적용
- 인덱스 최적화를 통한 검색 속도 향상
- Redis Pipeline (`executePipelined`) 기반 배치 조회로 매물 상세 정보 고속 처리
- 단계별 조건 검증으로 불필요한 연산 방지

#### 사용자 경험
- 확장 검색 적용 시 명확한 안내 메시지 제공
- 각 단계별 처리 시간 모니터링
- 추천 근거의 이해하기 쉬운 표현

#### 확장성 및 유지보수
- 모듈화된 설계로 각 단계 독립적 수정 가능
- 가중치 및 임계값의 설정값 외부화
- 로그 수집을 통한 시스템 성능 모니터링