# 부동산 추천 시스템 핵심 계산식 명세서

## 1. 문제 분석: 기존 설계의 계산식 부족 사항

### 1.1 추상적으로만 기술된 부분들

기존 문서에서 다음과 같이 **개념적으로만** 언급된 계산들:

```javascript
// ❌ 추상적 표현 (구현 불가)
double priceScore = property.getPriceScore() * 0.6;     // getPriceScore()가 뭔가?
double safetyScore = calculateSafetyScore(location);    // 어떤 공식으로?
double costEfficiency = avgPricePerArea / pricePerArea; // 단순 나눗셈이 맞나?
```

### 1.2 구체적 계산식이 필요한 핵심 영역

1. **가격우선형 가성비 점수**: 시세 대비 얼마나 저렴한가?
2. **안전우선형 종합 점수**: 4개 안전 요소를 어떻게 합산?
3. **평수우선형 공간효율 점수**: 평당 활용도를 어떻게 수치화?
4. **2단계 확장 조건**: 언제, 얼마나 확장할 것인가?

---

## 2. 가격우선형 가성비 점수 계산식

### 2.1 기본 가성비 점수 공식

```javascript
/**
 * 가성비 점수 = 지역할인율(40%) + 시세대비할인율(35%) + 거래량보정(15%) + 건물연차보정(10%)
 */

function calculatePriceScore(property, marketData) {
    // 1. 지역 할인율 계산 (40% 가중치)
    const regionDiscount = calculateRegionDiscount(property, marketData);
    
    // 2. 시세 대비 할인율 (35% 가중치)  
    const marketDiscount = calculateMarketDiscount(property, marketData);
    
    // 3. 거래량 보정 (15% 가중치)
    const volumeAdjustment = calculateVolumeAdjustment(property, marketData);
    
    // 4. 건물 연차 보정 (10% 가중치)
    const ageAdjustment = calculateAgeAdjustment(property);
    
    const finalScore = (regionDiscount * 0.4) + 
                      (marketDiscount * 0.35) + 
                      (volumeAdjustment * 0.15) + 
                      (ageAdjustment * 0.1);
                      
    return Math.max(0, Math.min(100, finalScore));
}
```

### 2.2 세부 계산식

#### A. 지역 할인율 계산
```javascript
function calculateRegionDiscount(property, marketData) {
    // 해당 구 평균 평당가
    const avgPricePerPyeong = marketData.districtAverage / 3.3;
    
    // 해당 매물 평당가
    const propertyPricePerPyeong = property.price / property.area;
    
    // 할인율 = (지역평균 - 매물가격) / 지역평균 * 100
    const discountRate = ((avgPricePerPyeong - propertyPricePerPyeong) / avgPricePerPyeong) * 100;
    
    // 할인율을 0-100 점수로 변환
    // 30% 할인 = 100점, 0% 할인 = 50점, -20% 할인(비쌈) = 0점
    if (discountRate >= 30) return 100;
    if (discountRate >= 0) return 50 + (discountRate * 50 / 30);
    return Math.max(0, 50 + (discountRate * 50 / 20));
}
```

#### B. 시세 대비 할인율 계산
```javascript
function calculateMarketDiscount(property, marketData) {
    // 최근 3개월 동일 단지 거래가 평균
    const recentSimilarAvg = marketData.getSimilarComplexAverage(
        property.complexName, 
        property.area, 
        3 // 최근 3개월
    );
    
    if (!recentSimilarAvg) {
        // 유사 거래가 없으면 지역 평균 대비 계산
        return calculateRegionDiscount(property, marketData) * 0.8; // 80% 가중치
    }
    
    const discountRate = ((recentSimilarAvg - property.price) / recentSimilarAvg) * 100;
    
    // 시세 대비 할인율 점수화
    if (discountRate >= 15) return 100;
    if (discountRate >= 0) return 50 + (discountRate * 50 / 15);
    return Math.max(0, 50 + (discountRate * 50 / 10));
}
```

#### C. 거래량 보정 계산
```javascript
function calculateVolumeAdjustment(property, marketData) {
    // 해당 단지 최근 3개월 거래량
    const complexVolume = marketData.getComplexVolume(property.complexName, 3);
    const districtVolume = marketData.getDistrictVolume(property.district, 3);
    
    // 거래량 활성도 = 단지거래량 / 지역평균거래량
    const volumeRatio = complexVolume / (districtVolume / marketData.complexCount);
    
    // 적정 거래량 범위: 0.5배 ~ 2.0배
    if (volumeRatio >= 0.5 && volumeRatio <= 2.0) {
        return 80 + (Math.min(volumeRatio, 1.5) * 20 / 1.5); // 80-100점
    } else if (volumeRatio > 2.0) {
        return 60; // 과열 구간
    } else {
        return 40; // 거래 부진
    }
}
```

#### D. 건물 연차 보정 계산
```javascript
function calculateAgeAdjustment(property) {
    const currentYear = new Date().getFullYear();
    const buildingAge = currentYear - property.buildYear;
    
    // 건물 연차별 점수 (신축/리모델링 프리미엄 반영)
    if (buildingAge <= 5) return 100;        // 신축급
    if (buildingAge <= 10) return 90;        // 준신축
    if (buildingAge <= 15) return 80;        // 양호
    if (buildingAge <= 20) return 70;        // 보통
    if (buildingAge <= 30) return 60;        // 노후
    return 40;                               // 재건축 대상급
}
```

---

## 3. 안전우선형 종합 안전 점수 계산식

### 3.1 안전 점수 통합 공식

```javascript
/**
 * 안전점수 = 범죄안전(40%) + 교통안전(25%) + CCTV밀도(15%) + 공공시설접근성(20%)
 * 각 세부항목은 Apache Commons Math의 Z-score 정규화 적용
 */

function calculateSafetyScore(location, district) {
    // 1. 범죄 안전도 (40% 가중치)
    const crimeScore = calculateCrimeScore(district);
    
    // 2. 교통 안전도 (25% 가중치)
    const trafficScore = calculateTrafficScore(location);
    
    // 3. CCTV 밀도 (15% 가중치)
    const cctvScore = calculateCCTVScore(location);
    
    // 4. 공공시설 접근성 (20% 가중치)
    const facilityScore = calculateFacilityScore(location);
    
    const safetyScore = (crimeScore * 0.4) + 
                       (trafficScore * 0.25) + 
                       (cctvScore * 0.15) + 
                       (facilityScore * 0.2);
                       
    return Math.max(0, Math.min(100, safetyScore));
}
```

### 3.2 범죄 안전도 계산식

```javascript
function calculateCrimeScore(district) {
    // 서울시 25개 구 범죄 통계 (2024년 기준)
    const CRIME_STATS = {
        // 구별 인구 10만명당 5대 범죄 발생건수
        '강남구': { total: 1847, violent: 342 },
        '서초구': { total: 1456, violent: 298 },
        '송파구': { total: 2134, violent: 445 },
        // ... 전체 25개 구 데이터
    };
    
    const districtCrime = CRIME_STATS[district];
    const seoulAverage = 2247; // 서울시 평균
    const seoulViolentAverage = 389;
    
    // 1. 전체 범죄율 점수 (70% 가중치)
    const totalCrimeRate = districtCrime.total / seoulAverage;
    let totalScore = Math.max(0, Math.min(100, 100 - (totalCrimeRate * 50)));
    
    // 2. 강력범죄율 점수 (30% 가중치) 
    const violentCrimeRate = districtCrime.violent / seoulViolentAverage;
    let violentScore = Math.max(0, Math.min(100, 100 - (violentCrimeRate * 60)));
    
    return (totalScore * 0.7) + (violentScore * 0.3);
}
```

### 3.3 교통 안전도 계산식

```javascript
function calculateTrafficScore(location) {
    // 1. 반경 1km 내 교통사고 건수 (최근 1년)
    const accidentCount = getTrafficAccidents(location, 1000, 12);
    
    // 2. 사고다발지역 여부 확인
    const isAccidentHotspot = checkAccidentHotspot(location, 500);
    
    // 3. 스쿨존 안전도
    const schoolZoneSafety = getSchoolZoneSafety(location, 300);
    
    // 서울시 평균: 반경 1km당 12건/년
    const seoulAverage = 12;
    
    // 사고 건수 점수 (60% 가중치)
    const accidentScore = Math.max(0, Math.min(100, 
        100 - ((accidentCount / seoulAverage) * 50)
    ));
    
    // 사고다발지역 보정 (25% 가중치)
    const hotspotScore = isAccidentHotspot ? 30 : 100;
    
    // 스쿨존 안전도 (15% 가중치)
    const schoolScore = schoolZoneSafety || 70; // 기본값 70점
    
    return (accidentScore * 0.6) + (hotspotScore * 0.25) + (schoolScore * 0.15);
}
```

### 3.4 CCTV 밀도 점수 계산식

```javascript
function calculateCCTVScore(location) {
    // 반경 500m 내 CCTV 개수 및 용도별 가중치
    const cctvData = getCCTVData(location, 500);
    
    let weightedCount = 0;
    cctvData.forEach(cctv => {
        switch(cctv.purpose) {
            case '범죄예방': weightedCount += 1.5; break;
            case '교통정보': weightedCount += 1.0; break;
            case '시설보안': weightedCount += 0.8; break;
            case '화재감시': weightedCount += 0.6; break;
            default: weightedCount += 0.5; break;
        }
    });
    
    // 최적 CCTV 밀도: 반경 500m당 8-15대 (가중치 적용)
    if (weightedCount >= 8 && weightedCount <= 15) {
        return 100; // 최적 밀도
    } else if (weightedCount > 15) {
        return 90 - ((weightedCount - 15) * 2); // 과밀도 감점
    } else if (weightedCount >= 5) {
        return 50 + ((weightedCount - 5) * 50 / 3); // 선형 증가
    } else {
        return Math.max(20, weightedCount * 10); // 최소 보장
    }
}
```

### 3.5 공공시설 접근성 점수 계산식

```javascript
function calculateFacilityScore(location) {
    // 1. 소방서 접근성 (40% 가중치)
    const fireStationDistance = getNearestFacilityDistance(location, 'fire_station');
    const fireScore = calculateDistanceScore(fireStationDistance, 1000, 3000); // 1km 최적, 3km 최악
    
    // 2. 병원 접근성 (40% 가중치)
    const hospitalDistance = getNearestFacilityDistance(location, 'hospital');
    const hospitalScore = calculateDistanceScore(hospitalDistance, 500, 2000); // 500m 최적, 2km 최악
    
    // 3. 경찰서/파출소 접근성 (20% 가중치)
    const policeDistance = getNearestFacilityDistance(location, 'police');
    const policeScore = calculateDistanceScore(policeDistance, 300, 1500); // 300m 최적, 1.5km 최악
    
    return (fireScore * 0.4) + (hospitalScore * 0.4) + (policeScore * 0.2);
}

function calculateDistanceScore(distance, optimalDistance, maxDistance) {
    if (distance <= optimalDistance) return 100;
    if (distance >= maxDistance) return 30; // 최소 보장
    
    // 선형 감소
    const ratio = (distance - optimalDistance) / (maxDistance - optimalDistance);
    return Math.max(30, 100 - (ratio * 70));
}
```

---

## 4. 평수우선형 공간효율 점수 계산식

### 4.1 공간효율 점수 통합 공식

```javascript
/**
 * 공간효율점수 = 평수충족도(50%) + 구조효율성(30%) + 층고활용도(20%)
 */

function calculateAreaScore(property, userPreference) {
    // 1. 평수 충족도 (50% 가중치)
    const areaFulfillment = calculateAreaFulfillment(property.area, userPreference);
    
    // 2. 방 구조 효율성 (30% 가중치)
    const structureEfficiency = calculateStructureEfficiency(property);
    
    // 3. 층고 활용도 (20% 가중치)
    const floorUtilization = calculateFloorUtilization(property);
    
    return (areaFulfillment * 0.5) + 
           (structureEfficiency * 0.3) + 
           (floorUtilization * 0.2);
}
```

### 4.2 평수 충족도 계산식

```javascript
function calculateAreaFulfillment(actualArea, userPreference) {
    const { minArea, idealArea, maxArea } = userPreference;
    
    // 사용자 조건별 점수 계산
    if (actualArea >= idealArea) {
        if (actualArea <= maxArea) {
            return 100; // 이상적 범위
        } else {
            // 초과시 점진적 감점
            const excessRatio = (actualArea - maxArea) / maxArea;
            return Math.max(80, 100 - (excessRatio * 40));
        }
    } else if (actualArea >= minArea) {
        // 최소~이상 구간: 선형 증가
        const fulfillmentRatio = (actualArea - minArea) / (idealArea - minArea);
        return 60 + (fulfillmentRatio * 40);
    } else {
        // 최소 미달: 급격한 감점
        const shortfallRatio = (minArea - actualArea) / minArea;
        return Math.max(0, 60 - (shortfallRatio * 60));
    }
}
```

### 4.3 구조 효율성 계산식

```javascript
function calculateStructureEfficiency(property) {
    const { rooms, bathrooms, area, structure } = property;
    
    // 1. 방수 대비 면적 효율성 (40% 가중치)
    const areaPerRoom = area / rooms;
    let roomEfficiency;
    if (areaPerRoom >= 8 && areaPerRoom <= 12) roomEfficiency = 100; // 최적
    else if (areaPerRoom >= 6 && areaPerRoom <= 15) roomEfficiency = 80;
    else roomEfficiency = 60;
    
    // 2. 구조별 활용도 보정 (40% 가중치)
    const STRUCTURE_BONUS = {
        '복도형': 70,    // 복도 공간 손실
        '계단형': 85,    // 중간 효율
        '판상형': 95,    // 높은 효율
        '타워형': 90,    // 양호한 효율
        '혼합형': 75     // 구조 복잡
    };
    const structureScore = STRUCTURE_BONUS[structure] || 70;
    
    // 3. 화장실 배치 효율성 (20% 가중치)
    const bathroomRatio = bathrooms / rooms;
    let bathroomScore;
    if (bathroomRatio >= 0.4 && bathroomRatio <= 0.6) bathroomScore = 100;
    else if (bathroomRatio >= 0.3 && bathroomRatio <= 0.8) bathroomScore = 80;
    else bathroomScore = 60;
    
    return (roomEfficiency * 0.4) + (structureScore * 0.4) + (bathroomScore * 0.2);
}
```

### 4.4 층고 활용도 계산식

```javascript
function calculateFloorUtilization(property) {
    const { floor, totalFloors, direction, buildingType } = property;
    
    // 1. 층수별 점수 (50% 가중치)
    let floorScore;
    const midFloor = Math.floor(totalFloors / 2);
    
    if (floor >= 3 && floor <= midFloor + 2) {
        floorScore = 100; // 최적 층수 (3층 ~ 중간층+2)
    } else if (floor === 1 || floor === 2) {
        floorScore = 70; // 저층 (보안/소음 우려)
    } else if (floor > midFloor + 2) {
        // 고층: 점진적 감점
        const highFloorPenalty = (floor - midFloor - 2) * 5;
        floorScore = Math.max(60, 100 - highFloorPenalty);
    } else {
        floorScore = 80; // 기타
    }
    
    // 2. 채광 방향 보정 (30% 가중치)
    const DIRECTION_BONUS = {
        '남향': 100,
        '남동향': 95,
        '남서향': 90,
        '동향': 80,
        '서향': 75,
        '북동향': 70,
        '북서향': 65,
        '북향': 60
    };
    const directionScore = DIRECTION_BONUS[direction] || 70;
    
    // 3. 건물유형별 보정 (20% 가중치)
    const BUILDING_BONUS = {
        '아파트': 100,
        '오피스텔': 85,
        '빌라': 80,
        '다세대': 75,
        '연립': 70
    };
    const buildingScore = BUILDING_BONUS[buildingType] || 70;
    
    return (floorScore * 0.5) + (directionScore * 0.3) + (buildingScore * 0.2);
}
```

---

## 5. 2단계 확장 검색 조건 계산식

### 5.1 확장 임계값 결정 공식

```javascript
/**
 * 매물 부족 판정 및 확장 범위 결정
 */

function determineExpansionStrategy(foundProperties, userCondition) {
    const MINIMUM_RESULTS = 3; // 최소 추천 개수
    
    if (foundProperties.length >= MINIMUM_RESULTS) {
        return { needsExpansion: false };
    }
    
    // 우선순위별 확장 전략 결정
    const expansionLevels = calculateExpansionLevels(userCondition);
    return {
        needsExpansion: true,
        strategy: expansionLevels
    };
}
```

### 5.2 가격우선형 확장 계산식

```javascript
function calculatePriceExpansion(userCondition, currentResults) {
    const expansion = {
        level1: null, // 예산 확장
        level2: null, // 안전 기준 완화
        level3: null  // 평수 기준 완화
    };
    
    // Level 1: 예산 확장 (우선순위 1위)
    expansion.level1 = {
        budgetIncrease: calculateBudgetIncrease(userCondition),
        expectedResults: estimateResultIncrease('budget', expansion.level1.budgetIncrease)
    };
    
    // Level 2: 안전 기준 완화 (우선순위 2위)
    if (expansion.level1.expectedResults < 3) {
        expansion.level2 = {
            safetyThreshold: Math.max(30, userCondition.minSafetyScore - 15),
            expectedResults: estimateResultIncrease('safety', expansion.level2.safetyThreshold)
        };
    }
    
    // Level 3: 평수 기준 완화 (우선순위 3위)
    if ((expansion.level1.expectedResults + expansion.level2.expectedResults) < 3) {
        expansion.level3 = {
            areaReduction: Math.max(0.8, userCondition.minAreaRatio - 0.1),
            expectedResults: estimateResultIncrease('area', expansion.level3.areaReduction)
        };
    }
    
    return expansion;
}

function calculateBudgetIncrease(userCondition) {
    const currentBudget = userCondition.maxBudget;
    const districtMarketData = getDistrictMarketData(userCondition.district);
    
    // 해당 지역 시세를 고려한 현실적 증액 계산
    const marketAverage = districtMarketData.averagePrice;
    const budgetRatio = currentBudget / marketAverage;
    
    if (budgetRatio < 0.8) {
        return currentBudget * 0.15; // 시세보다 낮으면 15% 증액
    } else if (budgetRatio < 1.0) {
        return currentBudget * 0.10; // 시세 근처면 10% 증액
    } else {
        return currentBudget * 0.05; // 시세보다 높으면 5% 증액
    }
}
```

### 5.3 안전우선형 확장 계산식

```javascript
function calculateSafetyExpansion(userCondition, currentResults) {
    const expansion = {
        level1: null, // 예산 확장 (안전 기준은 절대 유지)
        level2: null, // 평수 타협
        level3: null  // 지역 확장
    };
    
    // Level 1: 예산 확장 (안전 점수는 절대 유지)
    expansion.level1 = {
        budgetIncrease: userCondition.maxBudget * 0.20, // 안전위해 20% 증액 허용
        maintainedSafety: userCondition.minSafetyScore,  // 안전 점수 절대 유지
        expectedResults: estimateResultIncrease('budget_safety', expansion.level1)
    };
    
    // Level 2: 평수 타협
    if (expansion.level1.expectedResults < 3) {
        expansion.level2 = {
            areaReduction: Math.max(0.85, userCondition.minAreaRatio - 0.1),
            maintainedSafety: userCondition.minSafetyScore,
            expectedResults: estimateResultIncrease('area_safety', expansion.level2)
        };
    }
    
    // Level 3: 인접 지역 확장 (안전 점수 유지)
    if ((expansion.level1.expectedResults + expansion.level2.expectedResults) < 3) {
        const adjacentDistricts = getAdjacentDistrictsWithSafety(
            userCondition.district, 
            userCondition.minSafetyScore
        );
        
        expansion.level3 = {
            expandedDistricts: adjacentDistricts,
            maintainedSafety: userCondition.minSafetyScore,
            expectedResults: estimateResultIncrease('location_safety', expansion.level3)
        };
    }
    
    return expansion;
}
```

### 5.4 평수우선형 확장 계산식

```javascript
function calculateAreaExpansion(userCondition, currentResults) {
    const expansion = {
        level1: null, // 예산 확장 (절대 최소평수는 유지)
        level2: null, // 위치 타협
        level3: null  // 구조/층수 타협
    };
    
    // Level 1: 예산 확장 (절대 최소평수 절대 유지)
    expansion.level1 = {
        budgetIncrease: userCondition.maxBudget * 0.12, // 넓은 공간 위해 12% 증액
        absoluteMinArea: userCondition.absoluteMinArea,  // 절대 최소평수 유지
        expectedResults: estimateResultIncrease('budget_area', expansion.level1)
    };
    
    // Level 2: 위치 타협
    if (expansion.level1.expectedResults < 3) {
        const expandedLocations = getExpandedLocations(
            userCondition.district,
            userCondition.absoluteMinArea
        );
        
        expansion.level2 = {
            expandedDistricts: expandedLocations,
            absoluteMinArea: userCondition.absoluteMinArea, // 여전히 유지
            expectedResults: estimateResultIncrease('location_area', expansion.level2)
        };
    }
    
    // Level 3: 구조/층수 조건 완화
    if ((expansion.level1.expectedResults + expansion.level2.expectedResults) < 3) {
        expansion.level3 = {
            relaxedStructure: true,        // 구조 조건 완화
            relaxedFloor: true,           // 층수 조건 완화
            absoluteMinArea: userCondition.absoluteMinArea, // 평수만큼은 유지
            expectedResults: estimateResultIncrease('structure_area', expansion.level3)
        };
    }
    
    return expansion;
}
```

---

## 6. 최종 종합 점수 계산식

### 6.1 우선순위별 최종 점수 산출

```javascript
function calculateFinalScore(property, userPriority, marketData, safetyData) {
    const priceScore = calculatePriceScore(property, marketData);
    const safetyScore = calculateSafetyScore(property.location, safetyData);
    const areaScore = calculateAreaScore(property, userPriority.areaPreference);
    
    // 우선순위별 가중치 적용
    switch(userPriority.type) {
        case 'PRICE_PRIORITY':
            return {
                finalScore: (priceScore * 0.60) + (safetyScore * 0.20) + (areaScore * 0.20),
                breakdown: {
                    price: { score: priceScore, weight: 0.60, contribution: priceScore * 0.60 },
                    safety: { score: safetyScore, weight: 0.20, contribution: safetyScore *