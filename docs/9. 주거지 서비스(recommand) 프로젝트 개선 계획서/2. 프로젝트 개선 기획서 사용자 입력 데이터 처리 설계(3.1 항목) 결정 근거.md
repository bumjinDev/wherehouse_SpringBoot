## 1. 비즈니스 로직 설계 시 발생한 논의점 정의

### 1.1 기존 설계의 한계점 재분석
기존 "3.1 사용자 입력 데이터 처리" 설계는 보편적 사용자 행동 패턴을 기반으로 우선순위별 입력 체계를 구성하였으나, 실제 서비스 운영 시 발생할 수 있는 **매물 부족 상황**에 대한 대응 전략이 부재했다.

### 1.2 새로운 요구사항 도출
서비스 기획 과정에서 다음과 같은 핵심 요구사항이 추가로 식별되었다:

1. **기본 조건 만족 매물이 충분할 때**: 우선순위별 세밀한 점수 계산으로 최적 추천
2. **기본 조건 만족 매물이 부족할 때**: 우선순위에 따른 차별적 양보 전략으로 실용적 대안 제공

---

## 2. 하이브리드 접근법 채택 배경

### 2.1 기존 검토한 접근법들의 한계

#### 2.1.1 개별 요소 인자화 방식
사용자별 비중치를 정형화하기 위해 모든 세부 요소를 개별 인자로 받는 방식이다. 이는 최대한의 개인화를 제공하나, 사용자 입력 복잡도가 급격히 증가하는 단점이 있다.

#### 2.1.2 패턴 분류 시스템
사용자를 사전 정의된 패턴으로 분류하여 각 패턴별 고정 가중치를 적용하는 방식이다. 논의된 패턴 분류 체계는 다음과 같다:

**패턴 0: 극단적 가격 민감형**
- 예산 유연성: 0%
- 안전 임계값: 30점
- 특성: 무조건 최저가 우선, 다른 조건 최소한만 고려

**패턴 1: 균형 가격 중시형**  
- 예산 유연성: 5%
- 안전 임계값: 50점
- 특성: 가격 우선이지만 기본적 안전성 확보

**패턴 2: 안전 최소선형**
- 예산 유연성: 10%
- 안전 임계값: 70점
- 특성: 가격 고려하되 안전 기준 엄격 적용

**패턴 3: 가성비 추구형**
- 예산 유연성: 15%
- 안전 임계값: 60점
- 특성: 가격 대비 종합적 가치 평가 중시

**패턴 4: 프리미엄 지향형**
- 예산 유연성: 20%
- 안전 임계값: 80점
- 특성: 품질 우선, 가격은 부차적 고려사항

#### 2.1.3 접근법 1: 보편적 패턴 기반 필터링 (기존 검토)
```
사용자별로 다른 필터링 조건 적용:

가격우선형 → "예산+5% 유연성, 안전 40점 이상, 평수 18평 이상"
안전우선형 → "안전 70점 이상, 예산+20% 허용, 평수 타협 가능"
평수우선형 → "절대 25평 이상, 예산+15% 허용, 위치 타협 가능"

→ 필터링 단계부터 다름
```

**장점:**
- 사용자 특성 반영도 높음
- 진짜 "맞춤형" 추천 가능
- 차별화 효과 크지만..**복잡함**

**단점:**
- 필터링 로직 복잡
- 사용자 입력 복잡
- 디버깅 어려움
- 매물 부족 시 해결책 부재

#### 2.1.4 접근법 2: 통일 조건 + 우선순위 정렬 (기존 검토)
```
모든 사용자에게 동일한 필터링:

1. 예산 2000-3000만원 범위 내 매물
2. 평수 20-30평 범위 내 매물  
3. 안전 점수 50점 이상 매물
4. 강남구 아파트 매물

→ 동일한 후보군에서 우선순위별로 다른 정렬만 적용
```

**장점:**
- **구현 단순함**
- 사용자 이해하기 쉬움
- 예측 가능한 결과
- **2주 내 확실한 완성**

**단점:**
- 개인화 수준 낮음
- 차별화 임팩트 상대적으로 작음
- 매물 부족 시 여전히 해결책 부재

#### 2.1.5 기존 접근법들의 공통 한계점

**수학적 모델링의 복잡성**
패턴 분류 시스템 구현을 위해서는 각 패턴을 정의하는 수학적 수식이 요구된다. 이러한 수식 도출을 위해서는 대규모 사용자 행동 데이터셋이 필수적이다.

**데이터 확보의 현실적 제약**
패턴 정의에 필요한 빅데이터 확보 방안이 명확하지 않으며, 외부 데이터 소스에 대한 접근성 또한 제한적이다.

**개발 일정 제약**
프로젝트 완료 기한(2주) 내에서 복잡한 패턴 분석 시스템 구축은 기술적으로 실현 불가능한 것으로 판단된다.

**매물 부족 상황 미고려**
기존 모든 접근법은 "충분한 매물이 있다"는 가정 하에 설계되어, 실제 서비스에서 빈번히 발생하는 매물 부족 상황에 대한 대응책이 부재했다.

### 2.2 하이브리드 접근법의 핵심 아이디어
**"2단계 폴백 시스템"** - 접근법 2를 기반으로 하되, 매물 부족 시에는 접근법 1의 패턴 기반 확장을 적용

```
1단계: 통일된 기본 조건으로 매물 확보 시도
       ↓
   매물 충분? → YES: 우선순위별 점수 계산으로 세밀한 랭킹
       ↓
      NO: 우선순위 패턴별 차별적 확장 검색
```

---

## 3. 2단계 폴백 시스템 설계 근거

### 3.1 1단계: 기본 조건 기반 매물 확보

#### 3.1.1 설계 철학
**"먼저 안전한 범위에서 최적해를 찾는다"**

```java
// 모든 우선순위 공통 기본 조건
public class BasicSearchCondition {
    private int minBudget;           // 사용자가 명시한 최소 예산
    private int maxBudget;           // 사용자가 명시한 최대 예산  
    private int minArea;             // 사용자가 명시한 최소 평수
    private int maxArea;             // 사용자가 명시한 최대 평수
    private String district;         // 사용자가 선택한 지역구
    private String propertyType;     // 사용자가 선택한 건물유형
    private String rentalType;       // 전세/월세 선택
}
```

#### 3.1.2 1단계 성공 시: 우선순위별 점수 계산
```java
// 동일한 후보군에서 우선순위별 다른 가중치 적용
private double calculatePriorityScore(Property property, PriorityType priority) {
    switch(priority) {
        case PRICE_PRIORITY:
            return property.getPriceScore() * 0.6 +     // 가격 60%
                   property.getSafetyScore() * 0.2 +    // 안전 20%  
                   property.getAreaScore() * 0.2;       // 평수 20%
                   
        case SAFETY_PRIORITY:
            return property.getSafetyScore() * 0.6 +    // 안전 60%
                   property.getPriceScore() * 0.2 +     // 가격 20%
                   property.getAreaScore() * 0.2;       // 평수 20%
                   
        case AREA_PRIORITY:
            return property.getAreaScore() * 0.6 +      // 평수 60%
                   property.getPriceScore() * 0.2 +     // 가격 20%
                   property.getSafetyScore() * 0.2;     // 안전 20%
    }
}
```

### 3.2 2단계: 우선순위별 차별적 확장 전략

#### 3.2.1 설계 철학
**"사용자의 우선순위에 따라 양보하는 순서와 범위를 달리한다"**

#### 3.2.2 가격우선형 확장 전략
```java
public class PricePriorityExpansion {
    private int budgetFlexibility;      // 예산 유연성 % (1순위 완화)
    private int safetyMinThreshold;     // 안전 최소 임계값 (2순위 완화) 
    private int areaMinThreshold;       // 평수 최소 임계값 (3순위 완화)
    
    // 확장 논리: "가격이 최우선이므로 예산을 먼저 늘려보고, 
    //           그래도 안 되면 안전이나 평수 기준을 낮춘다"
}
```

**확장 순서 근거**: 가격우선 사용자는 "조금 더 비싸더라도" 가성비 좋은 매물을 원하므로 예산 확장이 1순위

#### 3.2.3 안전우선형 확장 전략  
```java
public class SafetyPriorityExpansion {
    private List<String> safetyFactors;    // 안전 중요 요소 (절대 유지)
    private int minSafetyScore;            // 최소 안전 점수 (절대 유지)
    private int budgetExceedAllowed;       // 예산 초과 허용 % (1순위 완화)
    private boolean areaCompromiseOk;      // 평수 타협 여부 (2순위 완화)
    private boolean locationExpansionOk;   // 인접 지역 확장 (3순위 완화)
    
    // 확장 논리: "안전이 최우선이므로 안전 기준은 절대 낮추지 않고,
    //           예산이나 평수, 지역에서 양보한다"
}
```

**확장 순서 근거**: 안전우선 사용자는 "안전을 위해서라면 돈을 더 내거나 좁은 곳도 감수"하므로 안전 기준은 절대 유지

#### 3.2.4 평수우선형 확장 전략
```java
public class AreaPriorityExpansion {  
    private int absoluteMinArea;           // 절대 최소 평수 (절대 유지)
    private int idealArea;                 // 이상적 평수
    private String roomStructure;          // 방 구조 선호 (유지 선호)
    private int budgetExceedAllowed;       // 예산 초과 허용 % (1순위 완화)
    private boolean locationCompromiseOk;  // 위치 타협 여부 (2순위 완화)
    
    // 확장 논리: "넓은 공간이 최우선이므로 절대 최소 평수는 유지하고,
    //           예산이나 위치에서 양보한다"
}
```

**확장 순서 근거**: 평수우선 사용자는 "좁은 곳은 절대 안 되지만 멀거나 비싸도 괜찮다"는 심리

---

## 4. 기술적 구현 전략

### 4.1 현실적 복잡도 관리

#### 4.1.1 단계별 구현 접근
```java
public class TwoPhaseRecommendService {
    
    public List<PropertyRecommendation> getRecommendations(UserInputRequest request) {
        
        // 1단계: 간단하고 안전한 기본 검색
        List<Property> baseCandidates = findBasicMatches(request.getBasicCondition());
        
        if (baseCandidates.size() >= MIN_RECOMMENDATION_COUNT) {
            // 성공: 복잡한 계산 없이 우선순위별 점수만 적용
            return calculatePriorityScores(baseCandidates, request.getPriorityType());
        } else {
            // 실패: 이때만 복잡한 확장 로직 적용
            return expandSearchByPriority(request);
        }
    }
}
```

#### 4.1.2 복잡도 분산 전략
- **1단계는 단순하게**: 기본 WHERE 조건 + 우선순위별 가중치만
- **2단계만 복잡하게**: 확장 로직은 별도 모듈로 분리
- **점진적 구현**: 1단계 완성 후 2단계 추가

### 4.2 개발 일정 현실성 확보

#### 4.2.1 1주차: 1단계 시스템 완성
```
- 기본 조건 필터링 (3일)
- 우선순위별 점수 계산 (2일)  
- 기본 추천 결과 표시 (2일)
→ 7일 후 동작하는 기본 버전 완성
```

#### 4.2.2 2주차: 2단계 확장 시스템 추가
```
- 우선순위별 확장 조건 처리 (3일)
- 확장 검색 로직 구현 (3일)
- 확장 안내 메시지 시스템 (1일)
→ 14일 후 완전체 버전 완성
```

---

## 5. 비즈니스 가치 및 차별화 효과

### 5.1 사용자 경험 개선

#### 5.1.1 성공 시나리오 (1단계)
```
사용자: "예산 2500만원, 20평 이상, 강남구, 가격우선"
시스템: 기본 조건 만족 매물 12개 발견
결과: "2300만원 (가성비 9.2점) - 주변 대비 8% 저렴한 가격"
사용자 반응: "정확히 내가 원하던 결과!"
```

#### 5.1.2 실패 극복 시나리오 (2단계)  
```
사용자: "예산 2000만원, 25평 이상, 서초구, 가격우선, 예산유연성 10%"
시스템: 기본 조건 만족 매물 1개 발견 (부족!)
확장: 예산을 2200만원까지 늘려서 재검색
결과: "2150만원 (8개 매물 발견) - 예산 7.5% 확장으로 더 많은 선택지 확보"
사용자 반응: "조금 더 비싸지만 선택의 여지가 생겼네!"
```

### 5.2 기존 서비스 대비 차별화

#### 5.2.1 일반적인 부동산 서비스
```
매물 없음 → "조건을 완화해 주세요" (사용자에게 책임 전가)
```

#### 5.2.2 우리 서비스의 차별점
```
매물 없음 → "가격우선이시니 예산을 10% 늘려서 찾아드릴게요" (지능적 대안 제시)
```

---

## 6. 기술 아키텍처 결정 사항

### 6.1 하이브리드 접근법 채택 이유

#### 6.1.1 복잡도 vs 효과 최적화
- **필요할 때만 복잡한 로직 사용**: 매물 충분할 때는 단순, 부족할 때만 복잡
- **점진적 구현 가능**: 1단계 완성 후 2단계 추가로 위험 분산
- **디버깅 용이성**: 단계별 분리로 문제 지점 명확화

#### 6.1.2 사용자 만족도 vs 개발 효율성 균형
- **높은 사용자 만족**: 어떤 상황에서도 추천 결과 제공
- **현실적 개발 일정**: 2주 내 확실한 완성 가능
- **확장성 확보**: 추후 더 복잡한 패턴 추가 용이

### 6.2 최종 구현 방향

#### 6.2.1 핵심 설계 철학
**"단순함 위에 지능을 더한다"**
- 기본은 단순하고 안전하게
- 필요시에만 지능적 확장
- 사용자에게는 투명하게 안내

#### 6.2.2 성공 기준
- **기능적 성공**: 모든 상황에서 추천 결과 제공
- **기술적 성공**: 2주 내 안정적 구현 완료  
- **사용자 경험 성공**: 명확한 추천 근거와 확장 안내

---

## 7. 결론

### 7.1 최종 선택: 2단계 폴백 하이브리드 시스템

이번 설계는 기존의 "패턴 분석 vs 단순 우선순위" 이분법을 넘어, **"상황에 따른 적응적 복잡도"** 접근법을 채택했다.

- **매물 충분 시**: 단순하고 빠른 우선순위 점수 계산
- **매물 부족 시**: 지능적이고 차별화된 확장 전략

### 7.2 기대 효과

#### 7.2.1 단기 효과 (2주 내)
- 안정적으로 동작하는 추천 시스템 완성
- 우선순위별 차별화된 추천 결과 제공
- 매물 부족 상황의 우아한 해결

#### 7.2.2 장기 효과 (서비스 운영 후)
- 사용자별 추천 만족도 데이터 수집 가능
- 확장 패턴별 성공률 분석을 통한 지속적 개선
- 더 복잡한 개인화 시스템으로의 자연스러운 진화

**이 설계로 "현실적 완성도"와 "의미있는 차별화"를 동시에 달성할 수 있을 것이다.**