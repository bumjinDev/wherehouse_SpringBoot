# 가로등 데이터 분석용 Oracle DB 설계 및 JPA 구현

**프로젝트명:** 안전성 점수 계산 시스템 - 가로등 분석 데이터 처리  
**버전:** 1.0  
**작성일:** 2025.08.31  
**목적:** 기존 가로등 원본 데이터를 KakaoMap API로 주소 정보를 보강하여 피어슨 상관분석에 활용하기 위한 분석용 테이블 구축

---

## 프로젝트 개요

### 데이터 처리 목표
기존 가로등 원본 테이블의 관리번호, 위도, 경도 정보를 기반으로 KakaoMap API 역지오코딩을 통해 지역구, 지역동, 도로명주소, 지번주소 정보를 추가하여 분석 전용 테이블 `ANALYSIS_STREETLIGHT_STATISTICS`로 구축한다.

### 핵심 특징
- **좌표 → 주소 변환**: 기존 위도/경도 데이터를 KakaoMap API 역지오코딩으로 주소 정보 획득
- **주소 정보 보강**: 사용자 UI에서 필요한 지역구, 지역동, 도로명주소, 지번주소 추가
- **분석 전용 설계**: 제약조건 없이 순수 분석 목적의 테이블 구조
- **기존 인터페이스 재사용**: 원천 데이터 접근에 필요한 JPA Entity와 Repository는 기존 `AnalysisStaticData` 패키지에서 직접 import하여 사용

---

## 1. Oracle 테이블 DDL

**목적**: 분석 전용 가로등 테이블 생성 및 시퀀스 설정
**역할**: 피어슨 상관분석에 사용될 독립변수(가로등 밀도) 데이터 저장소 구축

```sql
-- 기존 테이블과 데이터를 완전히 삭제
DROP TABLE ANALYSIS_STREETLIGHT_STATISTICS CASCADE CONSTRAINTS PURGE;
DROP SEQUENCE SEQ_ANALYSIS_STREETLIGHT_STATISTICS;

-- 분석용 가로등 통계 테이블 생성
CREATE TABLE ANALYSIS_STREETLIGHT_STATISTICS (
    ID                      NUMBER,                     -- 제한 없음
    MANAGEMENT_NUMBER       VARCHAR2(4000),             -- 최대 크기
    DISTRICT_NAME           VARCHAR2(4000),             -- 자치구명
    DONG_NAME               VARCHAR2(4000),             -- 법정동명
    ROAD_ADDRESS            VARCHAR2(4000),             -- 도로명주소
    JIBUN_ADDRESS           VARCHAR2(4000),             -- 지번주소
    LATITUDE                NUMBER,                     -- 제한 없음
    LONGITUDE               NUMBER                      -- 제한 없음
);

-- 시퀀스 생성
CREATE SEQUENCE SEQ_ANALYSIS_STREETLIGHT_STATISTICS 
    START WITH 1 
    INCREMENT BY 1 
    NOCACHE
    NOCYCLE;

-- 확인
DESC ANALYSIS_STREETLIGHT_STATISTICS;
SELECT COUNT(*) FROM ANALYSIS_STREETLIGHT_STATISTICS;
```

## 2. JPA Entity

**목적**: 분석용 가로등 테이블과 Java 객체 간 ORM 매핑
**역할**: 데이터베이스 CRUD 작업을 위한 엔티티 클래스 정의

```java
package com.WhereHouse.AnalysisData.streetlight.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;

@Entity
@Table(name = "ANALYSIS_STREETLIGHT_STATISTICS")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AnalysisStreetlightStatistics {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "analysis_streetlight_seq")
    @SequenceGenerator(name = "analysis_streetlight_seq", sequenceName = "SEQ_ANALYSIS_STREETLIGHT_STATISTICS", allocationSize = 1)
    @Column(name = "ID")
    private Long id;

    @Column(name = "MANAGEMENT_NUMBER")
    private String managementNumber;

    @Column(name = "DISTRICT_NAME")
    private String districtName;

    @Column(name = "DONG_NAME") 
    private String dongName;

    @Column(name = "ROAD_ADDRESS")
    private String roadAddress;

    @Column(name = "JIBUN_ADDRESS")
    private String jibunAddress;

    @Column(name = "LATITUDE")
    private Double latitude;

    @Column(name = "LONGITUDE")
    private Double longitude;
}
```

## 3. Repository

**목적**: 분석용 가로등 데이터에 대한 데이터 접근 계층 구현
**역할**: JPA 기반 CRUD 연산 및 맞춤형 쿼리 메서드 제공 (구별 가로등 개수 조회, 데이터 검증용)

```java
package com.WhereHouse.AnalysisData.streetlight.repository;

import com.WhereHouse.AnalysisData.streetlight.entity.AnalysisStreetlightStatistics;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface AnalysisStreetlightRepository extends JpaRepository<AnalysisStreetlightStatistics, Long> {
    
    // 기본 CRUD는 JpaRepository가 제공
    
    // 데이터 검증용 커스텀 쿼리
    @Query("SELECT COUNT(a) FROM AnalysisStreetlightStatistics a")
    long countAnalysisData();
    
    // 구별 가로등 개수 조회 (피어슨 상관분석용)
    @Query("SELECT a.districtName, COUNT(a) FROM AnalysisStreetlightStatistics a GROUP BY a.districtName ORDER BY COUNT(a) DESC")
    List<Object[]> findStreetlightCountByDistrict();
    
    // 특정 구의 가로등 목록 조회
    List<AnalysisStreetlightStatistics> findByDistrictName(String districtName);
    
    // 관리번호로 중복 확인
    boolean existsByManagementNumber(String managementNumber);
}
```

## 4. 가로등 데이터 분석용 처리 Component

**목적**: 원본 가로등 데이터를 KakaoMap API로 주소 정보를 보강하여 분석용 테이블로 변환하는 비즈니스 로직 처리
**역할**: 
- 기존 가로등 원본 테이블에서 관리번호, 위도, 경도 조회
- KakaoMap API 역지오코딩으로 지역구, 지역동, 도로명주소, 지번주소 획득
- API 호출 제한 대응을 위한 Sleep 처리 및 예외 처리

```java
package com.WhereHouse.AnalysisData.streetlight.processor;

import com.WhereHouse.AnalysisData.streetlight.entity.AnalysisStreetlightStatistics;
import com.WhereHouse.AnalysisData.streetlight.repository.AnalysisStreetlightRepository;
// 원본 데이터 접근을 위한 기존 패키지 import
import com.WhereHouse.AnalysisStaticData.StreetLightRaw.Entity.StreetlightRawData;
import com.WhereHouse.AnalysisStaticData.StreetLightRaw.Repository.StreetlightRawDataRepository;
// KakaoMap API 클라이언트 import
import com.WhereHouse.AnalysisData.streetlight.client.StreetLightKakaoAddressApiClient;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.List;

/**
 * 가로등 데이터 분석용 테이블 생성 처리 컴포넌트
 * 
 * 기존 가로등 원본 테이블에서 데이터를 조회하여
 * KakaoMap API로 주소 정보를 보강한 후 
 * 분석 전용 ANALYSIS_STREETLIGHT_STATISTICS 테이블로 저장하는 작업을 수행한다.
 * 
 * 주요 기능:
 * - 원본 가로등 데이터 조회 및 검증
 * - KakaoMap API 역지오코딩을 통한 주소 정보 획득
 * - 분석용 테이블 데이터 품질 검증
 * - 구별 가로등 개수 통계 로깅
 * 
 * @author Safety Analysis System
 * @since 1.0
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class StreetlightDataProcessor {

    // 원본 가로등 테이블 접근을 위한 Repository
    private final StreetlightRawDataRepository originalStreetlightRepository;
    
    // 분석용 가로등 테이블 접근을 위한 Repository  
    private final AnalysisStreetlightRepository analysisStreetlightRepository;
    
    // KakaoMap API 클라이언트
    private final StreetLightKakaoAddressApiClient kakaoAddressApiClient;

    /**
     * 가로등 데이터 분석용 테이블 생성 메인 프로세스
     * 
     * 작업 순서:
     * 1. 기존 분석용 데이터 존재 여부 확인
     * 2. 원본 가로등 데이터 조회 및 검증
     * 3. KakaoMap API 역지오코딩으로 주소 정보 획득
     * 4. 데이터 변환 및 분석용 테이블 저장
     * 5. 데이터 품질 검증 및 결과 로깅
     */
    @Transactional
    public void processAnalysisStreetlightData() {
        log.info("=== 가로등 데이터 분석용 테이블 생성 작업 시작 ===");
        
        // Step 1: 기존 분석용 데이터 중복 처리 방지를 위한 존재 여부 확인
        long existingAnalysisDataCount = analysisStreetlightRepository.count();
        if (existingAnalysisDataCount > 0) {
            log.info("분석용 가로등 데이터가 이미 존재합니다 (총 {} 개). 작업을 스킵합니다.", existingAnalysisDataCount);
            return;
        }

        // Step 2: 원본 가로등 데이터 조회 및 검증
        List<StreetlightRawData> originalStreetlightDataList = originalStreetlightRepository.findAll();
        if (originalStreetlightDataList.isEmpty()) {
            log.warn("원본 가로등 데이터가 존재하지 않습니다. 먼저 StreetlightRawDataLoader를 통해 CSV 데이터를 로드해주세요.");
            return;
        }
        
        log.info("원본 가로등 데이터 {} 개 발견", originalStreetlightDataList.size());

        // Step 3: 데이터 변환 및 저장 작업 수행
        int successfulConversionCount = 0;  // 성공적으로 변환된 데이터 개수
        int failedConversionCount = 0;      // 변환 실패한 데이터 개수
        int apiCallCount = 0;               // API 호출 횟수

        for (StreetlightRawData originalStreetlightData : originalStreetlightDataList) {
            try {
                // 진행률 출력 (100개마다)
                if ((successfulConversionCount + failedConversionCount) % 100 == 0) {
                    double progress = ((double)(successfulConversionCount + failedConversionCount) / originalStreetlightDataList.size()) * 100;
                    log.info("진행률: {:.1f}% ({}/{})", progress, 
                        successfulConversionCount + failedConversionCount, originalStreetlightDataList.size());
                }
                
                // 원본 데이터를 분석용 엔티티로 변환 (KakaoMap API 호출 포함)
                AnalysisStreetlightStatistics analysisTargetStreetlightData = convertToAnalysisEntity(originalStreetlightData);
                apiCallCount++;
                
                // 분석용 테이블에 데이터 저장
                analysisStreetlightRepository.save(analysisTargetStreetlightData);
                successfulConversionCount++;
                
                log.debug("분석용 데이터 생성 완료: {} (구: {}, 동: {})", 
                    originalStreetlightData.getManagementNumber(), 
                    analysisTargetStreetlightData.getDistrictName(),
                    analysisTargetStreetlightData.getDongName());

                // API 호출 제한 대응 (100ms 대기)
                Thread.sleep(100);

            } catch (Exception dataConversionException) {
                log.error("분석용 데이터 생성 실패 - 관리번호: {}, 오류: {}", 
                    originalStreetlightData.getManagementNumber(), dataConversionException.getMessage());
                failedConversionCount++;
            }
        }

        // Step 4: 변환 작업 결과 로깅
        log.info("가로등 데이터 분석용 테이블 생성 작업 완료 - 성공: {} 개, 실패: {} 개, API 호출: {} 회", 
            successfulConversionCount, failedConversionCount, apiCallCount);
        
        // Step 5: 최종 데이터 검증 및 품질 확인
        performFinalDataValidation();
        
        log.info("=== 가로등 데이터 분석용 테이블 생성 작업 종료 ===");
    }
    
    /**
     * 원본 가로등 데이터를 KakaoMap API로 주소 정보를 보강하여 분석용 엔티티로 변환
     * 
     * @param originalStreetlightData 원본 가로등 데이터 엔티티
     * @return 주소 정보가 보강된 분석용 가로등 엔티티
     * @throws Exception KakaoMap API 호출 실패 시
     */
    private AnalysisStreetlightStatistics convertToAnalysisEntity(StreetlightRawData originalStreetlightData) throws Exception {
        
        // 기본 정보 설정
        String managementNumber = originalStreetlightData.getManagementNumber();
        Double latitude = originalStreetlightData.getLatitude();
        Double longitude = originalStreetlightData.getLongitude();
        
        // 주소 정보 초기화
        String districtName = "주소정보없음";
        String dongName = "주소정보없음";
        String roadAddress = "주소정보없음";
        String jibunAddress = "주소정보없음";
        
        // KakaoMap API 역지오코딩 호출하여 주소 정보 획득
        try {
            if (latitude != null && longitude != null && 
                latitude != 0 && longitude != 0) {
                
                // 좌표를 문자열로 변환
                String latitudeStr = latitude.toString();
                String longitudeStr = longitude.toString();
                
                // KakaoMap API 호출
                StreetLightKakaoAddressApiClient.CoordinateToAddressResponse response = 
                    kakaoAddressApiClient.coordinateToAddress(longitudeStr, latitudeStr);
                
                if (response.getDocuments() != null && !response.getDocuments().isEmpty()) {
                    StreetLightKakaoAddressApiClient.CoordinateToAddressResponse.Document document = response.getDocuments().get(0);
                    
                    // 도로명 주소 정보 추출
                    if (document.getRoadAddress() != null) {
                        StreetLightKakaoAddressApiClient.CoordinateToAddressResponse.RoadAddress roadAddr = document.getRoadAddress();
                        districtName = roadAddr.getRegion2DepthName(); // 구
                        dongName = roadAddr.getRegion3DepthName();     // 동
                        roadAddress = roadAddr.getAddressName();       // 전체 도로명 주소
                    }
                    
                    // 지번 주소 정보 추출 (도로명 주소가 없을 경우 대안)
                    if (document.getAddress() != null) {
                        StreetLightKakaoAddressApiClient.CoordinateToAddressResponse.Address addr = document.getAddress();
                        if ("주소정보없음".equals(districtName)) {
                            districtName = addr.getRegion2DepthName(); // 구
                            dongName = addr.getRegion3DepthName();     // 동
                        }
                        jibunAddress = addr.getAddressName();         // 전체 지번 주소
                    }
                }
            }
        } catch (Exception apiException) {
            log.warn("KakaoMap API 호출 실패 - 관리번호: {}, 좌표: ({}, {}), 오류: {}", 
                managementNumber, latitude, longitude, apiException.getMessage());
            // API 호출이 실패해도 기본 정보는 저장하도록 처리
        }
        
        return AnalysisStreetlightStatistics.builder()
            .managementNumber(managementNumber)
            .districtName(districtName)
            .dongName(dongName)
            .roadAddress(roadAddress)
            .jibunAddress(jibunAddress)
            .latitude(latitude)
            .longitude(longitude)
            .build();
    }
    
    /**
     * 분석용 데이터의 최종 검증 및 품질 확인
     * 
     * 작업 내용:
     * - 전체 데이터 개수 확인
     * - 구별 가로등 개수 상위 5개 로깅
     * - 데이터 검증 과정에서 발생하는 오류 처리
     */
    private void performFinalDataValidation() {
        try {
            // 최종 저장된 분석용 데이터 개수 확인
            long finalAnalysisDataCount = analysisStreetlightRepository.count();
            log.info("최종 분석용 가로등 데이터 저장 완료: {} 개", finalAnalysisDataCount);
            
            // 구별 가로등 개수 조회 및 로깅 (피어슨 상관분석 검증용)
            List<Object[]> districtStreetlightCountList = analysisStreetlightRepository.findStreetlightCountByDistrict();
            log.info("서울시 구별 가로등 개수 순위 (상위 5개구):");
            
            districtStreetlightCountList.stream()
                .limit(5)
                .forEach(rankingRow -> {
                    String districtName = (String) rankingRow[0];    // 구 이름
                    Long streetlightCount = (Long) rankingRow[1];    // 가로등 개수
                    log.info("  {} : {} 개", districtName, streetlightCount);
                });
                
        } catch (Exception dataValidationException) {
            log.error("분석용 데이터 검증 과정에서 오류가 발생했습니다: {}", 
                dataValidationException.getMessage(), dataValidationException);
        }
    }
}
```

## 5. KakaoAddressApiClient - Kakao Map API 역지오코딩 클라이언트

**목적**: 좌표(위도, 경도)를 주소 정보로 변환하는 Kakao Map API 호출 클라이언트
**역할**: 가로등 데이터의 위도/경도를 기반으로 지역구, 지역동, 도로명주소, 지번주소 정보 획득

```java
package com.WhereHouse.common.api;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.util.List;

/**
 * Kakao Map API 역지오코딩 클라이언트
 * 
 * 좌표(위도, 경도)를 입력받아 주소 정보를 반환하는 Kakao Map API 호출 클라이언트
 * 
 * 주요 기능:
 * - 좌표 → 주소 변환 (역지오코딩)
 * - 도로명 주소 및 지번 주소 반환
 * - 행정구역 정보 (구, 동) 반환
 * 
 * API 제한사항:
 * - 무료 플랜: 300,000회/일
 * - 호출 간격 제한: 없음 (하지만 100ms 대기 권장)
 * 
 * @author Safety Analysis System
 * @since 1.0
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class KakaoAddressApiClient {

    @Value("${app.kakao.api.key}")
    private String kakaoApiKey;

    private final RestTemplate restTemplate;

    // Kakao Map API 역지오코딩 엔드포인트
    private static final String KAKAO_COORD2ADDRESS_URL = "https://dapi.kakao.com/v2/local/geo/coord2address.json";

    /**
     * 좌표를 주소로 변환하는 역지오코딩 API 호출
     * 
     * @param longitude 경도 (x 좌표)
     * @param latitude 위도 (y 좌표)
     * @return 주소 정보가 포함된 응답 객체
     * @throws Exception API 호출 실패 시
     */
    public CoordinateToAddressResponse coordinateToAddress(String longitude, String latitude) throws Exception {
        
        // API 요청 URL 생성
        String requestUrl = UriComponentsBuilder.fromHttpUrl(KAKAO_COORD2ADDRESS_URL)
                .queryParam("x", longitude)  // 경도
                .queryParam("y", latitude)   // 위도
                .queryParam("input_coord", "WGS84")  // 입력 좌표계 (GPS 좌표계)
                .build()
                .toUriString();

        // HTTP 헤더 설정 (인증키 포함)
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "KakaoAK " + kakaoApiKey);
        headers.set("Content-Type", "application/json");

        HttpEntity<String> entity = new HttpEntity<>(headers);

        try {
            log.debug("Kakao API 호출: {}", requestUrl);
            
            // API 호출
            ResponseEntity<CoordinateToAddressResponse> response = restTemplate.exchange(
                    requestUrl,
                    HttpMethod.GET,
                    entity,
                    CoordinateToAddressResponse.class
            );

            CoordinateToAddressResponse responseBody = response.getBody();
            
            if (responseBody != null && responseBody.getDocuments() != null && !responseBody.getDocuments().isEmpty()) {
                log.debug("Kakao API 응답 성공: 좌표({}, {}) → 주소 {} 개 반환", 
                    longitude, latitude, responseBody.getDocuments().size());
                return responseBody;
            } else {
                log.warn("Kakao API 응답에 주소 정보가 없습니다: 좌표({}, {})", longitude, latitude);
                return new CoordinateToAddressResponse(); // 빈 응답 반환
            }

        } catch (Exception e) {
            log.error("Kakao API 호출 실패: 좌표({}, {}), 오류: {}", longitude, latitude, e.getMessage());
            throw new Exception("Kakao Map API 호출 실패: " + e.getMessage(), e);
        }
    }

    /**
     * Kakao Map API 좌표→주소 변환 응답 DTO
     */
    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class CoordinateToAddressResponse {
        
        @JsonProperty("documents")
        private List<Document> documents;

        @JsonProperty("meta")
        private Meta meta;

        /**
         * 주소 문서 정보
         */
        @Data
        @JsonIgnoreProperties(ignoreUnknown = true)
        public static class Document {
            
            @JsonProperty("road_address")
            private RoadAddress roadAddress;

            @JsonProperty("address")
            private Address address;
        }

        /**
         * 도로명 주소 정보
         */
        @Data
        @JsonIgnoreProperties(ignoreUnknown = true)
        public static class RoadAddress {
            
            @JsonProperty("address_name")
            private String addressName;

            @JsonProperty("region_1depth_name")
            private String region1DepthName;

            @JsonProperty("region_2depth_name")
            private String region2DepthName;

            @JsonProperty("region_3depth_name")
            private String region3DepthName;

            @JsonProperty("road_name")
            private String roadName;

            @JsonProperty("underground_yn")
            private String undergroundYn;

            @JsonProperty("main_building_no")
            private String mainBuildingNo;

            @JsonProperty("sub_building_no")
            private String subBuildingNo;

            @JsonProperty("building_name")
            private String buildingName;

            @JsonProperty("zone_no")
            private String zoneNo;
        }

        /**
         * 지번 주소 정보
         */
        @Data
        @JsonIgnoreProperties(ignoreUnknown = true)
        public static class Address {
            
            @JsonProperty("address_name")
            private String addressName;

            @JsonProperty("region_1depth_name")
            private String region1DepthName;

            @JsonProperty("region_2depth_name")
            private String region2DepthName;

            @JsonProperty("region_3depth_name")
            private String region3DepthName;

            @JsonProperty("mountain_yn")
            private String mountainYn;

            @JsonProperty("main_address_no")
            private String mainAddressNo;

            @JsonProperty("sub_address_no")
            private String subAddressNo;

            @JsonProperty("zip_code")
            private String zipCode;
        }

        /**
         * 메타 정보
         */
        @Data
        @JsonIgnoreProperties(ignoreUnknown = true)
        public static class Meta {
            
            @JsonProperty("total_count")
            private Integer totalCount;
        }
    }
}
```

## 5. StreetLightKakaoAddressApiClient - Kakao Map API 역지오코딩 클라이언트

**목적**: 좌표(위도, 경도)를 주소 정보로 변환하는 Kakao Map API 호출 클라이언트
**역할**: 가로등 데이터의 위도/경도를 기반으로 지역구, 지역동, 도로명주소, 지번주소 정보 획득

```java
package com.WhereHouse.AnalysisData.streetlight.client;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.util.List;

/**
 * Kakao Map API 역지오코딩 클라이언트
 * 
 * 좌표(위도, 경도)를 입력받아 주소 정보를 반환하는 Kakao Map API 호출 클라이언트
 * 
 * 주요 기능:
 * - 좌표 → 주소 변환 (역지오코딩)
 * - 도로명 주소 및 지번 주소 반환
 * - 행정구역 정보 (구, 동) 반환
 * 
 * API 제한사항:
 * - 무료 플랜: 300,000회/일
 * - 호출 간격 제한: 없음 (하지만 100ms 대기 권장)
 * 
 * @author Safety Analysis System
 * @since 1.0
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class StreetLightKakaoAddressApiClient {

    @Value("${kakao.rest-api-key}")
    private String kakaoApiKey;

    private final RestTemplate restTemplate;

    // Kakao Map API 역지오코딩 엔드포인트
    private static final String KAKAO_COORD2ADDRESS_URL = "https://dapi.kakao.com/v2/local/geo/coord2address.json";

    /**
     * 좌표를 주소로 변환하는 역지오코딩 API 호출
     * 
     * @param longitude 경도 (x 좌표)
     * @param latitude 위도 (y 좌표)
     * @return 주소 정보가 포함된 응답 객체
     * @throws Exception API 호출 실패 시
     */
    public CoordinateToAddressResponse coordinateToAddress(String longitude, String latitude) throws Exception {
        
        // API 요청 URL 생성
        String requestUrl = UriComponentsBuilder.fromHttpUrl(KAKAO_COORD2ADDRESS_URL)
                .queryParam("x", longitude)  // 경도
                .queryParam("y", latitude)   // 위도
                .queryParam("input_coord", "WGS84")  // 입력 좌표계 (GPS 좌표계)
                .build()
                .toUriString();

        // HTTP 헤더 설정 (인증키 포함)
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "KakaoAK " + kakaoApiKey);
        headers.set("Content-Type", "application/json");

        HttpEntity<String> entity = new HttpEntity<>(headers);

        try {
            log.debug("Kakao API 호출: {}", requestUrl);
            
            // API 호출
            ResponseEntity<CoordinateToAddressResponse> response = restTemplate.exchange(
                    requestUrl,
                    HttpMethod.GET,
                    entity,
                    CoordinateToAddressResponse.class
            );

            CoordinateToAddressResponse responseBody = response.getBody();
            
            if (responseBody != null && responseBody.getDocuments() != null && !responseBody.getDocuments().isEmpty()) {
                log.debug("Kakao API 응답 성공: 좌표({}, {}) → 주소 {} 개 반환", 
                    longitude, latitude, responseBody.getDocuments().size());
                return responseBody;
            } else {
                log.warn("Kakao API 응답에 주소 정보가 없습니다: 좌표({}, {})", longitude, latitude);
                return new CoordinateToAddressResponse(); // 빈 응답 반환
            }

        } catch (Exception e) {
            log.error("Kakao API 호출 실패: 좌표({}, {}), 오류: {}", longitude, latitude, e.getMessage());
            throw new Exception("Kakao Map API 호출 실패: " + e.getMessage(), e);
        }
    }

    /**
     * Kakao Map API 좌표→주소 변환 응답 DTO
     */
    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class CoordinateToAddressResponse {
        
        @JsonProperty("documents")
        private List<Document> documents;

        @JsonProperty("meta")
        private Meta meta;

        /**
         * 주소 문서 정보
         */
        @Data
        @JsonIgnoreProperties(ignoreUnknown = true)
        public static class Document {
            
            @JsonProperty("road_address")
            private RoadAddress roadAddress;

            @JsonProperty("address")
            private Address address;
        }

        /**
         * 도로명 주소 정보
         */
        @Data
        @JsonIgnoreProperties(ignoreUnknown = true)
        public static class RoadAddress {
            
            @JsonProperty("address_name")
            private String addressName;

            @JsonProperty("region_1depth_name")
            private String region1DepthName;

            @JsonProperty("region_2depth_name")
            private String region2DepthName;

            @JsonProperty("region_3depth_name")
            private String region3DepthName;

            @JsonProperty("road_name")
            private String roadName;

            @JsonProperty("underground_yn")
            private String undergroundYn;

            @JsonProperty("main_building_no")
            private String mainBuildingNo;

            @JsonProperty("sub_building_no")
            private String subBuildingNo;

            @JsonProperty("building_name")
            private String buildingName;

            @JsonProperty("zone_no")
            private String zoneNo;
        }

        /**
         * 지번 주소 정보
         */
        @Data
        @JsonIgnoreProperties(ignoreUnknown = true)
        public static class Address {
            
            @JsonProperty("address_name")
            private String addressName;

            @JsonProperty("region_1depth_name")
            private String region1DepthName;

            @JsonProperty("region_2depth_name")
            private String region2DepthName;

            @JsonProperty("region_3depth_name")
            private String region3DepthName;

            @JsonProperty("mountain_yn")
            private String mountainYn;

            @JsonProperty("main_address_no")
            private String mainAddressNo;

            @JsonProperty("sub_address_no")
            private String subAddressNo;

            @JsonProperty("zip_code")
            private String zipCode;
        }

        /**
         * 메타 정보
         */
        @Data
        @JsonIgnoreProperties(ignoreUnknown = true)
        public static class Meta {
            
            @JsonProperty("total_count")
            private Integer totalCount;
        }
    }
}
```

## 6. RestTemplate 설정

**목적**: Kakao Map API 호출을 위한 HTTP 클라이언트 Bean 설정
**역할**: StreetLightKakaoAddressApiClient에서 사용할 RestTemplate Bean 제공

```java
package com.WhereHouse.AnalysisData.streetlight.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class RestTemplateConfig {
    
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

## 7. Main 처리 클래스 연동

**목적**: 전체 분석용 데이터 처리 작업에 가로등 프로세서 추가
**역할**: 기존 Main 클래스에 가로등 데이터 처리 프로세서 연동

```java
package com.WhereHouse.AnalysisData.main;

import com.WhereHouse.AnalysisData.crime.processor.CrimeDataProcessor;
import com.WhereHouse.AnalysisData.streetlight.processor.StreetlightDataProcessor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class AnalysisDataProcessor implements CommandLineRunner {

    private final CrimeDataProcessor crimeDataProcessor;
    private final StreetlightDataProcessor streetlightDataProcessor;
    // 향후 17개 ERD별 프로세서 추가 예정

    @Override
    public void run(String... args) throws Exception {
        log.info("=== 안전성 분석용 데이터 처리 시작 ===");
        
        try {
            // 1. 범죄 데이터 처리
            log.info("1. 범죄 데이터 분석용 테이블 생성 시작");
            crimeDataProcessor.processAnalysisCrimeData();
            
            // 2. 가로등 데이터 처리
            log.info("2. 가로등 데이터 분석용 테이블 생성 시작");
            streetlightDataProcessor.processAnalysisStreetlightData();
            
            // 향후 추가될 17개 ERD별 데이터 처리
            // 3. CCTV 데이터 처리
            // log.info("3. CCTV 데이터 분석용 테이블 생성 시작");
            // cctvDataProcessor.processAnalysisCctvData();
            
            // ... 추가 프로세서들
            
        } catch (Exception e) {
            log.error("안전성 분석용 데이터 처리 중 오류 발생", e);
            throw e;
        }
        
        log.info("=== 안전성 분석용 데이터 처리 완료 ===");
    }
}
```

## 실행 방법 및 검증

### 1. 데이터베이스 설정
1. Oracle DB에 DDL 스크립트 실행
2. 테이블 생성 및 시퀀스 확인

### 2. 추가 설정 필요 사항

#### 2.1. application.yml 설정 추가
```yaml
kakao:
  rest-api-key: YOUR_KAKAO_API_KEY_HERE
```

#### 2.2. KakaoMap API 설정 확인
- API 키 유효성 확인
- 일일 호출 한도 확인 (무료: 300,000회/일)

### 3. 애플리케이션 실행
```bash
./gradlew bootRun
```

### 4. 실행 결과 검증
```sql
-- 데이터 개수 확인
SELECT COUNT(*) FROM ANALYSIS_STREETLIGHT_STATISTICS;

-- 구별 가로등 개수 확인
SELECT DISTRICT_NAME, COUNT(*) as STREETLIGHT_COUNT 
FROM ANALYSIS_STREETLIGHT_STATISTICS 
GROUP BY DISTRICT_NAME 
ORDER BY COUNT(*) DESC;

-- 주소 정보 품질 확인
SELECT 
    COUNT(*) as TOTAL_COUNT,
    SUM(CASE WHEN DISTRICT_NAME != '주소정보없음' THEN 1 ELSE 0 END) as VALID_ADDRESS_COUNT,
    ROUND(SUM(CASE WHEN DISTRICT_NAME != '주소정보없음' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as VALID_RATIO
FROM ANALYSIS_STREETLIGHT_STATISTICS;
```

## 예상 처리 결과

### 로그 출력 예시
```
=== 안전성 분석용 데이터 처리 시작 ===
2. 가로등 데이터 분석용 테이블 생성 시작
원본 가로등 데이터 133526 개 발견
진행률: 7.5% (100/133526)
진행률: 15.0% (200/133526)
...
가로등 데이터 분석용 테이블 생성 작업 완료 - 성공: 133520 개, 실패: 6 개, API 호출: 133526 회
서울시 구별 가로등 개수 순위 (상위 5개구):
  강남구 : 8014 개
  송파구 : 7892 개
  강서구 : 7654 개
  영등포구 : 6789 개
  종로구 : 6234 개
=== 안전성 분석용 데이터 처리 완료 ===
```

### 데이터 품질 예상 결과
- 전체 가로등 데이터: 약 133,526개
- 주소 변환 성공률: 95% 이상 (API 호출 제한이나 네트워크 오류 제외)
- 구별 데이터 분포: 25개 자치구 전체 커버

이 시스템은 향후 피어슨 상관분석에서 독립변수로 활용될 구별 가로등 밀도 계산의 기초 데이터를 제공합니다.