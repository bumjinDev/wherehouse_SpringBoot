# 서울시 인구밀도 통계 데이터 Oracle DB 설계 및 JPA 구현

## 1. Oracle 테이블 DDL

### 1.1 기본 테이블 구조
```sql
-- 기존 테이블 및 시퀀스 삭제
DROP TABLE SEOUL_POPULATION_DENSITY CASCADE CONSTRAINTS;
DROP SEQUENCE SEQ_SEOUL_POPULATION_DENSITY;

-- 서울시 인구밀도 통계 테이블 생성
CREATE TABLE SEOUL_POPULATION_DENSITY (
    ID                          NUMBER(19) PRIMARY KEY,
    DISTRICT_LEVEL1             VARCHAR2(50),
    DISTRICT_LEVEL2             VARCHAR2(50),
    DISTRICT_LEVEL3             VARCHAR2(50),
    YEAR_2024_1                 NUMBER(4),
    YEAR_2024_2                 NUMBER(4),
    YEAR_2024_3                 NUMBER(4),
    POPULATION_COUNT            NUMBER(12) DEFAULT 0,
    AREA_SIZE                   NUMBER(15,5) DEFAULT 0,
    POPULATION_DENSITY          NUMBER(15,5) DEFAULT 0,
    CREATED_AT                  TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT UK_SEOUL_DISTRICT UNIQUE (DISTRICT_LEVEL2)
);

-- 시퀀스 생성
CREATE SEQUENCE SEQ_SEOUL_POPULATION_DENSITY START WITH 1 INCREMENT BY 1;
```

### 1.2 필드 크기 설정 근거
- **DISTRICT_LEVEL1, DISTRICT_LEVEL2, DISTRICT_LEVEL3**: 50자로 설정 (구별명 대응)
- **POPULATION_COUNT**: NUMBER(12)로 설정하여 천만 단위까지 수용
- **AREA_SIZE**: NUMBER(15,5)로 설정하여 소수점 정밀도 보장
- **POPULATION_DENSITY**: NUMBER(15,5)로 설정하여 밀도 계산 정밀도 확보

## 2. application.yml 설정

```yaml
# CSV 파일 경로 설정
app:
  csv:
    population-density-path: classpath:data/seoul_population_density_2024.csv
```

## 3. JPA Entity

```java
package com.WhereHouse.APITest.Population.Entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "SEOUL_POPULATION_DENSITY")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SeoulPopulationDensity {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "population_seq")
    @SequenceGenerator(name = "population_seq", sequenceName = "SEQ_SEOUL_POPULATION_DENSITY", allocationSize = 1)
    @Column(name = "ID")
    private Long id;

    @Column(name = "DISTRICT_LEVEL1", length = 50)
    private String districtLevel1 = "데이터없음";

    @Column(name = "DISTRICT_LEVEL2", length = 50)
    private String districtLevel2 = "데이터없음";

    @Column(name = "DISTRICT_LEVEL3", length = 50)
    private String districtLevel3 = "데이터없음";

    @Column(name = "YEAR_2024_1")
    private Integer year20241 = 2024;

    @Column(name = "YEAR_2024_2")
    private Integer year20242 = 2024;

    @Column(name = "YEAR_2024_3")
    private Integer year20243 = 2024;

    @Column(name = "POPULATION_COUNT")
    private Long populationCount = 0L;

    @Column(name = "AREA_SIZE", precision = 15, scale = 5)
    private BigDecimal areaSize = BigDecimal.ZERO;

    @Column(name = "POPULATION_DENSITY", precision = 15, scale = 5)
    private BigDecimal populationDensity = BigDecimal.ZERO;

    @Column(name = "CREATED_AT")
    private LocalDateTime createdAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();

        // NULL 값들을 기본값으로 설정
        if (districtLevel1 == null) districtLevel1 = "데이터없음";
        if (districtLevel2 == null) districtLevel2 = "데이터없음";
        if (districtLevel3 == null) districtLevel3 = "데이터없음";
        if (year20241 == null) year20241 = 2024;
        if (year20242 == null) year20242 = 2024;
        if (year20243 == null) year20243 = 2024;
        if (populationCount == null) populationCount = 0L;
        if (areaSize == null) areaSize = BigDecimal.ZERO;
        if (populationDensity == null) populationDensity = BigDecimal.ZERO;
    }
}
```

## 4. Repository

```java
package com.WhereHouse.APITest.Population.Repository;

import com.WhereHouse.APITest.Population.Entity.SeoulPopulationDensity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface SeoulPopulationDensityRepository extends JpaRepository<SeoulPopulationDensity, Long> {
    
    Optional<SeoulPopulationDensity> findByDistrictLevel2(String districtName);
    
    @Query("SELECT s FROM SeoulPopulationDensity s WHERE s.districtLevel2 != '소계' ORDER BY s.populationDensity DESC")
    List<SeoulPopulationDensity> findAllOrderByPopulationDensityDesc();
    
    @Query("SELECT s FROM SeoulPopulationDensity s WHERE s.districtLevel2 LIKE %:keyword%")
    List<SeoulPopulationDensity> findByDistrictNameContaining(@Param("keyword") String keyword);
    
    boolean existsByDistrictLevel2(String districtName);
}
```

## 5. 배치 처리 CSV 로더

### 5.1 핵심 특징
- **텍스트 파싱**: 정규표현식을 사용한 구별 데이터 추출
- **트랜잭션 처리**: 전체 데이터를 단일 트랜잭션으로 처리
- **데이터 검증**: 중복 데이터 방지 및 파싱 결과 검증

```java
package com.WhereHouse.APITest.Population.Loader;

import com.WhereHouse.APITest.Population.Entity.SeoulPopulationDensity;
import com.WhereHouse.APITest.Population.Repository.SeoulPopulationDensityRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Component
@RequiredArgsConstructor
@Slf4j
public class PopulationDensityDataLoader implements CommandLineRunner {

    private final SeoulPopulationDensityRepository repository;

    private static final String DATA_TEXT = """
        동별(1) 동별(2) 동별(3) 2024 2024 2024 동별(1) 동별(2) 동별(3) 인구 (명) 면적 (㎢) 인구밀도 (명/㎢) 
        합계 소계 소계 9597372 605.21 15858 
        합계 종로구 소계 149608 23.91 6256 
        합계 중구 소계 131214 9.96 13174 
        합계 용산구 소계 217194 21.87 9932 
        합계 성동구 소계 281289 16.82 16723 
        합계 광진구 소계 348652 17.06 20433 
        합계 동대문구 소계 358603 14.22 25226 
        합계 중랑구 소계 385349 18.5 20832 
        합계 성북구 소계 435037 24.58 17700 
        합계 강북구 소계 289374 23.61 12258 
        합계 도봉구 소계 306032 20.65 14819 
        합계 노원구 소계 496552 35.44 14010 
        합계 은평구 소계 465350 29.71 15663 
        합계 서대문구 소계 318622 17.63 18073 
        합계 마포구 소계 372745 23.85 15626 
        합계 양천구 소계 434351 17.41 24953 
        합계 강서구 소계 562194 41.45 13563 
        합계 구로구 소계 411916 20.12 20472 
        합계 금천구 소계 239070 13.02 18364 
        합계 영등포구 소계 397173 24.55 16177 
        합계 동작구 소계 387352 16.35 23684 
        합계 관악구 소계 495620 29.57 16762 
        합계 서초구 소계 413076 46.97 8795 
        합계 강남구 소계 563215 39.5 14259 
        합계 송파구 소계 656310 33.88 19374 
        합계 강동구 소계 481474 24.59 19580
        """;

    @Override
    @Transactional
    public void run(String... args) {
        long existingCount = repository.count();
        if (existingCount > 0) {
            log.info("서울시 인구밀도 데이터 이미 존재 ({}개). 로딩 스킵", existingCount);
            return;
        }

        try {
            List<SeoulPopulationDensity> dataList = parseTextData();
            
            if (!dataList.isEmpty()) {
                List<SeoulPopulationDensity> savedList = repository.saveAll(dataList);
                log.info("서울시 인구밀도 데이터 로딩 완료 - 총 {} 건 저장", savedList.size());
            }
            
        } catch (Exception e) {
            log.error("서울시 인구밀도 데이터 로딩 실패: {}", e.getMessage(), e);
        }
    }

    private List<SeoulPopulationDensity> parseTextData() {
        List<SeoulPopulationDensity> dataList = new ArrayList<>();
        String[] lines = DATA_TEXT.trim().split("\\n");
        Pattern pattern = Pattern.compile("합계\\s+(\\S+)\\s+소계\\s+(\\d+)\\s+([\\d.]+)\\s+(\\d+)");
        
        for (String line : lines) {
            String trimmedLine = line.trim();
            if (trimmedLine.isEmpty() || trimmedLine.contains("동별") || trimmedLine.contains("인구")) {
                continue;
            }
            
            Matcher matcher = pattern.matcher(trimmedLine);
            if (matcher.find()) {
                try {
                    String districtName = matcher.group(1);
                    Long population = Long.parseLong(matcher.group(2));
                    BigDecimal area = new BigDecimal(matcher.group(3));
                    Long density = Long.parseLong(matcher.group(4));
                    
                    SeoulPopulationDensity data = SeoulPopulationDensity.builder()
                            .districtLevel1("합계")
                            .districtLevel2(districtName)
                            .districtLevel3("소계")
                            .year20241(2024)
                            .year20242(2024)
                            .year20243(2024)
                            .populationCount(population)
                            .areaSize(area)
                            .populationDensity(new BigDecimal(density))
                            .build();
                    
                    dataList.add(data);
                    
                } catch (NumberFormatException e) {
                    log.warn("숫자 변환 실패: {}", trimmedLine);
                }
            }
        }
        
        log.info("총 {}개의 데이터 파싱 완료", dataList.size());
        return dataList;
    }
}
```

## 6. 파일 위치

```
src/main/resources/data/seoul_population_density_2024.csv
```

## 7. 주요 특징 요약

### 7.1 데이터베이스 설계
- **확장 가능한 스키마**: 다단계 구별 정보 저장 구조
- **정밀도 보장**: BigDecimal을 사용한 면적/밀도 정확한 계산
- **제약조건**: UNIQUE 제약으로 중복 방지

### 7.2 JPA 구현
- **Builder 패턴**: 객체 생성의 유연성 제공
- **@PrePersist**: 자동 기본값 설정 및 타임스탬프 처리
- **정밀도 제어**: BigDecimal의 precision과 scale 명시적 설정

### 7.3 데이터 로딩
- **텍스트 파싱**: 정규표현식을 이용한 구조화되지 않은 데이터 처리
- **오류 복구**: 파싱 실패 시 적절한 로깅과 건너뛰기
- **실시간 모니터링**: 진행 상황 및 결과 실시간 확인

이 문서는 서울시 인구밀도 통계 데이터의 완전한 Oracle DB 설계부터 JPA 구현, 텍스트 데이터 로딩까지 전 과정을 다루며, 실제 운영 환경에서 발생할 수 있는 다양한 문제점들과 해결방안을 포함하고 있습니다.