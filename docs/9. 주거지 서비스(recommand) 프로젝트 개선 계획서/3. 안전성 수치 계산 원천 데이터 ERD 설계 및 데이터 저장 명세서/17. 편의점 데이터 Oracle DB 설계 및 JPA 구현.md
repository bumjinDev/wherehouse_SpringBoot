# 편의점 데이터 CSV 로더 Oracle DB 설계 및 JPA 구현

## 1. Oracle 테이블 DDL (현재 구현 기준)

```sql
-- 1단계: 기존 테이블 완전 삭제
DROP TABLE CONVENIENCE_STORE_DATA CASCADE CONSTRAINTS PURGE;
DROP SEQUENCE SEQ_CONVENIENCE_STORE_DATA;

-- 2단계: 편의점 데이터 테이블 생성 (현재 Entity 구조에 맞춰 수정)
CREATE TABLE CONVENIENCE_STORE_DATA (
    ID NUMBER PRIMARY KEY,                              -- PK (자동생성)
    OPEN_LOCAL_GOV_CODE VARCHAR2(50),                   -- 개방자치단체코드
    MANAGEMENT_NUMBER VARCHAR2(50),                     -- 관리번호
    LICENSE_DATE DATE,                                  -- 인허가일자
    LICENSE_CANCEL_DATE DATE,                           -- 인허가취소일자
    BUSINESS_STATUS_CODE VARCHAR2(50),                  -- 영업상태코드 (길이 증가)
    BUSINESS_STATUS_NAME VARCHAR2(50),                  -- 영업상태명
    DETAILED_STATUS_CODE VARCHAR2(50),                  -- 상세영업상태코드 (길이 증가)
    DETAILED_STATUS_NAME VARCHAR2(50),                  -- 상세영업상태명
    CLOSURE_DATE DATE,                                  -- 폐업일자
    SUSPENSION_START_DATE DATE,                         -- 휴업시작일자
    SUSPENSION_END_DATE DATE,                           -- 휴업종료일자
    REOPENING_DATE DATE,                                -- 재개업일자
    PHONE_NUMBER VARCHAR2(50),                          -- 전화번호 (길이 증가)
    LOCATION_AREA NUMBER(15,2),                         -- 소재지면적
    LOCATION_POSTAL_CODE VARCHAR2(50),                  -- 소재지우편번호 (길이 증가)
    LOT_ADDRESS VARCHAR2(500),                          -- 지번주소
    ROAD_ADDRESS VARCHAR2(500),                         -- 도로명주소
    ROAD_POSTAL_CODE VARCHAR2(50),                      -- 도로명우편번호 (길이 증가)
    BUSINESS_NAME VARCHAR2(200),                        -- 사업장명
    LAST_MODIFIED_DATE TIMESTAMP,                       -- 최종수정일자
    DATA_UPDATE_TYPE VARCHAR2(50),                      -- 데이터갱신구분 (길이 증가)
    DATA_UPDATE_TIME VARCHAR2(50),                      -- 데이터갱신일자 (길이 증가)
    BUSINESS_TYPE_NAME VARCHAR2(100),                   -- 업태구분명
    COORDINATE_X NUMBER(15,10),                         -- 좌표정보(X)
    COORDINATE_Y NUMBER(20,10),                         -- 좌표정보(Y) - precision 증가
    SALES_AREA NUMBER(20,2),                            -- 판매점영업면적 - precision 증가
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,     -- 데이터 로드 시각
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP      -- 데이터 수정 시각
);

-- 3단계: 시퀀스 생성
CREATE SEQUENCE SEQ_CONVENIENCE_STORE_DATA 
    START WITH 1 
    INCREMENT BY 1 
    NOCACHE
    NOCYCLE;

-- 4단계: 테이블 확인
DESC CONVENIENCE_STORE_DATA;
SELECT COUNT(*) FROM CONVENIENCE_STORE_DATA;
```

## 2. JPA Entity (현재 구현된 버전)

```java
package com.WhereHouse.AnalysisStaticData.ConvenienceStore.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "CONVENIENCE_STORE_DATA")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ConvenienceStoreData {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "convenience_seq")
    @SequenceGenerator(name = "convenience_seq", sequenceName = "SEQ_CONVENIENCE_STORE_DATA", allocationSize = 1)
    @Column(name = "ID")
    private Long id;

    @Column(name = "OPEN_LOCAL_GOV_CODE", length = 50)
    private String openLocalGovCode;                    // 개방자치단체코드

    @Column(name = "MANAGEMENT_NUMBER", length = 50)
    private String managementNumber;                    // 관리번호

    @Column(name = "LICENSE_DATE")
    private LocalDate licenseDate;                      // 인허가일자

    @Column(name = "LICENSE_CANCEL_DATE")
    private LocalDate licenseCancelDate;                // 인허가취소일자

    @Column(name = "BUSINESS_STATUS_CODE", length = 50)
    private String businessStatusCode;                  // 영업상태코드

    @Column(name = "BUSINESS_STATUS_NAME", length = 50)
    private String businessStatusName;                  // 영업상태명

    @Column(name = "DETAILED_STATUS_CODE", length = 50)
    private String detailedStatusCode;                  // 상세영업상태코드

    @Column(name = "DETAILED_STATUS_NAME", length = 50)
    private String detailedStatusName;                  // 상세영업상태명

    @Column(name = "CLOSURE_DATE")
    private LocalDate closureDate;                      // 폐업일자

    @Column(name = "SUSPENSION_START_DATE")
    private LocalDate suspensionStartDate;              // 휴업시작일자

    @Column(name = "SUSPENSION_END_DATE")
    private LocalDate suspensionEndDate;                // 휴업종료일자

    @Column(name = "REOPENING_DATE")
    private LocalDate reopeningDate;                    // 재개업일자

    @Column(name = "PHONE_NUMBER", length = 50)
    private String phoneNumber;                         // 전화번호

    @Column(name = "LOCATION_AREA", precision = 15, scale = 2)
    private BigDecimal locationArea;                    // 소재지면적

    @Column(name = "LOCATION_POSTAL_CODE", length = 50)
    private String locationPostalCode;                  // 소재지우편번호

    @Column(name = "LOT_ADDRESS", length = 500)
    private String lotAddress;                          // 지번주소

    @Column(name = "ROAD_ADDRESS", length = 500)
    private String roadAddress;                         // 도로명주소

    @Column(name = "ROAD_POSTAL_CODE", length = 50)
    private String roadPostalCode;                      // 도로명우편번호

    @Column(name = "BUSINESS_NAME", length = 200)
    private String businessName;                        // 사업장명

    @Column(name = "LAST_MODIFIED_DATE")
    private LocalDateTime lastModifiedDate;             // 최종수정일자

    @Column(name = "DATA_UPDATE_TYPE", length = 50)
    private String dataUpdateType;                      // 데이터갱신구분

    @Column(name = "DATA_UPDATE_TIME", length = 50)
    private String dataUpdateTime;                      // 데이터갱신일자

    @Column(name = "BUSINESS_TYPE_NAME", length = 100)
    private String businessTypeName;                    // 업태구분명

    @Column(name = "COORDINATE_X", precision = 15, scale = 10)
    private BigDecimal coordinateX;                     // 좌표정보(X)

    @Column(name = "COORDINATE_Y", precision = 20, scale = 10)
    private BigDecimal coordinateY;                     // 좌표정보(Y)

    @Column(name = "SALES_AREA", precision = 20, scale = 2)
    private BigDecimal salesArea;                       // 판매점영업면적

    @Column(name = "CREATED_AT")
    private LocalDateTime createdAt;                    // 데이터 로드 시각

    @Column(name = "UPDATED_AT")
    private LocalDateTime updatedAt;                    // 데이터 수정 시각

    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}
```

## 3. Repository (현재 구현된 버전)

```java
package com.WhereHouse.AnalysisStaticData.ConvenienceStore.reposiotry;

import com.WhereHouse.AnalysisStaticData.ConvenienceStore.entity.ConvenienceStoreData;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface ConvenienceStoreDataRepository extends JpaRepository<ConvenienceStoreData, Long> {

    // 관리번호로 조회
    Optional<ConvenienceStoreData> findByManagementNumber(String managementNumber);

    // 중복 체크
    boolean existsByManagementNumber(String managementNumber);

    // 영업상태별 조회
    List<ConvenienceStoreData> findByBusinessStatusCode(String businessStatusCode);
    List<ConvenienceStoreData> findByBusinessStatusName(String businessStatusName);

    // 영업중인 편의점만 조회
    @Query("SELECT c FROM ConvenienceStoreData c WHERE c.businessStatusCode = '1' AND c.businessStatusName LIKE '%영업%'")
    List<ConvenienceStoreData> findActiveStores();

    // 주소 기반 검색
    List<ConvenienceStoreData> findByRoadAddressContaining(String address);
    List<ConvenienceStoreData> findByLotAddressContaining(String address);

    // 사업장명으로 검색
    List<ConvenienceStoreData> findByBusinessNameContaining(String businessName);

    // 특정 지역 편의점 조회
    @Query("SELECT c FROM ConvenienceStoreData c WHERE c.roadAddress LIKE %:region% OR c.lotAddress LIKE %:region%")
    List<ConvenienceStoreData> findByRegion(@Param("region") String region);

    // 영업상태별 통계
    @Query("SELECT c.businessStatusName, COUNT(c) FROM ConvenienceStoreData c GROUP BY c.businessStatusName ORDER BY COUNT(c) DESC")
    List<Object[]> countByBusinessStatus();

    // 지역별 편의점 수 통계 (도로명주소 기준 - 서울 25개구)
    @Query(value = """
        SELECT 
            CASE 
                WHEN ROAD_ADDRESS LIKE '%강남구%' THEN '강남구'
                WHEN ROAD_ADDRESS LIKE '%서초구%' THEN '서초구'
                WHEN ROAD_ADDRESS LIKE '%송파구%' THEN '송파구'
                WHEN ROAD_ADDRESS LIKE '%강동구%' THEN '강동구'
                WHEN ROAD_ADDRESS LIKE '%마포구%' THEN '마포구'
                WHEN ROAD_ADDRESS LIKE '%서대문구%' THEN '서대문구'
                WHEN ROAD_ADDRESS LIKE '%은평구%' THEN '은평구'
                WHEN ROAD_ADDRESS LIKE '%종로구%' THEN '종로구'
                WHEN ROAD_ADDRESS LIKE '%중구%' THEN '중구'
                WHEN ROAD_ADDRESS LIKE '%용산구%' THEN '용산구'
                WHEN ROAD_ADDRESS LIKE '%성동구%' THEN '성동구'
                WHEN ROAD_ADDRESS LIKE '%동대문구%' THEN '동대문구'
                WHEN ROAD_ADDRESS LIKE '%중랑구%' THEN '중랑구'
                WHEN ROAD_ADDRESS LIKE '%성북구%' THEN '성북구'
                WHEN ROAD_ADDRESS LIKE '%강북구%' THEN '강북구'
                WHEN ROAD_ADDRESS LIKE '%도봉구%' THEN '도봉구'
                WHEN ROAD_ADDRESS LIKE '%노원구%' THEN '노원구'
                WHEN ROAD_ADDRESS LIKE '%광진구%' THEN '광진구'
                WHEN ROAD_ADDRESS LIKE '%영등포구%' THEN '영등포구'
                WHEN ROAD_ADDRESS LIKE '%동작구%' THEN '동작구'
                WHEN ROAD_ADDRESS LIKE '%관악구%' THEN '관악구'
                WHEN ROAD_ADDRESS LIKE '%강서구%' THEN '강서구'
                WHEN ROAD_ADDRESS LIKE '%양천구%' THEN '양천구'
                WHEN ROAD_ADDRESS LIKE '%구로구%' THEN '구로구'
                ELSE '기타'
            END as district,
            COUNT(*) as count
        FROM CONVENIENCE_STORE_DATA 
        WHERE ROAD_ADDRESS IS NOT NULL
        GROUP BY 
            CASE 
                WHEN ROAD_ADDRESS LIKE '%강남구%' THEN '강남구'
                WHEN ROAD_ADDRESS LIKE '%서초구%' THEN '서초구'
                WHEN ROAD_ADDRESS LIKE '%송파구%' THEN '송파구'
                WHEN ROAD_ADDRESS LIKE '%강동구%' THEN '강동구'
                WHEN ROAD_ADDRESS LIKE '%마포구%' THEN '마포구'
                WHEN ROAD_ADDRESS LIKE '%서대문구%' THEN '서대문구'
                WHEN ROAD_ADDRESS LIKE '%은평구%' THEN '은평구'
                WHEN ROAD_ADDRESS LIKE '%종로구%' THEN '종로구'
                WHEN ROAD_ADDRESS LIKE '%중구%' THEN '중구'
                WHEN ROAD_ADDRESS LIKE '%용산구%' THEN '용산구'
                WHEN ROAD_ADDRESS LIKE '%성동구%' THEN '성동구'
                WHEN ROAD_ADDRESS LIKE '%동대문구%' THEN '동대문구'
                WHEN ROAD_ADDRESS LIKE '%중랑구%' THEN '중랑구'
                WHEN ROAD_ADDRESS LIKE '%성북구%' THEN '성북구'
                WHEN ROAD_ADDRESS LIKE '%강북구%' THEN '강북구'
                WHEN ROAD_ADDRESS LIKE '%도봉구%' THEN '도봉구'
                WHEN ROAD_ADDRESS LIKE '%노원구%' THEN '노원구'
                WHEN ROAD_ADDRESS LIKE '%광진구%' THEN '광진구'
                WHEN ROAD_ADDRESS LIKE '%영등포구%' THEN '영등포구'
                WHEN ROAD_ADDRESS LIKE '%동작구%' THEN '동작구'
                WHEN ROAD_ADDRESS LIKE '%관악구%' THEN '관악구'
                WHEN ROAD_ADDRESS LIKE '%강서구%' THEN '강서구'
                WHEN ROAD_ADDRESS LIKE '%양천구%' THEN '양천구'
                WHEN ROAD_ADDRESS LIKE '%구로구%' THEN '구로구'
                ELSE '기타'
            END
        ORDER BY COUNT(*) DESC
        """, nativeQuery = true)
    List<Object[]> countByDistrict();

    // 날짜 범위별 조회
    List<ConvenienceStoreData> findByLicenseDateBetween(LocalDate startDate, LocalDate endDate);
    List<ConvenienceStoreData> findByClosureDateBetween(LocalDate startDate, LocalDate endDate);

    // 페이징 처리된 전체 조회
    Page<ConvenienceStoreData> findAll(Pageable pageable);

    // 영업중인 편의점 페이징 조회
    @Query("SELECT c FROM ConvenienceStoreData c WHERE c.businessStatusCode = '1' AND c.businessStatusName LIKE '%영업%'")
    Page<ConvenienceStoreData> findActiveStores(Pageable pageable);
}
```

## 4. CSV 데이터 로더 Component (현재 구현된 버전)

```java
package com.WhereHouse.AnalysisStaticData.ConvenienceStore.component;

import com.WhereHouse.AnalysisStaticData.ConvenienceStore.entity.ConvenienceStoreData;
import com.WhereHouse.AnalysisStaticData.ConvenienceStore.reposiotry.ConvenienceStoreDataRepository;
import com.opencsv.CSVReader;
import com.opencsv.exceptions.CsvValidationException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.List;

@Component
@RequiredArgsConstructor
@Slf4j
public class ConvenienceStoreExcelLoader { // implements CommandLineRunner - 주석처리됨

    private final ConvenienceStoreDataRepository repository;

    @Value("${app.csv.convenience-path}")
    private Resource csvFileResource; // 변수명 변경됨

    @Value("${convenience-store.excel.header-row:0}")
    private int headerRowIndex;

    @Value("${convenience-store.excel.batch-size:1000}")
    private int batchSize;

    // CSV 파싱용 포맷터들
    private static final DateTimeFormatter[] DATE_FORMATTERS = {
            DateTimeFormatter.ofPattern("yyyy-MM-dd"),
            DateTimeFormatter.ofPattern("yyyy/MM/dd"),
            DateTimeFormatter.ofPattern("yyyyMMdd"),
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"),
            DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss")
    };
    
    private static final DateTimeFormatter[] DATETIME_FORMATTERS = {
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"),
            DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss"),
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm"),
            DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm"),
            DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss")
    };

    // @Override - 주석처리됨
    @Transactional
    public void run(String... args) {
        log.info("편의점 CSV 데이터 로딩 시작...");
        log.info("파일 경로: {}", csvFileResource.getFilename());

        try {
            long existingCount = repository.count();
            if (existingCount > 0) {
                log.info("기존 데이터 {}개 존재. 전체 삭제 후 새로 로드합니다.", existingCount);
                repository.deleteAllInBatch();
            }

            List<ConvenienceStoreData> dataList = loadCsvData();

            if (dataList.isEmpty()) {
                log.warn("로드할 데이터가 없습니다.");
                return;
            }

            log.info("총 {}개 데이터 로드 완료. 배치 저장 시작...", dataList.size());
            saveDataInBatches(dataList);

            long finalCount = repository.count();
            log.info("편의점 데이터 로딩 완료: {}개 데이터 저장", finalCount);

            printDataStatistics();
        } catch (Exception e) {
            log.error("편의점 CSV 데이터 로딩 실패", e);
            throw new RuntimeException("편의점 데이터 로딩 실패", e);
        }
    }

    // 메서드명을 loadCsvData로 변경하고 내부 로직을 opencsv에 맞게 수정
    private List<ConvenienceStoreData> loadCsvData() throws IOException, CsvValidationException {
        List<ConvenienceStoreData> dataList = new ArrayList<>();

        // InputStream을 UTF-8 인코딩으로 읽기 위한 InputStreamReader
        try (InputStream is = csvFileResource.getInputStream();
             InputStreamReader reader = new InputStreamReader(is, StandardCharsets.UTF_8);
             CSVReader csvReader = new CSVReader(reader)) {

            // 헤더 행 스킵
            for (int i = 0; i <= headerRowIndex; i++) {
                csvReader.readNext();
            }

            String[] line;
            int rowNumber = headerRowIndex + 1;
            while ((line = csvReader.readNext()) != null) {
                rowNumber++;
                try {
                    ConvenienceStoreData data = mapRowToEntity(line);
                    dataList.add(data);
                } catch (Exception e) {
                    log.warn("행 {} 처리 실패: {}", rowNumber, e.getMessage());
                }
            }
        }
        return dataList;
    }

    // 파라미터를 String 배열로 받도록 수정
    private ConvenienceStoreData mapRowToEntity(String[] row) {
        return ConvenienceStoreData.builder()
                .openLocalGovCode(getStringValue(row, 0))
                .managementNumber(getStringValue(row, 1))
                .licenseDate(getDateValue(row, 2))
                .licenseCancelDate(getDateValue(row, 3))
                .businessStatusCode(getStringValue(row, 4))
                .businessStatusName(getStringValue(row, 5))
                .detailedStatusCode(getStringValue(row, 6))
                .detailedStatusName(getStringValue(row, 7))
                .closureDate(getDateValue(row, 8))
                .suspensionStartDate(getDateValue(row, 9))
                .suspensionEndDate(getDateValue(row, 10))
                .reopeningDate(getDateValue(row, 11))
                .phoneNumber(getStringValue(row, 12))
                .locationArea(getBigDecimalValue(row, 13))
                .locationPostalCode(getStringValue(row, 14))
                .lotAddress(getStringValue(row, 15))
                .roadAddress(getStringValue(row, 16))
                .roadPostalCode(getStringValue(row, 17))
                .businessName(getStringValue(row, 18))
                .lastModifiedDate(getDateTimeValue(row, 19))
                .dataUpdateType(getStringValue(row, 20))
                .dataUpdateTime(getStringValue(row, 21))
                .businessTypeName(getStringValue(row, 22))
                .coordinateX(getBigDecimalValue(row, 23))
                .coordinateY(getBigDecimalValue(row, 24))
                .salesArea(getBigDecimalValue(row, 25))
                .build();
    }

    // 헬퍼 메서드들도 String 배열을 받도록 수정
    private String getStringValue(String[] row, int index) {
        if (index >= row.length || row[index] == null || row[index].trim().isEmpty()) {
            return null;
        }
        return row[index].trim();
    }

    private LocalDate getDateValue(String[] row, int index) {
        String dateStr = getStringValue(row, index);
        if (dateStr == null) return null;
        for (DateTimeFormatter formatter : DATE_FORMATTERS) {
            try {
                return LocalDate.parse(dateStr, formatter);
            } catch (DateTimeParseException e) { /* 다음 포맷 시도 */ }
        }
        return null;
    }

    private LocalDateTime getDateTimeValue(String[] row, int index) {
        String dateTimeStr = getStringValue(row, index);
        if (dateTimeStr == null) return null;
        for (DateTimeFormatter formatter : DATETIME_FORMATTERS) {
            try {
                return LocalDateTime.parse(dateTimeStr, formatter);
            } catch (DateTimeParseException e) { /* 다음 포맷 시도 */ }
        }
        return null;
    }

    private BigDecimal getBigDecimalValue(String[] row, int index) {
        String valueStr = getStringValue(row, index);
        if (valueStr == null) return BigDecimal.ZERO;
        try {
            return new BigDecimal(valueStr);
        } catch (NumberFormatException e) {
            return BigDecimal.ZERO;
        }
    }

    private void saveDataInBatches(List<ConvenienceStoreData> dataList) {
        int totalSize = dataList.size();
        for (int i = 0; i < totalSize; i += batchSize) {
            int end = Math.min(i + batchSize, totalSize);
            List<ConvenienceStoreData> batch = dataList.subList(i, end);
            repository.saveAll(batch);
            log.info("배치 저장 완료: {} / {}", end, totalSize);
        }
    }

    private void printDataStatistics() {
        log.info("========== 데이터 로드 통계 ==========");
        List<Object[]> stats = repository.countByBusinessStatus();
        if (stats.isEmpty()) {
            log.info("통계 데이터가 없습니다.");
        } else {
            stats.forEach(row -> log.info("영업상태: {}, 개수: {}", row[0], row[1]));
        }
        log.info("======================================");
    }
}
```

## 5. application.yml 설정 예시

```yaml
# 편의점 CSV 파일 설정
app:
  csv:
    convenience-path: classpath:data/convenience-store-data.csv

# 편의점 로더 설정
convenience-store:
  excel:
    header-row: 0      # CSV 헤더 행 번호 (0부터 시작)
    batch-size: 1000   # 배치 저장 크기

# 데이터베이스 설정 (Oracle)
spring:
  datasource:
    url: jdbc:oracle:thin:@localhost:1521:xe
    username: your_username
    password: your_password
    driver-class-name: oracle.jdbc.OracleDriver
  
  jpa:
    hibernate:
      ddl-auto: none  # 테이블은 직접 생성
    properties:
      hibernate:
        dialect: org.hibernate.dialect.OracleDialect
        format_sql: true
    show-sql: true
```

## 6. 데이터 출처 정보

### 서울시 안전상비의약품 판매업소 인허가 정보
- **데이터셋 URL**: https://data.seoul.go.kr/dataList/OA-16483/S/1/datasetView.do
- **제공기관**: 서울특별시
- **카테고리**: 보건
- **데이터 형태**: CSV 파일
- **업데이트 주기**: 월 1회
- **좌표계**: WGS84 (EPSG:4326)
- **인코딩**: UTF-8

이 데이터셋은 서울시내 편의점과 같은 안전상비의약품 판매업소의 인허가 정보를 포함하고 있으며, 영업상태, 주소정보, 좌표정보 등의 상세 정보를 제공합니다. 본 시스템은 이러한 공공데이터를 활용하여 편의점 정보를 체계적으로 관리하고 분석할 수 있도록 구성되었습니다.