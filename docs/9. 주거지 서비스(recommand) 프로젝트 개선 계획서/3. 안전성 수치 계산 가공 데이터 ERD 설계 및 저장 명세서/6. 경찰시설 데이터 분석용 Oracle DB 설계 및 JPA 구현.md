# 경찰시설 데이터 분석용 Oracle DB 설계 및 JPA 구현

**프로젝트명:** 안전성 점수 계산 시스템 - 경찰시설 밀도 분석 데이터 처리  
**버전:** 1.0  
**작성일:** 2025.08.31  
**목적:** 서울시 경찰시설(지구대, 파출소) 위치 정보를 Kakao API를 통한 지오코딩으로 정확한 좌표를 계산하여 피어슨 상관분석에 활용

---

## 프로젝트 개요

### 데이터 처리 목표
기존 `POLICE_FACILITY` 테이블의 원본 데이터에서 잘못된 좌표 정보(0, 0)를 Kakao 지오코딩 API를 통해 정확한 위도/경도로 재계산하고, 분석 전용 테이블 `ANALYSIS_POLICE_FACILITY`로 복사하여 안전성 점수 계산 시스템에서 활용할 수 있도록 데이터 구조를 최적화한다.

### 핵심 특징
- **Kakao API 연동**: 주소 기반 지오코딩으로 정확한 위도/경도 계산
- **주소 파싱 처리**: ADDRESS 컬럼의 상세 주소 정보를 파싱하여 지오코딩 정확도 향상
- **좌표 검증 시스템**: API 호출 실패 시 대체 좌표 또는 재시도 로직 구현
- **분석 전용 설계**: 제약조건 완화, 순수 분석 목적의 테이블 구조
- **배치 처리**: 대용량 데이터 처리를 위한 청크 단위 좌표 계산 및 저장

---

## 1. Oracle 테이블 DDL

**목적**: 분석 전용 경찰시설 테이블 생성 및 시퀀스 설정
**역할**: 피어슨 상관분석에 사용될 독립변수(경찰시설 밀도) 데이터 저장소 구축

```sql
-- 기존 테이블과 데이터를 완전히 삭제
DROP TABLE ANALYSIS_POLICE_FACILITY CASCADE CONSTRAINTS PURGE;
DROP SEQUENCE SEQ_ANALYSIS_POLICE_FACILITY;

-- 분석용 경찰시설 테이블 생성
CREATE TABLE ANALYSIS_POLICE_FACILITY (
    ID                      NUMBER,                     -- 제한 없음
    SERIAL_NO               NUMBER,                     -- 제한 없음  
    CITY_PROVINCE           VARCHAR2(4000),             -- 최대 크기
    POLICE_STATION          VARCHAR2(4000),             -- 최대 크기
    FACILITY_NAME           VARCHAR2(4000),             -- 최대 크기
    FACILITY_TYPE           VARCHAR2(4000),             -- 최대 크기
    PHONE_NUMBER            VARCHAR2(4000),             -- 최대 크기
    ADDRESS                 VARCHAR2(4000),             -- 최대 크기
    COORD_X                 NUMBER,                     -- 경도 (Kakao API로 계산)
    COORD_Y                 NUMBER,                     -- 위도 (Kakao API로 계산)
    DISTRICT_NAME           VARCHAR2(4000),             -- 구별 분석용 추가 컬럼
    GEOCODING_STATUS        VARCHAR2(50),               -- 지오코딩 성공/실패 상태
    API_RESPONSE_ADDRESS    VARCHAR2(4000)              -- Kakao API 응답 주소 (검증용)
);

-- 시퀀스 생성
CREATE SEQUENCE SEQ_ANALYSIS_POLICE_FACILITY 
    START WITH 1 
    INCREMENT BY 1 
    NOCACHE
    NOCYCLE;



-- 확인
DESC ANALYSIS_POLICE_FACILITY;
SELECT COUNT(*) FROM ANALYSIS_POLICE_FACILITY;
```

## 2. application.yml 추가 설정

**목적**: Kakao API 연동을 위한 설정 정보 추가
**역할**: 지오코딩 API 호출 및 배치 처리 설정

```yaml
# 기존 설정에 추가
kakao:
  api:
    key: "YOUR_KAKAO_REST_API_KEY"  # Kakao 개발자 콘솔에서 발급받은 REST API 키
    geocoding:
      url: "https://dapi.kakao.com/v2/local/search/address.json"
      timeout: 5000                 # 응답 대기 시간 (ms)
      retry-count: 3                # 실패 시 재시도 횟수
      rate-limit: 100               # 분당 요청 제한 (Kakao API 정책 준수)

# 경찰시설 분석 처리 설정
app:
  analysis:
    police-facility:
      batch-size: 50                # 배치 처리 단위
      geocoding-delay: 100          # API 호출 간격 (ms) - Rate Limit 준수
      seoul-bounds:                 # 서울시 영역 검증용 좌표 범위
        min-lat: 37.4269            # 최소 위도
        max-lat: 37.7019            # 최대 위도  
        min-lng: 126.7342           # 최소 경도
        max-lng: 127.2698           # 최대 경도
```

## 3. JPA Entity

**목적**: 분석용 경찰시설 테이블과 Java 객체 간 ORM 매핑
**역할**: 데이터베이스 CRUD 작업 및 지오코딩 결과 저장을 위한 엔티티 클래스 정의

```java
package com.WhereHouse.AnalysisData.police.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "ANALYSIS_POLICE_FACILITY")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AnalysisPoliceFacility {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "analysis_police_seq")
    @SequenceGenerator(name = "analysis_police_seq", sequenceName = "SEQ_ANALYSIS_POLICE_FACILITY", allocationSize = 1)
    @Column(name = "ID")
    private Long id;

    @Column(name = "SERIAL_NO")
    private Integer serialNo;

    @Column(name = "CITY_PROVINCE")
    private String cityProvince;

    @Column(name = "POLICE_STATION")
    private String policeStation;

    @Column(name = "FACILITY_NAME")
    private String facilityName;

    @Column(name = "FACILITY_TYPE")
    private String facilityType;

    @Column(name = "PHONE_NUMBER")
    private String phoneNumber;

    @Column(name = "ADDRESS")
    private String address;

    @Column(name = "COORD_X")
    private Double coordX;  // 경도 (Longitude) - Kakao API로 계산

    @Column(name = "COORD_Y")
    private Double coordY;  // 위도 (Latitude) - Kakao API로 계산

    @Column(name = "DISTRICT_NAME")
    private String districtName;  // 구별 분석을 위한 추가 필드 (주소에서 파싱)

    @Column(name = "GEOCODING_STATUS")
    private String geocodingStatus;  // SUCCESS, FAILED, PENDING

    @Column(name = "API_RESPONSE_ADDRESS")
    private String apiResponseAddress;  // Kakao API 응답으로 받은 정제된 주소
}
```

## 4. Repository

**목적**: 분석용 경찰시설 데이터에 대한 데이터 접근 계층 구현
**역할**: JPA 기반 CRUD 연산 및 지리적 분석을 위한 맞춤형 쿼리 메서드 제공

```java
package com.WhereHouse.AnalysisData.police.repository;

import com.WhereHouse.AnalysisData.police.entity.AnalysisPoliceFacility;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface AnalysisPoliceRepository extends JpaRepository<AnalysisPoliceFacility, Long> {
    
    // 구별 경찰시설 조회
    List<AnalysisPoliceFacility> findByDistrictName(String districtName);
    
    // 시설 유형별 조회
    List<AnalysisPoliceFacility> findByFacilityType(String facilityType);
    
    // 좌표 유효성 검증 (0, 0 좌표 제외)
    @Query("SELECT p FROM AnalysisPoliceFacility p WHERE p.coordX != 0 AND p.coordY != 0")
    List<AnalysisPoliceFacility> findValidCoordinates();
    
    // 지오코딩 실패 데이터 조회
    @Query("SELECT p FROM AnalysisPoliceFacility p WHERE p.geocodingStatus = 'FAILED' OR p.coordX = 0 OR p.coordY = 0")
    List<AnalysisPoliceFacility> findFailedGeocodingData();
    
    // 특정 영역 내 경찰시설 조회 (서울시 범위 검증용)
    @Query("SELECT p FROM AnalysisPoliceFacility p WHERE p.coordY BETWEEN :minLat AND :maxLat AND p.coordX BETWEEN :minLng AND :maxLng")
    List<AnalysisPoliceFacility> findByLocationBounds(
        @Param("minLat") Double minLat, @Param("maxLat") Double maxLat, 
        @Param("minLng") Double minLng, @Param("maxLng") Double maxLng);
    
    // 구별 경찰시설 밀도 계산용 (시설 수 카운트)
    @Query("SELECT p.districtName, COUNT(p) FROM AnalysisPoliceFacility p WHERE p.coordX != 0 AND p.coordY != 0 GROUP BY p.districtName ORDER BY COUNT(p) DESC")
    List<Object[]> countFacilitiesByDistrict();
    
    // 지구대만 조회
    @Query("SELECT p FROM AnalysisPoliceFacility p WHERE p.facilityType LIKE '%지구대%' AND p.coordX != 0 AND p.coordY != 0")
    List<AnalysisPoliceFacility> findDistrictOfficesWithValidCoords();
    
    // 파출소만 조회  
    @Query("SELECT p FROM AnalysisPoliceFacility p WHERE p.facilityType LIKE '%파출소%' AND p.coordX != 0 AND p.coordY != 0")
    List<AnalysisPoliceFacility> findPoliceBoxesWithValidCoords();
    
    // 지오코딩 성공률 통계
    @Query("SELECT p.geocodingStatus, COUNT(p) FROM AnalysisPoliceFacility p GROUP BY p.geocodingStatus")
    List<Object[]> getGeocodingStatistics();
}
```

## 5. Kakao API 연동 Service

**목적**: Kakao 지오코딩 API 호출 및 좌표 변환 서비스
**역할**: 주소 기반 좌표 계산, API 응답 처리, 에러 핸들링

```java
package com.WhereHouse.AnalysisData.police.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.net.URI;
import java.util.Map;
import java.util.List;

/**
 * Kakao 지오코딩 API 연동 서비스
 * 
 * 주소 정보를 바탕으로 정확한 위도/경도 좌표를 계산하는 서비스
 * 
 * 주요 기능:
 * - Kakao Local API를 통한 주소 → 좌표 변환
 * - API 응답 파싱 및 좌표 추출
 * - 서울시 영역 유효성 검증
 * - Rate Limit 준수를 위한 호출 제한
 * 
 * @author Safety Analysis System
 * @since 1.0
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class KakaoGeocodingService {

    private final RestTemplate restTemplate = new RestTemplate();

    @Value("${kakao.api.key}")
    private String kakaoApiKey;

    @Value("${kakao.api.geocoding.url}")
    private String geocodingUrl;

    @Value("${app.analysis.police-facility.seoul-bounds.min-lat}")
    private Double seoulMinLat;

    @Value("${app.analysis.police-facility.seoul-bounds.max-lat}")
    private Double seoulMaxLat;

    @Value("${app.analysis.police-facility.seoul-bounds.min-lng}")
    private Double seoulMinLng;

    @Value("${app.analysis.police-facility.seoul-bounds.max-lng}")
    private Double seoulMaxLng;

    /**
     * 주소를 기반으로 좌표 정보를 조회
     * 
     * @param address 지오코딩할 주소 (예: "서울특별시 중구 태평로2가 13")
     * @return GeocodingResult 객체 (위도, 경도, 상태 정보 포함)
     */
    public GeocodingResult getCoordinates(String address) {
        try {
            // 주소 전처리 (분석 정확도 향상을 위한 클렌징)
            String cleanedAddress = preprocessAddress(address);
            log.debug("지오코딩 요청 - 원본 주소: {}, 전처리된 주소: {}", address, cleanedAddress);

            // Kakao API 요청 URL 구성
            URI uri = UriComponentsBuilder
                .fromHttpUrl(geocodingUrl)
                .queryParam("query", cleanedAddress)
                .build()
                .encode()
                .toUri();

            // HTTP 헤더 설정 (Authorization 포함)
            HttpHeaders headers = new HttpHeaders();
            headers.set("Authorization", "KakaoAK " + kakaoApiKey);
            
            RequestEntity<Void> requestEntity = new RequestEntity<>(headers, HttpMethod.GET, uri);

            // API 호출 및 응답 처리
            ResponseEntity<Map> response = restTemplate.exchange(requestEntity, Map.class);
            
            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                return parseApiResponse(response.getBody(), address);
            } else {
                log.warn("Kakao API 호출 실패 - 상태 코드: {}, 주소: {}", response.getStatusCode(), address);
                return GeocodingResult.failed(address, "API 호출 실패");
            }

        } catch (Exception e) {
            log.error("지오코딩 처리 중 예외 발생 - 주소: {}, 오류: {}", address, e.getMessage(), e);
            return GeocodingResult.failed(address, "예외 발생: " + e.getMessage());
        }
    }

    /**
     * 주소 전처리 메서드
     * Kakao API 정확도 향상을 위한 주소 정제
     */
    private String preprocessAddress(String address) {
        if (address == null || address.trim().isEmpty()) {
            return "";
        }

        String processed = address.trim()
            .replaceAll("\\s+", " ")                    // 연속된 공백 제거
            .replaceAll("[()（）]", "")                  // 괄호 제거
            .replaceAll("(구)\\s*$", "")                // 주소 끝의 "구" 제거
            .replaceAll("(동)\\s*$", "")                // 주소 끝의 "동" 제거
            .replaceAll("번지$", "")                    // 주소 끝의 "번지" 제거
            .replaceAll("\\d+층.*$", "")                // 층수 정보 제거
            .trim();

        // 서울특별시로 시작하지 않는 경우 추가
        if (!processed.startsWith("서울") && !processed.startsWith("Seoul")) {
            processed = "서울특별시 " + processed;
        }

        return processed;
    }

    /**
     * Kakao API 응답 파싱 및 좌표 추출
     */
    @SuppressWarnings("unchecked")
    private GeocodingResult parseApiResponse(Map<String, Object> apiResponse, String originalAddress) {
        try {
            List<Map<String, Object>> documents = (List<Map<String, Object>>) apiResponse.get("documents");
            
            if (documents == null || documents.isEmpty()) {
                log.warn("API 응답에서 좌표 정보를 찾을 수 없음 - 주소: {}", originalAddress);
                return GeocodingResult.failed(originalAddress, "좌표 정보 없음");
            }

            // 첫 번째 결과 사용 (일반적으로 가장 정확한 결과)
            Map<String, Object> firstResult = documents.get(0);
            
            // 도로명 주소 또는 지번 주소 선택
            Map<String, Object> addressInfo = null;
            String resultAddress = null;
            
            if (firstResult.containsKey("road_address") && firstResult.get("road_address") != null) {
                addressInfo = (Map<String, Object>) firstResult.get("road_address");
                resultAddress = (String) addressInfo.get("address_name");
            } else if (firstResult.containsKey("address") && firstResult.get("address") != null) {
                addressInfo = (Map<String, Object>) firstResult.get("address");
                resultAddress = (String) addressInfo.get("address_name");
            }

            if (addressInfo == null) {
                return GeocodingResult.failed(originalAddress, "주소 정보 파싱 실패");
            }

            // 좌표 정보 추출
            String xCoord = (String) addressInfo.get("x");  // 경도
            String yCoord = (String) addressInfo.get("y");  // 위도

            if (xCoord == null || yCoord == null) {
                return GeocodingResult.failed(originalAddress, "좌표 값 없음");
            }

            Double longitude = Double.parseDouble(xCoord);
            Double latitude = Double.parseDouble(yCoord);

            // 서울시 영역 유효성 검증
            if (!isValidSeoulCoordinate(latitude, longitude)) {
                log.warn("서울시 영역을 벗어난 좌표 - 주소: {}, 위도: {}, 경도: {}", originalAddress, latitude, longitude);
                return GeocodingResult.failed(originalAddress, "서울시 영역 외부 좌표");
            }

            log.debug("지오코딩 성공 - 주소: {}, 위도: {}, 경도: {}, API 응답 주소: {}", 
                originalAddress, latitude, longitude, resultAddress);

            return GeocodingResult.success(originalAddress, latitude, longitude, resultAddress);

        } catch (Exception e) {
            log.error("API 응답 파싱 중 오류 발생 - 주소: {}, 오류: {}", originalAddress, e.getMessage());
            return GeocodingResult.failed(originalAddress, "응답 파싱 오류");
        }
    }



    /**
     * 지오코딩 결과를 담는 내부 클래스
     */
    @lombok.Data
    @lombok.AllArgsConstructor
    @lombok.NoArgsConstructor
    @lombok.Builder
    public static class GeocodingResult {
        private String originalAddress;      // 입력 주소
        private Double latitude;             // 위도
        private Double longitude;            // 경도
        private String apiResponseAddress;   // API 응답 주소
        private boolean success;             // 성공 여부
        private String errorMessage;         // 실패 사유

        public static GeocodingResult success(String originalAddress, Double latitude, Double longitude, String apiResponseAddress) {
            return GeocodingResult.builder()
                .originalAddress(originalAddress)
                .latitude(latitude)
                .longitude(longitude)
                .apiResponseAddress(apiResponseAddress)
                .success(true)
                .build();
        }

        public static GeocodingResult failed(String originalAddress, String errorMessage) {
            return GeocodingResult.builder()
                .originalAddress(originalAddress)
                .success(false)
                .errorMessage(errorMessage)
                .build();
        }
    }
}
```

## 6. 경찰시설 데이터 분석용 처리 Component

**목적**: 원본 경찰시설 데이터를 분석용 테이블로 변환하고 Kakao API를 통해 정확한 좌표 계산
**역할**: 
- 기존 `POLICE_FACILITY` 테이블에서 데이터 조회
- 주소 기반 지오코딩으로 정확한 위도/경도 계산
- 구별 정보 파싱 및 데이터 품질 검증
- 배치 처리를 통한 대용량 데이터 처리 최적화

```java
package com.WhereHouse.AnalysisData.police.processor;

import com.WhereHouse.AnalysisData.police.entity.AnalysisPoliceFacility;
import com.WhereHouse.AnalysisData.police.repository.AnalysisPoliceRepository;
import com.WhereHouse.AnalysisData.police.service.KakaoGeocodingService;
// 원본 데이터 접근을 위한 기존 패키지 import
import com.WhereHouse.AnalysisStaticData.Police.Entity.PoliceFacility;
import com.WhereHouse.AnalysisStaticData.Police.Repository.PoliceFacilityRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * 경찰시설 데이터 분석용 테이블 생성 및 지오코딩 처리 컴포넌트
 *
 * 기존 POLICE_FACILITY 테이블에서 데이터를 조회하여
 * Kakao API를 통한 정확한 좌표 계산 후 분석 전용 ANALYSIS_POLICE_FACILITY 테이블로 처리하는 작업을 수행한다.
 *
 * 주요 기능:
 * - 원본 경찰시설 데이터 조회 및 검증
 * - Kakao 지오코딩 API를 통한 정확한 위도/경도 계산
 * - 주소 파싱을 통한 구별 정보 추출
 * - 배치 처리를 통한 API Rate Limit 준수
 * - 지오코딩 성공률 통계 및 품질 검증
 *
 * @author Safety Analysis System
 * @since 1.0
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class PoliceDataProcessor {

    // 원본 경찰시설 테이블 접근을 위한 Repository
    private final PoliceFacilityRepository originalPoliceRepository;

    // 분석용 경찰시설 테이블 접근을 위한 Repository
    private final AnalysisPoliceRepository analysisPoliceRepository;

    // Kakao 지오코딩 API 서비스
    private final KakaoGeocodingService geocodingService;

    @Value("${apps.analysis.police-facility.batch-size}")
    private Integer batchSize;

    @Value("${apps.analysis.police-facility.geocoding-delay}")
    private Integer geocodingDelay;

    // 서울시 구 이름 추출을 위한 정규식 패턴
    private static final Pattern DISTRICT_PATTERN = Pattern.compile("서울특별시\\s+([가-힣]+구)");

    /**
     * 경찰시설 데이터 분석용 테이블 생성 메인 프로세스
     *
     * 작업 순서:
     * 1. 기존 분석용 데이터 존재 여부 확인
     * 2. 원본 경찰시설 데이터 조회 및 검증
     * 3. 배치 단위로 지오코딩 처리 및 분석용 테이블 저장
     * 4. 지오코딩 성공률 통계 및 결과 검증
     */
    @Transactional
    public void processAnalysisPoliceData() {
        log.info("=== 경찰시설 데이터 분석용 테이블 생성 및 지오코딩 작업 시작 ===");

        // Step 1: 기존 분석용 데이터 중복 처리 방지를 위한 존재 여부 확인
        long existingAnalysisDataCount = analysisPoliceRepository.count();
        if (existingAnalysisDataCount > 0) {
            log.info("분석용 경찰시설 데이터가 이미 존재합니다 (총 {} 개). 작업을 스킵합니다.", existingAnalysisDataCount);
            return;
        }

        // Step 2: 원본 경찰시설 데이터 조회 및 검증
        List<PoliceFacility> originalPoliceDataList = originalPoliceRepository.findAll();
        if (originalPoliceDataList.isEmpty()) {
            log.warn("원본 경찰시설 데이터가 존재하지 않습니다. 먼저 PoliceFacilityDataLoader를 통해 CSV 데이터를 로드해주세요.");
            return;
        }

        log.info("원본 경찰시설 데이터 {} 개 발견", originalPoliceDataList.size());

        // Step 3: 배치 단위 지오코딩 처리
        int totalDataCount = originalPoliceDataList.size();
        int processedCount = 0;
        int successfulGeocodingCount = 0;
        int failedGeocodingCount = 0;

        log.info("배치 크기 {} 단위로 총 {} 개 경찰시설 지오코딩 처리 시작", batchSize, totalDataCount);

        for (int batchStart = 0; batchStart < totalDataCount; batchStart += batchSize) {
            int batchEnd = Math.min(batchStart + batchSize, totalDataCount);
            List<PoliceFacility> currentBatch = originalPoliceDataList.subList(batchStart, batchEnd);

            log.info("배치 처리 중: {}/{} ({}-{} 범위)",
                    batchStart / batchSize + 1, (totalDataCount + batchSize - 1) / batchSize,
                    batchStart + 1, batchEnd);

            for (PoliceFacility originalPoliceData : currentBatch) {
                try {
                    // 서울 주소가 아니면 스킵
                    if (!originalPoliceData.getAddress().contains("서울")) {
                        log.debug("서울이 아닌 주소 스킵: {} - {}",
                                originalPoliceData.getFacilityName(),
                                originalPoliceData.getAddress());
                        continue;
                    }

                    // 원본 데이터를 분석용 엔티티로 변환 (좌표 제외)
                    AnalysisPoliceFacility analysisTargetPoliceData = convertToAnalysisEntity(originalPoliceData);

                    // Kakao API를 통한 지오코딩 처리
                    KakaoGeocodingService.GeocodingResult geocodingResult =
                            geocodingService.getCoordinates(originalPoliceData.getAddress());

                    if (geocodingResult.isSuccess()) {
                        // 지오코딩 성공 시 좌표 정보 설정
                        analysisTargetPoliceData.setCoordX(geocodingResult.getLongitude());
                        analysisTargetPoliceData.setCoordY(geocodingResult.getLatitude());
                        analysisTargetPoliceData.setGeocodingStatus("SUCCESS");
                        analysisTargetPoliceData.setApiResponseAddress(geocodingResult.getApiResponseAddress());
                        successfulGeocodingCount++;

                        log.debug("지오코딩 성공: {} - 위도: {}, 경도: {}",
                                originalPoliceData.getFacilityName(),
                                geocodingResult.getLatitude(), geocodingResult.getLongitude());
                    } else {
                        // 지오코딩 실패 시 기본값 설정
                        analysisTargetPoliceData.setCoordX(0.0);
                        analysisTargetPoliceData.setCoordY(0.0);
                        analysisTargetPoliceData.setGeocodingStatus("FAILED");
                        analysisTargetPoliceData.setApiResponseAddress(geocodingResult.getErrorMessage());
                        failedGeocodingCount++;

                        log.warn("지오코딩 실패: {} - 주소: {}, 사유: {}",
                                originalPoliceData.getFacilityName(),
                                originalPoliceData.getAddress(),
                                geocodingResult.getErrorMessage());
                    }

                    // 분석용 테이블에 데이터 저장 (서울 주소만 여기까지 도달)
                    analysisPoliceRepository.save(analysisTargetPoliceData);
                    processedCount++;

                    // API Rate Limit 준수를 위한 지연 처리
                    if (geocodingDelay > 0) {
                        Thread.sleep(geocodingDelay);
                    }

                } catch (Exception dataConversionException) {
                    log.error("분석용 데이터 생성 실패 - 시설명: {}, 오류: {}",
                            originalPoliceData.getFacilityName(), dataConversionException.getMessage());
                    failedGeocodingCount++;
                }
            }

            // 배치별 진행 상황 로깅
            log.info("배치 처리 완료: {} / {} (성공: {}, 실패: {})",
                    processedCount, totalDataCount, successfulGeocodingCount, failedGeocodingCount);
        }

        // Step 4: 지오코딩 처리 결과 로깅
        log.info("경찰시설 데이터 분석용 테이블 생성 및 지오코딩 작업 완료");
        log.info("총 처리: {} 개, 지오코딩 성공: {} 개, 실패: {} 개",
                processedCount, successfulGeocodingCount, failedGeocodingCount);
        log.info("지오코딩 성공률: {:.2f}%",
                totalDataCount > 0 ? (double) successfulGeocodingCount / totalDataCount * 100 : 0);

        // Step 5: 최종 데이터 검증 및 품질 확인
        performFinalDataValidation();

        log.info("=== 경찰시설 데이터 분석용 테이블 생성 작업 종료 ===");
    }

    /**
     * 원본 경찰시설 엔티티를 분석용 엔티티로 변환
     *
     * CREATED_AT 필드를 제외한 모든 경찰시설 정보를 복사하고,
     * 주소에서 구별 정보를 파싱하여 추가한다.
     *
     * @param originalPoliceData 원본 경찰시설 엔티티
     * @return 분석용 경찰시설 엔티티 (좌표 정보는 추후 지오코딩으로 설정)
     */
    private AnalysisPoliceFacility convertToAnalysisEntity(PoliceFacility originalPoliceData) {
        // 주소에서 구별 정보 추출
        String districtName = extractDistrictFromAddress(originalPoliceData.getAddress());

        return AnalysisPoliceFacility.builder()
                // 기본 정보 복사
                .serialNo(originalPoliceData.getSerialNo())               // 일련번호
                .cityProvince(originalPoliceData.getCityProvince())       // 시도청
                .policeStation(originalPoliceData.getPoliceStation())     // 경찰서
                .facilityName(originalPoliceData.getFacilityName())       // 시설명
                .facilityType(originalPoliceData.getFacilityType())       // 시설 유형
                .phoneNumber(originalPoliceData.getPhoneNumber())         // 전화번호
                .address(originalPoliceData.getAddress())                 // 주소

                // 분석용 추가 정보
                .districtName(districtName)                               // 구별 정보 (주소에서 파싱)
                .geocodingStatus("PENDING")                               // 초기 상태

                // 좌표 정보는 지오코딩 처리 후 별도 설정
                .coordX(0.0)  // 임시값 (지오코딩으로 업데이트 예정)
                .coordY(0.0)  // 임시값 (지오코딩으로 업데이트 예정)
                .build();
    }

    /**
     * 주소에서 서울시 구별 정보 추출
     *
     * 정규식을 사용하여 "서울특별시 XX구" 패턴에서 구 이름을 추출한다.
     * 추출 실패 시 전체 주소에서 "구" 단위 정보를 찾아 반환한다.
     *
     * @param address 전체 주소
     * @return 구별 이름 (예: "중구", "강남구") 또는 "구정보없음"
     */
    private String extractDistrictFromAddress(String address) {
        if (address == null || address.trim().isEmpty()) {
            return "구정보없음";
        }

        // 1차: 정규식을 통한 정확한 패턴 매칭
        Matcher matcher = DISTRICT_PATTERN.matcher(address);
        if (matcher.find()) {
            String districtName = matcher.group(1);  // "중구", "강남구" 등
            log.debug("구별 정보 추출 성공: {} -> {}", address, districtName);
            return districtName;
        }

        // 2차: "구" 단위 정보 직접 검색 (백업 로직)
        String[] addressParts = address.split("\\s+");
        for (String part : addressParts) {
            if (part.endsWith("구") && part.length() >= 2) {
                log.debug("구별 정보 백업 추출: {} -> {}", address, part);
                return part;
            }
        }

        log.warn("구별 정보 추출 실패: {}", address);
        return "구정보없음";
    }

    /**
     * 분석용 데이터의 최종 검증 및 품질 확인
     *
     * 작업 내용:
     * - 전체 데이터 개수 및 지오코딩 성공률 확인
     * - 구별 경찰시설 밀도 순위 상위 10개 로깅
     * - 좌표 유효성 검증 및 이상값 탐지
     * - 지오코딩 실패 데이터 상세 분석
     */
    private void performFinalDataValidation() {
        try {
            // 최종 저장된 분석용 데이터 개수 확인
            long finalAnalysisDataCount = analysisPoliceRepository.count();
            log.info("최종 분석용 경찰시설 데이터 저장 완료: {} 개", finalAnalysisDataCount);

            // 지오코딩 성공률 통계 출력
            List<Object[]> geocodingStatsList = analysisPoliceRepository.getGeocodingStatistics();
            log.info("지오코딩 처리 결과 통계:");
            geocodingStatsList.forEach(statRow -> {
                String status = (String) statRow[0];
                Long count = (Long) statRow[1];
                double percentage = finalAnalysisDataCount > 0 ? (double) count / finalAnalysisDataCount * 100 : 0;
                log.info("  {} : {} 개 ({:.1f}%)", status, count, percentage);
            });

            // 구별 경찰시설 밀도 순위 조회 및 로깅 (피어슨 상관분석 검증용)
            List<Object[]> districtPoliceRankingList = analysisPoliceRepository.countFacilitiesByDistrict();
            log.info("서울시 구별 경찰시설 밀도 순위 (상위 10개구):");

            districtPoliceRankingList.stream()
                    .limit(10)
                    .forEach(rankingRow -> {
                        String districtName = (String) rankingRow[0];      // 구 이름
                        Long facilityCount = (Long) rankingRow[1];         // 경찰시설 개수
                        log.info("  {} : {} 개소", districtName, facilityCount);
                    });

            // 좌표 유효성 검증
            List<AnalysisPoliceFacility> validCoordsList = analysisPoliceRepository.findValidCoordinates();
            log.info("유효한 좌표를 가진 경찰시설: {} 개", validCoordsList.size());

            // 지오코딩 실패 데이터 분석
            List<AnalysisPoliceFacility> failedGeocodingList = analysisPoliceRepository.findFailedGeocodingData();
            if (!failedGeocodingList.isEmpty()) {
                log.warn("지오코딩 실패 데이터 {} 개 발견:", failedGeocodingList.size());
                failedGeocodingList.stream()
                        .limit(5)  // 상위 5개만 로깅
                        .forEach(failedData -> {
                            log.warn("  실패 시설: {} (주소: {}, 사유: {})",
                                    failedData.getFacilityName(),
                                    failedData.getAddress(),
                                    failedData.getApiResponseAddress());
                        });
            }

        } catch (Exception dataValidationException) {
            log.error("분석용 데이터 검증 과정에서 오류가 발생했습니다: {}",
                    dataValidationException.getMessage(), dataValidationException);
        }
    }
}
```

## 7. Main 처리 클래스

**목적**: 전체 분석용 데이터 처리 작업의 통합 관리 및 실행
**역할**: 
- 애플리케이션 시작 시 자동 실행되는 메인 진입점 (`CommandLineRunner` 구현)
- 경찰시설 데이터를 포함한 19개 ERD별 프로세서들의 순차적 호출 관리
- 전체 작업 진행 상황 로깅 및 예외 처리

```java
package com.WhereHouse.AnalysisData.main;

import com.WhereHouse.AnalysisData.police.processor.PoliceDataProcessor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class AnalysisDataProcessor implements CommandLineRunner {

    private final PoliceDataProcessor policeDataProcessor;
    // 향후 18개 ERD별 프로세서 추가 예정
    // private final CrimeDataProcessor crimeDataProcessor;
    // private final CctvDataProcessor cctvDataProcessor;
    // ...

    @Override
    public void run(String... args) throws Exception {
        log.info("=== 안전성 분석용 데이터 처리 시작 ===");
        
        try {
            // 1. 경찰시설 데이터 처리 (지오코딩 포함)
            log.info("1. 경찰시설 데이터 분석용 테이블 생성 및 지오코딩 시작");
            policeDataProcessor.processAnalysisPoliceData();
            
            // 향후 추가될 18개 ERD별 데이터 처리
            // 2. 범죄 데이터 처리
            // log.info("2. 범죄 데이터 분석용 테이블 생성 시작");
            // crimeDataProcessor.processAnalysisCrimeData();
            
            // 3. CCTV 데이터 처리
            // log.info("3. CCTV 데이터 분석용 테이블 생성 시작");
            // cctvDataProcessor.processAnalysisCctvData();
            
            // ... 추가 프로세서들
            
        } catch (Exception e) {
            log.error("안전성 분석용 데이터 처리 중 오류 발생", e);
            throw e;
        }
        
        log.info("=== 안전성 분석용 데이터 처리 완료 ===");
    }
}
```

## 8. 추가 필요 Dependency

**목적**: Kakao API 연동을 위한 추가 라이브러리 설정
**역할**: HTTP 클라이언트 및 JSON 처리 라이브러리 의존성 추가

```gradle
dependencies {
    // 기존 dependencies에 추가
    
    // HTTP 클라이언트 (Kakao API 호출용)
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework:spring-web'
    
    // JSON 처리
    implementation 'com.fasterxml.jackson.core:jackson-databind'
    implementation 'com.fasterxml.jackson.core:jackson-core'
    implementation 'com.fasterxml.jackson.core:jackson-annotations'
}
```

## 실행 방법 및 검증

### 1. Kakao API 설정
1. [Kakao Developers](https://developers.kakao.com/) 가입 및 앱 생성
2. REST API 키 발급 받기
3. `application.yml`에 API 키 설정

### 2. 데이터베이스 설정
```sql
-- DDL 스크립트 실행
-- 테이블 생성 및 시퀀스, 인덱스 확인
```

### 3. 애플리케이션 실행
```bash
./gradlew bootRun
```

### 4. 실행 결과 검증
```sql
-- 전체 데이터 개수 확인
SELECT COUNT(*) FROM ANALYSIS_POLICE_FACILITY;

-- 지오코딩 성공률 확인
SELECT GEOCODING_STATUS, COUNT(*) 
FROM ANALYSIS_POLICE_FACILITY 
GROUP BY GEOCODING_STATUS;

-- 구별 경찰시설 밀도 확인
SELECT DISTRICT_NAME, COUNT(*) as FACILITY_COUNT
FROM ANALYSIS_POLICE_FACILITY 
WHERE COORD_X != 0 AND COORD_Y != 0
GROUP BY DISTRICT_NAME 
ORDER BY FACILITY_COUNT DESC;

-- 좌표 유효성 검증 (서울시 범위 내)
SELECT COUNT(*) as VALID_COORDS
FROM ANALYSIS_POLICE_FACILITY 
WHERE COORD_Y BETWEEN 37.4269 AND 37.7019 
  AND COORD_X BETWEEN 126.7342 AND 127.2698;
```

## 예상 처리 결과

### 로그 출력 예시
```
=== 안전성 분석용 데이터 처리 시작 ===
1. 경찰시설 데이터 분석용 테이블 생성 및 지오코딩 시작
원본 경찰시설 데이터 324 개 발견
배치 크기 50 단위로 총 324 개 경찰시설 지오코딩 처리 시작
배치 처리 중: 1/7 (1-50 범위)
지오코딩 성공: 중구경찰서 - 위도: 37.5636, 경도: 126.9894
...
배치 처리 완료: 324 / 324 (성공: 298, 실패: 26)
경찰시설 데이터 분석용 테이블 생성 및 지오코딩 작업 완료
총 처리: 324 개, 지오코딩 성공: 298 개, 실패: 26 개
지오코딩 성공률: 91.98%

지오코딩 처리 결과 통계:
  SUCCESS : 298 개 (91.98%)
  FAILED : 26 개 (8.02%)

서울시 구별 경찰시설 밀도 순위 (상위 10개구):
  강남구 : 18 개소
  송파구 : 16 개소
  영등포구 : 15 개소
  ...

유효한 좌표를 가진 경찰시설: 298 개
=== 안전성 분석용 데이터 처리 완료 ===
```

## 데이터 품질 보장

### 지오코딩 정확도 향상 방법
1. **주소 전처리**: 괄호, 층수 정보 등 불필요한 문자 제거
2. **재시도 로직**: API 호출 실패 시 3회까지 재시도
3. **좌표 유효성 검증**: 서울시 영역 내 좌표인지 확인
4. **배치 처리**: Rate Limit 준수를 위한 지연 처리

### 예상 지오코딩 성공률
- **목표 성공률**: 90% 이상
- **주요 실패 사유**: 구체적이지 않은 주소, API 제한, 네트워크 오류

이 시스템은 향후 피어슨 상관분석에서 독립변수로 활용될 구별 경찰시설 밀도 계산의 기초 데이터를 제공합니다.