# 서울시 은행 지점 개수 데이터 분석용 Oracle DB 설계 및 JPA 구현

**프로젝트명:** 안전성 점수 계산 시스템 - 은행 지점 개수 분석 데이터 처리  
**버전:** 1.0  
**작성일:** 2025.08.30  
**목적:** 서울시 구별 동별 은행 지점 개수 데이터를 피어슨 상관분석 계산에 활용하기 위한 분석용 테이블 구축

---

## 프로젝트 개요

### 데이터 처리 목표
기존 `FINANCIAL_INSTITUTION` 테이블의 원본 데이터를 분석 전용 테이블 `ANALYSIS_BANKCOUNT_STATISTICS`로 복사하여 안전성 점수 계산 시스템에서 활용할 수 있도록 데이터 구조를 최적화한다.

### 핵심 특징
- **좌표 변환 불필요**: 은행 지점 개수 데이터는 구별/동별 집계 데이터이므로 개별 좌표 정보 불요
- **단순 데이터 복사**: 원본 테이블에서 `CREATED_AT` 제외한 모든 필드 복사
- **분석 전용 설계**: 제약조건 없이 순수 분석 목적의 테이블 구조
- **기존 인터페이스 재사용**: 원천 데이터 접근에 필요한 JPA Entity와 Repository는 기존 `AnalysisStaticData` 패키지에서 직접 import하여 사용

---

## 1. Oracle 테이블 DDL

**목적**: 분석 전용 금융기관 분포 테이블 생성 및 시퀀스 설정
**역할**: 피어슨 상관분석에 사용될 독립변수(구별 은행 밀도) 데이터 저장소 구축

```sql
-- 기존 테이블과 데이터를 완전히 삭제
DROP TABLE ANALYSIS_BANKCOUNT_STATISTICS CASCADE CONSTRAINTS PURGE;
DROP SEQUENCE SEQ_ANALYSIS_BANKCOUNT_STATISTICS;

-- 분석용 은행 지점 개수 테이블 생성
CREATE TABLE ANALYSIS_BANKCOUNT_STATISTICS (
    ID                      NUMBER,                     -- 제한 없음
    SIGUNGU                 VARCHAR2(4000),             -- 최대 크기
    DONG                    VARCHAR2(4000),             -- 최대 크기
    WOORI_BANK              NUMBER,                     -- 우리은행
    SC_BANK                 NUMBER,                     -- SC제일은행
    KB_BANK                 NUMBER,                     -- KB국민은행
    SHINHAN_BANK            NUMBER,                     -- 신한은행
    CITI_BANK               NUMBER,                     -- 한국씨티은행
    HANA_BANK               NUMBER,                     -- KEB하나은행
    IBK_BANK                NUMBER,                     -- IBK기업은행
    NH_BANK                 NUMBER,                     -- NH농협은행
    SUHYUP_BANK             NUMBER,                     -- 수협은행
    KDB_BANK                NUMBER,                     -- KDB산업은행
    EXIM_BANK               NUMBER,                     -- 한국수출입은행
    FOREIGN_BANK            NUMBER                      -- 외국은행
);

-- 시퀀스 생성
CREATE SEQUENCE SEQ_ANALYSIS_BANKCOUNT_STATISTICS 
    START WITH 1 
    INCREMENT BY 1 
    NOCACHE
    NOCYCLE;

-- 확인
DESC ANALYSIS_BANKCOUNT_STATISTICS;
SELECT COUNT(*) FROM ANALYSIS_BANKCOUNT_STATISTICS;
```

## 2. JPA Entity

**목적**: 분석용 은행 지점 개수 테이블과 Java 객체 간 ORM 매핑
**역할**: 데이터베이스 CRUD 작업을 위한 엔티티 클래스 정의

```java
package com.WhereHouse.AnalysisData.bankcount.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "ANALYSIS_BANKCOUNT_STATISTICS")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AnalysisBankCountStatistics {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "analysis_bankcount_seq")
    @SequenceGenerator(name = "analysis_bankcount_seq", sequenceName = "SEQ_ANALYSIS_BANKCOUNT_STATISTICS", allocationSize = 1)
    @Column(name = "ID")
    private Long id;

    @Column(name = "SIGUNGU", length = 100)
    private String sigungu;

    @Column(name = "DONG", length = 100)
    private String dong;

    @Column(name = "WOORI_BANK")
    private Integer wooriBankCount;

    @Column(name = "SC_BANK")
    private Integer scBankCount;

    @Column(name = "KB_BANK")
    private Integer kbBankCount;

    @Column(name = "SHINHAN_BANK")
    private Integer shinhanBankCount;

    @Column(name = "CITI_BANK")
    private Integer citiBankCount;

    @Column(name = "HANA_BANK")
    private Integer hanaBankCount;

    @Column(name = "IBK_BANK")
    private Integer ibkBankCount;

    @Column(name = "NH_BANK")
    private Integer nhBankCount;

    @Column(name = "SUHYUP_BANK")
    private Integer suhyupBankCount;

    @Column(name = "KDB_BANK")
    private Integer kdbBankCount;

    @Column(name = "EXIM_BANK")
    private Integer eximBankCount;

    @Column(name = "FOREIGN_BANK")
    private Integer foreignBankCount;
}
```

## 3. Repository

**목적**: 분석용 은행 지점 개수 데이터에 대한 데이터 접근 계층 구현
**역할**: JPA 기반 CRUD 연산 및 맞춤형 쿼리 메서드 제공 (구별 은행 밀도 조회, 데이터 검증용)

```java
package com.WhereHouse.AnalysisData.bankcount.repository;

import com.WhereHouse.AnalysisData.bankcount.entity.AnalysisBankCountStatistics;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface AnalysisBankCountRepository extends JpaRepository<AnalysisBankCountStatistics, Long> {
    
    List<AnalysisBankCountStatistics> findBySigungu(String sigungu);
    
    Optional<AnalysisBankCountStatistics> findBySigunguAndDong(String sigungu, String dong);
    
    boolean existsBySigunguAndDong(String sigungu, String dong);
    
    @Query("SELECT COUNT(a) FROM AnalysisBankCountStatistics a")
    long countAnalysisData();
    
    @Query("SELECT a.sigungu, SUM(a.wooriBankCount + a.scBankCount + a.kbBankCount + a.shinhanBankCount + " +
           "a.citiBankCount + a.hanaBankCount + a.ibkBankCount + a.nhBankCount + " +
           "a.suhyupBankCount + a.kdbBankCount + a.eximBankCount + a.foreignBankCount) as totalBanks " +
           "FROM AnalysisBankCountStatistics a GROUP BY a.sigungu ORDER BY totalBanks DESC")
    List<Object[]> findDistrictBankDensityRanking();
}
```

## 4. 은행 지점 개수 데이터 분석용 처리 Component

**목적**: 원본 은행 지점 개수 데이터를 분석용 테이블로 변환하는 비즈니스 로직 처리
**역할**: 
- 기존 `FINANCIAL_INSTITUTION` 테이블에서 서울시 동별 데이터 조회
- `CREATED_AT` 필드 제외한 모든 은행 지점 개수 필드 복사
- 데이터 품질 검증 및 구별 은행 밀도 순위 로깅

```java
package com.WhereHouse.AnalysisData.bankcount.processor;

import com.WhereHouse.AnalysisData.bankcount.entity.AnalysisBankCountStatistics;
import com.WhereHouse.AnalysisData.bankcount.repository.AnalysisBankCountRepository;
// 원본 데이터 접근을 위한 기존 패키지 import
import com.WhereHouse.AnalysisStaticData.FinancialInstitutionInfoSave.entity.FinancialInstitution;
import com.WhereHouse.AnalysisStaticData.FinancialInstitutionInfoSave.repository.FinancialInstitutionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * 은행 지점 개수 데이터 분석용 테이블 생성 처리 컴포넌트
 * 
 * 기존 FINANCIAL_INSTITUTION 테이블에서 데이터를 조회하여
 * 분석 전용 ANALYSIS_BANKCOUNT_STATISTICS 테이블로 복사하는 작업을 수행한다.
 * 
 * 주요 기능:
 * - 원본 은행 지점 개수 데이터 조회 및 검증
 * - CREATED_AT 필드 제외한 모든 은행 지점 개수 필드 복사
 * - 분석용 테이블 데이터 품질 검증
 * - 구별 은행 밀도 순위 로깅
 * 
 * @author Safety Analysis System
 * @since 1.0
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class BankCountDataProcessor {

    // 원본 은행 지점 개수 테이블 접근을 위한 Repository
    private final FinancialInstitutionRepository originalFinancialRepository;
    
    // 분석용 은행 지점 개수 테이블 접근을 위한 Repository  
    private final AnalysisBankCountRepository analysisBankCountRepository;

    /**
     * 은행 지점 개수 데이터 분석용 테이블 생성 메인 프로세스
     * 
     * 작업 순서:
     * 1. 기존 분석용 데이터 존재 여부 확인
     * 2. 원본 금융기관 데이터 조회 및 검증
     * 3. 데이터 변환 및 분석용 테이블 저장
     * 4. 데이터 품질 검증 및 결과 로깅
     */
    @Transactional
    public void processAnalysisBankCountData() {
        log.info("=== 은행 지점 개수 데이터 분석용 테이블 생성 작업 시작 ===");
        
        // Step 1: 기존 분석용 데이터 중복 처리 방지를 위한 존재 여부 확인
        long existingAnalysisDataCount = analysisBankCountRepository.count();
        if (existingAnalysisDataCount > 0) {
            log.info("분석용 은행 지점 개수 데이터가 이미 존재합니다 (총 {} 개). 작업을 스킵합니다.", existingAnalysisDataCount);
            return;
        }

        // Step 2: 원본 은행 지점 개수 데이터 조회 및 검증
        List<FinancialInstitution> originalFinancialDataList = originalFinancialRepository.findAll();
        if (originalFinancialDataList.isEmpty()) {
            log.warn("원본 은행 지점 개수 데이터가 존재하지 않습니다. 먼저 FinancialInstitutionDataLoader를 통해 CSV 데이터를 로드해주세요.");
            return;
        }
        
        log.info("원본 은행 지점 개수 데이터 {} 개 동 발견", originalFinancialDataList.size());

        // Step 3: 데이터 변환 및 저장 작업 수행
        int successfulConversionCount = 0;  // 성공적으로 변환된 데이터 개수
        int failedConversionCount = 0;      // 변환 실패한 데이터 개수

        for (FinancialInstitution originalFinancialData : originalFinancialDataList) {
            try {
                // 원본 데이터를 분석용 엔티티로 변환 (CREATED_AT 필드 제외)
                AnalysisBankCountStatistics analysisTargetBankCountData = convertToAnalysisEntity(originalFinancialData);
                
                // 분석용 테이블에 데이터 저장
                analysisBankCountRepository.save(analysisTargetBankCountData);
                successfulConversionCount++;
                
                log.debug("분석용 데이터 생성 완료: {} {} (총 은행 수: {} 개)", 
                    originalFinancialData.getSigungu(), originalFinancialData.getDong(),
                    calculateTotalBankCount(originalFinancialData));

            } catch (Exception dataConversionException) {
                log.error("분석용 데이터 생성 실패 - 구/동: {} {}, 오류: {}", 
                    originalFinancialData.getSigungu(), originalFinancialData.getDong(), 
                    dataConversionException.getMessage());
                failedConversionCount++;
            }
        }

        // Step 4: 변환 작업 결과 로깅
        log.info("은행 지점 개수 데이터 분석용 테이블 생성 작업 완료 - 성공: {} 개, 실패: {} 개", 
            successfulConversionCount, failedConversionCount);
        
        // Step 5: 최종 데이터 검증 및 품질 확인
        performFinalDataValidation();
        
        log.info("=== 은행 지점 개수 데이터 분석용 테이블 생성 작업 종료 ===");
    }
    
    /**
     * 원본 은행 지점 개수 엔티티를 분석용 엔티티로 변환
     * 
     * CREATED_AT 필드를 제외한 모든 은행 지점 개수 필드를 복사한다.
     * 
     * @param originalFinancialData 원본 은행 지점 개수 엔티티
     * @return 분석용 은행 지점 개수 엔티티
     */
    private AnalysisBankCountStatistics convertToAnalysisEntity(FinancialInstitution originalFinancialData) {
        return AnalysisBankCountStatistics.builder()
            // 기본 정보
            .sigungu(originalFinancialData.getSigungu())               // 시군구명
            .dong(originalFinancialData.getDong())                     // 동명
            
            // 각 은행별 지점 수
            .wooriBankCount(originalFinancialData.getWooriBankCount()) // 우리은행 지점 수
            .scBankCount(originalFinancialData.getScBankCount())       // SC제일은행 지점 수
            .kbBankCount(originalFinancialData.getKbBankCount())       // KB국민은행 지점 수
            .shinhanBankCount(originalFinancialData.getShinhanBankCount()) // 신한은행 지점 수
            .citiBankCount(originalFinancialData.getCitiBankCount())   // 한국씨티은행 지점 수
            .hanaBankCount(originalFinancialData.getHanaBankCount())   // KEB하나은행 지점 수
            .ibkBankCount(originalFinancialData.getIbkBankCount())     // IBK기업은행 지점 수
            .nhBankCount(originalFinancialData.getNhBankCount())       // NH농협은행 지점 수
            .suhyupBankCount(originalFinancialData.getSuhyupBankCount()) // 수협은행 지점 수
            .kdbBankCount(originalFinancialData.getKdbBankCount())     // KDB산업은행 지점 수
            .eximBankCount(originalFinancialData.getEximBankCount())   // 한국수출입은행 지점 수
            .foreignBankCount(originalFinancialData.getForeignBankCount()) // 외국은행 지점 수
            .build();
    }
    
    /**
     * 개별 지역의 총 은행 지점 수 계산
     * 
     * @param financialData 금융기관 분포 데이터
     * @return 총 은행 지점 수
     */
    private int calculateTotalBankCount(FinancialInstitution financialData) {
        return (financialData.getWooriBankCount() != null ? financialData.getWooriBankCount() : 0) +
               (financialData.getScBankCount() != null ? financialData.getScBankCount() : 0) +
               (financialData.getKbBankCount() != null ? financialData.getKbBankCount() : 0) +
               (financialData.getShinhanBankCount() != null ? financialData.getShinhanBankCount() : 0) +
               (financialData.getCitiBankCount() != null ? financialData.getCitiBankCount() : 0) +
               (financialData.getHanaBankCount() != null ? financialData.getHanaBankCount() : 0) +
               (financialData.getIbkBankCount() != null ? financialData.getIbkBankCount() : 0) +
               (financialData.getNhBankCount() != null ? financialData.getNhBankCount() : 0) +
               (financialData.getSuhyupBankCount() != null ? financialData.getSuhyupBankCount() : 0) +
               (financialData.getKdbBankCount() != null ? financialData.getKdbBankCount() : 0) +
               (financialData.getEximBankCount() != null ? financialData.getEximBankCount() : 0) +
               (financialData.getForeignBankCount() != null ? financialData.getForeignBankCount() : 0);
    }
    
    /**
     * 분석용 데이터의 최종 검증 및 품질 확인
     * 
     * 작업 내용:
     * - 전체 데이터 개수 확인
     * - 구별 은행 밀도 순위 상위 5개 로깅
     * - 데이터 검증 과정에서 발생하는 오류 처리
     */
    private void performFinalDataValidation() {
        try {
            // 최종 저장된 분석용 데이터 개수 확인
            long finalAnalysisDataCount = analysisBankCountRepository.count();
            log.info("최종 분석용 은행 지점 개수 데이터 저장 완료: {} 개 동", finalAnalysisDataCount);
            
            // 구별 은행 밀도 순위 조회 및 로깅 (피어슨 상관분석 검증용)
            List<Object[]> districtBankDensityRankingList = analysisBankCountRepository.findDistrictBankDensityRanking();
            log.info("서울시 구별 은행 밀도 순위 (상위 5개구):"););
            
            districtBankDensityRankingList.stream()
                .limit(5)
                .forEach(rankingRow -> {
                    String districtName = (String) rankingRow[0];         // 구 이름
                    Long totalBankCount = (Long) rankingRow[1];           // 총 은행 지점 수
                    log.info("  {} : {} 개 지점", districtName, totalBankCount);
                });
                
        } catch (Exception dataValidationException) {
            log.error("분석용 데이터 검증 과정에서 오류가 발생했습니다: {}", 
                dataValidationException.getMessage(), dataValidationException);
        }
    }
}
```

## 5. Main 처리 클래스 수정

**목적**: 전체 분석용 데이터 처리 작업에 은행 지점 개수 데이터 처리 추가
**역할**: 범죄 데이터에 이어서 은행 지점 개수 데이터 처리를 순차적으로 실행

```java
package com.WhereHouse.AnalysisData.main;

import com.WhereHouse.AnalysisData.crime.processor.CrimeDataProcessor;
import com.WhereHouse.AnalysisData.bankcount.processor.BankCountDataProcessor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class AnalysisDataProcessor implements CommandLineRunner {

    private final CrimeDataProcessor crimeDataProcessor;
    private final BankCountDataProcessor bankCountDataProcessor;
    // 향후 17개 ERD별 프로세서 추가 예정
    // private final CctvDataProcessor cctvDataProcessor;
    // ...

    @Override
    public void run(String... args) throws Exception {
        log.info("=== 안전성 분석용 데이터 처리 시작 ===");
        
        try {
            // 1. 범죄 데이터 처리
            log.info("1. 범죄 데이터 분석용 테이블 생성 시작");
            crimeDataProcessor.processAnalysisCrimeData();
            
            // 2. 은행 지점 개수 데이터 처리
            log.info("2. 은행 지점 개수 데이터 분석용 테이블 생성 시작");
            bankCountDataProcessor.processAnalysisBankCountData();
            
            // 향후 추가될 17개 ERD별 데이터 처리
            // 3. CCTV 데이터 처리
            // log.info("3. CCTV 데이터 분석용 테이블 생성 시작");
            // cctvDataProcessor.processAnalysisCctvData();
            
            // ... 추가 프로세서들
            
        } catch (Exception e) {
            log.error("안전성 분석용 데이터 처리 중 오류 발생", e);
            throw e;
        }
        
        log.info("=== 안전성 분석용 데이터 처리 완료 ===");
    }
}
```

## 실행 방법 및 검증

### 1. 데이터베이스 설정
1. Oracle DB에 DDL 스크립트 실행
2. 테이블 생성 및 시퀀스 확인

### 2. 애플리케이션 실행
```bash
./gradlew bootRun
```

### 3. 실행 결과 검증
```sql
-- 데이터 개수 확인
SELECT COUNT(*) FROM ANALYSIS_BANKCOUNT_STATISTICS;

-- 구별 은행 밀도 확인
SELECT SIGUNGU, 
       SUM(WOORI_BANK + SC_BANK + KB_BANK + SHINHAN_BANK + 
           CITI_BANK + HANA_BANK + IBK_BANK + NH_BANK + 
           SUHYUP_BANK + KDB_BANK + EXIM_BANK + FOREIGN_BANK) as TOTAL_BANKS
FROM ANALYSIS_BANKCOUNT_STATISTICS 
GROUP BY SIGUNGU 
ORDER BY TOTAL_BANKS DESC;
```

## 예상 처리 결과

### 로그 출력 예시
```
=== 안전성 분석용 데이터 처리 시작 ===
1. 범죄 데이터 분석용 테이블 생성 시작
범죄 데이터 분석용 테이블 생성 작업 완료 - 성공: 25 개, 실패: 0 개
2. 은행 지점 개수 데이터 분석용 테이블 생성 시작
원본 은행 지점 개수 데이터 423 개 동 발견
은행 지점 개수 데이터 분석용 테이블 생성 작업 완료 - 성공: 423 개, 실패: 0 개
서울시 구별 은행 밀도 순위 (상위 5개구):
  강남구 : 234 개 지점
  중구 : 189 개 지점
  종로구 : 156 개 지점
  ...
=== 안전성 분석용 데이터 처리 완료 ===
```

이 시스템은 향후 피어슨 상관분석에서 독립변수로 활용될 구별 은행 밀도 계산의 기초 데이터를 제공합니다.