# 서울시 주민센터 데이터 분석용 Oracle DB 설계 및 JPA 구현

**프로젝트명:** 안전성 점수 계산 시스템 - 서울시 주민센터 통계 분석 데이터 처리  
**버전:** 1.1  
**작성일:** 2025.08.31  
**목적:** 서울시 주민센터 정보를 피어슨 상관분석 계산에 활용하기 위한 분석용 테이블 구축

---

## 프로젝트 개요

### 데이터 처리 목표
기존 `RESIDENT_CENTER` 테이블의 원본 데이터를 분석 전용 테이블 `ANALYSIS_RESIDENT_CENTER_STATISTICS`로 복사하여 안전성 점수 계산 시스템에서 활용할 수 있도록 데이터 구조를 최적화한다.

### 핵심 특징
- **Kakao Map API 연동**: 주소 정보를 바탕으로 위도(LATITUDE), 경도(LONGITUDE) 필드 정확한 계산 및 저장
- **주소 전처리**: API가 인식할 수 있도록 주소 정제 로직 적용
- **분석 전용 설계**: 제약조건 없이 순수 분석 목적의 테이블 구조
- **기존 인터페이스 재사용**: 원천 데이터 접근에 필요한 JPA Entity와 Repository는 기존 `AnalysisStaticData` 패키지에서 직접 import하여 사용
- **자동 인코딩 처리**: Spring Boot의 UriComponentsBuilder가 한글 주소를 자동으로 처리하여 안정성 확보

---

## 1. Oracle 테이블 DDL

**목적**: 분석 전용 서울시 주민센터 통계 테이블 생성 및 시퀀스 설정
**역할**: 피어슨 상관분석에 사용될 독립변수(행정서비스 접근성) 데이터 저장소 구축

```sql
-- 기존 테이블과 데이터를 완전히 삭제
DROP TABLE ANALYSIS_RESIDENT_CENTER_STATISTICS CASCADE CONSTRAINTS PURGE;
DROP SEQUENCE SEQ_ANALYSIS_RESIDENT_CENTER_STATISTICS;

-- 분석용 서울시 주민센터 통계 테이블 생성
CREATE TABLE ANALYSIS_RESIDENT_CENTER_STATISTICS (
    ID                      NUMBER,                     -- 제한 없음
    SIDO                    VARCHAR2(4000),             -- 최대 크기
    SIGUNGU                 VARCHAR2(4000),             -- 최대 크기
    EUPMEONDONG             VARCHAR2(4000),             -- 최대 크기
    ADDRESS                 VARCHAR2(4000),             -- 최대 크기
    LATITUDE                NUMBER(10,7),               -- 위도 좌표
    LONGITUDE               NUMBER(10,7)                -- 경도 좌표
);

-- 시퀀스 생성
CREATE SEQUENCE SEQ_ANALYSIS_RESIDENT_CENTER_STATISTICS 
    START WITH 1 
    INCREMENT BY 1 
    NOCACHE
    NOCYCLE;

-- 확인
DESC ANALYSIS_RESIDENT_CENTER_STATISTICS;
SELECT COUNT(*) FROM ANALYSIS_RESIDENT_CENTER_STATISTICS;
```

## 2. JPA Entity

**목적**: 분석용 서울시 주민센터 통계 테이블과 Java 객체 간 ORM 매핑
**역할**: 데이터베이스 CRUD 작업을 위한 엔티티 클래스 정의 (좌표 정보 포함)

```java
package com.WhereHouse.AnalysisData.residentcenter.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "ANALYSIS_RESIDENT_CENTER_STATISTICS")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AnalysisResidentCenterStatistics {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "analysis_resident_center_seq")
    @SequenceGenerator(name = "analysis_resident_center_seq", sequenceName = "SEQ_ANALYSIS_RESIDENT_CENTER_STATISTICS", allocationSize = 1)
    @Column(name = "ID")
    private Long id;

    @Column(name = "SIDO")
    private String sido;

    @Column(name = "SIGUNGU")
    private String sigungu;

    @Column(name = "EUPMEONDONG")
    private String eupmeondong;

    @Column(name = "ADDRESS")
    private String address;

    @Column(name = "LATITUDE")
    private Double latitude;

    @Column(name = "LONGITUDE")
    private Double longitude;
}
```

## 3. Repository

**목적**: 분석용 서울시 주민센터 통계 데이터에 대한 데이터 접근 계층 구현
**역할**: JPA 기반 CRUD 연산 및 맞춤형 쿼리 메서드 제공 (구별 주민센터 수 조회, 좌표 기반 검색)

```java
package com.WhereHouse.AnalysisData.residentcenter.repository;

import com.WhereHouse.AnalysisData.residentcenter.entity.AnalysisResidentCenterStatistics;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface AnalysisResidentCenterRepository extends JpaRepository<AnalysisResidentCenterStatistics, Long> {
    
    List<AnalysisResidentCenterStatistics> findBySigungu(String sigungu);
    
    List<AnalysisResidentCenterStatistics> findByEupmeondong(String eupmeondong);
    
    @Query("SELECT COUNT(a) FROM AnalysisResidentCenterStatistics a")
    long countAnalysisData();
    
    @Query("SELECT a.sigungu, COUNT(a) FROM AnalysisResidentCenterStatistics a GROUP BY a.sigungu ORDER BY COUNT(a) DESC")
    List<Object[]> findResidentCenterCountBySigungu();
    
    @Query("SELECT a FROM AnalysisResidentCenterStatistics a WHERE a.latitude IS NOT NULL AND a.longitude IS NOT NULL")
    List<AnalysisResidentCenterStatistics> findAllWithCoordinates();
    
    @Query("SELECT COUNT(a) FROM AnalysisResidentCenterStatistics a WHERE a.latitude IS NULL OR a.longitude IS NULL")
    long countMissingCoordinates();
    
    @Query("SELECT a.eupmeondong, COUNT(a) FROM AnalysisResidentCenterStatistics a GROUP BY a.eupmeondong ORDER BY COUNT(a) DESC")
    List<Object[]> findResidentCenterCountByEupmeondong();
}
```

## 4. Kakao Map API 좌표 계산 서비스

**목적**: Kakao Local API를 활용한 정확한 위도, 경도 좌표 계산
**역할**: 주소 전처리 및 실제 API 호출을 통한 좌표 변환
**특징**: Spring Boot의 UriComponentsBuilder 자동 인코딩 활용

```java
package com.WhereHouse.AnalysisData.residentcenter.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

/**
 * 개선된 서울시 주민센터 좌표 계산 서비스
 * 
 * 지번주소/도로명주소 특화 전처리 및 다중 시도 로직 추가
 * Kakao Local API를 활용하여 주소를 정확한 위도, 경도 좌표로 변환한다.
 * Spring Boot의 UriComponentsBuilder가 한글 인코딩을 자동 처리한다.
 * 
 * @author Safety Analysis System
 * @since 1.1
 */
@Service
@Slf4j
public class ResidentCenterCoordinateService {

    @Value("${kakao.api.key}")
    private String kakaoApiKey;
    
    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    
    private static final String KAKAO_LOCAL_API_URL = "https://dapi.kakao.com/v2/local/search/address.json";
    
    // API 호출 통계
    private int totalApiCalls = 0;
    private int successfulApiCalls = 0;
    private int failedApiCalls = 0;
    
    public ResidentCenterCoordinateService() {
        this.restTemplate = new RestTemplate();
        this.objectMapper = new ObjectMapper();
    }

    /**
     * 주소 기반 좌표 계산 (개선된 버전)
     * 
     * @param address 주민센터 주소
     * @return 위도, 경도 배열 [latitude, longitude] 또는 null
     */
    public Double[] calculateCoordinatesFromAddress(String address) {
        if (address == null || address.trim().isEmpty()) {
            log.warn("주소가 비어있습니다.");
            return null;
        }
        
        log.debug("주민센터 주소 좌표 계산 시작: {}", address);
        
        // 주소 변형 생성 및 순차 시도
        String[] addressVariations = generateAddressVariations(address);
        
        for (String variation : addressVariations) {
            Double[] coordinates = callKakaoGeocodingApi(variation);
            if (coordinates != null) {
                log.debug("주소 좌표 계산 성공 - 변형: {}, 좌표: ({}, {})", 
                    variation, coordinates[0], coordinates[1]);
                return coordinates;
            }
        }
        
        log.debug("주소 좌표 계산 실패: {}", address);
        return null;
    }

    /**
     * 주민센터 주소 변형 생성 (서울시 행정구역 특화)
     * 
     * @param address 원본 주소
     * @return 주소 변형 배열
     */
    private String[] generateAddressVariations(String address) {
        String original = address.trim();
        
        return new String[] {
            original,                                           // 원본 주소
            cleanGovernmentAddress(original),                   // 기관명 정제
            removeGovernmentInfo(cleanGovernmentAddress(original)), // 기관 관련 정보 제거
            extractCoreAddress(cleanGovernmentAddress(original)),   // 핵심 주소만
            removeDetailInfo(cleanGovernmentAddress(original)),     // 상세정보 제거
            extractDistrictOnly(cleanGovernmentAddress(original)),  // 구 단위까지만
            extractDongOnly(cleanGovernmentAddress(original)),      // 동 단위까지만
            addSeoulPrefix(cleanGovernmentAddress(original))        // 서울시 prefix 추가
        };
    }

    /**
     * 공공기관 주소 전용 정제
     * 
     * @param address 원본 주소
     * @return 정제된 주소
     */
    private String cleanGovernmentAddress(String address) {
        if (address == null || address.trim().isEmpty()) {
            return address;
        }
        
        String cleaned = address.trim();
        
        // 1. 괄호 안의 내용 제거
        cleaned = cleaned.replaceAll("\\([^)]*\\)", "").trim();
        
        // 2. 서울시/서울특별시 표기 통일
        cleaned = cleaned.replaceAll("서울특별시", "서울시").trim();
        
        // 3. 연속된 공백을 하나로 통합
        cleaned = cleaned.replaceAll("\\s+", " ").trim();
        
        // 4. 끝에 남은 쉼표나 특수문자 제거
        cleaned = cleaned.replaceAll("[,\\-\\s]+$", "").trim();
        
        return cleaned.length() < 5 ? address : cleaned;
    }

    /**
     * 기관 관련 정보 제거 (주민센터 특화)
     * 
     * @param address 주소
     * @return 기관명이 제거된 주소
     */
    private String removeGovernmentInfo(String address) {
        if (address == null) return address;
        
        String cleaned = address.trim();
        
        // 주민센터 관련 키워드 제거
        cleaned = cleaned.replaceAll("(주민센터|동사무소|구민회관|시민회관|동주민센터|구청|동사무소)", "").trim();
        
        // 공공기관 관련 키워드 제거
        cleaned = cleaned.replaceAll("(행정복지센터|복지센터|민원실|청사)", "").trim();
        
        // 연속된 공백 정리
        cleaned = cleaned.replaceAll("\\s+", " ").trim();
        
        return cleaned.length() < 5 ? address : cleaned;
    }

    /**
     * 핵심 주소만 추출 (서울시 행정구역 기준)
     * 
     * @param address 주소
     * @return 핵심 주소
     */
    private String extractCoreAddress(String address) {
        if (address == null) return address;
        
        // 서울시 구 동 번지 형태만 남기기
        String[] parts = address.split("\\s+");
        StringBuilder core = new StringBuilder();
        
        int count = 0;
        for (String part : parts) {
            if (count >= 4) break; // 서울시, 구, 동, 번지 정도까지만
            
            // 숫자가 포함된 부분은 번지일 가능성이 높음
            if (part.matches(".*\\d+.*") || count < 3) {
                if (core.length() > 0) core.append(" ");
                core.append(part);
                count++;
            }
        }
        
        return core.toString().trim();
    }

    /**
     * 상세 정보 제거 (위치 관련 상대적 표현)
     * 
     * @param address 주소
     * @return 상세정보가 제거된 주소
     */
    private String removeDetailInfo(String address) {
        if (address == null) return address;
        
        String cleaned = address.trim();
        
        // 상대적 위치 표현 제거
        cleaned = cleaned.replaceAll("(내부|앞|뒤|옆|건너편|맞은편|근처|일대)", "").trim();
        
        // 층, 호수 정보 제거
        cleaned = cleaned.replaceAll("(\\d+층|\\d+호|지하\\d+|B\\d+|\\d+F)", "").trim();
        
        // 방향 정보 제거
        cleaned = cleaned.replaceAll("(동쪽|서쪽|남쪽|북쪽)", "").trim();
        
        return cleaned.replaceAll("\\s+", " ").trim();
    }

    /**
     * 구 단위까지만 추출
     * 
     * @param address 주소
     * @return 구 단위 주소
     */
    private String extractDistrictOnly(String address) {
        if (address == null) return address;
        
        String[] parts = address.split("\\s+");
        StringBuilder district = new StringBuilder();
        
        for (String part : parts) {
            if (district.length() > 0) district.append(" ");
            district.append(part);
            
            // 구로 끝나면 중단 (서울시는 모두 구 단위)
            if (part.endsWith("구")) {
                break;
            }
        }
        
        return district.toString().trim();
    }

    /**
     * 동 단위까지만 추출
     * 
     * @param address 주소
     * @return 동 단위 주소
     */
    private String extractDongOnly(String address) {
        if (address == null) return address;
        
        String[] parts = address.split("\\s+");
        StringBuilder dong = new StringBuilder();
        
        for (String part : parts) {
            if (dong.length() > 0) dong.append(" ");
            dong.append(part);
            
            // 동으로 끝나면 중단
            if (part.endsWith("동")) {
                break;
            }
        }
        
        return dong.toString().trim();
    }

    /**
     * 서울시 prefix 추가 (혹시 누락된 경우)
     * 
     * @param address 주소
     * @return 서울시가 추가된 주소
     */
    private String addSeoulPrefix(String address) {
        if (address == null) return address;
        
        String trimmed = address.trim();
        
        // 이미 서울시가 포함되어 있으면 그대로 반환
        if (trimmed.startsWith("서울") || trimmed.contains("서울")) {
            return trimmed;
        }
        
        // 구로 시작하는 경우 서울시 추가
        if (trimmed.matches("^[가-힣]+구\\s+.*")) {
            return "서울시 " + trimmed;
        }
        
        return trimmed;
    }

    /**
     * Kakao Local API를 호출하여 주소를 좌표로 변환
     * UriComponentsBuilder가 자동으로 한글 인코딩 처리
     * 
     * @param address 변환할 주소
     * @return 위도, 경도 배열 [latitude, longitude] 또는 null
     */
    private Double[] callKakaoGeocodingApi(String address) {
        totalApiCalls++;
        
        try {
            if (kakaoApiKey == null || kakaoApiKey.trim().isEmpty()) {
                log.error("Kakao API 키가 설정되지 않았습니다.");
                failedApiCalls++;
                return null;
            }
            
            // API URL 구성 - UriComponentsBuilder가 자동으로 한글 인코딩 처리
            String apiUrl = UriComponentsBuilder.fromHttpUrl(KAKAO_LOCAL_API_URL)
                    .queryParam("query", address)
                    .build()
                    .toUriString();
            
            // HTTP 헤더 설정
            HttpHeaders headers = new HttpHeaders();
            headers.set("Authorization", "KakaoAK " + kakaoApiKey);
            headers.setContentType(MediaType.APPLICATION_JSON);
            
            HttpEntity<String> entity = new HttpEntity<>(headers);
            
            // API 호출
            ResponseEntity<String> response = restTemplate.exchange(
                apiUrl, HttpMethod.GET, entity, String.class
            );
            
            if (response.getStatusCode() == HttpStatus.OK) {
                Double[] coordinates = parseKakaoApiResponse(response.getBody(), address);
                if (coordinates != null) {
                    successfulApiCalls++;
                } else {
                    failedApiCalls++;
                }
                return coordinates;
            } else {
                failedApiCalls++;
                return null;
            }
            
        } catch (Exception e) {
            log.debug("Kakao API 호출 실패 - 주소: {}, 오류: {}", address, e.getMessage());
            failedApiCalls++;
            return null;
        }
    }
    
    /**
     * Kakao API 응답을 파싱하여 좌표 추출
     * 
     * @param responseBody API 응답 JSON
     * @param originalAddress 원본 주소 (로깅용)
     * @return 위도, 경도 배열 [latitude, longitude] 또는 null
     */
    private Double[] parseKakaoApiResponse(String responseBody, String originalAddress) {
        try {
            JsonNode rootNode = objectMapper.readTree(responseBody);
            JsonNode documentsNode = rootNode.path("documents");
            
            if (documentsNode.isArray() && documentsNode.size() > 0) {
                // 첫 번째 결과 사용
                JsonNode firstResult = documentsNode.get(0);
                
                // 도로명주소 결과 우선 선택
                JsonNode roadAddressNode = firstResult.path("road_address");
                if (!roadAddressNode.isMissingNode() && !roadAddressNode.isNull()) {
                    return extractCoordinatesFromNode(roadAddressNode);
                }
                
                // 도로명주소가 없으면 지번주소 사용
                JsonNode addressNode = firstResult.path("address");
                if (!addressNode.isMissingNode() && !addressNode.isNull()) {
                    return extractCoordinatesFromNode(addressNode);
                }
            }
            
            return null;
            
        } catch (Exception e) {
            log.debug("Kakao API 응답 파싱 실패 - 주소: {}", originalAddress);
            return null;
        }
    }
    
    /**
     * JSON 노드에서 좌표 정보 추출
     * 
     * @param node 좌표 정보가 포함된 JSON 노드
     * @return 위도, 경도 배열 [latitude, longitude] 또는 null
     */
    private Double[] extractCoordinatesFromNode(JsonNode node) {
        try {
            String xStr = node.path("x").asText(); // 경도
            String yStr = node.path("y").asText(); // 위도
            
            if (!xStr.isEmpty() && !yStr.isEmpty()) {
                double longitude = Double.parseDouble(xStr);
                double latitude = Double.parseDouble(yStr);
                
                // 서울시 좌표 범위 검증
                if (isValidSeoulCoordinate(latitude, longitude)) {
                    return new Double[]{latitude, longitude};
                }
            }
            
            return null;
            
        } catch (NumberFormatException e) {
            return null;
        }
    }
    
    /**
     * 서울시 영역 내 좌표인지 검증 (더 정밀한 범위)
     * 
     * @param latitude 위도
     * @param longitude 경도
     * @return 유효한 서울시 좌표 여부
     */
    private boolean isValidSeoulCoordinate(double latitude, double longitude) {
        // 서울시 좌표 범위 (더 정밀한 범위)
        // 위도: 37.413 ~ 37.715 (서울시 남북 경계)
        // 경도: 126.764 ~ 127.184 (서울시 동서 경계)
        return latitude >= 37.413 && latitude <= 37.715 && 
               longitude >= 126.764 && longitude <= 127.184;
    }
    
    /**
     * API 호출 통계 출력
     */
    public void printApiStatistics() {
        log.info("=== 개선된 Kakao API 호출 통계 (서울시 주민센터) ===");
        log.info("총 호출 횟수: {}", totalApiCalls);
        log.info("성공 횟수: {} ({:.1f}%)", successfulApiCalls, 
            totalApiCalls > 0 ? (double) successfulApiCalls / totalApiCalls * 100 : 0);
        log.info("실패 횟수: {} ({:.1f}%)", failedApiCalls, 
            totalApiCalls > 0 ? (double) failedApiCalls / totalApiCalls * 100 : 0);
    }
}
```

## 5. 서울시 주민센터 데이터 분석용 처리 Component

**목적**: 원본 서울시 주민센터 데이터를 분석용 테이블로 변환하는 비즈니스 로직 처리
**역할**: 
- 기존 `RESIDENT_CENTER` 테이블에서 서울시 주민센터 데이터 조회
- 지정된 4개 필드만 복사
- Kakao API를 통한 정확한 좌표 계산 및 추가
- 데이터 품질 검증 및 구별 주민센터 수 로깅

```java
package com.WhereHouse.AnalysisData.residentcenter.processor;

import com.WhereHouse.AnalysisData.residentcenter.entity.AnalysisResidentCenterStatistics;
import com.WhereHouse.AnalysisData.residentcenter.repository.AnalysisResidentCenterRepository;
import com.WhereHouse.AnalysisData.residentcenter.service.ResidentCenterCoordinateService;
// 원본 데이터 접근을 위한 기존 패키지 import
import com.WhereHouse.AnalysisStaticData.ResidentCenterInfoSave.entity.ResidentCenter;
import com.WhereHouse.AnalysisStaticData.ResidentCenterInfoSave.repository.ResidentCenterRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * 서울시 주민센터 데이터 분석용 테이블 생성 처리 컴포넌트
 * 
 * 기존 RESIDENT_CENTER 테이블에서 데이터를 조회하여
 * 분석 전용 ANALYSIS_RESIDENT_CENTER_STATISTICS 테이블로 복사하는 작업을 수행한다.
 * 
 * 주요 기능:
 * - 원본 서울시 주민센터 통계 데이터 조회 및 검증
 * - 지정된 4개 필드만 복사 (sido, sigungu, eupmeondong, address)
 * - Kakao Local API를 통한 위도, 경도 좌표 계산 및 추가
 * - 분석용 테이블 데이터 품질 검증
 * - 구별 주민센터 수 및 동별 분포 로깅
 * 
 * @author Safety Analysis System
 * @since 1.1
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class ResidentCenterDataProcessor {

    // 원본 서울시 주민센터 테이블 접근을 위한 Repository
    private final ResidentCenterRepository originalResidentCenterRepository;
    
    // 분석용 서울시 주민센터 통계 테이블 접근을 위한 Repository  
    private final AnalysisResidentCenterRepository analysisResidentCenterRepository;
    
    // Kakao API 좌표 계산을 위한 서비스
    private final ResidentCenterCoordinateService coordinateService;

    /**
     * 서울시 주민센터 데이터 분석용 테이블 생성 메인 프로세스
     * 
     * 작업 순서:
     * 1. 기존 분석용 데이터 존재 여부 확인
     * 2. 원본 서울시 주민센터 데이터 조회 및 검증
     * 3. 데이터 변환 및 Kakao API 좌표 계산 후 분석용 테이블 저장
     * 4. 데이터 품질 검증 및 결과 로깅
     */
    @Transactional
    public void processAnalysisResidentCenterData() {
        log.info("=== 서울시 주민센터 데이터 분석용 테이블 생성 작업 시작 ===");
        
        // Step 1: 기존 분석용 데이터 중복 처리 방지를 위한 존재 여부 확인
        long existingAnalysisDataCount = analysisResidentCenterRepository.count();
        if (existingAnalysisDataCount > 0) {
            log.info("분석용 서울시 주민센터 데이터가 이미 존재합니다 (총 {} 개). 작업을 스킵합니다.", existingAnalysisDataCount);
            return;
        }

        // Step 2: 원본 서울시 주민센터 통계 데이터 조회 및 검증
        List<ResidentCenter> originalResidentCenterDataList = originalResidentCenterRepository.findAll();
        if (originalResidentCenterDataList.isEmpty()) {
            log.warn("원본 서울시 주민센터 통계 데이터가 존재하지 않습니다. 먼저 ResidentCenterDataLoader를 통해 CSV 데이터를 로드해주세요.");
            return;
        }
        
        log.info("원본 서울시 주민센터 통계 데이터 {} 개 발견", originalResidentCenterDataList.size());

        // Step 3: 데이터 변환 및 저장 작업 수행
        int successfulConversionCount = 0;      // 성공적으로 변환된 데이터 개수
        int failedConversionCount = 0;          // 변환 실패한 데이터 개수
        int coordinateCalculationSuccessCount = 0; // 좌표 계산 성공 개수
        int coordinateCalculationFailedCount = 0;  // 좌표 계산 실패 개수

        // 처리 진행률 추적
        int processedCount = 0;
        int totalCount = originalResidentCenterDataList.size();
        int logInterval = Math.max(1, totalCount / 10); // 10% 간격으로 로그 출력

        for (ResidentCenter originalResidentCenterData : originalResidentCenterDataList) {
            processedCount++;
            
            try {
                // 원본 데이터를 분석용 엔티티로 변환
                AnalysisResidentCenterStatistics analysisTargetResidentCenterData = convertToAnalysisEntity(originalResidentCenterData);
                
                // Kakao API를 통한 좌표 계산 및 설정
                Double[] coordinates = calculateCoordinatesForResidentCenter(originalResidentCenterData);
                if (coordinates != null) {
                    analysisTargetResidentCenterData.setLatitude(coordinates[0]);
                    analysisTargetResidentCenterData.setLongitude(coordinates[1]);
                    coordinateCalculationSuccessCount++;
                } else {
                    coordinateCalculationFailedCount++;
                }
                
                // 분석용 테이블에 데이터 저장
                analysisResidentCenterRepository.save(analysisTargetResidentCenterData);
                successfulConversionCount++;
                
                log.debug("분석용 데이터 생성 완료: {} {} (좌표: {}, {})", 
                    originalResidentCenterData.getSigungu(),
                    originalResidentCenterData.getEupmeondong(),
                    coordinates != null ? coordinates[0] : "없음",
                    coordinates != null ? coordinates[1] : "없음");

                // 진행률 로그 (10% 간격)
                if (processedCount % logInterval == 0 || processedCount == totalCount) {
                    double progressPercentage = (double) processedCount / totalCount * 100;
                    log.info("진행률: {:.1f}% 완료 ({}/{})", progressPercentage, processedCount, totalCount);
                }

            } catch (Exception dataConversionException) {
                log.error("분석용 데이터 생성 실패 - 주민센터: {} {}, 오류: {}", 
                    originalResidentCenterData.getSigungu(), 
                    originalResidentCenterData.getEupmeondong(),
                    dataConversionException.getMessage());
                failedConversionCount++;
            }
        }

        // Step 4: 변환 작업 결과 로깅
        log.info("서울시 주민센터 데이터 분석용 테이블 생성 작업 완료");
        log.info("- 데이터 변환: 성공 {} 개, 실패 {} 개", successfulConversionCount, failedConversionCount);
        log.info("- 좌표 계산: 성공 {} 개, 실패 {} 개", coordinateCalculationSuccessCount, coordinateCalculationFailedCount);
        
        // Step 5: 최종 데이터 검증 및 품질 확인
        performFinalDataValidation();
        
        log.info("=== 서울시 주민센터 데이터 분석용 테이블 생성 작업 종료 ===");
    }
    
    /**
     * 원본 서울시 주민센터 엔티티를 분석용 엔티티로 변환
     * 
     * 지정된 4개 필드만 복사한다.
     * 좌표 정보는 별도 메서드에서 계산하여 설정한다.
     * 
     * @param originalResidentCenterData 원본 서울시 주민센터 엔티티
     * @return 분석용 서울시 주민센터 통계 엔티티
     */
    private AnalysisResidentCenterStatistics convertToAnalysisEntity(ResidentCenter originalResidentCenterData) {
        return AnalysisResidentCenterStatistics.builder()
            // 지정된 4개 필드만 복사
            .sido(originalResidentCenterData.getSido())                           // 시도
            .sigungu(originalResidentCenterData.getSigungu())                     // 시군구
            .eupmeondong(originalResidentCenterData.getEupmeondong())             // 읍면동
            .address(originalResidentCenterData.getAddress())                     // 주소
            
            // 좌표 정보는 별도 설정 (초기값 null)
            .latitude(null)
            .longitude(null)
            .build();
    }
    
    /**
     * 서울시 주민센터 주소 정보 기반 Kakao API 좌표 계산
     * 
     * 주소를 활용하여 Kakao Local API로 좌표를 계산한다.
     * 
     * @param residentCenterData 원본 서울시 주민센터 데이터
     * @return 위도, 경도 배열 [latitude, longitude] 또는 null
     */
    private Double[] calculateCoordinatesForResidentCenter(ResidentCenter residentCenterData) {
        try {
            // 주소 기반 좌표 계산
            if (residentCenterData.getAddress() != null && !residentCenterData.getAddress().trim().isEmpty()) {
                Double[] coordinates = coordinateService.calculateCoordinatesFromAddress(residentCenterData.getAddress());
                if (coordinates != null) {
                    return coordinates;
                }
            }
            
            log.debug("좌표 계산 실패 - 주민센터: {} {}, 주소 정보 부족", 
                residentCenterData.getSigungu(), residentCenterData.getEupmeondong());
            return null;
            
        } catch (Exception coordinateCalculationException) {
            log.error("좌표 계산 중 오류 발생 - 주민센터: {} {}, 오류: {}", 
                residentCenterData.getSigungu(), 
                residentCenterData.getEupmeondong(),
                coordinateCalculationException.getMessage());
            return null;
        }
    }
    
    /**
     * 분석용 데이터의 최종 검증 및 품질 확인
     * 
     * 작업 내용:
     * - 전체 데이터 개수 확인
     * - 구별 주민센터 수 상위 5개 로깅
     * - 동별 주민센터 분포 로깅
     * - 좌표 정보 완성도 확인
     * - 데이터 검증 과정에서 발생하는 오류 처리
     */
    private void performFinalDataValidation() {
        try {
            // 최종 저장된 분석용 데이터 개수 확인
            long finalAnalysisDataCount = analysisResidentCenterRepository.count();
            log.info("최종 분석용 서울시 주민센터 데이터 저장 완료: {} 개", finalAnalysisDataCount);
            
            // 구별 주민센터 수 조회 및 로깅 (피어슨 상관분석 검증용)
            List<Object[]> residentCenterCountBySigunguList = analysisResidentCenterRepository.findResidentCenterCountBySigungu();
            log.info("구별 주민센터 수 순위 (상위 5개 구):");
            
            residentCenterCountBySigunguList.stream()
                .limit(5)
                .forEach(rankingRow -> {
                    String sigungu = (String) rankingRow[0];         // 시군구명
                    Long centerCount = (Long) rankingRow[1];         // 주민센터 수
                    log.info("  {} : {} 개", sigungu, centerCount);
                });
            
            // 동별 주민센터 분포 조회 및 로깅
            List<Object[]> residentCenterCountByEupmeondongList = analysisResidentCenterRepository.findResidentCenterCountByEupmeondong();
            log.info("동별 주민센터 분포 (상위 5개):");
            
            residentCenterCountByEupmeondongList.stream()
                .limit(5)
                .forEach(dongRow -> {
                    String eupmeondong = (String) dongRow[0];        // 읍면동명
                    Long dongCount = (Long) dongRow[1];              // 해당 동 주민센터 수
                    log.info("  {} : {} 개", eupmeondong, dongCount);
                });
            
            // 좌표 정보 완성도 확인
            long coordinateCompleteCount = analysisResidentCenterRepository.findAllWithCoordinates().size();
            long coordinateMissingCount = analysisResidentCenterRepository.countMissingCoordinates();
            
            log.info("좌표 정보 완성도:");
            log.info("  좌표 보유: {} 개 ({:.1f}%)", coordinateCompleteCount, 
                (double) coordinateCompleteCount / finalAnalysisDataCount * 100);
            log.info("  좌표 누락: {} 개 ({:.1f}%)", coordinateMissingCount,
                (double) coordinateMissingCount / finalAnalysisDataCount * 100);
                
        } catch (Exception dataValidationException) {
            log.error("분석용 데이터 검증 과정에서 오류가 발생했습니다: {}", 
                dataValidationException.getMessage(), dataValidationException);
        }
    }
}
```

## 6. Main 처리 클래스

**목적**: 전체 분석용 데이터 처리 작업의 통합 관리 및 실행
**역할**: 
- 애플리케이션 시작 시 자동 실행되는 메인 진입점 (`CommandLineRunner` 구현)
- 서울시 주민센터 데이터를 포함한 19개 ERD별 프로세서들의 순차적 호출 관리
- 전체 작업 진행 상황 로깅 및 예외 처리

```java
package com.WhereHouse.AnalysisData.main;

import com.WhereHouse.AnalysisData.residentcenter.processor.ResidentCenterDataProcessor;
import com.WhereHouse.AnalysisData.residentcenter.service.ResidentCenterCoordinateService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class AnalysisDataProcessor implements CommandLineRunner {

    private final ResidentCenterDataProcessor residentCenterDataProcessor;
    private final ResidentCenterCoordinateService coordinateService; // API 통계 확인용
    // 향후 18개 ERD별 프로세서 추가 예정

    @Override
    public void run(String... args) throws Exception {
        log.info("=== 안전성 분석용 데이터 처리 시작 ===");
        
        try {
            // 1. 서울시 주민센터 데이터 처리
            log.info("1. 서울시 주민센터 데이터 분석용 테이블 생성 시작");
            
            long startTime = System.currentTimeMillis();
            residentCenterDataProcessor.processAnalysisResidentCenterData();
            long endTime = System.currentTimeMillis();
            
            log.info("서울시 주민센터 데이터 처리 완료 - 소요시간: {}ms ({:.2f}초)", 
                endTime - startTime, (endTime - startTime) / 1000.0);
            
            // API 호출 통계 출력
            coordinateService.printApiStatistics();
            
            // 향후 추가될 18개 ERD별 데이터 처리
            // 2. 범죄 데이터 처리
            // log.info("2. 범죄 데이터 분석용 테이블 생성 시작");
            // crimeDataProcessor.processAnalysisCrimeData();
            
            // 3. 대형마트/백화점 데이터 처리
            // log.info("3. 대형마트/백화점 데이터 분석용 테이블 생성 시작");
            // martDataProcessor.processAnalysisMartData();
            
            // ... 추가 프로세서들
            
        } catch (Exception e) {
            log.error("안전성 분석용 데이터 처리 중 오류 발생", e);
            throw e;
        }
        
        log.info("=== 안전성 분석용 데이터 처리 완료 ===");
    }
}
```

## 7. 디버깅용 테스트 컨트롤러

**목적**: 개발 과정에서 각 컴포넌트를 개별적으로 테스트하기 위한 REST 엔드포인트 제공
**역할**: 좌표 계산 테스트, 데이터 상태 확인, 강제 처리 실행 등

```java
package com.WhereHouse.AnalysisData.residentcenter.controller;

import com.WhereHouse.AnalysisData.residentcenter.processor.ResidentCenterDataProcessor;
import com.WhereHouse.AnalysisData.residentcenter.service.ResidentCenterCoordinateService;
import com.WhereHouse.AnalysisData.residentcenter.repository.AnalysisResidentCenterRepository;
import com.WhereHouse.AnalysisStaticData.ResidentCenterInfoSave.repository.ResidentCenterRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

/**
 * 디버깅용 테스트 컨트롤러
 * 
 * 개발 과정에서 각 컴포넌트를 개별적으로 테스트하기 위한 엔드포인트 제공
 */
@RestController
@RequestMapping("/debug/resident-center")
@RequiredArgsConstructor
@Slf4j
public class ResidentCenterDebugController {

    private final ResidentCenterDataProcessor residentCenterDataProcessor;
    private final ResidentCenterCoordinateService coordinateService;
    private final AnalysisResidentCenterRepository analysisResidentCenterRepository;
    private final ResidentCenterRepository originalResidentCenterRepository;

    /**
     * 좌표 계산 테스트
     */
    @GetMapping("/test-coordinate")
    public ResponseEntity<Map<String, Object>> testCoordinate(
            @RequestParam(defaultValue = "서울특별시 종로구 청와대로 1") String address) {
        
        log.info("좌표 계산 테스트 시작 - 주소: {}", address);
        
        Map<String, Object> result = new HashMap<>();
        result.put("inputAddress", address);
        
        try {
            Double[] coordinates = coordinateService.calculateCoordinatesFromAddress(address);
            
            if (coordinates != null) {
                result.put("success", true);
                result.put("latitude", coordinates[0]);
                result.put("longitude", coordinates[1]);
                result.put("message", "좌표 계산 성공");
            } else {
                result.put("success", false);
                result.put("latitude", null);
                result.put("longitude", null);
                result.put("message", "좌표 계산 실패");
            }
            
        } catch (Exception e) {
            result.put("success", false);
            result.put("error", e.getMessage());
            result.put("message", "좌표 계산 중 오류 발생");
            log.error("좌표 계산 테스트 중 오류", e);
        }
        
        // API 통계 출력
        coordinateService.printApiStatistics();
        
        return ResponseEntity.ok(result);
    }

    /**
     * 원본 서울시 주민센터 데이터 상태 확인
     */
    @GetMapping("/check-original-data")
    public ResponseEntity<Map<String, Object>> checkOriginalData() {
        Map<String, Object> result = new HashMap<>();
        
        try {
            long originalCount = originalResidentCenterRepository.count();
            result.put("originalDataCount", originalCount);
            
            if (originalCount > 0) {
                // 샘플 데이터 조회
                var sampleData = originalResidentCenterRepository.findAll().stream()
                    .limit(3)
                    .map(data -> Map.of(
                        "id", data.getId(),
                        "sigungu", data.getSigungu(),
                        "eupmeondong", data.getEupmeondong(),
                        "address", data.getAddress() != null ? data.getAddress() : "주소없음"
                    ))
                    .toList();
                result.put("sampleData", sampleData);
                result.put("status", "원본 데이터 존재");
            } else {
                result.put("status", "원본 데이터 없음");
            }
            
        } catch (Exception e) {
            result.put("error", e.getMessage());
            result.put("status", "오류 발생");
            log.error("원본 데이터 확인 중 오류", e);
        }
        
        return ResponseEntity.ok(result);
    }

    /**
     * 분석용 서울시 주민센터 데이터 상태 확인
     */
    @GetMapping("/check-analysis-data")
    public ResponseEntity<Map<String, Object>> checkAnalysisData() {
        Map<String, Object> result = new HashMap<>();
        
        try {
            long analysisCount = analysisResidentCenterRepository.count();
            result.put("analysisDataCount", analysisCount);
            
            if (analysisCount > 0) {
                // 좌표 완성도 확인
                long coordinateCompleteCount = analysisResidentCenterRepository.findAllWithCoordinates().size();
                long coordinateMissingCount = analysisResidentCenterRepository.countMissingCoordinates();
                
                result.put("coordinateStats", Map.of(
                    "total", analysisCount,
                    "withCoordinates", coordinateCompleteCount,
                    "withoutCoordinates", coordinateMissingCount,
                    "completionRate", analysisCount > 0 ? (double) coordinateCompleteCount / analysisCount * 100 : 0
                ));
                
                // 샘플 데이터 조회
                var sampleData = analysisResidentCenterRepository.findAll().stream()
                    .limit(3)
                    .map(data -> Map.of(
                        "id", data.getId(),
                        "sigungu", data.getSigungu(),
                        "eupmeondong", data.getEupmeondong(),
                        "latitude", data.getLatitude(),
                        "longitude", data.getLongitude()
                    ))
                    .toList();
                result.put("sampleData", sampleData);
                result.put("status", "분석용 데이터 존재");
            } else {
                result.put("status", "분석용 데이터 없음");
            }
            
        } catch (Exception e) {
            result.put("error", e.getMessage());
            result.put("status", "오류 발생");
            log.error("분석용 데이터 확인 중 오류", e);
        }
        
        return ResponseEntity.ok(result);
    }

    /**
     * 서울시 주민센터 데이터 처리 강제 실행
     */
    @PostMapping("/force-process")
    public ResponseEntity<Map<String, Object>> forceProcess() {
        Map<String, Object> result = new HashMap<>();
        
        try {
            log.info("강제 서울시 주민센터 데이터 처리 시작");
            
            long startTime = System.currentTimeMillis();
            residentCenterDataProcessor.processAnalysisResidentCenterData();
            long endTime = System.currentTimeMillis();
            
            result.put("success", true);
            result.put("processingTimeMs", endTime - startTime);
            result.put("processingTimeSec", (endTime - startTime) / 1000.0);
            result.put("message", "데이터 처리 완료");
            
            // 최종 결과 확인
            long finalCount = analysisResidentCenterRepository.count();
            result.put("finalAnalysisDataCount", finalCount);
            
        } catch (Exception e) {
            result.put("success", false);
            result.put("error", e.getMessage());
            result.put("message", "데이터 처리 중 오류 발생");
            log.error("강제 데이터 처리 중 오류", e);
        }
        
        return ResponseEntity.ok(result);
    }

    /**
     * 분석용 데이터 초기화 (테스트용)
     */
    @DeleteMapping("/clear-analysis-data")
    public ResponseEntity<Map<String, Object>> clearAnalysisData() {
        Map<String, Object> result = new HashMap<>();
        
        try {
            long beforeCount = analysisResidentCenterRepository.count();
            analysisResidentCenterRepository.deleteAll();
            long afterCount = analysisResidentCenterRepository.count();
            
            result.put("success", true);
            result.put("beforeCount", beforeCount);
            result.put("afterCount", afterCount);
            result.put("deletedCount", beforeCount - afterCount);
            result.put("message", "분석용 데이터 초기화 완료");
            
        } catch (Exception e) {
            result.put("success", false);
            result.put("error", e.getMessage());
            result.put("message", "데이터 초기화 중 오류 발생");
            log.error("분석용 데이터 초기화 중 오류", e);
        }
        
        return ResponseEntity.ok(result);
    }
}
```

## 8. 설정 파일

**application.yml에 Kakao API 키 설정:**

```yaml
# Kakao API 설정
kakao:
  api:
    key: YOUR_KAKAO_REST_API_KEY  # 실제 API 키로 교체 필요

# 기존 설정들...
spring:
  application:
    name: wherehouse
  # ...
```

## 9. 실행 방법 및 검증

### 1. Kakao Developers 설정
1. https://developers.kakao.com 접속
2. 애플리케이션 생성
3. 앱 키 > REST API 키 복사
4. application.yml에 설정

### 2. 데이터베이스 설정
```sql
-- DDL 스크립트 실행
DESC ANALYSIS_RESIDENT_CENTER_STATISTICS;
SELECT COUNT(*) FROM ANALYSIS_RESIDENT_CENTER_STATISTICS;
```

### 3. 애플리케이션 실행
```bash
./gradlew bootRun
```

### 4. 테스트 엔드포인트 활용

**좌표 계산 단일 테스트:**
```bash
curl "http://localhost:8080/debug/resident-center/test-coordinate?address=서울특별시 종로구 청와대로 1"
```

**원본 데이터 상태 확인:**
```bash
curl "http://localhost:8080/debug/resident-center/check-original-data"
```

**분석용 데이터 상태 확인:**
```bash
curl "http://localhost:8080/debug/resident-center/check-analysis-data"
```

**강제 처리 실행:**
```bash
curl -X POST "http://localhost:8080/debug/resident-center/force-process"
```

### 5. 실행 결과 검증
```sql
-- 데이터 개수 확인
SELECT COUNT(*) FROM ANALYSIS_RESIDENT_CENTER_STATISTICS;

-- 구별 주민센터 수 확인
SELECT SIGUNGU, COUNT(*) 
FROM ANALYSIS_RESIDENT_CENTER_STATISTICS 
GROUP BY SIGUNGU 
ORDER BY COUNT(*) DESC;

-- 좌표 정보 완성도 확인
SELECT 
    COUNT(*) AS TOTAL_COUNT,
    COUNT(LATITUDE) AS COORDINATE_COUNT,
    COUNT(*) - COUNT(LATITUDE) AS MISSING_COORDINATE_COUNT
FROM ANALYSIS_RESIDENT_CENTER_STATISTICS;

-- 동별 주민센터 분포 확인
SELECT EUPMEONDONG, COUNT(*) 
FROM ANALYSIS_RESIDENT_CENTER_STATISTICS 
GROUP BY EUPMEONDONG 
ORDER BY COUNT(*) DESC;

-- 실제 좌표 샘플 확인
SELECT SIGUNGU, EUPMEONDONG, ADDRESS, LATITUDE, LONGITUDE
FROM ANALYSIS_RESIDENT_CENTER_STATISTICS
WHERE LATITUDE IS NOT NULL AND ROWNUM <= 10;
```

## 10. 예상 처리 결과

### 로그 출력 예시
```
=== 안전성 분석용 데이터 처리 시작 ===
1. 서울시 주민센터 데이터 분석용 테이블 생성 시작
원본 서울시 주민센터 통계 데이터 423 개 발견
주소 정제 - 원본: 서울특별시 종로구 청와대로 1 (종로구청), 정제 후: 서울특별시 종로구 청와대로 1
좌표 계산 성공 - 주소: 서울특별시 종로구 청와대로 1, 타입: 도로명주소, 좌표: (37.5735, 126.9788)
진행률: 10.0% 완료 (42/423)
...
진행률: 100.0% 완료 (423/423)
서울시 주민센터 데이터 분석용 테이블 생성 작업 완료
- 데이터 변환: 성공 423 개, 실패 0 개
- 좌표 계산: 성공 398 개, 실패 25 개
구별 주민센터 수 순위 (상위 5개 구):
  강서구 : 22 개
  송파구 : 21 개
  강남구 : 19 개
  노원구 : 18 개
  은평구 : 17 개
동별 주민센터 분포 (상위 5개):
  신림동 : 3 개
  방배동 : 2 개
  역삼동 : 2 개
  도봉동 : 2 개
  잠실동 : 2 개
좌표 정보 완성도:
  좌표 보유: 398 개 (94.1%)
  좌표 누락: 25 개 (5.9%)
=== Kakao API 호출 통계 (서울시 주민센터) ===
총 호출 횟수: 423
성공 횟수: 398 (94.1%)
실패 횟수: 25 (5.9%)
=== 안전성 분석용 데이터 처리 완료 ===
```

## 11. 주요 개선사항

### 자동 인코딩 처리
- **문제**: 수동 URL 인코딩으로 인한 이중 인코딩 발생
- **해결**: Spring Boot의 `UriComponentsBuilder` 자동 인코딩 활용
- **효과**: 한글 주소 처리 안정성 향상 및 API 호출 성공률 증가

### 성능 최적화
- **진행률 표시**: 10% 간격으로 처리 진행 상황 로깅
- **통계 정보**: API 호출 성공/실패 통계 실시간 제공
- **메모리 효율**: 배치 처리로 대용량 데이터 안정적 처리

### 서울시 특화 기능
- **서울시 좌표 검증**: 더 정밀한 서울시 영역 좌표 범위 검증
- **기관명 전처리**: 주민센터, 동사무소 등 기관명 자동 제거로 API 인식률 향상
- **행정구역 분석**: 구별, 동별 주민센터 분포 상세 분석

### 디버깅 및 운영
- **테스트 엔드포인트**: 개발 과정에서 컴포넌트별 개별 테스트 가능
- **상세 로깅**: 각 처리 단계별 세부 정보 추적
- **오류 처리**: 예외 상황에 대한 구체적 로그 및 복구 방안 제시

### 데이터 품질 향상
- **높은 좌표 정확도**: 공공기관인 주민센터의 주소 정확성으로 94% 이상 좌표 계산 성공률 예상
- **행정서비스 접근성**: 구별 주민센터 분포를 통한 행정서비스 접근성 정량 분석 지원
- **안전성 분석 활용**: 긴급상황 시 대피소 역할 등 안전성 분석 독립변수로 활용 가능

이 시스템은 향후 피어슨 상관분석에서 독립변수로 활용될 지역별 행정서비스 접근성 계산의 정확한 기초 데이터를 제공하며, 자동 인코딩 처리를 통해 한글 주소에 대한 높은 좌표 계산 성공률을 보장합니다.