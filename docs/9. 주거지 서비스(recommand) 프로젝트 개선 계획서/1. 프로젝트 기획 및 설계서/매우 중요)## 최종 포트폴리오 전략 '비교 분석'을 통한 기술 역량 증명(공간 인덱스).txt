## 최종 포트폴리오 전략: '비교 분석'을 통한 기술 역량 증명
1. 최종 목표 (Final Goal)
단순히 안전성 점수 기능을 구현하는 것을 넘어, 대규모 데이터를 처리하는 두 가지 대표적인 백엔드 아키텍처, 즉 **'배치 기반 격자 시스템'**과 **'실시간 반경 조회 시스템'**을 모두 구축한다. 이후 각 시스템의 성능과 정확성을 정량적으로 벤치마킹하고, 그 결과를 바탕으로 시스템 설계의 트레이드오프(Trade-off)를 명확히 분석하고 설명함으로써, 실무 수준의 문제 해결 능력과 기술적 깊이를 증명한다.

2. 데이터베이스 및 공통 기반 구축 (Phase 1)
통합 데이터베이스 구축

데이터 소스: 소상공인 CSV (편의점, 유흥업소), 공공데이터 파일(CCTV, 경찰서, 병원), 서울시 5대 범죄 통계 CSV 등 모든 정적 데이터를 OCI의 무료 Autonomous Database(Oracle)에 적재한다.

핵심 최적화: 모든 시설물 테이블의 좌표(위도/경도) 컬럼에 **공간 인덱스(Spatial Index)**를 생성하여, 대용량 데이터에 대한 위치 기반 쿼리 성능을 비약적으로 향상시킨다.

성능 비교를 위한 벤치마킹 계획

개선 전 (Before): 공간 인덱스를 사용하지 않고 테이블 전체를 스캔(Full Table Scan)하여 반경 내 시설물을 찾는 쿼리를 구현한다. (시간 복잡도: O(N))

개선 후 (After): 공간 인덱스를 사용하는 쿼리(e.g., Oracle SDO_WITHIN_DISTANCE)를 구현한다. (시간 복잡도: O(log N))

측정: 두 방식의 쿼리 실행 시간을 밀리초(ms) 단위로 측정하고, README에 "DB 성능 최적화 과정" 섹션을 만들어 표와 그래프로 명확히 비교 분석한다.

3. 두 가지 핵심 아키텍처 구현 (Phase 2)
[Architecture A] 배치 기반 격자(Grid) 시스템

구현: Spring Batch 또는 @Scheduled를 사용하여 서울시 전체(약 6만 개 격자)에 대한 '미시적 안전 점수'를 주기적으로 미리 계산하는 배치 애플리케이션을 구현한다.

각 격자의 점수를 계산할 때는 최적화된 '공간 인덱스' 쿼리를 사용하여 DB 부하를 최소화한다.

계산된 결과 (격자 ID, 점수)는 Redis에 저장한다.

API 엔드포인트 (?mode=batch): 사용자 요청 시 Redis에서 해당 격자의 점수를 **단순 조회(Lookup)**하여 즉시 반환한다.

[Architecture B] 실시간 반경(Radius) 조회 시스템

구현: 사용자 요청 시 DB에 직접 실시간으로 쿼리하여 점수를 계산하는 서비스 로직을 구현한다.

마찬가지로 최적화된 '공간 인덱스' 쿼리를 사용하여 응답 속도를 최대한 확보한다.

API 엔드포인트 (?mode=realtime): 매물 좌표를 기준으로 반경 내 시설물을 동적으로 계산하여 점수를 반환한다.

4. 최종 포트폴리오 결과물
동작하는 애플리케이션: 쿼리 파라미터를 통해 두 가지 모드(Batch vs. Real-time)로 모두 동작하는 안전성 점수 조회 API.

상세한 README.md 문서:

[프로젝트 개요]: 해결하고자 했던 문제와 최종 목표 서술.

[아키텍처 설계]: 두 가지 아키텍처의 설계 다이어그램과 동작 방식 설명.

[DB 성능 최적화]: 공간 인덱스 적용 전/후의 성능 비교 데이터(표, 그래프)와 시간 복잡도 분석(O(N) → O(log N)) 과정 서술.

[아키텍처 비교 분석]: 부하 테스트를 통해 측정한 두 모델의 응답 속도(ms), 처리량(TPS), DB 자원 사용량 등을 비교하고, '성능'과 '정확성'의 트레이드오프에 대한 자신의 기술적인 결론을 명확히 제시.

[결론]: 어떤 상황에서 어떤 아키텍처가 더 유리하며, 만약 실제 프로덕션 환경이라면 '배치 기반 격자 시스템'을 선택할 것이라는 데이터 기반의 논리적 근거를 제시.