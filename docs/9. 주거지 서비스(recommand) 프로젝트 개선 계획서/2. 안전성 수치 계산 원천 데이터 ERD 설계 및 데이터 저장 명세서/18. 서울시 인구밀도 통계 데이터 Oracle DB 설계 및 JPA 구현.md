# 서울시 인구밀도 통계 데이터 CSV 기반 Oracle DB 설계 및 JPA 구현 (완전 최종)

## 1. 실제 CSV 파일 분석 결과

### 1.1 CSV 파일 구조
- 파일명: `인구밀도_202509011.csv`
- 인코딩: UTF-8
- 구조: 총 27개 행 (헤더 2행 + 데이터 25개 구)

### 1.2 실제 CSV 컬럼 구조
```csv
"동별(1)",동별(2),동별(3),2024,2024,2024
"동별(1)",동별(2),동별(3),인구 (명),면적 (㎢),인구밀도 (명/㎢)
"합계",소계,소계,9597372,605.21,15858
"합계",종로구,소계,149608,23.91,6256
```

**컬럼 매핑:**
- 컬럼 0: "동별(1)" → "합계" (사용하지 않음)
- **컬럼 1: 동별(2) → 구 이름** (DISTRICT_NAME)
- 컬럼 2: 동별(3) → "소계" (사용하지 않음)
- **컬럼 3: 인구수** (POPULATION_COUNT)
- **컬럼 4: 면적** (AREA_SIZE)
- **컬럼 5: 인구밀도** (POPULATION_DENSITY)

## 2. Oracle 테이블 DDL (ERD 기반)

### 2.1 테이블 생성
```sql
-- 기존 테이블 및 시퀀스 삭제
DROP TABLE POPULATION_DENSITY CASCADE CONSTRAINTS;
DROP SEQUENCE SEQ_POPULATION_DENSITY;

-- 서울시 인구밀도 분석 테이블 생성
CREATE TABLE POPULATION_DENSITY (
    ID                          NUMBER PRIMARY KEY,
    DISTRICT_NAME               VARCHAR2(100),
    YEAR                        NUMBER(4) DEFAULT 2024,
    POPULATION_COUNT            NUMBER,
    AREA_SIZE                   NUMBER(15,5),
    POPULATION_DENSITY          NUMBER(15,5),
    CREATED_AT                  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 시퀀스 생성
CREATE SEQUENCE SEQ_POPULATION_DENSITY START WITH 1 INCREMENT BY 1;
```

### 2.2 필드 설명
- **ID**: 기본키, 시퀀스로 자동 생성
- **DISTRICT_NAME**: 서울시 구 단위 지역명 (종로구, 중구, 용산구 등)
- **YEAR**: 데이터 기준 연도 (기본값: 2024)
- **POPULATION_COUNT**: 인구수 (명)
- **AREA_SIZE**: 면적 (㎢)
- **POPULATION_DENSITY**: 인구밀도 (명/㎢)
- **CREATED_AT**: 데이터 생성 시간

## 3. JPA Entity

```java
package com.WhereHouse.APITest.Population.Entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "POPULATION_DENSITY")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PopulationDensity {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "population_seq")
    @SequenceGenerator(
        name = "population_seq", 
        sequenceName = "SEQ_POPULATION_DENSITY", 
        allocationSize = 1
    )
    @Column(name = "ID")
    private Long id;

    @Column(name = "DISTRICT_NAME", length = 100, nullable = false)
    private String districtName;

    @Column(name = "YEAR", nullable = false)
    private Integer year;

    @Column(name = "POPULATION_COUNT")
    private Long populationCount;

    @Column(name = "AREA_SIZE", precision = 15, scale = 5)
    private BigDecimal areaSize;

    @Column(name = "POPULATION_DENSITY", precision = 15, scale = 5)
    private BigDecimal populationDensity;

    @Column(name = "CREATED_AT")
    private LocalDateTime createdAt;

    @PrePersist
    protected void onCreate() {
        if (this.createdAt == null) {
            this.createdAt = LocalDateTime.now();
        }
        if (this.year == null) {
            this.year = 2024;
        }
    }
    
    // 인구밀도 계산 메서드
    public void calculateDensity() {
        if (populationCount != null && areaSize != null && 
            areaSize.compareTo(BigDecimal.ZERO) > 0) {
            this.populationDensity = new BigDecimal(populationCount)
                .divide(areaSize, 5, BigDecimal.ROUND_HALF_UP);
        }
    }
    
    // 편의 메서드
    public String getFormattedPopulationCount() {
        return populationCount != null ? String.format("%,d명", populationCount) : "0명";
    }
    
    public String getFormattedAreaSize() {
        return areaSize != null ? String.format("%.2f㎢", areaSize) : "0.00㎢";
    }
    
    public String getFormattedPopulationDensity() {
        return populationDensity != null ? String.format("%.0f명/㎢", populationDensity) : "0명/㎢";
    }
}
```

## 4. Repository

```java
package com.WhereHouse.APITest.Population.Repository;

import com.WhereHouse.APITest.Population.Entity.PopulationDensity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

@Repository
public interface PopulationDensityRepository extends JpaRepository<PopulationDensity, Long> {
    
    // 구 이름과 연도로 조회
    Optional<PopulationDensity> findByDistrictNameAndYear(String districtName, Integer year);
    
    // 인구밀도 순으로 정렬 (내림차순) - '소계' 제외
    @Query("SELECT a FROM PopulationDensity a WHERE a.districtName != '소계' ORDER BY a.populationDensity DESC")
    List<PopulationDensity> findAllOrderByPopulationDensityDesc();
    
    // 인구수 순으로 정렬 (내림차순) - '소계' 제외
    @Query("SELECT a FROM PopulationDensity a WHERE a.districtName != '소계' ORDER BY a.populationCount DESC")
    List<PopulationDensity> findAllOrderByPopulationCountDesc();
    
    // 면적 순으로 정렬 (내림차순) - '소계' 제외
    @Query("SELECT a FROM PopulationDensity a WHERE a.districtName != '소계' ORDER BY a.areaSize DESC")
    List<PopulationDensity> findAllOrderByAreaSizeDesc();
    
    // 구 이름 검색
    @Query("SELECT a FROM PopulationDensity a WHERE a.districtName LIKE %:keyword% AND a.districtName != '소계'")
    List<PopulationDensity> findByDistrictNameContaining(@Param("keyword") String keyword);
    
    // 특정 인구밀도 이상인 구
    @Query("SELECT a FROM PopulationDensity a WHERE a.populationDensity >= :density AND a.districtName != '소계' ORDER BY a.populationDensity DESC")
    List<PopulationDensity> findByPopulationDensityGreaterThanEqual(@Param("density") BigDecimal density);
    
    // 특정 인구수 이상인 구
    @Query("SELECT a FROM PopulationDensity a WHERE a.populationCount >= :population AND a.districtName != '소계' ORDER BY a.populationCount DESC")
    List<PopulationDensity> findByPopulationCountGreaterThanEqual(@Param("population") Long population);
    
    // 연도별 조회
    List<PopulationDensity> findByYear(Integer year);
    
    // 중복 체크
    boolean existsByDistrictNameAndYear(String districtName, Integer year);
    
    // 통계 쿼리
    @Query("SELECT COUNT(a) FROM PopulationDensity a WHERE a.districtName != '소계'")
    long countValidDistricts();
    
    @Query("SELECT SUM(a.populationCount) FROM PopulationDensity a WHERE a.districtName != '소계'")
    Long getTotalPopulation();
    
    @Query("SELECT SUM(a.areaSize) FROM PopulationDensity a WHERE a.districtName != '소계'")
    BigDecimal getTotalAreaSize();
    
    @Query("SELECT AVG(a.populationDensity) FROM PopulationDensity a WHERE a.districtName != '소계'")
    BigDecimal getAveragePopulationDensity();
    
    @Query("SELECT MAX(a.populationDensity) FROM PopulationDensity a WHERE a.districtName != '소계'")
    BigDecimal getMaxPopulationDensity();
    
    @Query("SELECT MIN(a.populationDensity) FROM PopulationDensity a WHERE a.districtName != '소계'")
    BigDecimal getMinPopulationDensity();
    
    // 상위 N개 구 조회
    @Query("SELECT a FROM PopulationDensity a WHERE a.districtName != '소계' ORDER BY a.populationDensity DESC")
    List<PopulationDensity> findTopByPopulationDensity();
}
```

## 5. CSV 배치 처리 로더

```java
package com.WhereHouse.APITest.Population.Loader;

import com.WhereHouse.APITest.Population.Entity.PopulationDensity;
import com.WhereHouse.APITest.Population.Repository.PopulationDensityRepository;
import com.opencsv.CSVReader;
import com.opencsv.exceptions.CsvException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@Component
@RequiredArgsConstructor
@Slf4j
public class PopulationDensityDataLoader implements CommandLineRunner {

    private final PopulationDensityRepository repository;
    private final ResourceLoader resourceLoader;

    @Value("${app.csv.population-density-path:classpath:인구밀도_202509011.csv}")
    private String csvFilePath;

    @Override
    @Transactional
    public void run(String... args) {
        long existingCount = repository.count();
        if (existingCount > 0) {
            log.info("서울시 인구밀도 데이터 이미 존재 ({}개). 로딩 스킵", existingCount);
            return;
        }

        try {
            List<PopulationDensity> dataList = loadFromCsv();
            
            if (!dataList.isEmpty()) {
                List<PopulationDensity> savedList = repository.saveAll(dataList);
                log.info("서울시 인구밀도 데이터 로딩 완료 - 총 {} 건 저장", savedList.size());
                logDataSummary(savedList);
            } else {
                log.warn("로딩할 데이터가 없습니다.");
            }
            
        } catch (Exception e) {
            log.error("서울시 인구밀도 데이터 로딩 실패: {}", e.getMessage(), e);
            throw new RuntimeException("데이터 로딩 중 오류 발생", e);
        }
    }

    private List<PopulationDensity> loadFromCsv() throws IOException, CsvException {
        List<PopulationDensity> dataList = new ArrayList<>();
        
        Resource resource = resourceLoader.getResource(csvFilePath);
        if (!resource.exists()) {
            throw new IOException("CSV 파일을 찾을 수 없습니다: " + csvFilePath);
        }

        log.info("CSV 파일 로딩 시작: {}", csvFilePath);
        
        try (CSVReader csvReader = new CSVReader(
                new InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8))) {
            
            List<String[]> records = csvReader.readAll();
            
            if (records.size() < 2) {
                log.warn("CSV 파일에 데이터가 부족합니다. 최소 2행 필요 (헤더 + 데이터)");
                return dataList;
            }
            
            // 첫 번째 행: "동별(1)",동별(2),동별(3),2024,2024,2024
            // 두 번째 행: "동별(1)",동별(2),동별(3),인구 (명),면적 (㎢),인구밀도 (명/㎢)
            // 세 번째 행부터 실제 데이터
            
            log.info("CSV 헤더 1행: {}", Arrays.toString(records.get(0)));
            log.info("CSV 헤더 2행: {}", Arrays.toString(records.get(1)));
            
            int processedCount = 0;
            int errorCount = 0;
            int skippedCount = 0;
            
            // 3번째 행부터 데이터 처리 (인덱스 2부터)
            for (int i = 2; i < records.size(); i++) {
                String[] record = records.get(i);
                
                try {
                    PopulationDensity data = parseCsvRecord(record, i + 1);
                    if (data != null) {
                        // 중복 체크
                        if (!repository.existsByDistrictNameAndYear(data.getDistrictName(), data.getYear())) {
                            dataList.add(data);
                            processedCount++;
                            log.debug("데이터 추가: {} - 인구: {}, 면적: {}, 밀도: {}", 
                                    data.getDistrictName(), 
                                    data.getPopulationCount(), 
                                    data.getAreaSize(), 
                                    data.getPopulationDensity());
                        } else {
                            skippedCount++;
                            log.debug("중복 데이터 스킵: {}", data.getDistrictName());
                        }
                    } else {
                        skippedCount++;
                    }
                } catch (Exception e) {
                    errorCount++;
                    log.warn("CSV 레코드 파싱 실패 - 행 {}: {}, 오류: {}", 
                            i + 1, Arrays.toString(record), e.getMessage());
                }
            }
            
            log.info("CSV 파싱 완료 - 처리: {}건, 스킵: {}건, 오류: {}건, 총 데이터: {}건", 
                    processedCount, skippedCount, errorCount, dataList.size());
        }
        
        return dataList;
    }

    private PopulationDensity parseCsvRecord(String[] record, int lineNumber) {
        if (record.length < 6) {
            log.debug("CSV 레코드 길이 부족 - 행 {}: {} (최소 6개 필요)", lineNumber, record.length);
            return null;
        }
        
        try {
            // 실제 CSV 구조에 맞춘 파싱
            String level1 = cleanString(record[0]);        // "합계"
            String districtName = cleanString(record[1]);  // 구 이름
            String level3 = cleanString(record[2]);        // "소계"
            
            // '소계'인 경우 필터링 (서울시 전체 합계는 제외)
            if ("소계".equals(districtName) || !StringUtils.hasText(districtName)) {
                log.debug("행 {}: '소계' 또는 빈 구 이름 필터링", lineNumber);
                return null;
            }
            
            // 데이터 파싱
            Long populationCount = parseLong(record[3]);      // 인구수
            BigDecimal areaSize = parseBigDecimal(record[4]); // 면적
            BigDecimal populationDensity = parseBigDecimal(record[5]); // 인구밀도
            
            // 유효성 검사
            if (populationCount == null || populationCount <= 0) {
                log.warn("행 {}: 유효하지 않은 인구수: {}", lineNumber, record[3]);
                return null;
            }
            
            if (areaSize == null || areaSize.compareTo(BigDecimal.ZERO) <= 0) {
                log.warn("행 {}: 유효하지 않은 면적: {}", lineNumber, record[4]);
                return null;
            }
            
            PopulationDensity entity = PopulationDensity.builder()
                    .districtName(districtName)
                    .year(2024)
                    .populationCount(populationCount)
                    .areaSize(areaSize)
                    .populationDensity(populationDensity)
                    .build();
            
            // 인구밀도 재계산 및 검증
            entity.calculateDensity();
            
            return entity;
                    
        } catch (Exception e) {
            log.error("CSV 레코드 파싱 중 오류 발생 - 행 {}: {}", lineNumber, Arrays.toString(record), e);
            throw new RuntimeException("레코드 파싱 실패", e);
        }
    }
    
    private String cleanString(String value) {
        if (value == null) return null;
        // 따옴표 제거 및 공백 정리
        return value.replace("\"", "").trim();
    }
    
    private Long parseLong(String value) {
        if (!StringUtils.hasText(value)) {
            return null;
        }
        try {
            // 숫자에서 콤마 및 공백 제거
            String cleanValue = cleanString(value).replaceAll("[,\\s]", "");
            return Long.parseLong(cleanValue);
        } catch (NumberFormatException e) {
            log.debug("Long 파싱 실패: {}", value);
            return null;
        }
    }
    
    private BigDecimal parseBigDecimal(String value) {
        if (!StringUtils.hasText(value)) {
            return null;
        }
        try {
            // 숫자에서 콤마 및 공백 제거
            String cleanValue = cleanString(value).replaceAll("[,\\s]", "");
            return new BigDecimal(cleanValue);
        } catch (NumberFormatException e) {
            log.debug("BigDecimal 파싱 실패: {}", value);
            return null;
        }
    }
    
    private void logDataSummary(List<PopulationDensity> dataList) {
        if (dataList.isEmpty()) {
            return;
        }
        
        long totalPopulation = dataList.stream()
                .mapToLong(PopulationDensity::getPopulationCount)
                .sum();
        
        PopulationDensity maxDensity = dataList.stream()
                .max((a, b) -> a.getPopulationDensity().compareTo(b.getPopulationDensity()))
                .orElse(null);
        
        PopulationDensity minDensity = dataList.stream()
                .min((a, b) -> a.getPopulationDensity().compareTo(b.getPopulationDensity()))
                .orElse(null);
        
        PopulationDensity maxPopulation = dataList.stream()
                .max((a, b) -> a.getPopulationCount().compareTo(b.getPopulationCount()))
                .orElse(null);
        
        BigDecimal totalArea = dataList.stream()
                .map(PopulationDensity::getAreaSize)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        log.info("=== 서울시 인구밀도 데이터 요약 ===");
        log.info("총 구 개수: {}개", dataList.size());
        log.info("총 인구수: {:,}명", totalPopulation);
        log.info("총 면적: {}㎢", totalArea);
        
        if (maxDensity != null) {
            log.info("최고 인구밀도: {} ({:,}명/㎢)", 
                    maxDensity.getDistrictName(), maxDensity.getPopulationDensity());
        }
        if (minDensity != null) {
            log.info("최저 인구밀도: {} ({:,}명/㎢)", 
                    minDensity.getDistrictName(), minDensity.getPopulationDensity());
        }
        if (maxPopulation != null) {
            log.info("최대 인구수: {} ({:,}명)", 
                    maxPopulation.getDistrictName(), maxPopulation.getPopulationCount());
        }
        
        // 전체 서울시 평균 인구밀도 계산
        if (totalArea.compareTo(BigDecimal.ZERO) > 0) {
            BigDecimal avgDensity = new BigDecimal(totalPopulation)
                    .divide(totalArea, 2, BigDecimal.ROUND_HALF_UP);
            log.info("서울시 전체 평균 인구밀도: {}명/㎢", avgDensity);
        }
        
        log.info("===============================");
    }
}
```

## 6. application.yml 설정

```yaml
# 애플리케이션 설정
app:
  csv:
    population-density-path: classpath:인구밀도_202509011.csv

# Spring 설정
spring:
  application:
    name: seoul-population-density-api
    
  # 데이터베이스 설정
  datasource:
    url: jdbc:oracle:thin:@localhost:1521/XE
    username: ${DB_USERNAME:your_username}
    password: ${DB_PASSWORD:your_password}
    driver-class-name: oracle.jdbc.OracleDriver
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5
      connection-timeout: 20000
      idle-timeout: 600000
      max-lifetime: 1800000
    
  # JPA 설정
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: ${SHOW_SQL:false}
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.Oracle12cDialect
        jdbc:
          batch_size: 50
        order_inserts: true
        order_updates: true
        
  # 트랜잭션 설정
  transaction:
    default-timeout: 30
        
# 로깅 설정
logging:
  level:
    root: INFO
    com.WhereHouse.APITest.Population: ${LOG_LEVEL:INFO}
    org.hibernate.SQL: ${SQL_LOG_LEVEL:WARN}
    org.hibernate.type.descriptor.sql.BasicBinder: WARN
    org.springframework.transaction: WARN
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"

# 액추에이터 설정 (모니터링용)
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: when_authorized
```

## 7. Maven Dependencies (pom.xml 추가 항목)

```xml
<!-- CSV 처리를 위한 OpenCSV -->
<dependency>
    <groupId>com.opencsv</groupId>
    <artifactId>opencsv</artifactId>
    <version>5.8</version>
</dependency>

<!-- Oracle JDBC 드라이버 -->
<dependency>
    <groupId>com.oracle.database.jdbc</groupId>
    <artifactId>ojdbc8</artifactId>
    <scope>runtime</scope>
</dependency>

<!-- Lombok -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>

<!-- Spring Boot JPA -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

<!-- Spring Boot Web -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!-- 테스트 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```

## 8. 주요 수정사항 요약

### 8.1 CSV 파일 구조 분석 기반 수정
- **실제 CSV 구조**: 6개 컬럼 (동별1, 구이름, 동별3, 인구수, 면적, 인구밀도)
- **헤더 처리**: 2개 헤더 행 올바른 스킵 처리
- **데이터 위치**: 컬럼 인덱스 올바른 매핑

### 8.2 데이터 검증 및 필터링 강화
- **'소계' 데이터 필터링**: 서울시 전체 합계 데이터 제외
- **유효성 검사**: NULL 체크, 음수 체크, 빈 값 처리
- **중복 데이터 처리**: 구이름+연도 조합으로 중복 방지

### 8.3 에러 처리 및 로깅 개선
- **상세 로깅**: 파싱 과정별 상태 로깅
- **예외 처리**: Try-catch 블록으로 안정성 확보
- **통계 정보**: 로딩 완료 후 데이터 요약 정보 출력

### 8.4 성능 최적화
- **배치 처리**: JPA batch insert 설정
- **트랜잭션 관리**: 적절한 트랜잭션 범위 설정

이제 실제 CSV 파일 구조에 완벽하게 맞춰진 핵심 구현이 완성되었습니다.