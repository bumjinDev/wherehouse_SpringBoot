# 부동산 추천 시스템 종합 설계서

**프로젝트명**: 사용자 맞춤형 부동산 추천 엔진  
**문서 버전**: 1.0  
**작성일**: 2025년 9월 12일  
**작성자**: 정범진

---

## API 요구사항 명세서

### 1. 개요

#### 1.1. 목적

본 문서는 사용자 맞춤형 부동산 추천 시스템의 백엔드 API에 대한 기능적 요구사항과 인터페이스를 정의하는 것을 목적으로 한다. 본 명세서는 프론트엔드와 백엔드 개발자 간의 명확한 소통 기준을 제공하며, 일관성 있는 시스템 구현을 보장한다.

#### 1.2. 범위

본 명세서는 사용자의 조건에 맞는 상위 지역구를 추천하는 단일 API 엔드포인트(`GET /api/recommendations/districts`)에 대한 요구사항을 다룬다. API의 요청 파라미터, 응답 데이터 구조, 상태 코드, 그리고 예외 처리 방안을 포함한다.

### 2. 일반 요구사항

- **데이터 형식**: 모든 API 요청과 응답의 데이터 형식은 JSON(Application/json)을 사용한다.
- **문자 인코딩**: 모든 데이터는 UTF-8로 인코딩한다.
- **인증**: API 호출 시 발급된 인증 토큰을 HTTP 헤더에 포함해야 한다. (본 명세서 범위 외)
- **기본 URL**: `https://{your-domain}`

### 3. 엔드포인트 명세: 지역구 추천 API

#### 3.1. API 개요

| 항목 | 내용 |
|------|------|
| **기능 설명** | 사용자의 조건(예산, 평수)과 우선순위(가격, 안전, 공간)를 기반으로 서울시 내 최적의 지역구를 순위별로 추천한다. 조건에 맞는 매물이 부족할 경우, 사용자가 설정한 완화 기준에 따라 자동으로 검색 범위를 확장하는 2단계 폴백 시스템을 적용한다. |
| **HTTP Method** | `GET` |
| **Endpoint URL** | `/api/recommendations/districts` |

#### 3.2. 요청 (Request)

**Query Parameters**

| 파라미터 | 타입 | 필수 | 설명 | 예시 |
|---------|------|------|------|------|
| `leaseType` | String | ✓ | 임대 유형. `CHARTER`(전세) 또는 `MONTHLY`(월세) | `CHARTER` |
| `budgetMin` | Integer | ✓ | 최소 예산 (단위: 만원) | `20000` |
| `budgetMax` | Integer | ✓ | 최대 예산 (단위: 만원) | `30000` |
| `areaMin` | Double | ✓ | 최소 평수 (단위: 평) | `20` |
| `areaMax` | Double | ✓ | 최대 평수 (단위: 평) | `30` |
| `priority1` | String | ✓ | 1순위 중요도. `PRICE`, `SAFETY`, `SPACE` 중 선택 | `PRICE` |
| `priority2` | String | ✓ | 2순위 중요도 | `SAFETY` |
| `priority3` | String | ✓ | 3순위 중요도 | `SPACE` |
| `budgetFlexibility` | Integer | ✗ | 예산 유연성 (%). 2단계 확장 시 최대 예산을 이 비율만큼 초과 허용. (기본값: 0) | `10` |
| `minSafetyScore` | Integer | ✗ | 최소 안전 점수. 2단계 확장 시 이 점수까지 허용. (기본값: 0) | `70` |
| `absoluteMinArea` | Double | ✗ | 절대 최소 평수. 2단계 확장 시 이 평수까지 허용. (기본값: 0) | `15` |

#### 3.3. 응답 (Response)

**성공: 200 OK**

요청이 성공적으로 처리되었을 때 반환되는 JSON 객체.

**Response Body 예시:**
```json
{
  "searchStatus": "SUCCESS_EXPANDED",
  "message": "원하시는 조건의 매물이 부족하여, 평수 조건을 15평으로 완화하여 찾았어요.",
  "recommendedDistricts": [
    {
      "rank": 1,
      "districtName": "강남구",
      "summary": "가격 1순위 조건에 가장 부합하며, 조건 내 추천 매물이 12건 있습니다.",
      "topProperties": [
        {
          "propertyId": 101,
          "propertyName": "은마",
          "address": "서울특별시 강남구 대치동 316",
          "price": 60000,
          "leaseType": "전세",
          "area": 23.2,
          "floor": 14,
          "buildYear": 1979,
          "finalScore": 82.5
        }
      ]
    }
  ]
}
```

**Response Body Fields**

| 필드 | 타입 | 설명 |
|------|------|------|
| `searchStatus` | String | 검색 결과 상태 코드. 아래 4.1. 상태 코드 표 참조 |
| `message` | String | 사용자 안내 메시지. 검색 상태에 대한 부가 설명을 제공 |
| `recommendedDistricts[]` | Array | 추천 지역구 목록. `rank` 순으로 정렬됨 |
| `recommendedDistricts[].rank` | Integer | 지역구 추천 순위 |
| `recommendedDistricts[].districtName` | String | 지역구 이름 |
| `recommendedDistricts[].summary` | String | 이 지역구를 추천하는 핵심 요약 근거 |
| `recommendedDistricts[].topProperties[]` | Array | 해당 지역구 내에서 가장 점수가 높은 대표 매물 목록 |
| `...topProperties[].propertyId` | Long | 매물 고유 ID |
| `...topProperties[].propertyName` | String | 아파트/오피스텔 이름 |
| `...topProperties[].address` | String | 법정동과 지번을 조합한 주소 |
| `...topProperties[].price` | Integer | 보증금 또는 전세금 (단위: 만원) |
| `...topProperties[].leaseType` | String | '전세' 또는 '월세' |
| `...topProperties[].area` | Double | 전용 면적 (단위: 평). (전용면적㎡ ÷ 3.3058)로 계산 |
| `...topProperties[].floor` | Integer | 층수 |
| `...topProperties[].buildYear` | Integer | 건축 연도 |
| `...topProperties[].finalScore` | Double | 매물의 최종 추천 점수 (0~100점) |

### 4. 상태 코드 및 예외 처리

#### 4.1. searchStatus 상태 코드

| 코드 | 의미 | 설명 |
|------|------|------|
| `SUCCESS_NORMAL` | 기본 검색 성공 | 사용자의 초기 조건을 만족하는 지역구를 성공적으로 추천했습니다. |
| `SUCCESS_EXPANDED` | 확장 검색 성공 | 초기 조건으로는 매물이 부족하여, 3순위 또는 2순위 조건을 완화한 후 지역구를 추천했습니다. |
| `NO_RESULTS` | 결과 없음 | 모든 조건을 최대한 완화했음에도 불구하고 추천할 지역구를 찾지 못했습니다. |

#### 4.2. HTTP 상태 코드

| HTTP 코드 | 상황 | 응답 Body 예시 |
|-----------|------|-------------|
| `200 OK` | 요청 성공 | (3.3. 응답 섹션 참조) |
| `400 Bad Request` | 요청 파라미터 오류 (필수값 누락, 타입 불일치 등) | `{"errorCode": "INVALID_PARAMETER", "message": "budgetMin 파라미터는 필수입니다."}` |
| `500 Internal Server Error` | 서버 내부 로직 오류 | `{"errorCode": "SERVER_ERROR", "message": "요청 처리 중 오류가 발생했습니다."}` |

**기술적 구현 참고사항**  
파라미터 검증은 Spring Boot의 `@Valid` 어노테이션을 사용하여 처리한다.

---

## 비즈니스 기능 구현 명세서

### 1. 아키텍처 개요

시스템은 성능과 안정성을 위해 **'배치(Batch) 데이터 처리'**와 **'실시간(Real-time) 서비스'** 두 부분으로 나뉘어 동작한다.
- **배치 처리**: 주기적으로 외부 API에서 최신 매물 데이터를 수집, 가공하여 Redis에 최적화된 형태로 저장한다.
- **실시간 서비스**: 사용자 요청 시, 사전 처리된 Redis 데이터만을 사용하여 매우 빠른 속도로 추천 결과를 생성한다.

### 2. 기능 명세: 배치 데이터 처리 (Batch Process)

- **구현 위치**: `BatchScheduler.java` (가칭)
- **실행 주기**: 매일 새벽 4시, Spring `@Scheduled`를 통해 실행
- **핵심 역할**: MOLIT API의 데이터를 조회 가능한 형태로 Redis에 적재

| 기능 ID | 기능명 | 상세 구현 내용 |
|---------|--------|----------------|
| **B-01** | **전 지역구 매물 데이터 수집** | 1. 서울시 25개 자치구의 법정동 코드를 순회한다. 2. 각 자치구별로 국토교통부 전월세 API(`getRTMSDataSvcAptRent`)를 호출한다. 3. 페이징(`totalCount`, `pageNo`)을 고려하여 해당 지역구의 **모든 매물**을 수집한다. |
| **B-02** | **데이터 정제 및 객체 변환** | 1. API 응답(XML)의 각 `<item>`을 파싱하여 `Property` DTO 객체로 변환한다. 2. **가격**은 정수형으로, **평수**는 `(전용면적㎡ ÷ 3.3058)` 공식을 적용하여 `Double` 타입으로 변환한다. 3. **안전성 점수**는 해당 매물의 주소(동 단위)를 기반으로 미리 계산된 값을 매핑하여 `safetyScore` 필드에 저장한다. |
| **B-03** | **Redis 데이터 적재** | 1. **(Hashes)**: `Property` 객체 정보를 `property:{id}` 형태의 Key를 가진 Redis `Hash`로 저장한다. 2. **(Sorted Sets)**: 빠른 범위 검색을 위해 자치구별로 **가격**과 **평수**를 `Score`로 하는 `Sorted Set` 인덱스를 생성한다. (`idx:price:{districtName}`, `idx:area:{districtName}`) 3. 기존 데이터를 덮어쓰기 전에 `FLUSHDB` 또는 Key 패턴 삭제를 통해 데이터를 초기화한다. |

### 3. 기능 명세: 실시간 추천 서비스 (Real-time Service)

- **구현 위치**: `RecommendationService.java` (가칭)
- **호출 시점**: `GET /api/recommendations/districts` 엔드포인트 요청 시
- **핵심 역할**: Redis 데이터를 기반으로 사용자 맞춤형 지역구 및 매물 추천

| 기능 ID | 기능명 | 상세 구현 내용 |
|---------|--------|----------------|
| **S-01** | **전 지역구 1차 검색 (Strict)** | 1. 서울시 25개 자치구를 모두 순회한다. 2. 각 자치구마다, 사용자의 요청 조건(`budgetMin/Max`, `areaMin/Max`)을 기준으로 Redis `Sorted Set` 인덱스를 쿼리(`ZRANGEBYSCORE`)한다. 3. 가격과 평수 조건을 모두 만족하는 매물 ID들의 **교집합**을 구하여, 각 자치구별 **유효 매물 목록**을 생성한다. |
| **S-02** | **폴백(Fallback) 조건 판단** | 1. **S-01**에서 생성된 모든 자치구의 유효 매물 총합이 **3개 미만**인지 검사한다. 2. 3개 미만일 경우, **S-03 확장 검색**을 실행한다. 3. 3개 이상일 경우, **S-04 점수 계산**으로 넘어간다. |
| **S-03** | **2차 확장 검색 (Expanded)** | 1. 사용자의 `priority3`에 해당하는 조건을 완화된 임계값(`budgetFlexibility` 등)으로 변경한다. 2. 완화된 조건으로 **S-01** 과정을 다시 수행한다. 3. 그래도 매물이 부족하면 `priority2` 조건을 완화하여 한 번 더 수행한다. 4. 어떤 조건이 완화되었는지 `ResponseMessage` 변수에 기록한다. |
| **S-04** | **매물 단위 점수 계산** | 1. 각 자치구의 유효 매물 목록에 대해, 사용자의 우선순위(`priority1,2,3`)에 따라 **60%/30%/10% 가중치**를 적용한다. 2. `최종 점수 = (가격 점수 * 가중치) + (안전 점수 * 가중치) + (공간 점수 * 가중치)` 공식을 사용해 각 매물의 `finalScore`를 계산한다. 3. 각 자치구 내에서 매물을 `finalScore` 기준으로 내림차순 정렬한다. |
| **S-05** | **지역구 단위 점수 계산 및 정렬** | 1. 각 자치구의 **대표 점수**를 산출한다. (예: `(조건 만족 매물 수) * (상위 5개 매물의 평균 finalScore)`) 2. 산출된 대표 점수를 기준으로 **자치구 목록을 내림차순 정렬**하여 최종 순위를 결정한다. |
| **S-06** | **최종 응답 생성** | 1. 정렬된 지역구 목록에서 상위 3개를 선택한다. 2. 각 지역구별로 `rank`, `districtName`, `summary` 메시지, 그리고 `topProperties` (해당 지역구의 `finalScore` 상위 2~3개 매물)를 추출한다. 3. API 요구사항 명세서에 정의된 최종 `RecommendationResponseDto` 형태로 가공하여 반환한다. |

---

## 시스템 아키텍처 및 비즈니스 로직

### 전체 시스템 구조

시스템은 실시간 서비스 처리와 배치 처리로 구분되며, 총 3단계로 구성된다:

**실시간 서비스 처리 (사용자 요청 시)**
2. **사용자 요청 실시간 처리**: Redis에서 고속 검색 및 폴백 구조 적용
3. **최종 점수 계산 및 응답**: 우선순위 기반 점수 계산 및 정렬

**배치 처리 (사전 준비)**
1. **API 데이터 사전 처리 및 Redis 캐싱**: 매물 데이터 수집 및 인덱스 생성

### 2단계 (서비스): 사용자 요청 실시간 처리

사용자가 API를 요청했을 때 실행되는 로직이다. 이 단계에서는 느린 외부 API를 절대 직접 호출하지 않고, 오직 빠른 Redis 하고만 통신한다.

#### 2.1 Redis에서 1차 검색 (Strict Search)
- 사용자가 요청한 지역구(예: 강남구), 임대유형(전세 또는 월세), 평수 조건을 받는다.
- 전세의 경우: 전세금 범위
- 월세의 경우: 보증금 범위와 월세 범위
- Redis의 `Sorted Set` 인덱스를 사용해 각 조건을 만족하는 매물 ID 목록을 각각 조회한다.
  - `ZRANGEBYSCORE idx:price:강남구 20000 30000` -> 가격 조건 만족 ID 목록
  - `ZRANGEBYSCORE idx:area:강남구 20 30` -> 평수 조건 만족 ID 목록
- 가져온 ID 목록들의 교집합(Intersection)을 구해 모든 조건을 동시에 만족하는 최종 매물 ID 목록을 확정한다.

#### 2.2 폴백(Fallback) 구조 적용
- 1차 검색으로 찾은 매물 ID 개수가 3개 미만이면 확장 검색을 시작한다.
- 사용자의 우선순위(3순위→2순위 순)와 완화 임계값을 바탕으로 `ZRANGEBYSCORE`의 범위 값을 넓혀서 1번 과정을 다시 수행한다.

### 3단계 (서비스): 최종 점수 계산 및 응답

#### 3.1 매물 상세 정보 조회
2단계를 통해 확정된 최종 매물 ID 목록을 가지고, Redis **Hashes**에서 각 매물의 전체 상세 정보를 조회한다.

#### 3.2 점수 계산 및 정렬
조회된 매물 DTO 목록을 대상으로, 이전에 정의한 60%/30%/10% 고정 가중치 기반 점수 계산 로직을 실행하여 `finalScore`를 계산하고 내림차순으로 정렬한다.

#### 3.3 API 응답 생성
정렬된 최종 결과를 API 응답 명세에 맞춰 가공하여 사용자에게 반환한다.

### 1단계 (배치): API 데이터 사전 처리 및 Redis 캐싱

이 단계는 사용자 요청과 상관없이, 서버가 주기적으로(예: 매일 새벽) 실행하여 최신 매물 데이터를 미리 Redis에 가공하여 저장하는 과정이다. Spring의 `@Scheduled` 어노테이션을 사용해 자동화할 수 있다.

#### 1.1 전 지역구 데이터 수집
서울시 25개 자치구 코드를 순회하며 국토교통부 전월세 API를 호출한다. API 응답의 페이징 정보(`totalCount`, `pageNo`)를 확인하여 해당 지역구의 모든 매물 데이터를 빠짐없이 가져온다.

#### 1.2 데이터 가공 및 보강
API로부터 받은 XML/JSON 데이터를 `Property` DTO 객체로 파싱한다. 이 과정에서 각 매물별 안전성 점수를 계산하여 DTO에 함께 저장한다.

#### 1.3 Redis에 '인덱스' 형태로 저장 (핵심)
가공된 매물 데이터를 Redis에 저장할 때, 단순 `String(JSON)`이 아닌 아래와 같이 여러 자료구조를 조합하여 저장한다. 이는 Redis를 단순 캐시가 아닌 인메모리 검색 엔진처럼 사용하기 위함이다.

**매물 원본 데이터 (Hashes)**: 각 매물 정보는 `Hash` 자료구조로 저장한다.
- Key: `property:{id}` (예: `property:101`)
- Value: `{"price": 28000, "area": 22.5, "safetyScore": 85.2, ...}`
- 장점: 특정 매물 정보를 O(1) 시간 복잡도로 매우 빠르게 조회할 수 있다.

**검색을 위한 인덱스 (Sorted Sets)**: 사용자의 핵심 검색 조건(가격, 평수)을 빠르게 필터링하기 위해 자치구별로 `Sorted Set`을 생성한다.
- **가격 인덱스**:
  - Key: `idx:price:강남구`
  - Score: `가격` (예: 28000)
  - Member: `property:{id}` (예: "property:101")
- **평수 인덱스**:
  - Key: `idx:area:강남구`
  - Score: `평수` (예: 22.5)
  - Member: `property:{id}` (예: "property:101")
- 장점: `ZRANGEBYSCORE` 같은 명령어를 통해 O(log N)의 매우 빠른 속도로 특정 범위(예: 예산 2억~3억)에 해당하는 모든 매물 ID를 즉시 찾아낼 수 있다.

### 우선순위별 점수 계산 시스템

#### 개별 항목 점수화 (0~100점 척도)
각기 다른 단위의 값들을 동일한 척도로 정규화:

1. **가격 점수**
   ```
   가격_점수 = 100 - ((현재_가격 - 최저_가격) / (최고_가격 - 최저_가격) × 100)
   ```
   - 낮은 가격일수록 높은 점수

2. **공간 점수**
   ```
   공간_점수 = ((현재_평수 - 최소_평수) / (최대_평수 - 최소_평수) × 100)
   ```
   - 넓은 평수일수록 높은 점수

3. **안전 점수**
   - 유흥주점 밀도와 인구밀도 기반 사전 계산된 점수 활용
   - 이미 0~100점 척도로 표준화된 값

#### 우선순위별 가중치 적용
사용자가 선택한 우선순위에 따른 고정 가중치:

| 우선순위 | 가중치 |
|---------|--------|
| 1순위   | 60%    |
| 2순위   | 30%    |
| 3순위   | 10%    |

#### 최종 점수 산출
```
최종_점수 = (항목1_점수 × 가중치1) + (항목2_점수 × 가중치2) + (항목3_점수 × 가중치3)
```

**계산 예시: 가격 1순위, 안전 2순위, 공간 3순위인 경우**
```
최종_점수 = (가격_점수 × 0.6) + (안전_점수 × 0.3) + (공간_점수 × 0.1)
```

### 폴백 시스템 상세 설계

#### 확장 원칙
- **확장 순서**: 3순위 → 2순위 → 1순위 (1순위는 원칙적으로 완화하지 않음)
- **사용자 가치 보존**: 핵심 우선순위 조건은 최대한 유지
- **투명성 확보**: 완화된 조건을 사용자에게 명확히 고지

#### 확장 프로세스

**예시: 가격 1순위, 안전 2순위, 평수 3순위인 경우**
1. 1차 확장: 평수 조건 완화 (3순위)
2. 2차 확장: 안전 조건 완화 (2순위)  
3. 가격 조건은 절대 완화하지 않음 (1순위)

#### 조건 완화 적용
1. **1차 확장**
   - 3순위 조건의 완화 임계값 적용
   - 재검색 후 매물 수 확인
   - 충분한 매물 확보 시 확장 중단

2. **2차 확장** (1차 확장으로 부족한 경우)
   - 2순위 조건의 완화 임계값 추가 적용
   - 재검색 후 최종 매물 목록 확보

### 시스템 특징 및 장점

#### 적응적 복잡도 관리
- **평상시**: 단순한 기본 검색으로 빠른 응답
- **매물 부족 시**: 지능적 확장 검색으로 대안 제시

#### 사용자 중심 설계
- 명시적 우선순위 설정을 통한 개인화
- 핵심 가치 보존 원칙 (1순위 조건 유지)
- 투명한 추천 근거 제공

#### 확장 가능성
- 새로운 평가 항목 추가 용이
- 가중치 체계 조정 가능
- 다양한 완화 전략 적용 가능

### 구현 시 고려사항

#### 성능 최적화
- 기본 검색 결과 캐싱 적용
- 인덱스 최적화를 통한 검색 속도 향상
- 단계별 조건 검증으로 불필요한 연산 방지

#### 사용자 경험
- 확장 검색 적용 시 명확한 안내 메시지 제공
- 각 단계별 처리 시간 모니터링
- 추천 근거의 이해하기 쉬운 표현

#### 확장성 및 유지보수
- 모듈화된 설계로 각 단계 독립적 수정 가능
- 가중치 및 임계값의 설정값 외부화
- 로그 수집을 통한 시스템 성능 모니터링