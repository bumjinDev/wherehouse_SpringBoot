# 안전성 분석용 데이터 처리 시스템 구축 명세서

**프로젝트명:** 부동산 추천 시스템 - 안전성 점수 계산용 분석 데이터 구축  
**버전:** 1.0  
**작성일:** 2025.08.30  
**목적:** 피어슨 상관분석을 위한 19개 ERD별 분석 전용 테이블 자동 생성 시스템

---

## 1. 시스템 개요

### 1.1 전체 목표
기존 `AnalysisStaticData` 패키지에 저장된 원천 데이터를 새로운 `AnalysisData` 패키지의 분석 전용 테이블로 변환하여 피어슨 상관분석에 활용할 수 있도록 데이터를 정제 및 구조화한다.

### 1.2 핵심 설계 원칙
- **패키지 분리**: 원천 데이터(`AnalysisStaticData`)와 분석 데이터(`AnalysisData`) 완전 분리
- **ERD별 독립성**: 19개 각 ERD마다 독립적인 패키지 구조 및 프로세서
- **기존 인터페이스 재사용**: 원천 데이터 JPA Entity/Repository는 기존 것 그대로 import
- **통합 실행 관리**: 하나의 Main 클래스에서 모든 ERD 프로세서 순차 실행

---

## 2. 아키텍처 구조

### 2.1 패키지 구조
```
com.WhereHouse.AnalysisData/
├── main/
│   └── AnalysisDataProcessor.java          // 통합 Main 실행 클래스
├── crime/                                  // ERD별 독립 패키지 (예시)
│   ├── entity/
│   │   └── AnalysisCrimeStatistics.java    
│   ├── repository/
│   │   └── AnalysisCrimeRepository.java    
│   └── processor/
│       └── CrimeDataProcessor.java         
├── cctv/                                   // 다음 ERD 패키지
│   ├── entity/
│   ├── repository/
│   └── processor/
└── [17개 추가 ERD 패키지...]
```

### 2.2 데이터 흐름
```
[원천 데이터] → [프로세서] → [분석용 테이블]
     ↓              ↓              ↓
AnalysisStaticData  변환 로직    AnalysisData
   (기존 패키지)   (새로 구현)   (새로운 패키지)
```

---

## 3. 구현 표준화 템플릿

### 3.1 Oracle DDL 템플릿
```sql
-- 기존 테이블 완전 삭제
DROP TABLE ANALYSIS_[ERD명]_STATISTICS CASCADE CONSTRAINTS PURGE;
DROP SEQUENCE SEQ_ANALYSIS_[ERD명]_STATISTICS;

-- 제약조건 없는 분석용 테이블 생성
CREATE TABLE ANALYSIS_[ERD명]_STATISTICS (
    ID                      NUMBER,                     -- 제한 없음
    [필드명1]               VARCHAR2(4000),             -- 최대 크기
    [필드명2]               NUMBER,                     -- 제한 없음
    -- 좌표 필드 (필요시)
    LATITUDE                NUMBER,                     
    LONGITUDE               NUMBER
);

-- 시퀀스 생성
CREATE SEQUENCE SEQ_ANALYSIS_[ERD명]_STATISTICS START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;
```

### 3.2 JPA Entity 템플릿
```java
package com.WhereHouse.AnalysisData.[erd명].entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;

@Entity
@Table(name = "ANALYSIS_[ERD명]_STATISTICS")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Analysis[Erd명]Statistics {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "analysis_[erd명]_seq")
    @SequenceGenerator(name = "analysis_[erd명]_seq", sequenceName = "SEQ_ANALYSIS_[ERD명]_STATISTICS", allocationSize = 1)
    @Column(name = "ID")
    private Long id;

    // 비즈니스 필드들
    @Column(name = "[필드명]")
    private String [필드명];

    // 좌표 필드 (필요시)
    @Column(name = "LATITUDE", precision = 10, scale = 8)
    private BigDecimal latitude;

    @Column(name = "LONGITUDE", precision = 10, scale = 8)
    private BigDecimal longitude;
}
```

### 3.3 Repository 템플릿
```java
package com.WhereHouse.AnalysisData.[erd명].repository;

import com.WhereHouse.AnalysisData.[erd명].entity.Analysis[Erd명]Statistics;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface Analysis[Erd명]Repository extends JpaRepository<Analysis[Erd명]Statistics, Long> {
    
    // 기본 CRUD는 JpaRepository가 제공
    
    // 데이터 검증용 커스텀 쿼리
    @Query("SELECT COUNT(a) FROM Analysis[Erd명]Statistics a")
    long countAnalysisData();
    
    // 필요에 따라 추가 쿼리 메서드
}
```

### 3.4 Processor 템플릿
```java
package com.WhereHouse.AnalysisData.[erd명].processor;

import com.WhereHouse.AnalysisData.[erd명].entity.Analysis[Erd명]Statistics;
import com.WhereHouse.AnalysisData.[erd명].repository.Analysis[Erd명]Repository;
// 기존 원천 데이터 import
import com.WhereHouse.AnalysisStaticData.[원천패키지].entity.[원천Entity];
import com.WhereHouse.AnalysisStaticData.[원천패키지].repository.[원천Repository];
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;

/**
 * [ERD명] 데이터 분석용 테이블 생성 처리 컴포넌트
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class [Erd명]DataProcessor {

    private final [원천Repository] original[Erd명]Repository;
    private final Analysis[Erd명]Repository analysis[Erd명]Repository;

    @Transactional
    public void processAnalysis[Erd명]Data() {
        log.info("=== [ERD명] 데이터 분석용 테이블 생성 작업 시작 ===");
        
        // Step 1: 중복 확인
        long existingCount = analysis[Erd명]Repository.count();
        if (existingCount > 0) {
            log.info("분석용 [ERD명] 데이터 이미 존재 ({}개). 작업 스킵", existingCount);
            return;
        }

        // Step 2: 원본 데이터 조회
        List<[원천Entity]> originalDataList = original[Erd명]Repository.findAll();
        if (originalDataList.isEmpty()) {
            log.warn("원본 [ERD명] 데이터가 존재하지 않습니다.");
            return;
        }

        // Step 3: 데이터 변환 및 저장
        int successCount = 0;
        int failedCount = 0;

        for ([원천Entity] originalData : originalDataList) {
            try {
                Analysis[Erd명]Statistics analysisData = convertToAnalysisEntity(originalData);
                analysis[Erd명]Repository.save(analysisData);
                successCount++;
            } catch (Exception e) {
                log.error("변환 실패: {}", e.getMessage());
                failedCount++;
            }
        }

        log.info("[ERD명] 데이터 변환 완료 - 성공: {}, 실패: {}", successCount, failedCount);
        log.info("=== [ERD명] 데이터 분석용 테이블 생성 작업 종료 ===");
    }

    private Analysis[Erd명]Statistics convertToAnalysisEntity([원천Entity] original) {
        // 변환 로직 구현
        return Analysis[Erd명]Statistics.builder()
            // 필드 매핑
            .build();
    }
}
```

---

## 4. 좌표 변환 처리 가이드

### 4.1 좌표 변환이 필요한 ERD
개별 시설물 위치 정보가 있는 데이터:
- CCTV, 은행, 편의점, 경찰서, 병원, 학교 등

### 4.2 좌표 변환이 불필요한 ERD  
구별 집계 데이터:
- 범죄통계, 인구통계 등

### 4.3 KakaoMap API 연동 (좌표 변환 필요시)
```java
// Processor에 추가
private final KakaoAddressApiClient kakaoAddressApiClient;

// 변환 메서드에서 사용
KakaoAddressApiClient.AddressSearchResponse response = 
    kakaoAddressApiClient.searchAddress(address);
    
if (response.getDocuments() != null && !response.getDocuments().isEmpty()) {
    KakaoAddressApiClient.AddressSearchResponse.Document doc = 
        response.getDocuments().get(0);
    latitude = new BigDecimal(doc.getLatitude());
    longitude = new BigDecimal(doc.getLongitude());
}

// API 호출 제한 대응
Thread.sleep(100);
```

---

## 5. Main 통합 실행 클래스

### 5.1 AnalysisDataProcessor 구조
```java
package com.WhereHouse.AnalysisData.main;

import com.WhereHouse.AnalysisData.crime.processor.CrimeDataProcessor;
// ... 19개 프로세서 import
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class AnalysisDataProcessor implements CommandLineRunner {

    // 19개 프로세서 주입
    private final CrimeDataProcessor crimeDataProcessor;
    // private final CctvDataProcessor cctvDataProcessor;
    // ... 추가 프로세서들

    @Override
    public void run(String... args) throws Exception {
        log.info("=== 안전성 분석용 데이터 처리 시작 ===");
        
        try {
            // 순차적 실행
            crimeDataProcessor.processAnalysisCrimeData();
            // cctvDataProcessor.processAnalysisCctvData();
            // ... 추가 실행
            
        } catch (Exception e) {
            log.error("분석용 데이터 처리 중 오류 발생", e);
            throw e;
        }
        
        log.info("=== 안전성 분석용 데이터 처리 완료 ===");
    }
}
```

### 5.2 Spring Boot Main 애플리케이션 설정
```java
@SpringBootApplication
@ComponentScan(basePackages = {
    "com.WhereHouse.AnalysisStaticData", 
    "com.WhereHouse.AnalysisData"
})
public class ApiTestApplication {
    public static void main(String[] args) {
        SpringApplication.run(ApiTestApplication.class, args);
        System.out.println("Application Done");
    }
}
```

---

## 6. 실행 체크리스트

### 6.1 사전 준비
- [ ] Oracle DB DDL 실행으로 테이블 생성
- [ ] 기존 원천 데이터 존재 확인
- [ ] KakaoMap API 키 설정 (좌표 변환 필요시)

### 6.2 구현 확인
- [ ] JPA Entity 생성 및 테이블 매핑 확인
- [ ] Repository 인터페이스 구현
- [ ] Processor 비즈니스 로직 구현
- [ ] Main 클래스에 프로세서 추가

### 6.3 실행 및 검증
- [ ] Spring Boot 애플리케이션 실행
- [ ] 로그에서 데이터 변환 완료 확인
- [ ] Oracle에서 `SELECT COUNT(*) FROM ANALYSIS_[ERD명]_STATISTICS` 검증

---

## 7. 에러 처리 및 디버깅

### 7.1 자주 발생하는 문제
- **ComponentScan 누락**: `@ComponentScan`에 `AnalysisData` 패키지 추가 필요
- **DDL 제약조건**: Oracle 테이블 생성 시 제약조건으로 인한 ALTER 오류
- **API 호출 제한**: KakaoMap API 호출량 초과 시 속도 조절 필요

### 7.2 디버깅 로그 활용
각 프로세서는 다음 로그를 출력하도록 구현:
- 작업 시작/종료
- 원본 데이터 개수
- 변환 성공/실패 개수
- 단계별 진행 상황

---

## 8. 확장 및 유지보수 가이드

### 8.1 신규 ERD 추가 시
1. 패키지 구조 생성: `com.WhereHouse.AnalysisData.[신규erd명]`
2. 템플릿 기반 Entity/Repository/Processor 구현
3. Main 클래스에 프로세서 주입 및 실행 추가

### 8.2 성능 최적화
- 배치 사이즈 조정: `@Transactional` 범위 조정
- API 호출 최적화: 병렬 처리 또는 캐싱 고려
- 메모리 관리: 대용량 데이터 처리 시 스트리밍 방식 고려

이 명세서를 따라 구현하면 19개 모든 ERD에 대해 일관된 분석용 데이터 처리 시스템을 구축할 수 있습니다.