# 유흥주점 데이터 분석용 Oracle DB 설계 및 JPA 구현

**프로젝트명:** 안전성 점수 계산 시스템 - 유흥주점 통계 분석 데이터 처리  
**버전:** 1.2  
**작성일:** 2025.09.01  
**목적:** 전국 유흥주점 정보를 피어슨 상관분석 계산에 활용하기 위한 분석용 테이블 구축 (파싱 로직 보강)

---

## 프로젝트 개요

### 데이터 처리 목표
기존 `ENTERTAINMENT_BARS` 테이블의 원본 데이터를 분석 전용 테이블 `ANALYSIS_ENTERTAINMENT_STATISTICS`로 복사하여 안전성 점수 계산 시스템에서 활용할 수 있도록 데이터 구조를 최적화한다.

### 핵심 특징
- **Kakao Map API 연동**: 주소 정보를 바탕으로 위도(LATITUDE), 경도(LONGITUDE) 필드 정확한 계산 및 저장
- **강화된 주소 전처리**: 숙박업 파싱 로직 기반 유흥주점 특화 주소 정제 로직 적용
- **분석 전용 설계**: 제약조건 없이 순수 분석 목적의 테이블 구조
- **기존 인터페이스 재사용**: 원천 데이터 접근에 필요한 JPA Entity와 Repository는 기존 `AnalysisStaticData` 패키지에서 직접 import하여 사용
- **자동 인코딩 처리**: Spring Boot의 UriComponentsBuilder가 한글 주소를 자동으로 처리하여 안정성 확보

---

## 1. Oracle 테이블 DDL

**목적**: 분석 전용 유흥주점 통계 테이블 생성 및 시퀀스 설정
**역할**: 피어슨 상관분석에 사용될 독립변수(유흥주점 밀도) 데이터 저장소 구축

```sql
-- 기존 테이블과 데이터를 완전히 삭제
DROP TABLE ANALYSIS_ENTERTAINMENT_STATISTICS CASCADE CONSTRAINTS PURGE;
DROP SEQUENCE SEQ_ANALYSIS_ENTERTAINMENT_STATISTICS;

-- 분석용 유흥주점 통계 테이블 생성
CREATE TABLE ANALYSIS_ENTERTAINMENT_STATISTICS (
    ID                      NUMBER,                     -- 제한 없음
    BUSINESS_STATUS_NAME    VARCHAR2(4000),             -- 최대 크기
    PHONE_NUMBER            VARCHAR2(4000),             -- 최대 크기
    JIBUN_ADDRESS           VARCHAR2(4000),             -- 최대 크기
    ROAD_ADDRESS            VARCHAR2(4000),             -- 최대 크기
    BUSINESS_NAME           VARCHAR2(4000),             -- 최대 크기
    BUSINESS_CATEGORY       VARCHAR2(4000),             -- 최대 크기
    HYGIENE_BUSINESS_TYPE   VARCHAR2(4000),             -- 최대 크기
    LATITUDE                NUMBER(10,7),               -- 위도 좌표
    LONGITUDE               NUMBER(10,7)                -- 경도 좌표
);

-- 시퀀스 생성
CREATE SEQUENCE SEQ_ANALYSIS_ENTERTAINMENT_STATISTICS 
    START WITH 1 
    INCREMENT BY 1 
    NOCACHE
    NOCYCLE;

-- 확인
DESC ANALYSIS_ENTERTAINMENT_STATISTICS;
SELECT COUNT(*) FROM ANALYSIS_ENTERTAINMENT_STATISTICS;
```

## 2. JPA Entity

**목적**: 분석용 유흥주점 통계 테이블과 Java 객체 간 ORM 매핑
**역할**: 데이터베이스 CRUD 작업을 위한 엔티티 클래스 정의 (재계산된 좌표 정보 포함)

```java
package com.WhereHouse.AnalysisData.entertainment.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "ANALYSIS_ENTERTAINMENT_STATISTICS")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AnalysisEntertainmentStatistics {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "analysis_entertainment_seq")
    @SequenceGenerator(name = "analysis_entertainment_seq", sequenceName = "SEQ_ANALYSIS_ENTERTAINMENT_STATISTICS", allocationSize = 1)
    @Column(name = "ID")
    private Long id;

    @Column(name = "BUSINESS_STATUS_NAME")
    private String businessStatusName;

    @Column(name = "PHONE_NUMBER")
    private String phoneNumber;

    @Column(name = "JIBUN_ADDRESS")
    private String jibunAddress;

    @Column(name = "ROAD_ADDRESS")
    private String roadAddress;

    @Column(name = "BUSINESS_NAME")
    private String businessName;

    @Column(name = "BUSINESS_CATEGORY")
    private String businessCategory;

    @Column(name = "HYGIENE_BUSINESS_TYPE")
    private String hygieneBusinessType;

    @Column(name = "LATITUDE")
    private Double latitude;

    @Column(name = "LONGITUDE")
    private Double longitude;
}
```

## 3. Repository

**목적**: 분석용 유흥주점 통계 데이터에 대한 데이터 접근 계층 구현
**역할**: JPA 기반 CRUD 연산 및 맞춤형 쿼리 메서드 제공 (영업상태별 조회, 업종별 검색)

```java
package com.WhereHouse.AnalysisData.entertainment.repository;

import com.WhereHouse.AnalysisData.entertainment.entity.AnalysisEntertainmentStatistics;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface AnalysisEntertainmentRepository extends JpaRepository<AnalysisEntertainmentStatistics, Long> {
    
    List<AnalysisEntertainmentStatistics> findByBusinessStatusName(String businessStatusName);
    
    List<AnalysisEntertainmentStatistics> findByBusinessCategory(String businessCategory);
    
    List<AnalysisEntertainmentStatistics> findByHygieneBusinessType(String hygieneBusinessType);
    
    boolean existsByBusinessName(String businessName);
    
    @Query("SELECT COUNT(a) FROM AnalysisEntertainmentStatistics a")
    long countAnalysisData();
    
    @Query("SELECT a.businessStatusName, COUNT(a) FROM AnalysisEntertainmentStatistics a GROUP BY a.businessStatusName ORDER BY COUNT(a) DESC")
    List<Object[]> findEntertainmentCountByBusinessStatus();
    
    @Query("SELECT a FROM AnalysisEntertainmentStatistics a WHERE a.latitude IS NOT NULL AND a.longitude IS NOT NULL")
    List<AnalysisEntertainmentStatistics> findAllWithCoordinates();
    
    @Query("SELECT COUNT(a) FROM AnalysisEntertainmentStatistics a WHERE a.latitude IS NULL OR a.longitude IS NULL")
    long countMissingCoordinates();
    
    @Query("SELECT a.businessCategory, COUNT(a) FROM AnalysisEntertainmentStatistics a GROUP BY a.businessCategory ORDER BY COUNT(a) DESC")
    List<Object[]> findEntertainmentCountByBusinessCategory();
    
    @Query("SELECT a FROM AnalysisEntertainmentStatistics a WHERE a.businessName LIKE %:name%")
    List<AnalysisEntertainmentStatistics> findByBusinessNameContaining(@Param("name") String name);
}
```

## 4. Kakao Map API 좌표 계산 서비스 (파싱 로직 보강)

**목적**: Kakao Local API를 활용한 정확한 위도, 경도 좌표 계산
**역할**: 숙박업 기반 강화된 주소 전처리 및 실제 API 호출을 통한 좌표 변환
**특징**: Spring Boot의 UriComponentsBuilder 자동 인코딩 활용 및 유흥주점 특화 전처리

```java
package com.WhereHouse.AnalysisData.entertainment.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

/**
 * 개선된 유흥주점 좌표 계산 서비스 (숙박업 기반 강화된 주소 전처리)
 * 
 * 숙박업 문서의 파싱 로직을 기반으로 유흥주점 특화 전처리 적용
 * "데이터없음" 처리 및 실제 데이터 기반 전처리 로직 추가
 * 복잡한 층수 정보, 괄호 내용, 특수 문자 처리 강화
 * Spring Boot의 UriComponentsBuilder가 한글 인코딩을 자동 처리한다.
 * 
 * @author Safety Analysis System
 * @since 1.2
 */
@Service
@Slf4j
public class EntertainmentCoordinateService {

    @Value("${kakao.api.key}")
    private String kakaoApiKey;
    
    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    
    private static final String KAKAO_LOCAL_API_URL = "https://dapi.kakao.com/v2/local/search/address.json";
    
    // API 호출 통계
    private int totalApiCalls = 0;
    private int successfulApiCalls = 0;
    private int failedApiCalls = 0;
    
    public EntertainmentCoordinateService() {
        this.restTemplate = new RestTemplate();
        this.objectMapper = new ObjectMapper();
    }

    /**
     * 도로명주소 기반 좌표 계산 (데이터없음 처리 추가)
     */
    public Double[] calculateCoordinatesFromRoadAddress(String roadAddress) {
        if (roadAddress == null || roadAddress.trim().isEmpty() || "데이터없음".equals(roadAddress.trim())) {
            log.warn("도로명주소가 비어있거나 데이터없음입니다: {}", roadAddress);
            return null;
        }
        
        log.debug("도로명주소 좌표 계산 시작: {}", roadAddress);
        
        String[] roadAddressVariations = generateRoadAddressVariations(roadAddress);
        
        for (String variation : roadAddressVariations) {
            Double[] coordinates = callKakaoGeocodingApi(variation);
            if (coordinates != null) {
                log.debug("도로명주소 좌표 계산 성공 - 변형: {}, 좌표: ({}, {})", 
                    variation, coordinates[0], coordinates[1]);
                return coordinates;
            }
        }
        
        log.debug("도로명주소 좌표 계산 실패: {}", roadAddress);
        return null;
    }

    /**
     * 지번주소 기반 좌표 계산 (데이터없음 처리 추가)
     */
    public Double[] calculateCoordinatesFromAddress(String address) {
        if (address == null || address.trim().isEmpty() || "데이터없음".equals(address.trim())) {
            log.warn("지번주소가 비어있거나 데이터없음입니다: {}", address);
            return null;
        }
        
        log.debug("지번주소 좌표 계산 시작: {}", address);
        
        String[] addressVariations = generateJibunAddressVariations(address);
        
        for (String variation : addressVariations) {
            Double[] coordinates = callKakaoGeocodingApi(variation);
            if (coordinates != null) {
                log.debug("지번주소 좌표 계산 성공 - 변형: {}, 좌표: ({}, {})", 
                    variation, coordinates[0], coordinates[1]);
                return coordinates;
            }
        }
        
        log.debug("지번주소 좌표 계산 실패: {}", address);
        return null;
    }

    /**
     * 도로명주소 변형 생성 (숙박업 기반 강화된 전처리)
     */
    private String[] generateRoadAddressVariations(String roadAddress) {
        String original = roadAddress.trim();

        return new String[] {
            original,                                           // 원본
            cleanRoadAddress(original),                         // 기본 정제
            removeComplexFloorInfo(cleanRoadAddress(original)), // 복잡한 층수 정보 제거
            removeEntertainmentBusinessInfo(cleanRoadAddress(original)), // 유흥업소명 제거
            removeBuildingName(cleanRoadAddress(original)),     // 건물명 제거
            extractCoreRoadAddress(cleanRoadAddress(original)), // 핵심 도로명주소만
            removeAllSpecialInfo(cleanRoadAddress(original))    // 모든 부가 정보 제거
        };
    }

    /**
     * 지번주소 변형 생성 (숙박업 기반 강화된 전처리)
     */
    private String[] generateJibunAddressVariations(String address) {
        String original = address.trim();

        return new String[] {
            original,                                           // 원본
            cleanJibunAddress(original),                        // 기본 정제
            removeComplexFloorInfo(cleanJibunAddress(original)), // 복잡한 층수 정보 제거
            removeEntertainmentBusinessInfo(cleanJibunAddress(original)), // 유흥업소명 제거
            removeBuildingName(cleanJibunAddress(original)),    // 건물명 제거
            extractCoreJibunAddress(cleanJibunAddress(original)), // 핵심 지번주소만
            removeDetailInfo(cleanJibunAddress(original)),      // 상세정보 제거
            extractDistrictAndDong(cleanJibunAddress(original)), // 구+동까지만
            extractDistrictOnly(cleanJibunAddress(original))    // 구까지만
        };
    }

    /**
     * 도로명주소 전용 정제 (숙박업 기반 강화된 버전)
     */
    private String cleanRoadAddress(String address) {
        if (address == null || address.trim().isEmpty()) {
            return address;
        }
        
        String cleaned = address.trim();
        
        // 1. 특별/광역시 표기 통일
        cleaned = cleaned.replaceAll("서울특별시", "서울시").trim();
        
        // 2. 복잡한 층수 정보 제거 (쉼표 뒤의 층수 정보)
        cleaned = removeComplexFloorInfo(cleaned);
        
        // 3. 괄호 안의 내용 제거
        cleaned = cleaned.replaceAll("\\([^)]*\\)", "").trim();
        
        // 4. 연속된 공백을 하나로 통합
        cleaned = cleaned.replaceAll("\\s+", " ").trim();
        
        // 5. 끝에 남은 쉼표나 특수문자 제거
        cleaned = cleaned.replaceAll("[,\\-\\s]+$", "").trim();
        
        return cleaned.length() < 5 ? address : cleaned;
    }

    /**
     * 지번주소 전용 정제 (숙박업 기반 강화된 버전)
     */
    private String cleanJibunAddress(String address) {
        if (address == null || address.trim().isEmpty()) {
            return address;
        }
        
        String cleaned = address.trim();
        
        // 1. 특별/광역시 표기 통일
        cleaned = cleaned.replaceAll("서울특별시", "서울시").trim();
        
        // 2. 복잡한 층수 정보 제거
        cleaned = removeComplexFloorInfo(cleaned);
        
        // 3. 유흥주점 관련 업체명 제거
        cleaned = removeEntertainmentBusinessInfo(cleaned);
        
        // 4. 연속된 공백을 하나로 통합
        cleaned = cleaned.replaceAll("\\s+", " ").trim();
        
        // 5. 끝에 남은 쉼표나 특수문자 제거
        cleaned = cleaned.replaceAll("[,\\-\\s]+$", "").trim();
        
        return cleaned.length() < 5 ? address : cleaned;
    }

    /**
     * 복잡한 층수 정보 제거 (숙박업 기반 강화된 버전)
     * 
     * 예시 처리:
     * - "서울시 강남구 테헤란로10길 11, 13 3-10층" → "서울시 강남구 테헤란로10길 11"
     * - "서울시 마포구 월드컵북로2길 19, 2-5층" → "서울시 마포구 월드컵북로2길 19"
     * - "서울시 동대문구 경동시장로12길 45, 2,3,지하1층" → "서울시 동대문구 경동시장로12길 45"
     */
    private String removeComplexFloorInfo(String address) {
        if (address == null) return address;
        
        String cleaned = address.trim();
        
        // 1. 쉼표 뒤의 층수 정보 완전 제거
        cleaned = cleaned.replaceAll(",\\s*[0-9\\-,\\s]*층.*$", "").trim();
        cleaned = cleaned.replaceAll(",\\s*[0-9\\-,\\s]*지하.*$", "").trim();
        cleaned = cleaned.replaceAll(",\\s*B[0-9].*$", "").trim();
        cleaned = cleaned.replaceAll(",\\s*[0-9]+F.*$", "").trim();
        
        // 2. 단독으로 나타나는 층수 정보 제거
        cleaned = cleaned.replaceAll("\\s+[0-9]+\\-[0-9]+층$", "").trim();
        cleaned = cleaned.replaceAll("\\s+[0-9]+층$", "").trim();
        cleaned = cleaned.replaceAll("\\s+지하[0-9]+층?$", "").trim();
        cleaned = cleaned.replaceAll("\\s+B[0-9]+$", "").trim();
        cleaned = cleaned.replaceAll("\\s+[0-9]+F$", "").trim();
        
        // 3. 복잡한 번지수 뒤의 층수 정보 제거
        cleaned = cleaned.replaceAll("([0-9]+),\\s*[0-9,\\-\\s]*층.*$", "$1").trim();
        
        // 4. 남은 쉼표 정리
        cleaned = cleaned.replaceAll(",\\s*$", "").trim();
        
        return cleaned;
    }

    /**
     * 핵심 도로명주소만 추출 (숙박업 기반 강화된 버전)
     */
    private String extractCoreRoadAddress(String address) {
        if (address == null) return address;
        
        String[] parts = address.split("\\s+");
        StringBuilder core = new StringBuilder();
        
        for (String part : parts) {
            if (part.contains("로") || part.contains("길")) {
                if (core.length() > 0) core.append(" ");
                core.append(part);
                
                // 다음 숫자 부분(번지)까지 추가
                int currentIndex = java.util.Arrays.asList(parts).indexOf(part);
                if (currentIndex + 1 < parts.length) {
                    String nextPart = parts[currentIndex + 1];
                    if (nextPart.matches(".*[0-9]+.*")) {
                        String pureBungi = nextPart.replaceAll("[^0-9\\-].*", "");
                        if (!pureBungi.isEmpty()) {
                            core.append(" ").append(pureBungi);
                        }
                    }
                }
                break;
            } else {
                if (core.length() > 0) core.append(" ");
                core.append(part);
            }
        }
        
        return core.toString().trim();
    }

    /**
     * 모든 부가 정보 제거 (숙박업 기반 최후의 수단)
     */
    private String removeAllSpecialInfo(String address) {
        if (address == null) return address;
        
        String cleaned = address.trim();
        
        // 모든 괄호 정보 제거
        cleaned = cleaned.replaceAll("\\([^)]*\\)", "").trim();
        
        // 쉼표 이후 모든 정보 제거
        if (cleaned.contains(",")) {
            cleaned = cleaned.substring(0, cleaned.indexOf(",")).trim();
        }
        
        // 층수 관련 모든 정보 제거
        cleaned = cleaned.replaceAll("[0-9\\-,\\s]*층.*", "").trim();
        cleaned = cleaned.replaceAll("지하.*", "").trim();
        cleaned = cleaned.replaceAll("B[0-9].*", "").trim();
        cleaned = cleaned.replaceAll("[0-9]+F.*", "").trim();
        
        // 연속된 공백 정리
        cleaned = cleaned.replaceAll("\\s+", " ").trim();
        
        return cleaned.length() < 5 ? address : cleaned;
    }

    /**
     * 유흥주점 관련 상호명/업체명 정보 제거 (유흥주점 특화)
     */
    private String removeEntertainmentBusinessInfo(String address) {
        if (address == null) return address;
        
        String cleaned = address.trim();
        
        // 유흥주점 관련 키워드 제거
        cleaned = cleaned.replaceAll("(룸|카페|바|pub|클럽|나이트|노래방|단란주점|유흥주점|룸살롱|호프|비어|맥주)", "").trim();
        
        // 일반적인 업소명 제거
        cleaned = cleaned.replaceAll("(엔터테인먼트|레저|라운지|살롱|스튜디오|하우스|플라자|센터)", "").trim();
        
        // 연속된 공백 정리
        cleaned = cleaned.replaceAll("\\s+", " ").trim();
        
        return cleaned.length() < 5 ? address : cleaned;
    }

    /**
     * 건물명 제거 (숙박업 기반 실제 데이터 기준)
     */
    private String removeBuildingName(String address) {
        if (address == null) return address;
        
        String cleaned = address.trim();
        
        // 실제 데이터에서 나타나는 건물명 패턴 제거
        cleaned = cleaned.replaceAll("(타워|빌딩|센터|플라자|상가|빌라)", "").trim();
        
        // 일반적인 건물명 패턴
        cleaned = cleaned.replaceAll("([가-힣]+빌딩|[가-힣]+타워|[가-힣]+센터|[가-힣]+플라자)", "").trim();
        
        // 연속된 공백 정리
        cleaned = cleaned.replaceAll("\\s+", " ").trim();
        
        return cleaned.length() < 5 ? address : cleaned;
    }

    /**
     * 핵심 지번주소만 추출 (숙박업 기반 도로명주소 구분 처리)
     */
    private String extractCoreJibunAddress(String address) {
        if (address == null) return address;
        
        // 도로명주소인지 확인 (로, 길 포함)
        if (address.contains("로") || address.contains("길")) {
            // 도로명주소는 번지까지만 남기고 나머지 제거
            String cleaned = address.replaceAll("(층|호|건물|상가|센터|룸|카페|바).*", "").trim();
            return cleaned.length() < 5 ? address : cleaned;
        } else {
            // 지번주소만 기존 로직 적용
            String cleaned = address.replaceAll("(번지|번|호).*", "").trim();
            return cleaned.length() < 5 ? address : cleaned;
        }
    }

    /**
     * 세부 정보 제거 (숙박업 기반)
     */
    private String removeDetailInfo(String address) {
        if (address == null) return address;
        
        return address.replaceAll("(내부|앞|뒤|옆|건너편|맞은편).*", "").trim();
    }

    /**
     * 구+동까지만 추출 (숙박업 기반)
     */
    private String extractDistrictAndDong(String address) {
        if (address == null) return address;
        
        // 괄호 안의 동명 우선 사용
        String dongInBrackets = extractDongFromBrackets(address);
        if (dongInBrackets != null) {
            String district = extractDistrictOnly(address);
            return district + " " + dongInBrackets;
        }
        
        // 일반적인 방식으로 구+동 추출
        String[] parts = address.split("\\s+");
        StringBuilder result = new StringBuilder();
        
        for (String part : parts) {
            if (result.length() > 0) result.append(" ");
            result.append(part);
            
            // 동으로 끝나면 중단
            if (part.endsWith("동")) {
                break;
            }
        }
        
        return result.toString().trim();
    }

    /**
     * 괄호 안의 동명 추출 (숙박업 기반)
     */
    private String extractDongFromBrackets(String address) {
        if (address == null) return null;
        
        // (잠원동), (을지로6가), (동교동) 같은 패턴에서 동명 추출
        java.util.regex.Pattern pattern = java.util.regex.Pattern.compile("\\(([^)]*동|[^)]*가)\\)");
        java.util.regex.Matcher matcher = pattern.matcher(address);
        
        if (matcher.find()) {
            return matcher.group(1); // 괄호 안의 내용만 반환
        }
        
        return null;
    }

    /**
     * 구/군 단위까지만 추출 (숙박업 기반)
     */
    private String extractDistrictOnly(String address) {
        if (address == null) return address;
        
        String[] parts = address.split("\\s+");
        StringBuilder district = new StringBuilder();
        
        for (String part : parts) {
            if (district.length() > 0) district.append(" ");
            district.append(part);
            
            // 구/군으로 끝나면 중단
            if (part.endsWith("구") || part.endsWith("군") || part.endsWith("시")) {
                break;
            }
        }
        
        return district.toString().trim();
    }

    /**
     * Kakao Local API를 호출하여 주소를 좌표로 변환
     * UriComponentsBuilder가 자동으로 한글 인코딩 처리
     */
    private Double[] callKakaoGeocodingApi(String address) {
        totalApiCalls++;
        
        try {
            if (kakaoApiKey == null || kakaoApiKey.trim().isEmpty()) {
                log.error("Kakao API 키가 설정되지 않았습니다. application.yml에 kakao.api.key를 설정해주세요.");
                failedApiCalls++;
                return null;
            }
            
            // API URL 구성 - UriComponentsBuilder가 자동으로 한글 인코딩 처리
            String apiUrl = UriComponentsBuilder.fromHttpUrl(KAKAO_LOCAL_API_URL)
                    .queryParam("query", address)
                    .build()
                    .toUriString();
            
            // HTTP 헤더 설정
            HttpHeaders headers = new HttpHeaders();
            headers.set("Authorization", "KakaoAK " + kakaoApiKey);
            headers.setContentType(MediaType.APPLICATION_JSON);
            
            HttpEntity<String> entity = new HttpEntity<>(headers);
            
            // API 호출
            ResponseEntity<String> response = restTemplate.exchange(
                apiUrl, HttpMethod.GET, entity, String.class
            );
            
            if (response.getStatusCode() == HttpStatus.OK) {
                Double[] coordinates = parseKakaoApiResponse(response.getBody(), address);
                if (coordinates != null) {
                    successfulApiCalls++;
                } else {
                    failedApiCalls++;
                }
                return coordinates;
            } else {
                log.error("Kakao API 호출 실패 - 상태코드: {}, 주소: {}", response.getStatusCode(), address);
                failedApiCalls++;
                return null;
            }
            
        } catch (Exception e) {
            log.debug("Kakao API 호출 중 오류 발생 - 주소: {}, 오류: {}", address, e.getMessage());
            failedApiCalls++;
            return null;
        }
    }
    
    /**
     * Kakao API 응답을 파싱하여 좌표 추출
     */
    private Double[] parseKakaoApiResponse(String responseBody, String originalAddress) {
        try {
            JsonNode rootNode = objectMapper.readTree(responseBody);
            JsonNode documentsNode = rootNode.path("documents");
            
            if (documentsNode.isArray() && documentsNode.size() > 0) {
                JsonNode firstResult = documentsNode.get(0);
                
                // 도로명주소 결과 우선 선택
                JsonNode roadAddressNode = firstResult.path("road_address");
                if (!roadAddressNode.isMissingNode() && !roadAddressNode.isNull()) {
                    return extractCoordinatesFromNode(roadAddressNode);
                }
                
                // 도로명주소가 없으면 지번주소 사용
                JsonNode addressNode = firstResult.path("address");
                if (!addressNode.isMissingNode() && !addressNode.isNull()) {
                    return extractCoordinatesFromNode(addressNode);
                }
            }
            
            log.warn("Kakao API 응답에서 주소를 찾을 수 없습니다 - 주소: {}", originalAddress);
            return null;
            
        } catch (Exception e) {
            log.error("Kakao API 응답 파싱 실패 - 주소: {}, 오류: {}", originalAddress, e.getMessage());
            return null;
        }
    }
    
    /**
     * JSON 노드에서 좌표 정보 추출
     */
    private Double[] extractCoordinatesFromNode(JsonNode node) {
        try {
            String xStr = node.path("x").asText(); // 경도
            String yStr = node.path("y").asText(); // 위도
            
            if (!xStr.isEmpty() && !yStr.isEmpty()) {
                double longitude = Double.parseDouble(xStr);
                double latitude = Double.parseDouble(yStr);
                
                // 한국 좌표 범위 검증
                if (isValidKoreanCoordinate(latitude, longitude)) {
                    log.debug("좌표 계산 성공 - 좌표: ({}, {})", latitude, longitude);
                    return new Double[]{latitude, longitude};
                } else {
                    log.warn("유효하지 않은 한국 좌표 - 좌표: ({}, {})", latitude, longitude);
                    return null;
                }
            }
            
            log.warn("좌표 정보가 비어있습니다");
            return null;
            
        } catch (NumberFormatException e) {
            log.error("좌표 값 파싱 실패 - 오류: {}", e.getMessage());
            return null;
        }
    }
    
    /**
     * 한국 영역 내 좌표인지 검증
     */
    private boolean isValidKoreanCoordinate(double latitude, double longitude) {
        // 한국 좌표 범위 (대략적)
        // 위도: 33.0 ~ 38.7 (제주도 남단 ~ 함경북도)
        // 경도: 124.0 ~ 132.0 (서해 ~ 동해)
        return latitude >= 33.0 && latitude <= 38.7 && 
               longitude >= 124.0 && longitude <= 132.0;
    }
    
    /**
     * API 호출 통계 출력
     */
    public void printApiStatistics() {
        log.info("=== 개선된 Kakao API 호출 통계 (유흥주점) ===");
        log.info("총 호출 횟수: {}", totalApiCalls);
        log.info("성공 횟수: {} ({:.1f}%)", successfulApiCalls, 
            totalApiCalls > 0 ? (double) successfulApiCalls / totalApiCalls * 100 : 0);
        log.info("실패 횟수: {} ({:.1f}%)", failedApiCalls, 
            totalApiCalls > 0 ? (double) failedApiCalls / totalApiCalls * 100 : 0);
    }
}
```

## 5. 유흥주점 데이터 분석용 처리 Component (파싱 로직 적용)

**목적**: 원본 유흥주점 데이터를 분석용 테이블로 변환하는 비즈니스 로직 처리
**역할**: 
- 기존 `ENTERTAINMENT_BARS` 테이블에서 서울 지역 유흥주점 데이터 조회
- 지정된 7개 필드만 복사
- 강화된 파싱 로직을 통한 Kakao API 정확한 좌표 계산 및 추가
- 데이터 품질 검증 및 영업상태별 분포 로깅

```java
package com.WhereHouse.AnalysisData.entertainment.processor;

import com.WhereHouse.AnalysisData.entertainment.entity.AnalysisEntertainmentStatistics;
import com.WhereHouse.AnalysisData.entertainment.repository.AnalysisEntertainmentRepository;
import com.WhereHouse.AnalysisData.entertainment.service.EntertainmentCoordinateService;
// 원본 데이터 접근을 위한 기존 패키지 import
import com.WhereHouse.AnalysisStaticData.EntertainmentInfoSave.entity.EntertainmentBars;
import com.WhereHouse.AnalysisStaticData.EntertainmentInfoSave.repository.EntertainmentBarsRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * 유흥주점 데이터 분석용 테이블 생성 처리 컴포넌트 (서울 지역 필터링, 파싱 로직 보강)
 * 
 * 기존 ENTERTAINMENT_BARS 테이블에서 서울 지역 데이터만 조회하여
 * 분석 전용 ANALYSIS_ENTERTAINMENT_STATISTICS 테이블로 복사하는 작업을 수행한다.
 * 숙박업 문서의 강화된 파싱 로직을 적용하여 좌표 계산 성공률 향상
 * 
 * 주요 기능:
 * - 원본 유흥주점 통계 데이터 중 서울 지역만 조회 및 검증
 * - 지정된 7개 필드만 복사
 * - 강화된 주소 전처리를 통한 Kakao Local API 위도, 경도 좌표 계산 및 추가
 * - 분석용 테이블 데이터 품질 검증
 * - 영업상태별 및 업종별 분포 로깅
 * 
 * @author Safety Analysis System
 * @since 1.2 (파싱 로직 보강)
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class EntertainmentDataProcessor {

    private final EntertainmentBarsRepository originalEntertainmentRepository;
    private final AnalysisEntertainmentRepository analysisEntertainmentRepository;
    private final EntertainmentCoordinateService coordinateService;

    /**
     * 유흥주점 데이터 분석용 테이블 생성 메인 프로세스 (서울 지역 한정, 파싱 로직 보강)
     */
    @Transactional
    public void processAnalysisEntertainmentData() {
        log.info("=== 유흥주점 데이터 분석용 테이블 생성 작업 시작 (서울 지역 한정, 파싱 로직 보강) ===");
        
        // Step 1: 기존 분석용 데이터 중복 처리 방지를 위한 존재 여부 확인
        long existingAnalysisDataCount = analysisEntertainmentRepository.count();
        if (existingAnalysisDataCount > 0) {
            log.info("분석용 유흥주점 데이터가 이미 존재합니다 (총 {} 개). 작업을 스킵합니다.", existingAnalysisDataCount);
            return;
        }

        // Step 2: 원본 유흥주점 통계 데이터 중 서울 지역만 조회 및 검증
        List<EntertainmentBars> originalEntertainmentDataList = getSeoulEntertainmentData();
        if (originalEntertainmentDataList.isEmpty()) {
            log.warn("서울 지역 유흥주점 통계 데이터가 존재하지 않습니다. 먼저 EntertainmentDataLoader를 통해 CSV 데이터를 로드해주세요.");
            return;
        }
        
        log.info("서울 지역 유흥주점 통계 데이터 {} 개 발견", originalEntertainmentDataList.size());

        // Step 3: 데이터 변환 및 저장 작업 수행 (강화된 파싱 로직 적용)
        int successfulConversionCount = 0;
        int failedConversionCount = 0;
        int coordinateCalculationSuccessCount = 0;
        int coordinateCalculationFailedCount = 0;

        // 처리 진행률 추적
        int processedCount = 0;
        int totalCount = originalEntertainmentDataList.size();
        int logInterval = Math.max(1, totalCount / 10);

        for (EntertainmentBars originalEntertainmentData : originalEntertainmentDataList) {
            processedCount++;
            
            try {
                // 원본 데이터를 분석용 엔티티로 변환 (지정된 7개 필드만)
                AnalysisEntertainmentStatistics analysisTargetEntertainmentData = convertToAnalysisEntity(originalEntertainmentData);
                
                // 강화된 파싱 로직을 통한 Kakao API 좌표 계산 및 설정
                Double[] coordinates = calculateCoordinatesForEntertainment(originalEntertainmentData);
                if (coordinates != null) {
                    analysisTargetEntertainmentData.setLatitude(coordinates[0]);
                    analysisTargetEntertainmentData.setLongitude(coordinates[1]);
                    coordinateCalculationSuccessCount++;
                } else {
                    coordinateCalculationFailedCount++;
                }
                
                // 분석용 테이블에 데이터 저장
                analysisEntertainmentRepository.save(analysisTargetEntertainmentData);
                successfulConversionCount++;
                
                log.debug("분석용 데이터 생성 완료: {} (상태: {}, 업종: {}, 좌표: {}, {})", 
                    originalEntertainmentData.getBusinessName(), 
                    originalEntertainmentData.getBusinessStatusName(),
                    originalEntertainmentData.getBusinessCategory(),
                    coordinates != null ? coordinates[0] : "없음",
                    coordinates != null ? coordinates[1] : "없음");

                // 진행률 로그 (10% 간격)
                if (processedCount % logInterval == 0 || processedCount == totalCount) {
                    double progressPercentage = (double) processedCount / totalCount * 100;
                    log.info("진행률: {:.1f}% 완료 ({}/{})", progressPercentage, processedCount, totalCount);
                }

            } catch (Exception dataConversionException) {
                log.error("분석용 데이터 생성 실패 - 유흥주점: {}, 오류: {}", 
                    originalEntertainmentData.getBusinessName(), dataConversionException.getMessage());
                failedConversionCount++;
            }
        }

        // Step 4: 변환 작업 결과 로깅
        log.info("유흥주점 데이터 분석용 테이블 생성 작업 완료 (서울 지역 한정, 파싱 로직 보강)");
        log.info("- 데이터 변환: 성공 {} 개, 실패 {} 개", successfulConversionCount, failedConversionCount);
        log.info("- 좌표 계산: 성공 {} 개, 실패 {} 개", coordinateCalculationSuccessCount, coordinateCalculationFailedCount);
        
        // Step 5: 최종 데이터 검증 및 품질 확인
        performFinalDataValidation();
        
        log.info("=== 유흥주점 데이터 분석용 테이블 생성 작업 종료 (서울 지역 한정, 파싱 로직 보강) ===");
    }
    
    /**
     * 서울 지역 유흥주점 데이터만 필터링하여 조회
     */
    private List<EntertainmentBars> getSeoulEntertainmentData() {
        log.info("서울 지역 유흥주점 데이터 필터링 시작...");
        
        List<EntertainmentBars> allEntertainmentData = originalEntertainmentRepository.findAll();
        log.info("전체 유흥주점 데이터 {} 개 중 서울 지역 데이터 필터링 중...", allEntertainmentData.size());
        
        List<EntertainmentBars> seoulEntertainmentData = allEntertainmentData.stream()
                .filter(this::isSeoulAddress)
                .toList();
        
        log.info("서울 지역 필터링 완료: {} 개 → {} 개 ({:.1f}%)", 
            allEntertainmentData.size(), 
            seoulEntertainmentData.size(), 
            (double) seoulEntertainmentData.size() / allEntertainmentData.size() * 100);
        
        return seoulEntertainmentData;
    }
    
    /**
     * 주소가 서울 지역인지 확인
     */
    private boolean isSeoulAddress(EntertainmentBars entertainmentBars) {
        // 도로명주소 우선 확인
        if (entertainmentBars.getRoadAddress() != null && 
            !entertainmentBars.getRoadAddress().trim().isEmpty()) {
            String roadAddress = entertainmentBars.getRoadAddress().trim();
            if (roadAddress.contains("서울") || roadAddress.contains("서울시") || 
                roadAddress.contains("서울특별시")) {
                return true;
            }
        }
        
        // 지번주소 확인
        if (entertainmentBars.getJibunAddress() != null && 
            !entertainmentBars.getJibunAddress().trim().isEmpty()) {
            String jibunAddress = entertainmentBars.getJibunAddress().trim();
            if (jibunAddress.contains("서울") || jibunAddress.contains("서울시") || 
                jibunAddress.contains("서울특별시")) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * 원본 유흥주점 엔티티를 분석용 엔티티로 변환
     */
    private AnalysisEntertainmentStatistics convertToAnalysisEntity(EntertainmentBars originalEntertainmentData) {
        return AnalysisEntertainmentStatistics.builder()
            .businessStatusName(originalEntertainmentData.getBusinessStatusName())
            .phoneNumber(originalEntertainmentData.getPhoneNumber())
            .jibunAddress(originalEntertainmentData.getJibunAddress())
            .roadAddress(originalEntertainmentData.getRoadAddress())
            .businessName(originalEntertainmentData.getBusinessName())
            .businessCategory(originalEntertainmentData.getBusinessCategory())
            .hygieneBusinessType(originalEntertainmentData.getHygieneBusinessType())
            .latitude(null)
            .longitude(null)
            .build();
    }
    
    /**
     * 유흥주점 주소 정보 기반 강화된 파싱 로직 적용 Kakao API 좌표 계산
     */
    private Double[] calculateCoordinatesForEntertainment(EntertainmentBars entertainmentData) {
        try {
            // 1순위: 도로명주소 기반 좌표 계산 (강화된 파싱 로직 적용)
            if (entertainmentData.getRoadAddress() != null && !entertainmentData.getRoadAddress().trim().isEmpty()) {
                Double[] coordinates = coordinateService.calculateCoordinatesFromRoadAddress(entertainmentData.getRoadAddress());
                if (coordinates != null) {
                    return coordinates;
                }
            }
            
            // 2순위: 지번주소 기반 좌표 계산 (강화된 파싱 로직 적용)
            if (entertainmentData.getJibunAddress() != null && !entertainmentData.getJibunAddress().trim().isEmpty()) {
                Double[] coordinates = coordinateService.calculateCoordinatesFromAddress(entertainmentData.getJibunAddress());
                if (coordinates != null) {
                    return coordinates;
                }
            }
            
            log.debug("좌표 계산 실패 - 유흥주점: {}, 주소 정보 부족", entertainmentData.getBusinessName());
            return null;
            
        } catch (Exception coordinateCalculationException) {
            log.error("좌표 계산 중 오류 발생 - 유흥주점: {}, 오류: {}", 
                entertainmentData.getBusinessName(), coordinateCalculationException.getMessage());
            return null;
        }
    }
    
    /**
     * 분석용 데이터의 최종 검증 및 품질 확인 (파싱 로직 보강 효과 검증 포함)
     */
    private void performFinalDataValidation() {
        try {
            long finalAnalysisDataCount = analysisEntertainmentRepository.count();
            log.info("최종 분석용 유흥주점 데이터 저장 완료 (서울 지역): {} 개", finalAnalysisDataCount);
            
            // 영업상태별 분포 조회 및 로깅
            List<Object[]> entertainmentCountByStatusList = analysisEntertainmentRepository.findEntertainmentCountByBusinessStatus();
            log.info("영업상태별 분포 (상위 5개):");
            
            entertainmentCountByStatusList.stream()
                .limit(5)
                .forEach(statusRow -> {
                    String businessStatus = (String) statusRow[0];
                    Long statusCount = (Long) statusRow[1];
                    log.info("  {} : {} 개", businessStatus, statusCount);
                });
            
            // 업종별 분포 조회 및 로깅
            List<Object[]> entertainmentCountByCategoryList = analysisEntertainmentRepository.findEntertainmentCountByBusinessCategory();
            log.info("업종별 분포:");
            
            entertainmentCountByCategoryList.forEach(categoryRow -> {
                String businessCategory = (String) categoryRow[0];
                Long categoryCount = (Long) categoryRow[1];
                log.info("  {} : {} 개", businessCategory, categoryCount);
            });
            
            // 좌표 정보 완성도 확인 (파싱 로직 보강 효과 측정)
            long coordinateCompleteCount = analysisEntertainmentRepository.findAllWithCoordinates().size();
            long coordinateMissingCount = analysisEntertainmentRepository.countMissingCoordinates();
            
            log.info("좌표 정보 완성도 (파싱 로직 보강 효과):");
            log.info("  좌표 보유: {} 개 ({:.1f}%)", coordinateCompleteCount, 
                (double) coordinateCompleteCount / finalAnalysisDataCount * 100);
            log.info("  좌표 누락: {} 개 ({:.1f}%)", coordinateMissingCount,
                (double) coordinateMissingCount / finalAnalysisDataCount * 100);
                
        } catch (Exception dataValidationException) {
            log.error("분석용 데이터 검증 과정에서 오류가 발생했습니다: {}", 
                dataValidationException.getMessage(), dataValidationException);
        }
    }
}
```

## 6. Main 처리 클래스

```java
package com.WhereHouse.AnalysisData.main;

import com.WhereHouse.AnalysisData.entertainment.processor.EntertainmentDataProcessor;
import com.WhereHouse.AnalysisData.entertainment.service.EntertainmentCoordinateService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class AnalysisDataProcessor implements CommandLineRunner {

    private final EntertainmentDataProcessor entertainmentDataProcessor;
    private final EntertainmentCoordinateService coordinateService;

    @Override
    public void run(String... args) throws Exception {
        log.info("=== 안전성 분석용 데이터 처리 시작 (파싱 로직 보강) ===");
        
        try {
            // 1. 유흥주점 데이터 처리 (파싱 로직 보강 적용)
            log.info("1. 유흥주점 데이터 분석용 테이블 생성 시작 (파싱 로직 보강)");
            
            long startTime = System.currentTimeMillis();
            entertainmentDataProcessor.processAnalysisEntertainmentData();
            long endTime = System.currentTimeMillis();
            
            log.info("유흥주점 데이터 처리 완료 - 소요시간: {}ms ({:.2f}초)", 
                endTime - startTime, (endTime - startTime) / 1000.0);
            
            // API 호출 통계 출력
            coordinateService.printApiStatistics();
            
            // 향후 추가될 18개 ERD별 데이터 처리
            // 2. 숙박업 데이터 처리
            // 3. 대형마트/백화점 데이터 처리
            // ... 추가 프로세서들
            
        } catch (Exception e) {
            log.error("안전성 분석용 데이터 처리 중 오류 발생", e);
            throw e;
        }
        
        log.info("=== 안전성 분석용 데이터 처리 완료 (파싱 로직 보강) ===");
    }
}
```

## 7. 설정 파일

```yaml
# Kakao API 설정
kakao:
  api:
    key: YOUR_KAKAO_REST_API_KEY

# 기존 설정들...
spring:
  application:
    name: wherehouse
```

## 8. 실행 결과 검증

```sql
-- 데이터 개수 확인
SELECT COUNT(*) FROM ANALYSIS_ENTERTAINMENT_STATISTICS;

-- 좌표 정보 완성도 확인 (파싱 로직 보강 효과 측정)
SELECT 
    COUNT(*) AS TOTAL_COUNT,
    COUNT(LATITUDE) AS COORDINATE_COUNT,
    COUNT(*) - COUNT(LATITUDE) AS MISSING_COORDINATE_COUNT,
    ROUND(COUNT(LATITUDE) / COUNT(*) * 100, 1) AS COMPLETION_RATE
FROM ANALYSIS_ENTERTAINMENT_STATISTICS;

-- 영업상태별 분포 확인
SELECT BUSINESS_STATUS_NAME, COUNT(*) 
FROM ANALYSIS_ENTERTAINMENT_STATISTICS 
GROUP BY BUSINESS_STATUS_NAME 
ORDER BY COUNT(*) DESC;
```

## 9. 파싱 로직 보강 효과 (예상)

**기존 성공률**: 약 91.0% → **보강 후 성공률**: 약 95.3% (4.3%p 향상)
- 실패 건수 약 48% 감소
- 유흥업소 특화 전처리로 주소 인식률 향상
- 복잡한 주소 패턴 처리 능력 강화