# 편의점 데이터 분석용 Oracle DB 설계 및 JPA 구현 (서울지역)

**프로젝트명:** 안전성 점수 계산 시스템 - 편의점 통계 분석 데이터 처리  
**버전:** 1.1  
**작성일:** 2025.09.01  
**목적:** 서울지역 편의점 정보를 피어슨 상관분석 계산에 활용하기 위한 분석용 테이블 구축

---

## 프로젝트 개요

### 데이터 처리 목표
기존 `CONVENIENCE_STORE_STATISTICS` 테이블의 원본 데이터 중 서울지역만을 필터링하여 분석 전용 테이블 `ANALYSIS_CONVENIENCE_STORE_STATISTICS`로 복사하여 안전성 점수 계산 시스템에서 활용할 수 있도록 데이터 구조를 최적화한다.

### 핵심 특징
- **서울지역 필터링**: 주소를 기준으로 서울지역 편의점만 추출
- **기존 좌표 활용**: 원본 데이터에 포함된 위도, 경도 정보를 그대로 사용
- **분석 전용 설계**: 제약조건 없이 순수 분석 목적의 테이블 구조
- **기존 인터페이스 재사용**: 원천 데이터 접근에 필요한 JPA Entity와 Repository는 기존 `safety` 패키지에서 직접 import하여 사용
- **선택적 필드 복사**: 분석에 필요한 12개 핵심 컬럼만 선별 저장

---

## 1. Oracle 테이블 DDL

**목적**: 분석 전용 편의점 통계 테이블 생성 및 시퀀스 설정
**역할**: 피어슨 상관분석에 사용될 독립변수(편의점 밀도) 데이터 저장소 구축

```sql
-- 기존 테이블과 데이터를 완전히 삭제
DROP TABLE ANALYSIS_CONVENIENCE_STORE_STATISTICS CASCADE CONSTRAINTS PURGE;
DROP SEQUENCE SEQ_ANALYSIS_CONVENIENCE_STORE_STATISTICS;

-- 분석용 편의점 통계 테이블 생성 (서울지역만)
CREATE TABLE ANALYSIS_CONVENIENCE_STORE_STATISTICS (
    ID                      NUMBER,                     -- 제한 없음
    KAKAO_PLACE_ID          VARCHAR2(4000),             -- 카카오 장소 ID
    PLACE_NAME              VARCHAR2(4000),             -- 장소명
    CATEGORY_NAME           VARCHAR2(4000),             -- 카테고리명
    CATEGORY_GROUP_CODE     VARCHAR2(4000),             -- 카테고리 그룹 코드
    PHONE                   VARCHAR2(4000),             -- 전화번호
    ADDRESS_NAME            VARCHAR2(4000),             -- 주소명
    ROAD_ADDRESS_NAME       VARCHAR2(4000),             -- 도로명 주소명
    LONGITUDE               NUMBER(10,7),               -- 경도 좌표
    LATITUDE                NUMBER(10,7),               -- 위도 좌표
    PLACE_URL               VARCHAR2(4000),             -- 장소 URL
    DISTRICT                VARCHAR2(4000),             -- 구 정보
    STORE_BRAND             VARCHAR2(4000)              -- 편의점 브랜드
);

-- 시퀀스 생성
CREATE SEQUENCE SEQ_ANALYSIS_CONVENIENCE_STORE_STATISTICS 
    START WITH 1 
    INCREMENT BY 1 
    NOCACHE
    NOCYCLE;

-- 확인
DESC ANALYSIS_CONVENIENCE_STORE_STATISTICS;
SELECT COUNT(*) FROM ANALYSIS_CONVENIENCE_STORE_STATISTICS;
```

## 2. JPA Entity

**목적**: 분석용 편의점 통계 테이블과 Java 객체 간 ORM 매핑
**역할**: 데이터베이스 CRUD 작업을 위한 엔티티 클래스 정의 (서울지역 편의점 데이터)

```java
package com.wherehouse.AnalysisData.convenience.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;

@Entity
@Table(name = "ANALYSIS_CONVENIENCE_STORE_STATISTICS")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AnalysisConvenienceStoreStatistics {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "analysis_convenience_seq")
    @SequenceGenerator(name = "analysis_convenience_seq", sequenceName = "SEQ_ANALYSIS_CONVENIENCE_STORE_STATISTICS", allocationSize = 1)
    @Column(name = "ID")
    private Long id;

    @Column(name = "KAKAO_PLACE_ID")
    private String kakaoPlaceId;

    @Column(name = "PLACE_NAME")
    private String placeName;

    @Column(name = "CATEGORY_NAME")
    private String categoryName;

    @Column(name = "CATEGORY_GROUP_CODE")
    private String categoryGroupCode;

    @Column(name = "PHONE")
    private String phone;

    @Column(name = "ADDRESS_NAME")
    private String addressName;

    @Column(name = "ROAD_ADDRESS_NAME")
    private String roadAddressName;

    @Column(name = "LONGITUDE")
    private BigDecimal longitude;

    @Column(name = "LATITUDE")
    private BigDecimal latitude;

    @Column(name = "PLACE_URL")
    private String placeUrl;

    @Column(name = "DISTRICT")
    private String district;

    @Column(name = "STORE_BRAND")
    private String storeBrand;
}
```

## 3. Repository

**목적**: 분석용 편의점 통계 데이터에 대한 데이터 접근 계층 구현
**역할**: JPA 기반 CRUD 연산 및 맞춤형 쿼리 메서드 제공 (브랜드별 조회, 구별 검색)

```java
package com.wherehouse.AnalysisData.convenience.repository;

import com.wherehouse.AnalysisData.convenience.entity.AnalysisConvenienceStoreStatistics;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface AnalysisConvenienceStoreRepository extends JpaRepository<AnalysisConvenienceStoreStatistics, Long> {
    
    List<AnalysisConvenienceStoreStatistics> findByDistrict(String district);
    
    List<AnalysisConvenienceStoreStatistics> findByStoreBrand(String storeBrand);
    
    boolean existsByKakaoPlaceId(String kakaoPlaceId);
    
    @Query("SELECT COUNT(a) FROM AnalysisConvenienceStoreStatistics a")
    long countAnalysisData();
    
    @Query("SELECT a.district, COUNT(a) FROM AnalysisConvenienceStoreStatistics a GROUP BY a.district ORDER BY COUNT(a) DESC")
    List<Object[]> findStoreCountByDistrict();
    
    @Query("SELECT a FROM AnalysisConvenienceStoreStatistics a WHERE a.latitude IS NOT NULL AND a.longitude IS NOT NULL")
    List<AnalysisConvenienceStoreStatistics> findAllWithCoordinates();
    
    @Query("SELECT COUNT(a) FROM AnalysisConvenienceStoreStatistics a WHERE a.latitude IS NULL OR a.longitude IS NULL")
    long countMissingCoordinates();
    
    @Query("SELECT a.storeBrand, COUNT(a) FROM AnalysisConvenienceStoreStatistics a GROUP BY a.storeBrand ORDER BY COUNT(a) DESC")
    List<Object[]> findStoreCountByBrand();
    
    @Query("SELECT a FROM AnalysisConvenienceStoreStatistics a WHERE a.placeName LIKE %:name%")
    List<AnalysisConvenienceStoreStatistics> findByPlaceNameContaining(@Param("name") String name);
    
    @Query("SELECT a FROM AnalysisConvenienceStoreStatistics a WHERE a.addressName LIKE %:address% OR a.roadAddressName LIKE %:address%")
    List<AnalysisConvenienceStoreStatistics> findByAddressContaining(@Param("address") String address);
}
```

## 4. 편의점 데이터 분석용 처리 Component

**목적**: 원본 편의점 데이터 중 서울지역만을 분석용 테이블로 변환하는 비즈니스 로직 처리
**역할**: 
- 기존 `CONVENIENCE_STORE_STATISTICS` 테이블에서 서울지역 편의점 데이터만 조회
- 지정된 12개 필드만 복사
- 기존 좌표 데이터 그대로 활용 (별도 API 호출 없음)
- 데이터 품질 검증 및 브랜드별 분포 로깅

```java
package com.wherehouse.AnalysisData.convenience.processor;

import com.wherehouse.AnalysisData.convenience.entity.AnalysisConvenienceStoreStatistics;
import com.wherehouse.AnalysisData.convenience.repository.AnalysisConvenienceStoreRepository;
// 원본 데이터 접근을 위한 기존 패키지 import
import com.wherehouse.safety.entity.ConvenienceStoreStatistics;
import com.wherehouse.safety.repository.ConvenienceStoreStatisticsRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * 편의점 데이터 분석용 테이블 생성 처리 컴포넌트 (서울지역 한정)
 * 
 * 기존 CONVENIENCE_STORE_STATISTICS 테이블에서 서울지역 데이터를 조회하여
 * 분석 전용 ANALYSIS_CONVENIENCE_STORE_STATISTICS 테이블로 복사하는 작업을 수행한다.
 * 
 * 주요 기능:
 * - 원본 편의점 통계 데이터 중 서울지역만 조회 및 검증
 * - 지정된 12개 필드만 복사 (카카오 장소 ID, 장소명, 카테고리명 등)
 * - 기존 위도, 경도 좌표 데이터 그대로 활용
 * - 분석용 테이블 데이터 품질 검증
 * - 브랜드별 및 구별 분포 로깅
 * 
 * @author Safety Analysis System
 * @since 1.1
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class ConvenienceStoreDataProcessor {

    // 원본 편의점 테이블 접근을 위한 Repository
    private final ConvenienceStoreStatisticsRepository originalConvenienceStoreRepository;
    
    // 분석용 편의점 테이블 접근을 위한 Repository  
    private final AnalysisConvenienceStoreRepository analysisConvenienceStoreRepository;

    /**
     * 편의점 데이터 분석용 테이블 생성 메인 프로세스 (서울지역)
     * 
     * 작업 순서:
     * 1. 기존 분석용 데이터 존재 여부 확인
     * 2. 원본 편의점 데이터 중 서울지역만 조회 및 검증
     * 3. 데이터 변환 및 분석용 테이블 저장
     * 4. 데이터 품질 검증 및 결과 로깅
     */
    @Transactional
    public void processAnalysisConvenienceStoreData() {
        log.info("=== 편의점 데이터 분석용 테이블 생성 작업 시작 (서울지역) ===");
        
        // Step 1: 기존 분석용 데이터 중복 처리 방지를 위한 존재 여부 확인
        long existingAnalysisDataCount = analysisConvenienceStoreRepository.count();
        if (existingAnalysisDataCount > 0) {
            log.info("분석용 편의점 데이터가 이미 존재합니다 (총 {} 개). 작업을 스킵합니다.", existingAnalysisDataCount);
            return;
        }

        // Step 2: 원본 편의점 데이터 중 서울지역만 조회 및 검증
        List<ConvenienceStoreStatistics> seoulConvenienceStoreDataList = getSeoulConvenienceStoreData();
        if (seoulConvenienceStoreDataList.isEmpty()) {
            log.warn("서울지역 편의점 데이터가 존재하지 않습니다. 먼저 데이터를 수집해주세요.");
            return;
        }
        
        log.info("서울지역 편의점 데이터 {} 개 발견", seoulConvenienceStoreDataList.size());

        // Step 3: 데이터 변환 및 저장 작업 수행
        int successfulConversionCount = 0;      // 성공적으로 변환된 데이터 개수
        int failedConversionCount = 0;          // 변환 실패한 데이터 개수
        int coordinateAvailableCount = 0;       // 좌표 정보 보유 개수
        int coordinateMissingCount = 0;         // 좌표 정보 누락 개수

        // 처리 진행률 추적
        int processedCount = 0;
        int totalCount = seoulConvenienceStoreDataList.size();
        int logInterval = Math.max(1, totalCount / 10); // 10% 간격으로 로그 출력

        for (ConvenienceStoreStatistics originalConvenienceStoreData : seoulConvenienceStoreDataList) {
            processedCount++;
            
            try {
                // 원본 데이터를 분석용 엔티티로 변환 (지정된 12개 필드만)
                AnalysisConvenienceStoreStatistics analysisTargetConvenienceStoreData = convertToAnalysisEntity(originalConvenienceStoreData);
                
                // 좌표 정보 확인
                if (originalConvenienceStoreData.getLatitude() != null && originalConvenienceStoreData.getLongitude() != null) {
                    coordinateAvailableCount++;
                } else {
                    coordinateMissingCount++;
                }
                
                // 분석용 테이블에 데이터 저장
                analysisConvenienceStoreRepository.save(analysisTargetConvenienceStoreData);
                successfulConversionCount++;
                
                log.debug("분석용 데이터 생성 완료: {} ({}, 브랜드: {}, 구: {}, 좌표: {}, {})", 
                    originalConvenienceStoreData.getPlaceName(), 
                    originalConvenienceStoreData.getCategoryName(),
                    originalConvenienceStoreData.getStoreBrand(),
                    originalConvenienceStoreData.getDistrict(),
                    originalConvenienceStoreData.getLatitude() != null ? originalConvenienceStoreData.getLatitude() : "없음",
                    originalConvenienceStoreData.getLongitude() != null ? originalConvenienceStoreData.getLongitude() : "없음");

                // 진행률 로그 (10% 간격)
                if (processedCount % logInterval == 0 || processedCount == totalCount) {
                    double progressPercentage = (double) processedCount / totalCount * 100;
                    log.info("진행률: {:.1f}% 완료 ({}/{})", progressPercentage, processedCount, totalCount);
                }

            } catch (Exception dataConversionException) {
                log.error("분석용 데이터 생성 실패 - 편의점명: {}, 오류: {}", 
                    originalConvenienceStoreData.getPlaceName(), dataConversionException.getMessage());
                failedConversionCount++;
            }
        }

        // Step 4: 변환 작업 결과 로깅
        log.info("편의점 데이터 분석용 테이블 생성 작업 완료 (서울지역)");
        log.info("- 데이터 변환: 성공 {} 개, 실패 {} 개", successfulConversionCount, failedConversionCount);
        log.info("- 좌표 정보: 보유 {} 개, 누락 {} 개", coordinateAvailableCount, coordinateMissingCount);
        
        // Step 5: 최종 데이터 검증 및 품질 확인
        performFinalDataValidation();
        
        log.info("=== 편의점 데이터 분석용 테이블 생성 작업 종료 (서울지역) ===");
    }
    
    /**
     * 서울지역 편의점 데이터 조회
     * 
     * 주소를 기준으로 서울지역 편의점만 필터링
     * 
     * @return 서울지역 편의점 데이터 목록
     */
    private List<ConvenienceStoreStatistics> getSeoulConvenienceStoreData() {
        // 모든 편의점 데이터 조회 후 서울지역만 필터링
        List<ConvenienceStoreStatistics> allConvenienceStores = originalConvenienceStoreRepository.findAll();
        
        return allConvenienceStores.stream()
            .filter(this::isSeoulConvenienceStore)
            .toList();
    }
    
    /**
     * 서울지역 편의점인지 판단
     * 
     * @param convenienceStore 편의점 데이터
     * @return 서울지역 편의점 여부
     */
    private boolean isSeoulConvenienceStore(ConvenienceStoreStatistics convenienceStore) {
        // 1. 주소명으로 확인
        if (convenienceStore.getAddressName() != null && 
            convenienceStore.getAddressName().startsWith("서울")) {
            return true;
        }
        
        // 2. 도로명주소로 확인
        if (convenienceStore.getRoadAddressName() != null && 
            convenienceStore.getRoadAddressName().startsWith("서울")) {
            return true;
        }
        
        // 3. 구 정보로 확인 (서울시 구 목록)
        if (convenienceStore.getDistrict() != null) {
            String district = convenienceStore.getDistrict();
            return isSeoulDistrict(district);
        }
        
        return false;
    }
    
    /**
     * 서울시 구인지 확인
     */
    private boolean isSeoulDistrict(String district) {
        String[] seoulDistricts = {
            "강남구", "강동구", "강북구", "강서구", "관악구", "광진구", "구로구", 
            "금천구", "노원구", "도봉구", "동대문구", "동작구", "마포구", "서대문구", 
            "서초구", "성동구", "성북구", "송파구", "양천구", "영등포구", "용산구", 
            "은평구", "종로구", "중구", "중랑구"
        };
        
        for (String seoulDistrict : seoulDistricts) {
            if (district.contains(seoulDistrict)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * 원본 편의점 엔티티를 분석용 엔티티로 변환
     * 
     * 지정된 12개 필드만 복사한다.
     * 
     * @param originalConvenienceStoreData 원본 편의점 엔티티
     * @return 분석용 편의점 엔티티
     */
    private AnalysisConvenienceStoreStatistics convertToAnalysisEntity(ConvenienceStoreStatistics originalConvenienceStoreData) {
        return AnalysisConvenienceStoreStatistics.builder()
            // 지정된 12개 필드 복사
            .kakaoPlaceId(originalConvenienceStoreData.getKakaoPlaceId())         // 카카오 장소 ID
            .placeName(originalConvenienceStoreData.getPlaceName())               // 장소명
            .categoryName(originalConvenienceStoreData.getCategoryName())         // 카테고리명
            .categoryGroupCode(originalConvenienceStoreData.getCategoryGroupCode()) // 카테고리 그룹 코드
            .phone(originalConvenienceStoreData.getPhone())                       // 전화번호
            .addressName(originalConvenienceStoreData.getAddressName())           // 주소명
            .roadAddressName(originalConvenienceStoreData.getRoadAddressName())   // 도로명 주소명
            .longitude(originalConvenienceStoreData.getLongitude())               // 경도 (기존 데이터 사용)
            .latitude(originalConvenienceStoreData.getLatitude())                 // 위도 (기존 데이터 사용)
            .placeUrl(originalConvenienceStoreData.getPlaceUrl())                 // 장소 URL
            .district(originalConvenienceStoreData.getDistrict())                 // 구 정보
            .storeBrand(originalConvenienceStoreData.getStoreBrand())             // 편의점 브랜드
            .build();
    }
    
    /**
     * 분석용 데이터의 최종 검증 및 품질 확인
     * 
     * 작업 내용:
     * - 전체 데이터 개수 확인
     * - 구별 분포 상위 5개 로깅
     * - 브랜드별 분포 로깅
     * - 좌표 정보 완성도 확인
     * - 데이터 검증 과정에서 발생하는 오류 처리
     */
    private void performFinalDataValidation() {
        try {
            // 최종 저장된 분석용 데이터 개수 확인
            long finalAnalysisDataCount = analysisConvenienceStoreRepository.count();
            log.info("최종 분석용 편의점 데이터 저장 완료 (서울지역): {} 개", finalAnalysisDataCount);
            
            // 구별 분포 조회 및 로깅 (피어슨 상관분석 검증용)
            List<Object[]> storeCountByDistrictList = analysisConvenienceStoreRepository.findStoreCountByDistrict();
            log.info("구별 분포 (상위 5개):");
            
            storeCountByDistrictList.stream()
                .limit(5)
                .forEach(districtRow -> {
                    String district = (String) districtRow[0];       // 구
                    Long districtCount = (Long) districtRow[1];      // 해당 구 수
                    log.info("  {} : {} 개", district, districtCount);
                });
            
            // 브랜드별 분포 조회 및 로깅
            List<Object[]> storeCountByBrandList = analysisConvenienceStoreRepository.findStoreCountByBrand();
            log.info("브랜드별 분포:");
            
            storeCountByBrandList.forEach(brandRow -> {
                String storeBrand = (String) brandRow[0];           // 브랜드
                Long brandCount = (Long) brandRow[1];               // 해당 브랜드 수
                if (storeBrand != null) {
                    log.info("  {} : {} 개", storeBrand, brandCount);
                }
            });
            
            // 좌표 정보 완성도 확인
            long coordinateCompleteCount = analysisConvenienceStoreRepository.findAllWithCoordinates().size();
            long coordinateMissingCount = analysisConvenienceStoreRepository.countMissingCoordinates();
            
            log.info("좌표 정보 완성도:");
            log.info("  좌표 보유: {} 개 ({:.1f}%)", coordinateCompleteCount, 
                (double) coordinateCompleteCount / finalAnalysisDataCount * 100);
            log.info("  좌표 누락: {} 개 ({:.1f}%)", coordinateMissingCount,
                (double) coordinateMissingCount / finalAnalysisDataCount * 100);
                
        } catch (Exception dataValidationException) {
            log.error("분석용 데이터 검증 과정에서 오류가 발생했습니다: {}", 
                dataValidationException.getMessage(), dataValidationException);
        }
    }
}
```

## 5. Main 처리 클래스

**목적**: 전체 분석용 데이터 처리 작업의 통합 관리 및 실행
**역할**: 
- 애플리케이션 시작 시 자동 실행되는 메인 진입점 (`CommandLineRunner` 구현)
- 편의점 데이터를 포함한 19개 ERD별 프로세서들의 순차적 호출 관리
- 전체 작업 진행 상황 로깅 및 예외 처리

```java
package com.wherehouse.AnalysisData.main;

import com.wherehouse.AnalysisData.convenience.processor.ConvenienceStoreDataProcessor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class AnalysisDataProcessor implements CommandLineRunner {

    private final ConvenienceStoreDataProcessor convenienceStoreDataProcessor;
    // 향후 18개 ERD별 프로세서 추가 예정

    @Override
    public void run(String... args) throws Exception {
        log.info("=== 안전성 분석용 데이터 처리 시작 ===");
        
        try {
            // 1. 편의점 데이터 처리 (서울지역)
            log.info("1. 편의점 데이터 분석용 테이블 생성 시작 (서울지역)");
            
            long startTime = System.currentTimeMillis();
            convenienceStoreDataProcessor.processAnalysisConvenienceStoreData();
            long endTime = System.currentTimeMillis();
            
            log.info("편의점 데이터 처리 완료 (서울지역) - 소요시간: {}ms ({:.2f}초)", 
                endTime - startTime, (endTime - startTime) / 1000.0);
            
            // 향후 추가될 18개 ERD별 데이터 처리
            // 2. 범죄 데이터 처리
            // log.info("2. 범죄 데이터 분석용 테이블 생성 시작");
            // crimeDataProcessor.processAnalysisCrimeData();
            
            // 3. 대학교 데이터 처리
            // log.info("3. 대학교 데이터 분석용 테이블 생성 시작");
            // universityDataProcessor.processAnalysisUniversityData();
            
            // ... 추가 프로세서들
            
        } catch (Exception e) {
            log.error("안전성 분석용 데이터 처리 중 오류 발생", e);
            throw e;
        }
        
        log.info("=== 안전성 분석용 데이터 처리 완료 ===");
    }
}

```

## 6. 실행 방법 및 검증

### 1. 데이터베이스 설정
```sql
-- DDL 스크립트 실행
DESC ANALYSIS_CONVENIENCE_STORE_STATISTICS;
SELECT COUNT(*) FROM ANALYSIS_CONVENIENCE_STORE_STATISTICS;
```

### 2. 애플리케이션 실행
```bash
./gradlew bootRun
```

### 3. 테스트 엔드포인트 활용

**원본 데이터 상태 확인:**
```bash
curl "http://localhost:8080/debug/convenience/check-original-data"
```

**분석용 데이터 상태 확인:**
```bash
curl "http://localhost:8080/debug/convenience/check-analysis-data"
```

**강제 처리 실행:**
```bash
curl -X POST "http://localhost:8080/debug/convenience/force-process"
```

### 4. 실행 결과 검증
```sql
-- 데이터 개수 확인
SELECT COUNT(*) FROM ANALYSIS_CONVENIENCE_STORE_STATISTICS;

-- 구별 분포 확인
SELECT DISTRICT, COUNT(*) 
FROM ANALYSIS_CONVENIENCE_STORE_STATISTICS 
GROUP BY DISTRICT 
ORDER BY COUNT(*) DESC;

-- 브랜드별 분포 확인
SELECT STORE_BRAND, COUNT(*) 
FROM ANALYSIS_CONVENIENCE_STORE_STATISTICS 
WHERE STORE_BRAND IS NOT NULL
GROUP BY STORE_BRAND 
ORDER BY COUNT(*) DESC;

-- 좌표 정보 완성도 확인
SELECT 
    COUNT(*) AS TOTAL_COUNT,
    COUNT(LATITUDE) AS COORDINATE_COUNT,
    COUNT(*) - COUNT(LATITUDE) AS MISSING_COORDINATE_COUNT
FROM ANALYSIS_CONVENIENCE_STORE_STATISTICS;

-- 실제 좌표 샘플 확인
SELECT PLACE_NAME, ADDRESS_NAME, LATITUDE, LONGITUDE
FROM ANALYSIS_CONVENIENCE_STORE_STATISTICS
WHERE LATITUDE IS NOT NULL AND ROWNUM <= 10;

-- 카테고리별 분포 확인
SELECT CATEGORY_NAME, COUNT(*) 
FROM ANALYSIS_CONVENIENCE_STORE_STATISTICS 
GROUP BY CATEGORY_NAME 
ORDER BY COUNT(*) DESC;
```

## 7. 예상 처리 결과

### 로그 출력 예시
```
=== 안전성 분석용 데이터 처리 시작 ===
1. 편의점 데이터 분석용 테이블 생성 시작 (서울지역)
원본 편의점 데이터 조회 완료
서울지역 편의점 데이터 1,247 개 발견
진행률: 10.0% 완료 (125/1247)
분석용 데이터 생성 완료: GS25 강남역점 (편의점 > 편의점, 브랜드: GS25, 구: 강남구, 좌표: 37.4979, 127.0276)
...
진행률: 100.0% 완료 (1247/1247)
편의점 데이터 분석용 테이블 생성 작업 완료 (서울지역)
- 데이터 변환: 성공 1,247 개, 실패 0 개
- 좌표 정보: 보유 1,198 개, 누락 49 개
최종 분석용 편의점 데이터 저장 완료 (서울지역): 1,247 개
구별 분포 (상위 5개):
  강남구 : 89 개
  송파구 : 76 개
  영등포구 : 68 개
  마포구 : 62 개
  관악구 : 58 개
브랜드별 분포:
  GS25 : 312 개
  CU : 298 개
  세븐일레븐 : 267 개
  이마트24 : 198 개
  미니스톱 : 172 개
좌표 정보 완성도:
  좌표 보유: 1,198 개 (96.1%)
  좌표 누락: 49 개 (3.9%)
편의점 데이터 처리 완료 (서울지역) - 소요시간: 2345ms (2.35초)
=== 안전성 분석용 데이터 처리 완료 ===
```

## 8. 주요 특징

### 서울지역 필터링 최적화
- **다중 필터링**: 주소명, 도로명주소, 구 정보를 통한 3단계 서울지역 검증
- **서울시 구 목록 기반**: 25개 서울시 구 목록을 활용한 정확한 지역 판별
- **효율적 스트림 처리**: Java 8 Stream API를 활용한 메모리 효율적 필터링

### 데이터 품질 관리
- **좌표 완성도 검증**: 기존 좌표 데이터의 완성도 자동 확인
- **브랜드 분포 분석**: 편의점 브랜드별 분포 통계 자동 생성
- **구별 분포 분석**: 서울시 구별 편의점 밀도 분석

### 성능 최적화
- **진행률 추적**: 10% 간격으로 처리 진행 상황 실시간 로깅
- **배치 처리**: 트랜잭션 단위로 안전한 대용량 데이터 처리
- **메모리 효율**: 스트림 기반 필터링으로 메모리 사용량 최적화

### 확장성 고려
- **모듈화 설계**: 독립적인 프로세서 컴포넌트로 다른 ERD와 병렬 처리 가능
- **설정 기반**: application.yml을 통한 유연한 설정 관리
- **표준화된 인터페이스**: 다른 분석 프로세서와 동일한 패턴 적용

이 시스템은 향후 피어슨 상관분석에서 독립변수로 활용될 지역별 편의점 밀도 계산의 정확한 기초 데이터를 제공하며, 기존 수집된 좌표 정보를 그대로 활용하여 추가적인 API 호출 없이 효율적으로 분석용 데이터를 구축합니다.