# PC방 데이터 분석용 Oracle DB 설계 및 JPA 구현

**프로젝트명:** 안전성 점수 계산 시스템 - PC방 위치 분석 데이터 처리  
**버전:** 1.0  
**작성일:** 2025.08.30  
**목적:** 기존 `PC_BANGS` 테이블의 위치 정보에 카카오맵 API를 통한 좌표 변환을 추가하여 피어슨 상관분석 계산에 활용하기 위한 분석용 테이블 구축

---

## 프로젝트 개요

### 데이터 처리 목표
기존 `PC_BANGS` 테이블에서 7개 핵심 필드를 선별하고, 카카오맵 API를 통해 주소를 위도/경도 좌표로 변환하여 분석 전용 테이블 `ANALYSIS_PC_BANG_STATISTICS`에 9개 필드로 저장한다.

### 핵심 특징
- **선별적 필드 복사**: 7개 핵심 필드만 선택하여 분석 성능 최적화
- **카카오맵 API 연동**: 주소 → 위도/경도 좌표 실시간 변환
- **API 호출 최적화**: 호출 제한 고려한 속도 조절 (100ms 간격)
- **null 값 처리**: 문자열은 "데이터없음", 숫자는 0.0으로 기본값 설정
- **분석 전용 설계**: 제약조건 없이 순수 분석 목적의 테이블 구조
- **기존 인터페이스 재사용**: 원천 데이터 접근에 필요한 JPA Entity와 Repository는 기존 `AnalysisStaticData` 패키지에서 직접 import

---

## 1. application.yml 설정 추가

**목적**: 카카오맵 API 설정 및 요청 제어 파라미터 추가

```yaml
# 카카오 API 설정
kakao:
  rest-api-key: YOUR_KAKAO_REST_API_KEY_HERE
  local-api:
    base-url: https://dapi.kakao.com/v2/local
    search-radius: 5000
    max-page: 45
    page-size: 15
    request-delay: 100  # API 호출 간격 (ms)

# 기존 설정에 추가
logging:
  level:
    com.WhereHouse.AnalysisData.pcbang.processor: DEBUG
```

## 2. Oracle 테이블 DDL

**목적**: 분석용 PC방 위치 테이블 생성 및 시퀀스 설정
**역할**: 피어슨 상관분석에 사용될 독립변수(지역별 PC방 밀도) 데이터 저장소 구축

```sql
-- 기존 테이블과 데이터를 완전히 삭제
DROP TABLE ANALYSIS_PC_BANG_STATISTICS CASCADE CONSTRAINTS PURGE;
DROP SEQUENCE SEQ_ANALYSIS_PC_BANG_STATISTICS;

-- 분석용 PC방 위치 테이블 생성
CREATE TABLE ANALYSIS_PC_BANG_STATISTICS (
    ID                      NUMBER,                     -- 제한 없음
    DISTRICT_CODE           VARCHAR2(4000),             -- 구 코드
    MANAGEMENT_NUMBER       VARCHAR2(4000),             -- 관리번호
    BUSINESS_STATUS_NAME    VARCHAR2(4000),             -- 영업상태명
    JIBUN_ADDRESS          VARCHAR2(4000),             -- 지번주소
    ROAD_ADDRESS           VARCHAR2(4000),             -- 도로명주소
    BUSINESS_NAME          VARCHAR2(4000),             -- 업소명
    LATITUDE               NUMBER,                     -- 위도 (카카오맵 API)
    LONGITUDE              NUMBER,                     -- 경도 (카카오맵 API)
    GEOCODING_STATUS       VARCHAR2(4000)              -- 좌표변환 상태 메시지
);

-- 시퀀스 생성
CREATE SEQUENCE SEQ_ANALYSIS_PC_BANG_STATISTICS 
    START WITH 1 
    INCREMENT BY 1 
    NOCACHE
    NOCYCLE;

-- 확인
DESC ANALYSIS_PC_BANG_STATISTICS;
SELECT COUNT(*) FROM ANALYSIS_PC_BANG_STATISTICS;
```

## 3. JPA Entity

**목적**: 분석용 PC방 위치 테이블과 Java 객체 간 ORM 매핑
**역할**: 데이터베이스 CRUD 작업을 위한 엔티티 클래스 정의

```java
package com.WhereHouse.AnalysisData.pcbang.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;

@Entity
@Table(name = "ANALYSIS_PC_BANG_STATISTICS")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AnalysisPcBangStatistics {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "analysis_pc_bang_seq")
    @SequenceGenerator(name = "analysis_pc_bang_seq", sequenceName = "SEQ_ANALYSIS_PC_BANG_STATISTICS", allocationSize = 1)
    @Column(name = "ID")
    private Long id;

    @Column(name = "DISTRICT_CODE", length = 20)
    private String districtCode;

    @Column(name = "MANAGEMENT_NUMBER", length = 100)
    private String managementNumber;

    @Column(name = "BUSINESS_STATUS_NAME", length = 100)
    private String businessStatusName;

    @Column(name = "JIBUN_ADDRESS", length = 1000)
    private String jibunAddress;

    @Column(name = "ROAD_ADDRESS", length = 1000)
    private String roadAddress;

    @Column(name = "BUSINESS_NAME", length = 500)
    private String businessName;

    @Column(name = "LATITUDE", precision = 10, scale = 8)
    private BigDecimal latitude;

    @Column(name = "LONGITUDE", precision = 10, scale = 8)
    private BigDecimal longitude;

    @Column(name = "GEOCODING_STATUS", length = 4000)
    private String geocodingStatus;
}
```

## 4. Repository

**목적**: 분석용 PC방 위치 데이터에 대한 데이터 접근 계층 구현
**역할**: JPA 기반 CRUD 연산 및 맞춤형 쿼리 메서드 제공

```java
package com.WhereHouse.AnalysisData.pcbang.repository;

import com.WhereHouse.AnalysisData.pcbang.entity.AnalysisPcBangStatistics;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface AnalysisPcBangRepository extends JpaRepository<AnalysisPcBangStatistics, Long> {
    
    Optional<AnalysisPcBangStatistics> findByManagementNumber(String managementNumber);
    
    List<AnalysisPcBangStatistics> findByDistrictCode(String districtCode);
    
    List<AnalysisPcBangStatistics> findByBusinessStatusName(String businessStatusName);
    
    boolean existsByManagementNumber(String managementNumber);
    
    @Query("SELECT COUNT(a) FROM AnalysisPcBangStatistics a")
    long countAnalysisData();
    
    @Query("SELECT COUNT(a) FROM AnalysisPcBangStatistics a WHERE a.districtCode = :districtCode")
    long countByDistrictCode(@Param("districtCode") String districtCode);
    
    @Query("SELECT a.districtCode, COUNT(a) FROM AnalysisPcBangStatistics a GROUP BY a.districtCode ORDER BY COUNT(a) DESC")
    List<Object[]> findDistrictPcBangDensityRanking();
    
    @Query("SELECT a.businessStatusName, COUNT(a) FROM AnalysisPcBangStatistics a GROUP BY a.businessStatusName ORDER BY COUNT(a) DESC")
    List<Object[]> findBusinessStatusDistribution();

    @Query(value = "SELECT SUBSTR(ROAD_ADDRESS, 1, INSTR(ROAD_ADDRESS, ' ', 1, 2) - 1) as district, COUNT(*) as pc_bang_count " +
                  "FROM ANALYSIS_PC_BANG_STATISTICS " +
                  "WHERE ROAD_ADDRESS LIKE '서울%' " +
                  "GROUP BY SUBSTR(ROAD_ADDRESS, 1, INSTR(ROAD_ADDRESS, ' ', 1, 2) - 1) " +
                  "ORDER BY pc_bang_count DESC", nativeQuery = true)
    List<Object[]> findSeoulDistrictPcBangDensityRanking();

    @Query("SELECT a.geocodingStatus, COUNT(a) FROM AnalysisPcBangStatistics a GROUP BY a.geocodingStatus ORDER BY COUNT(a) DESC")
    List<Object[]> findGeocodingStatusDistribution();

    @Query("SELECT COUNT(a) FROM AnalysisPcBangStatistics a WHERE a.latitude != 0.0 AND a.longitude != 0.0")
    long countSuccessfulGeocodedData();
}
```

## 5. 카카오맵 API 클라이언트

**목적**: 주소를 위도/경도 좌표로 변환하는 카카오맵 API 연동 서비스

```java
package com.WhereHouse.AnalysisData.pcbang.client;

import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.math.BigDecimal;

@Component
@RequiredArgsConstructor
@Slf4j
public class KakaoAddressApiClient {

    @Value("${kakao.rest-api-key}")
    private String restApiKey;

    @Value("${kakao.local-api.base-url}")
    private String baseUrl;

    private final RestTemplate restTemplate = new RestTemplate();
    private final ObjectMapper objectMapper = new ObjectMapper();

    /**
     * 주소를 위도/경도 좌표로 변환
     */
    public AddressSearchResponse searchAddress(String address) {
        String url = baseUrl + "/search/address.json";
        
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "KakaoAK " + restApiKey);
        headers.setContentType(MediaType.APPLICATION_JSON);

        String fullUrl = url + "?query=" + address;
        HttpEntity<String> entity = new HttpEntity<>(headers);

        try {
            log.debug("카카오 API 호출 시작: {}", fullUrl);
            
            ResponseEntity<AddressSearchResponse> response = restTemplate.exchange(
                    fullUrl,
                    HttpMethod.GET,
                    entity,
                    AddressSearchResponse.class
            );
            
            log.debug("카카오 API 응답 상태: {}", response.getStatusCode());
            AddressSearchResponse responseBody = response.getBody();
            
            if (responseBody != null && responseBody.getMeta() != null) {
                log.debug("카카오 API 응답: total_count={}, documents_size={}", 
                    responseBody.getMeta().getTotal_count(),
                    responseBody.getDocuments() != null ? responseBody.getDocuments().size() : 0);
            }
            
            return responseBody;
        } catch (org.springframework.web.client.HttpClientErrorException e) {
            log.error("카카오 API HTTP 클라이언트 오류: address={}", address);
            log.error("  - 상태코드: {}", e.getStatusCode());
            log.error("  - 응답내용: {}", e.getResponseBodyAsString());
            log.error("  - URL: {}", fullUrl);
            return new AddressSearchResponse();
        } catch (org.springframework.web.client.HttpServerErrorException e) {
            log.error("카카오 API HTTP 서버 오류: address={}", address);
            log.error("  - 상태코드: {}", e.getStatusCode());
            log.error("  - 응답내용: {}", e.getResponseBodyAsString());
            log.error("  - URL: {}", fullUrl);
            return new AddressSearchResponse();
        } catch (Exception e) {
            log.error("카카오 주소 검색 API 호출 실패: address={}, error={}", address, e.getMessage());
            log.error("  - URL: {}", fullUrl);
            log.error("  - Exception Type: {}", e.getClass().getSimpleName());
            if (e.getCause() != null) {
                log.error("  - Cause: {}", e.getCause().getMessage());
            }
            return new AddressSearchResponse();
        }
    }

    // 응답 DTO 클래스들
    public static class AddressSearchResponse {
        private Meta meta;
        private java.util.List<Document> documents;

        public Meta getMeta() { return meta; }
        public void setMeta(Meta meta) { this.meta = meta; }
        public java.util.List<Document> getDocuments() { return documents; }
        public void setDocuments(java.util.List<Document> documents) { this.documents = documents; }
    }

    public static class Meta {
        private int total_count;
        private boolean is_end;

        public int getTotal_count() { return total_count; }
        public void setTotal_count(int total_count) { this.total_count = total_count; }
        public boolean isIs_end() { return is_end; }
        public void setIs_end(boolean is_end) { this.is_end = is_end; }
    }

    public static class Document {
        private String address_name;
        private String x; // 경도
        private String y; // 위도

        public String getAddress_name() { return address_name; }
        public void setAddress_name(String address_name) { this.address_name = address_name; }
        public String getX() { return x; }
        public void setX(String x) { this.x = x; }
        public String getY() { return y; }
        public void setY(String y) { this.y = y; }
        
        public String getLatitude() { return y; }
        public String getLongitude() { return x; }
    }
}
```

## 6. PC방 위치 데이터 분석용 처리 Component

**목적**: 원본 PC방 데이터를 분석용 테이블로 변환하고 카카오맵 API를 통해 좌표 정보를 추가하는 비즈니스 로직 처리

```java
package com.WhereHouse.AnalysisData.pcbang.processor;

import com.WhereHouse.AnalysisData.pcbang.client.KakaoAddressApiClient;
import com.WhereHouse.AnalysisData.pcbang.entity.AnalysisPcBangStatistics;
import com.WhereHouse.AnalysisData.pcbang.repository.AnalysisPcBangRepository;
// 원본 데이터 접근을 위한 기존 패키지 import
import com.WhereHouse.AnalysisStaticData.safety.entity.PcBangs;
import com.WhereHouse.AnalysisStaticData.safety.repository.PcBangsRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * PC방 위치 데이터 분석용 테이블 생성 처리 컴포넌트
 * 
 * 기존 PC_BANGS 테이블에서 7개 핵심 필드를 선별하고
 * 카카오맵 API를 통해 주소를 위도/경도 좌표로 변환하여
 * 분석 전용 ANALYSIS_PC_BANG_STATISTICS 테이블에 9개 필드로 저장한다.
 * 
 * 주요 기능:
 * - 원본 PC방 데이터 조회 및 검증
 * - 7개 핵심 필드 선별 및 카카오맵 API 좌표 변환
 * - API 호출 제한 고려한 속도 조절
 * - 분석용 테이블 데이터 품질 검증
 * - 구별 PC방 밀도 및 영업상태 분포 순위 로깅
 * 
 * @author Safety Analysis System
 * @since 1.0
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class PcBangDataProcessor {

    // 원본 PC방 테이블 접근을 위한 Repository
    private final PcBangsRepository originalPcBangRepository;
    
    // 분석용 PC방 테이블 접근을 위한 Repository  
    private final AnalysisPcBangRepository analysisPcBangRepository;

    // 카카오맵 API 클라이언트
    private final KakaoAddressApiClient kakaoAddressApiClient;

    // API 호출 간격 설정
    @Value("${kakao.local-api.request-delay}")
    private long requestDelay;

    /**
     * PC방 위치 데이터 분석용 테이블 생성 메인 프로세스
     * 
     * 작업 순서:
     * 1. 기존 분석용 데이터 존재 여부 확인
     * 2. 원본 PC방 데이터 조회 및 검증
     * 3. 7개 핵심 필드 선별 및 카카오맵 API 좌표 변환
     * 4. 분석용 테이블 저장
     * 5. 데이터 품질 검증 및 결과 로깅
     */
    @Transactional
    public void processAnalysisPcBangData() {
        log.info("=== PC방 위치 데이터 분석용 테이블 생성 작업 시작 ===");
        
        // Step 1: 기존 분석용 데이터 중복 처리 방지를 위한 존재 여부 확인
        long existingAnalysisDataCount = analysisPcBangRepository.count();
        if (existingAnalysisDataCount > 0) {
            log.info("분석용 PC방 위치 데이터가 이미 존재합니다 (총 {} 개). 작업을 스킵합니다.", existingAnalysisDataCount);
            return;
        }

        // Step 2: 원본 PC방 데이터 조회 및 검증
        List<PcBangs> originalPcBangDataList = originalPcBangRepository.findAll();
        if (originalPcBangDataList.isEmpty()) {
            log.warn("원본 PC방 데이터가 존재하지 않습니다. 먼저 PcBangsDataLoader를 통해 CSV 데이터를 수집해주세요.");
            return;
        }
        
        log.info("원본 PC방 데이터 {} 개 업소 발견", originalPcBangDataList.size());

        // Step 3: 데이터 변환 및 저장 작업 수행
        int successfulConversionCount = 0;  // 성공적으로 변환된 데이터 개수
        int failedConversionCount = 0;      // 변환 실패한 데이터 개수
        int apiSuccessCount = 0;            // API 좌표 변환 성공 개수
        int apiFailedCount = 0;             // API 좌표 변환 실패 개수

        for (int i = 0; i < originalPcBangDataList.size(); i++) {
            PcBangs originalPcBangData = originalPcBangDataList.get(i);
            
            // 진행률 로깅 (100건마다)
            if (i > 0 && i % 100 == 0) {
                double progress = ((double) i / originalPcBangDataList.size()) * 100;
                log.info("처리 진행률: {:.1f}% ({}/{}) - API 성공: {}, 실패: {}", 
                    progress, i, originalPcBangDataList.size(), apiSuccessCount, apiFailedCount);
            }

            try {
                // 원본 데이터에서 7개 핵심 필드 선별 및 분석용 엔티티로 변환
                AnalysisPcBangStatistics analysisTargetPcBangData = convertToAnalysisEntity(originalPcBangData);
                
                // 카카오맵 API를 통한 좌표 변환 시도
                AddressInfo addressInfo = determineAndCleanAddress(originalPcBangData);
                
                if (addressInfo.getCleanedAddress() != null) {
                    try {
                        log.debug("주소 정제 완료: [{}] {} → {}", 
                            addressInfo.getAddressType(), 
                            addressInfo.getCleanedAddress().length() > 50 ? 
                                addressInfo.getCleanedAddress().substring(0, 50) + "..." : 
                                addressInfo.getCleanedAddress(),
                            addressInfo.getCleanedAddress());
                            
                        // 여러 형태로 주소 검색 시도 (원본 PC방 데이터도 전달)
                        KakaoAddressApiClient.AddressSearchResponse response = 
                            tryMultipleAddressFormats(addressInfo.getCleanedAddress(), originalPcBangData);
                        
                        if (response.getDocuments() != null && !response.getDocuments().isEmpty()) {
                            KakaoAddressApiClient.Document document = response.getDocuments().get(0);
                            analysisTargetPcBangData.setLatitude(new BigDecimal(document.getLatitude()));
                            analysisTargetPcBangData.setLongitude(new BigDecimal(document.getLongitude()));
                            analysisTargetPcBangData.setGeocodingStatus(
                                "좌표변환 성공(" + addressInfo.getAddressType() + ")");
                            apiSuccessCount++;
                            
                            log.debug("좌표 변환 성공: {} → lat: {}, lng: {}", 
                                addressInfo.getCleanedAddress(), document.getLatitude(), document.getLongitude());
                        } else {
                            analysisTargetPcBangData.setGeocodingStatus(
                                "좌표변환 실패: 모든 주소 형태 시도했으나 결과 없음(" + addressInfo.getAddressType() + ")");
                            log.debug("좌표 변환 실패 (모든 형태 시도 실패): {}", addressInfo.getCleanedAddress());
                            apiFailedCount++;
                        }
                        
                        // API 호출 제한 준수를 위한 추가 대기 (여러 번 호출했으므로)
                        Thread.sleep(requestDelay);
                        
                    } catch (Exception apiException) {
                        analysisTargetPcBangData.setGeocodingStatus(
                            "좌표변환 실패: API 오류 - " + apiException.getMessage());
                        log.warn("카카오맵 API 호출 실패: {} - {}", addressInfo.getCleanedAddress(), apiException.getMessage());
                        apiFailedCount++;
                        
                        // API 에러 시 더 긴 대기
                        Thread.sleep(requestDelay * 5);
                    }
                } else {
                    // 주소 정제 실패 또는 주소 없음
                    analysisTargetPcBangData.setGeocodingStatus(addressInfo.getStatusMessage());
                    log.debug("주소 사용 불가: {}", addressInfo.getStatusMessage());
                    apiFailedCount++;
                }
                
                // 분석용 테이블에 데이터 저장
                analysisPcBangRepository.save(analysisTargetPcBangData);
                successfulConversionCount++;
                
                log.debug("분석용 데이터 생성 완료: {} (구코드: {}, 좌표: {}, {})", 
                    originalPcBangData.getBusinessName(), 
                    originalPcBangData.getDistrictCode(),
                    analysisTargetPcBangData.getLatitude(), 
                    analysisTargetPcBangData.getLongitude());

            } catch (Exception dataConversionException) {
                log.error("분석용 데이터 생성 실패 - PC방: {} (ID: {}), 오류: {}", 
                    originalPcBangData.getBusinessName(), originalPcBangData.getId(), 
                    dataConversionException.getMessage());
                failedConversionCount++;
            }
        }

        // Step 4: 변환 작업 결과 로깅
        log.info("PC방 위치 데이터 분석용 테이블 생성 작업 완료");
        log.info("  - 데이터 변환: 성공 {} 개, 실패 {} 개", successfulConversionCount, failedConversionCount);
        log.info("  - 좌표 변환: 성공 {} 개, 실패 {} 개", apiSuccessCount, apiFailedCount);
        
        // Step 5: 최종 데이터 검증 및 품질 확인
        performFinalDataValidation();
        
        log.info("=== PC방 위치 데이터 분석용 테이블 생성 작업 종료 ===");
    }
    
    /**
     * 원본 PC방 엔티티를 분석용 엔티티로 변환
     * 
     * 7개 핵심 필드를 복사하고, 좌표는 초기값으로 설정한다. (API 호출로 나중에 업데이트)
     * null 값은 적절한 기본값으로 변환 처리한다.
     * 
     * @param originalPcBangData 원본 PC방 엔티티
     * @return 분석용 PC방 엔티티
     */
    private AnalysisPcBangStatistics convertToAnalysisEntity(PcBangs originalPcBangData) {
        return AnalysisPcBangStatistics.builder()
            // 기본 정보
            .districtCode(handleNullString(originalPcBangData.getDistrictCode()))           // 구 코드
            .managementNumber(handleNullString(originalPcBangData.getManagementNumber()))   // 관리번호
            .businessStatusName(handleNullString(originalPcBangData.getBusinessStatusName())) // 영업상태명
            
            // 주소 정보
            .jibunAddress(handleNullString(originalPcBangData.getJibunAddress()))           // 지번주소
            .roadAddress(handleNullString(originalPcBangData.getRoadAddress()))             // 도로명주소
            
            // 업소 정보
            .businessName(handleNullString(originalPcBangData.getBusinessName()))           // 업소명
            
            // 좌표 정보 (초기값, API 호출로 업데이트 예정)
            .latitude(BigDecimal.ZERO)                                                      // 위도 (카카오맵 API)
            .longitude(BigDecimal.ZERO)                                                     // 경도 (카카오맵 API)
            
            // 좌표변환 상태 (초기값, API 호출 결과로 업데이트 예정)
            .geocodingStatus("좌표변환 대기중")                                                 // 좌표변환 상태 메시지
            .build();
    }

    /**
     * 카카오맵 API 호출에 사용할 주소 정제 및 결정
     * 1순위: 도로명주소 → 성공 시 바로 반환, 실패 시 2순위 시도
     * 2순위: 지번주소 → 도로명주소 실패한 경우에만 시도
     * 주소에서 괄호, 층수, 호수 등 API가 처리 못하는 부분 제거
     * 
     * @param originalPcBangData 원본 PC방 데이터
     * @return AddressInfo 객체 (정제된 주소, 사용된 주소 타입, 상태 메시지)
     */
    private AddressInfo determineAndCleanAddress(PcBangs originalPcBangData) {
        String roadAddress = originalPcBangData.getRoadAddress();
        String jibunAddress = originalPcBangData.getJibunAddress();
        
        // 1순위: 도로명주소 체크 및 정제
        if (roadAddress != null && !roadAddress.trim().isEmpty() && !roadAddress.equals("데이터없음")) {
            String cleanedAddress = cleanAddressForAPI(roadAddress);
            if (cleanedAddress != null) {
                return new AddressInfo(cleanedAddress, "도로명주소", "도로명주소 사용");
            }
        }
        
        // 2순위: 지번주소 체크 및 정제 (도로명주소가 없거나 정제 실패한 경우에만)
        if (jibunAddress != null && !jibunAddress.trim().isEmpty() && !jibunAddress.equals("데이터없음")) {
            String cleanedAddress = cleanAddressForAPI(jibunAddress);
            if (cleanedAddress != null) {
                return new AddressInfo(cleanedAddress, "지번주소", "지번주소 사용(도로명주소 없음 또는 정제 불가)");
            }
        }
        
        // 둘 다 사용 불가
        return new AddressInfo(null, "없음", "도로명주소/지번주소 모두 없음 또는 정제 불가");
    }

    /**
     * 카카오맵 API가 처리할 수 있도록 주소 정제
     * - 괄호 및 괄호 안 내용 제거: (건물명), (층수), (호수) 등
     * - 층/호 정보 제거: 1층, 2호, B1층 등
     * - 기타 불필요한 정보 제거
     * - 여러 형태로 변환하여 API 호출 시도
     * 
     * @param rawAddress 원본 주소
     * @return 정제된 주소 (null이면 사용 불가)
     */
    private String cleanAddressForAPI(String rawAddress) {
        if (rawAddress == null || rawAddress.trim().isEmpty()) {
            return null;
        }
        
        String cleaned = rawAddress.trim();
        
        // 괄호 및 괄호 안 내용 제거
        cleaned = cleaned.replaceAll("\\([^\\)]*\\)", "");
        cleaned = cleaned.replaceAll("\\)[^\\(]*", ""); // 남은 ) 제거
        
        // 층/호 정보 제거 (숫자+층, 숫자+호, B+숫자+층 등)
        cleaned = cleaned.replaceAll("\\s*[B0-9]+층\\s*", " ");
        cleaned = cleaned.replaceAll("\\s*[0-9]+호\\s*", " ");
        cleaned = cleaned.replaceAll("\\s*[B0-9]+F\\s*", " ");
        
        // 기타 상세 위치 정보 제거
        cleaned = cleaned.replaceAll("\\s*지하\\s*", " ");
        cleaned = cleaned.replaceAll("\\s*옥상\\s*", " ");
        cleaned = cleaned.replaceAll("\\s*,\\s*", " ");
        
        // "서울특별시" → "서울"로 단순화
        cleaned = cleaned.replace("서울특별시", "서울");
        
        // 다중 공백을 단일 공백으로 변환
        cleaned = cleaned.replaceAll("\\s+", " ");
        cleaned = cleaned.trim();
        
        // 최소 길이 체크 (너무 짧으면 사용 불가)
        if (cleaned.length() < 5) {
            return null;
        }
        
        return cleaned;
    }

    /**
     * 주소를 여러 형태로 변환하여 API 호출 시도
     * 1차: 정제된 전체 주소 (도로명주소 우선)
     * 2차: 더 단순한 형태 (시/도 제거)
     * 3차: 도로명만 추출
     * 4차: 지번주소로 재시도 (도로명 검색이 모두 실패한 경우)
     */
    private KakaoAddressApiClient.AddressSearchResponse tryMultipleAddressFormats(String baseAddress, PcBangs originalData) {
        // 1차 시도: 정제된 전체 주소
        log.debug("1차 주소 검색 시도: {}", baseAddress);
        KakaoAddressApiClient.AddressSearchResponse response = kakaoAddressApiClient.searchAddress(baseAddress);
        
        if (response.getDocuments() != null && !response.getDocuments().isEmpty()) {
            log.debug("1차 시도 성공: {} 개 결과", response.getDocuments().size());
            return response;
        }
        
        // API 호출 간격
        try { Thread.sleep(requestDelay); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        
        // 2차 시도: "서울" 제거한 형태
        String simplified = baseAddress.replace("서울", "").trim();
        if (!simplified.equals(baseAddress) && simplified.length() >= 5) {
            log.debug("2차 주소 검색 시도: {}", simplified);
            response = kakaoAddressApiClient.searchAddress(simplified);
            
            if (response.getDocuments() != null && !response.getDocuments().isEmpty()) {
                log.debug("2차 시도 성공: {} 개 결과", response.getDocuments().size());
                return response;
            }
            
            try { Thread.sleep(requestDelay); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        }
        
        // 3차 시도: 도로명과 번호만 추출
        String roadOnly = extractRoadNameAndNumber(baseAddress);
        if (roadOnly != null && !roadOnly.equals(baseAddress) && !roadOnly.equals(simplified)) {
            log.debug("3차 주소 검색 시도 (도로명만): {}", roadOnly);
            response = kakaoAddressApiClient.searchAddress(roadOnly);
            
            if (response.getDocuments() != null && !response.getDocuments().isEmpty()) {
                log.debug("3차 시도 성공: {} 개 결과", response.getDocuments().size());
                return response;
            }
            
            try { Thread.sleep(requestDelay); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        }
        
        // 4차 시도: 지번주소로 재시도 (모든 도로명 시도가 실패한 경우)
        String jibunAddress = originalData.getJibunAddress();
        if (jibunAddress != null && !jibunAddress.trim().isEmpty() && !jibunAddress.equals("데이터없음")) {
            String cleanedJibun = cleanAddressForAPI(jibunAddress);
            if (cleanedJibun != null && !cleanedJibun.equals(baseAddress)) {
                log.debug("4차 주소 검색 시도 (지번주소): {}", cleanedJibun);
                response = kakaoAddressApiClient.searchAddress(cleanedJibun);
                
                if (response.getDocuments() != null && !response.getDocuments().isEmpty()) {
                    log.debug("4차 시도 성공 (지번주소): {} 개 결과", response.getDocuments().size());
                    return response;
                }
                
                try { Thread.sleep(requestDelay); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
                
                // 5차 시도: 지번주소에서 "서울" 제거
                String simplifiedJibun = cleanedJibun.replace("서울", "").trim();
                if (!simplifiedJibun.equals(cleanedJibun) && simplifiedJibun.length() >= 5) {
                    log.debug("5차 주소 검색 시도 (지번주소 단순화): {}", simplifiedJibun);
                    response = kakaoAddressApiClient.searchAddress(simplifiedJibun);
                    
                    if (response.getDocuments() != null && !response.getDocuments().isEmpty()) {
                        log.debug("5차 시도 성공 (지번주소 단순화): {} 개 결과", response.getDocuments().size());
                        return response;
                    }
                    
                    try { Thread.sleep(requestDelay); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
                }
                
                // 6차 시도: 지번주소에서 동과 번지만 추출
                String jibunOnly = extractJibunDongAndNumber(cleanedJibun);
                if (jibunOnly != null && !jibunOnly.equals(cleanedJibun) && !jibunOnly.equals(simplifiedJibun)) {
                    log.debug("6차 주소 검색 시도 (지번 동+번지만): {}", jibunOnly);
                    response = kakaoAddressApiClient.searchAddress(jibunOnly);
                    
                    if (response.getDocuments() != null && !response.getDocuments().isEmpty()) {
                        log.debug("6차 시도 성공 (지번 동+번지만): {} 개 결과", response.getDocuments().size());
                        return response;
                    }
                }
            }
        }
        
        log.debug("모든 주소 형태 시도 실패");
        return new KakaoAddressApiClient.AddressSearchResponse();
    }

    /**
     * 도로명과 번호만 추출 (예: "종로구 율곡로 245" → "율곡로 245")
     */
    private String extractRoadNameAndNumber(String address) {
        // "구 도로명 번호" 패턴 추출
        java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(".*구\\s+([가-힣\\w]+로\\d*[가-길]*\\s+\\d+[\\-\\d]*)");
        java.util.regex.Matcher matcher = pattern.matcher(address);
        
        if (matcher.find()) {
            return matcher.group(1).trim();
        }
        
        return null;
    }

    /**
     * 지번주소에서 동과 번지만 추출 (예: "종로구 창신동 15-23" → "창신동 15-23")
     */
    private String extractJibunDongAndNumber(String address) {
        // "구 동명 번지" 패턴 추출
        java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(".*구\\s+([가-힣]+동\\s+\\d+[\\-\\d]*)");
        java.util.regex.Matcher matcher = pattern.matcher(address);
        
        if (matcher.find()) {
            return matcher.group(1).trim();
        }
        
        return null;
    }

    /**
     * 주소 정보를 담는 내부 클래스
     */
    private static class AddressInfo {
        private final String cleanedAddress;
        private final String addressType;
        private final String statusMessage;
        
        public AddressInfo(String cleanedAddress, String addressType, String statusMessage) {
            this.cleanedAddress = cleanedAddress;
            this.addressType = addressType;
            this.statusMessage = statusMessage;
        }
        
        public String getCleanedAddress() { return cleanedAddress; }
        public String getAddressType() { return addressType; }
        public String getStatusMessage() { return statusMessage; }
    }
    
    /**
     * 문자열 null 값 처리 - null이면 "데이터없음"으로 변환
     * 
     * @param value 원본 문자열 값
     * @return null이면 "데이터없음", 아니면 원본 값
     */
    private String handleNullString(String value) {
        return value != null ? value : "데이터없음";
    }
    
    /**
     * 분석용 데이터의 최종 검증 및 품질 확인
     * 
     * 작업 내용:
     * - 전체 데이터 개수 확인
     * - 구별 PC방 밀도 순위 상위 5개 로깅
     * - 영업상태별 분포 로깅
     * - 좌표 변환 성공률 확인
     * - 데이터 검증 과정에서 발생하는 오류 처리
     */
    private void performFinalDataValidation() {
        try {
            // 최종 저장된 분석용 데이터 개수 확인
            long finalAnalysisDataCount = analysisPcBangRepository.count();
            log.info("최종 분석용 PC방 데이터 저장 완료: {} 개 업소", finalAnalysisDataCount);
            
            // 구별 PC방 밀도 순위 조회 및 로깅 (피어슨 상관분석 검증용)
            List<Object[]> districtPcBangDensityRankingList = analysisPcBangRepository.findDistrictPcBangDensityRanking();
            log.info("구코드별 PC방 밀도 순위 (상위 5개):");
            
            districtPcBangDensityRankingList.stream()
                .limit(5)
                .forEach(rankingRow -> {
                    String districtCode = (String) rankingRow[0];         // 구 코드
                    Long totalPcBangCount = (Long) rankingRow[1];         // 총 PC방 개수
                    log.info("  {} : {} 개 업소", districtCode, totalPcBangCount);
                });
            
            // 서울시 구별 PC방 밀도 순위 조회 및 로깅
            List<Object[]> seoulDistrictPcBangDensityRankingList = analysisPcBangRepository.findSeoulDistrictPcBangDensityRanking();
            log.info("서울시 구별 PC방 밀도 순위 (상위 5개구):");
            
            seoulDistrictPcBangDensityRankingList.stream()
                .limit(5)
                .forEach(districtRow -> {
                    String districtName = (String) districtRow[0];        // 구 이름
                    Number pcBangCount = (Number) districtRow[1];         // PC방 개수
                    log.info("  {} : {} 개 업소", districtName, pcBangCount);
                });
            
            // 영업상태별 분포 조회 및 로깅
            List<Object[]> businessStatusDistributionList = analysisPcBangRepository.findBusinessStatusDistribution();
            log.info("영업상태별 PC방 분포:");
            
            businessStatusDistributionList.forEach(statusRow -> {
                String statusName = (String) statusRow[0];                // 영업상태명
                Long statusCount = (Long) statusRow[1];                   // 개수
                log.info("  {} : {} 개 업소", statusName, statusCount);
            });

            // 좌표 변환 성공률 확인
            long totalCount = analysisPcBangRepository.count();
            long successfulGeocodedCount = analysisPcBangRepository.countSuccessfulGeocodedData();
            
            log.info("좌표 변환 결과 요약:");
            log.info("  - 전체 데이터: {} 개", totalCount);
            log.info("  - 좌표 변환 성공: {} 개", successfulGeocodedCount);
            log.info("  - 좌표 변환 실패: {} 개", totalCount - successfulGeocodedCount);
            log.info("  - 성공률: {:.1f}%", totalCount > 0 ? (double)successfulGeocodedCount / totalCount * 100 : 0.0);
            
            // 좌표변환 상태별 분포 조회 및 로깅
            List<Object[]> geocodingStatusDistributionList = analysisPcBangRepository.findGeocodingStatusDistribution();
            log.info("좌표변환 상태별 분포:");
            
            geocodingStatusDistributionList.forEach(statusRow -> {
                String geocodingStatus = (String) statusRow[0];           // 좌표변환 상태
                Long statusCount = (Long) statusRow[1];                   // 개수
                log.info("  {} : {} 개 업소", geocodingStatus, statusCount);
            });
                
        } catch (Exception dataValidationException) {
            log.error("분석용 데이터 검증 과정에서 오류가 발생했습니다: {}", 
                dataValidationException.getMessage(), dataValidationException);
        }
    }
}
```

## 7. Main 처리 클래스 수정

**목적**: 전체 분석용 데이터 처리 작업에 PC방 위치 데이터 처리 추가
**역할**: 기존 데이터에 이어서 PC방 위치 데이터 처리를 순차적으로 실행

```java
package com.WhereHouse.AnalysisData.main;

import com.WhereHouse.AnalysisData.crime.processor.CrimeDataProcessor;
import com.WhereHouse.AnalysisData.bankcount.processor.BankCountDataProcessor;
import com.WhereHouse.AnalysisData.banklocation.processor.BankLocationDataProcessor;
import com.WhereHouse.AnalysisData.cctv.processor.CctvDataProcessor;
import com.WhereHouse.AnalysisData.pcbang.processor.PcBangDataProcessor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class AnalysisDataProcessor implements CommandLineRunner {

    private final CrimeDataProcessor crimeDataProcessor;
    private final BankCountDataProcessor bankCountDataProcessor;
    private final BankLocationDataProcessor bankLocationDataProcessor;
    private final CctvDataProcessor cctvDataProcessor;
    private final PcBangDataProcessor pcBangDataProcessor;
    // 향후 14개 ERD별 프로세서 추가 예정
    // private final ConvenienceStoreDataProcessor convenienceStoreDataProcessor;
    // ...

    @Override
    public void run(String... args) throws Exception {
        log.info("=== 안전성 분석용 데이터 처리 시작 ===");
        
        try {
            // 1. 범죄 데이터 처리
            log.info("1. 범죄 데이터 분석용 테이블 생성 시작");
            crimeDataProcessor.processAnalysisCrimeData();
            
            // 2. 은행 지점 개수 데이터 처리
            log.info("2. 은행 지점 개수 데이터 분석용 테이블 생성 시작");
            bankCountDataProcessor.processAnalysisBankCountData();
            
            // 3. 은행 위치 데이터 처리
            log.info("3. 은행 위치 데이터 분석용 테이블 생성 시작");
            bankLocationDataProcessor.processAnalysisBankLocationData();
            
            // 4. CCTV 위치 데이터 처리
            log.info("4. CCTV 위치 데이터 분석용 테이블 생성 시작");
            cctvDataProcessor.processAnalysisCctvData();
            
            // 5. PC방 위치 데이터 처리 (카카오맵 API 연동)
            log.info("5. PC방 위치 데이터 분석용 테이블 생성 시작");
            pcBangDataProcessor.processAnalysisPcBangData();
            
            // 향후 추가될 14개 ERD별 데이터 처리
            // 6. 편의점 데이터 처리
            // log.info("6. 편의점 데이터 분석용 테이블 생성 시작");
            // convenienceStoreDataProcessor.processAnalysisConvenienceStoreData();
            
            // ... 추가 프로세서들
            
        } catch (Exception e) {
            log.error("안전성 분석용 데이터 처리 중 오류 발생", e);
            throw e;
        }
        
        log.info("=== 안전성 분석용 데이터 처리 완료 ===");
    }
}
```

## 실행 방법 및 검증

### 1. 사전 조건 확인
1. 카카오 개발자센터에서 REST API 키 발급 및 `application.yml` 설정
2. CSV를 통한 `PC_BANGS` 테이블 데이터 수집 완료
3. Oracle DB에 DDL 스크립트 실행
4. 테이블 생성 및 시퀀스 확인

### 2. 애플리케이션 실행
```bash
./gradlew bootRun
```

### 3. 실행 결과 검증
```sql
-- 데이터 개수 확인
SELECT COUNT(*) FROM ANALYSIS_PC_BANG_STATISTICS;

-- 구코드별 PC방 밀도 확인
SELECT DISTRICT_CODE, COUNT(*) as PC_BANG_COUNT 
FROM ANALYSIS_PC_BANG_STATISTICS 
WHERE DISTRICT_CODE != '데이터없음'
GROUP BY DISTRICT_CODE 
ORDER BY PC_BANG_COUNT DESC;

-- 좌표 데이터 품질 확인
SELECT COUNT(*) as TOTAL_COUNT,
       SUM(CASE WHEN LONGITUDE = 0.0 OR LATITUDE = 0.0 THEN 1 ELSE 0 END) as NO_COORD_COUNT,
       SUM(CASE WHEN LONGITUDE != 0.0 AND LATITUDE != 0.0 THEN 1 ELSE 0 END) as HAS_COORD_COUNT
FROM ANALYSIS_PC_BANG_STATISTICS;

-- 서울시 구별 PC방 분포 확인 (주소에서 구 정보 추출)
SELECT SUBSTR(ROAD_ADDRESS, 1, INSTR(ROAD_ADDRESS, ' ', 1, 2) - 1) as DISTRICT, 
       COUNT(*) as PC_BANG_COUNT 
FROM ANALYSIS_PC_BANG_STATISTICS 
WHERE ROAD_ADDRESS LIKE '서울%'
GROUP BY SUBSTR(ROAD_ADDRESS, 1, INSTR(ROAD_ADDRESS, ' ', 1, 2) - 1) 
ORDER BY PC_BANG_COUNT DESC;

-- 영업상태별 분포 확인
SELECT BUSINESS_STATUS_NAME, COUNT(*) as STATUS_COUNT
FROM ANALYSIS_PC_BANG_STATISTICS
GROUP BY BUSINESS_STATUS_NAME
ORDER BY STATUS_COUNT DESC;
```

## 예상 처리 결과

### 로그 출력 예시
```
=== 안전성 분석용 데이터 처리 시작 ===
1. 범죄 데이터 분석용 테이블 생성 시작
범죄 데이터 분석용 테이블 생성 작업 완료 - 성공: 25 개, 실패: 0 개
2. 은행 지점 개수 데이터 분석용 테이블 생성 시작
은행 지점 개수 데이터 분석용 테이블 생성 작업 완료 - 성공: 423 개, 실패: 0 개
3. 은행 위치 데이터 분석용 테이블 생성 시작
은행 위치 데이터 분석용 테이블 생성 작업 완료 - 성공: 823 개, 실패: 0 개
4. CCTV 위치 데이터 분석용 테이블 생성 시작
CCTV 위치 데이터 분석용 테이블 생성 작업 완료 - 성공: 15,234 개, 실패: 0 개
5. PC방 위치 데이터 분석용 테이블 생성 시작
원본 PC방 데이터 2,456 개 업소 발견
처리 진행률: 20.4% (500/2,456) - API 성공: 432, 실패: 68
처리 진행률: 40.8% (1,000/2,456) - API 성공: 856, 실패: 144
처리 진행률: 61.2% (1,500/2,456) - API 성공: 1,287, 실패: 213
처리 진행률: 81.6% (2,000/2,456) - API 성공: 1,723, 실패: 277
PC방 위치 데이터 분석용 테이블 생성 작업 완료
  - 데이터 변환: 성공 2,456 개, 실패 0 개
  - 좌표 변환: 성공 2,145 개, 실패 311 개
구코드별 PC방 밀도 순위 (상위 5개):
  11680 : 387 개 업소
  11740 : 298 개 업소
  11590 : 245 개 업소
  11470 : 234 개 업소
  11230 : 198 개 업소
서울시 구별 PC방 밀도 순위 (상위 5개구):
  서울 강남구 : 387 개 업소
  서울 송파구 : 298 개 업소
  서울 동작구 : 245 개 업소
  서울 관악구 : 234 개 업소
  서울 동대문구 : 198 개 업소
영업상태별 PC방 분포:
  영업중 : 2,145 개 업소
  폐업 : 287 개 업소
  휴업 : 24 개 업소
좌표 변환 결과 요약:
  - 전체 데이터: 2,456 개
  - 좌표 보유: 계산 필요 (0이 아닌 lat/lng)
=== 안전성 분석용 데이터 처리 완료 ===
```

## 카카오맵 API 사용 시 주의사항

### API 제한
- **호출 제한**: 초당 10회, 일일 300,000회
- **대응 방안**: 100ms 간격으로 호출하여 초당 10회 제한 준수

### 주소 품질
- **우선순위**: 도로명주소 > 지번주소
- **실패 처리**: 좌표 변환 실패 시 0.0으로 설정하고 계속 진행

### 에러 처리
- **네트워크 에러**: 5배 긴 대기 후 재시도 없이 다음 건 처리
- **API 에러**: 로깅 후 다음 건 처리
- **데이터 에러**: 개별 레코드 실패해도 전체 작업 계속

이 시스템은 향후 피어슨 상관분석에서 독립변수로 활용될 지역별 PC방 밀도 계산의 핵심 좌표 데이터를 제공합니다.