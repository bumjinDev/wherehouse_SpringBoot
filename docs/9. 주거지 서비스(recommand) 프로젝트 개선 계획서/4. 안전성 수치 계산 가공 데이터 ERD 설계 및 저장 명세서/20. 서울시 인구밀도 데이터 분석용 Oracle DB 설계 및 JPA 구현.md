# 서울시 인구밀도 데이터 분석용 Oracle DB 설계 및 JPA 구현

**프로젝트명:** 안전성 점수 계산 시스템 - 인구밀도 통계 분석 데이터 처리  
**버전:** 1.0  
**작성일:** 2025.09.01  
**목적:** 서울시 25개 자치구별 인구밀도 통계를 피어슨 상관분석 계산에 활용하기 위한 분석용 테이블 구축

---

## 프로젝트 개요

### 데이터 처리 목표
기존 `SEOUL_POPULATION_DENSITY` 테이블의 원본 데이터를 분석 전용 테이블 `ANALYSIS_POPULATION_DENSITY`로 복사하여 안전성 점수 계산 시스템에서 활용할 수 있도록 데이터 구조를 최적화한다.

### 핵심 특징
- **좌표 변환 불필요**: 인구밀도 데이터는 구별 집계 데이터이므로 개별 좌표 정보 불요
- **단순 데이터 복사**: 원본 테이블에서 `CREATED_AT` 제외한 모든 필드 복사
- **분석 전용 설계**: 제약조건 없이 순수 분석 목적의 테이블 구조
- **기존 인터페이스 재사용**: 원천 데이터 접근에 필요한 JPA Entity와 Repository는 기존 `Population` 패키지에서 직접 import하여 사용

---

## 1. Oracle 테이블 DDL

**목적**: 분석 전용 인구밀도 통계 테이블 생성 및 시퀀스 설정
**역할**: 피어슨 상관분석에 사용될 독립변수(구별 인구밀도) 데이터 저장소 구축

```sql
-- 기존 테이블과 데이터를 완전히 삭제
DROP TABLE ANALYSIS_POPULATION_DENSITY CASCADE CONSTRAINTS PURGE;
DROP SEQUENCE SEQ_ANALYSIS_POPULATION_DENSITY;

-- 분석용 인구밀도 통계 테이블 생성
CREATE TABLE ANALYSIS_POPULATION_DENSITY (
    ID                      NUMBER,                     -- 제한 없음
    DISTRICT_NAME           VARCHAR2(4000),             -- 최대 크기
    YEAR                    NUMBER,                     -- 제한 없음
    POPULATION_COUNT        NUMBER,                     -- 제한 없음
    AREA_SIZE               NUMBER,                     -- 제한 없음
    POPULATION_DENSITY      NUMBER                      -- 제한 없음
);

-- 시퀀스 생성
CREATE SEQUENCE SEQ_ANALYSIS_POPULATION_DENSITY 
    START WITH 1 
    INCREMENT BY 1 
    NOCACHE
    NOCYCLE;

-- 확인
DESC ANALYSIS_POPULATION_DENSITY;
SELECT COUNT(*) FROM ANALYSIS_POPULATION_DENSITY;

```

## 2. JPA Entity

**목적**: 분석용 인구밀도 통계 테이블과 Java 객체 간 ORM 매핑
**역할**: 데이터베이스 CRUD 작업을 위한 엔티티 클래스 정의

```java
package com.WhereHouse.AnalysisData.population.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;

@Entity
@Table(name = "ANALYSIS_POPULATION_DENSITY")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AnalysisPopulationDensity {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "analysis_population_seq")
    @SequenceGenerator(name = "analysis_population_seq", sequenceName = "SEQ_ANALYSIS_POPULATION_DENSITY", allocationSize = 1)
    @Column(name = "ID")
    private Long id;

    @Column(name = "DISTRICT_NAME", length = 50)
    private String districtName;

    @Column(name = "YEAR")
    private Integer year;

    @Column(name = "POPULATION_COUNT")
    private Long populationCount;

    @Column(name = "AREA_SIZE", precision = 15, scale = 5)
    private BigDecimal areaSize;

    @Column(name = "POPULATION_DENSITY", precision = 15, scale = 5)
    private BigDecimal populationDensity;
}
```

## 3. Repository

**목적**: 분석용 인구밀도 통계 데이터에 대한 데이터 접근 계층 구현
**역할**: JPA 기반 CRUD 연산 및 맞춤형 쿼리 메서드 제공 (구별 순위 조회, 데이터 검증용)

```java
package com.WhereHouse.AnalysisData.population.repository;

import com.WhereHouse.AnalysisData.population.entity.AnalysisPopulationDensity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface AnalysisPopulationRepository extends JpaRepository<AnalysisPopulationDensity, Long> {
    
    Optional<AnalysisPopulationDensity> findByDistrictName(String districtName);
    
    List<AnalysisPopulationDensity> findAllByOrderByPopulationDensityDesc();
    
    boolean existsByDistrictName(String districtName);
    
    @Query("SELECT COUNT(a) FROM AnalysisPopulationDensity a")
    long countAnalysisData();
    
    @Query("SELECT a.districtName, a.populationDensity FROM AnalysisPopulationDensity a ORDER BY a.populationDensity DESC")
    List<Object[]> findDistrictDensityRanking();
}
```

## 4. 인구밀도 데이터 분석용 처리 Component

**목적**: 원본 인구밀도 데이터를 분석용 테이블로 변환하는 비즈니스 로직 처리
**역할**: 
- 기존 `SEOUL_POPULATION_DENSITY` 테이블에서 25개 구 데이터 조회
- `CREATED_AT` 필드 제외한 모든 인구밀도 통계 필드 복사
- 데이터 품질 검증 및 구별 인구밀도 순위 로깅

```java
package com.WhereHouse.AnalysisData.population.processor;

import com.WhereHouse.AnalysisData.population.entity.AnalysisPopulationDensity;
import com.WhereHouse.AnalysisData.population.repository.AnalysisPopulationRepository;
// 원본 데이터 접근을 위한 기존 패키지 import
import com.WhereHouse.APITest.Population.Entity.SeoulPopulationDensity;
import com.WhereHouse.APITest.Population.Repository.SeoulPopulationDensityRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * 인구밀도 데이터 분석용 테이블 생성 처리 컴포넌트
 * 
 * 기존 SEOUL_POPULATION_DENSITY 테이블에서 데이터를 조회하여
 * 분석 전용 ANALYSIS_POPULATION_DENSITY 테이블로 복사하는 작업을 수행한다.
 * 
 * 주요 기능:
 * - 원본 인구밀도 통계 데이터 조회 및 검증
 * - CREATED_AT 필드 제외한 모든 인구밀도 통계 필드 복사
 * - 분석용 테이블 데이터 품질 검증
 * - 구별 인구밀도 순위 로깅
 * 
 * @author Safety Analysis System
 * @since 1.0
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class PopulationDataProcessor {

    // 원본 인구밀도 통계 테이블 접근을 위한 Repository
    private final SeoulPopulationDensityRepository originalPopulationRepository;
    
    // 분석용 인구밀도 통계 테이블 접근을 위한 Repository  
    private final AnalysisPopulationRepository analysisPopulationRepository;

    /**
     * 인구밀도 데이터 분석용 테이블 생성 메인 프로세스
     * 
     * 작업 순서:
     * 1. 기존 분석용 데이터 존재 여부 확인
     * 2. 원본 인구밀도 데이터 조회 및 검증
     * 3. 데이터 변환 및 분석용 테이블 저장
     * 4. 데이터 품질 검증 및 결과 로깅
     */
    @Transactional
    public void processAnalysisPopulationData() {
        log.info("=== 인구밀도 데이터 분석용 테이블 생성 작업 시작 ===");
        
        // Step 1: 기존 분석용 데이터 중복 처리 방지를 위한 존재 여부 확인
        long existingAnalysisDataCount = analysisPopulationRepository.count();
        if (existingAnalysisDataCount > 0) {
            log.info("분석용 인구밀도 데이터가 이미 존재합니다 (총 {} 개). 작업을 스킵합니다.", existingAnalysisDataCount);
            return;
        }

        // Step 2: 원본 인구밀도 통계 데이터 조회 및 검증
        List<SeoulPopulationDensity> originalPopulationDataList = originalPopulationRepository.findAll();
        if (originalPopulationDataList.isEmpty()) {
            log.warn("원본 인구밀도 통계 데이터가 존재하지 않습니다. 먼저 PopulationDensityDataLoader를 통해 데이터를 로드해주세요.");
            return;
        }
        
        log.info("원본 인구밀도 통계 데이터 {} 개 구 발견", originalPopulationDataList.size());

        // Step 3: 데이터 변환 및 저장 작업 수행
        int successfulConversionCount = 0;  // 성공적으로 변환된 데이터 개수
        int failedConversionCount = 0;      // 변환 실패한 데이터 개수

        for (SeoulPopulationDensity originalPopulationData : originalPopulationDataList) {
            try {
                // 원본 데이터를 분석용 엔티티로 변환 (CREATED_AT 필드 제외)
                AnalysisPopulationDensity analysisTargetPopulationData = convertToAnalysisEntity(originalPopulationData);
                
                // 분석용 테이블에 데이터 저장
                analysisPopulationRepository.save(analysisTargetPopulationData);
                successfulConversionCount++;
                
                log.debug("분석용 데이터 생성 완료: {} 구 (인구밀도: {} 명/㎢)", 
                    originalPopulationData.getDistrictLevel2(), originalPopulationData.getPopulationDensity());

            } catch (Exception dataConversionException) {
                log.error("분석용 데이터 생성 실패 - 구명: {}, 오류: {}", 
                    originalPopulationData.getDistrictLevel2(), dataConversionException.getMessage());
                failedConversionCount++;
            }
        }

        // Step 4: 변환 작업 결과 로깅
        log.info("인구밀도 데이터 분석용 테이블 생성 작업 완료 - 성공: {} 개, 실패: {} 개", 
            successfulConversionCount, failedConversionCount);
        
        // Step 5: 최종 데이터 검증 및 품질 확인
        performFinalDataValidation();
        
        log.info("=== 인구밀도 데이터 분석용 테이블 생성 작업 종료 ===");
    }
    
    /**
     * 원본 인구밀도 통계 엔티티를 분석용 엔티티로 변환
     * 
     * CREATED_AT 필드를 제외한 모든 인구밀도 통계 필드를 복사한다.
     * 
     * @param originalPopulationData 원본 인구밀도 통계 엔티티
     * @return 분석용 인구밀도 통계 엔티티
     */
    private AnalysisPopulationDensity convertToAnalysisEntity(SeoulPopulationDensity originalPopulationData) {
        return AnalysisPopulationDensity.builder()
            // 기본 정보
            .districtName(originalPopulationData.getDistrictLevel2())     // 자치구명
            .year(originalPopulationData.getYear())                       // 통계 연도
            
            // 인구밀도 통계
            .populationCount(originalPopulationData.getPopulationCount()) // 인구 수
            .areaSize(originalPopulationData.getAreaSize())               // 면적 (㎢)
            .populationDensity(originalPopulationData.getPopulationDensity()) // 인구밀도 (명/㎢)
            .build();
    }
    
    /**
     * 분석용 데이터의 최종 검증 및 품질 확인
     * 
     * 작업 내용:
     * - 전체 데이터 개수 확인
     * - 구별 인구밀도 순위 상위 5개 로깅
     * - 데이터 검증 과정에서 발생하는 오류 처리
     */
    private void performFinalDataValidation() {
        try {
            // 최종 저장된 분석용 데이터 개수 확인
            long finalAnalysisDataCount = analysisPopulationRepository.count();
            log.info("최종 분석용 인구밀도 데이터 저장 완료: {} 개 구", finalAnalysisDataCount);
            
            // 구별 인구밀도 순위 조회 및 로깅 (피어슨 상관분석 검증용)
            List<Object[]> districtDensityRankingList = analysisPopulationRepository.findDistrictDensityRanking();
            log.info("서울시 구별 인구밀도 순위 (상위 5개구):");
            
            districtDensityRankingList.stream()
                .limit(5)
                .forEach(rankingRow -> {
                    String districtName = (String) rankingRow[0];           // 구 이름
                    Object densityObj = rankingRow[1];                      // 인구밀도
                    log.info("  {} : {} 명/㎢", districtName, densityObj);
                });
                
        } catch (Exception dataValidationException) {
            log.error("분석용 데이터 검증 과정에서 오류가 발생했습니다: {}", 
                dataValidationException.getMessage(), dataValidationException);
        }
    }
}
```

## 5. Main 처리 클래스

**목적**: 전체 분석용 데이터 처리 작업의 통합 관리 및 실행
**역할**: 
- 애플리케이션 시작 시 자동 실행되는 메인 진입점 (`CommandLineRunner` 구현)
- 인구밀도 데이터를 포함한 19개 ERD별 프로세서들의 순차적 호출 관리
- 전체 작업 진행 상황 로깅 및 예외 처리

```java
package com.WhereHouse.AnalysisData.main;

import com.WhereHouse.AnalysisData.population.processor.PopulationDataProcessor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class AnalysisDataProcessor implements CommandLineRunner {

    private final PopulationDataProcessor populationDataProcessor;
    // 향후 18개 ERD별 프로세서 추가 예정
    // private final CrimeDataProcessor crimeDataProcessor;
    // private final CctvDataProcessor cctvDataProcessor;
    // ...

    @Override
    public void run(String... args) throws Exception {
        log.info("=== 안전성 분석용 데이터 처리 시작 ===");
        
        try {
            // 1. 인구밀도 데이터 처리
            log.info("1. 인구밀도 데이터 분석용 테이블 생성 시작");
            populationDataProcessor.processAnalysisPopulationData();
            
            // 향후 추가될 18개 ERD별 데이터 처리
            // 2. 범죄 데이터 처리
            // log.info("2. 범죄 데이터 분석용 테이블 생성 시작");
            // crimeDataProcessor.processAnalysisCrimeData();
            
            // 3. CCTV 데이터 처리
            // log.info("3. CCTV 데이터 분석용 테이블 생성 시작");
            // cctvDataProcessor.processAnalysisCctvData();
            
            // ... 추가 프로세서들
            
        } catch (Exception e) {
            log.error("안전성 분석용 데이터 처리 중 오류 발생", e);
            throw e;
        }
        
        log.info("=== 안전성 분석용 데이터 처리 완료 ===");
    }
}
```

## 실행 방법 및 검증

### 1. 데이터베이스 설정
1. Oracle DB에 DDL 스크립트 실행
2. 테이블 생성 및 시퀀스 확인

### 2. 애플리케이션 실행
```bash
./gradlew bootRun
```

### 3. 실행 결과 검증
```sql
-- 데이터 개수 확인
SELECT COUNT(*) FROM ANALYSIS_POPULATION_DENSITY;

-- 구별 데이터 확인
SELECT DISTRICT_NAME, POPULATION_DENSITY FROM ANALYSIS_POPULATION_DENSITY 
ORDER BY POPULATION_DENSITY DESC;
```

## 예상 처리 결과

### 로그 출력 예시
```
=== 안전성 분석용 데이터 처리 시작 ===
1. 인구밀도 데이터 분석용 테이블 생성 시작
원본 인구밀도 통계 데이터 25 개 구 발견
분석용 데이터 생성 완료: 양천구 구 (인구밀도: 24953 명/㎢)
...
인구밀도 데이터 분석용 테이블 생성 작업 완료 - 성공: 25 개, 실패: 0 개
서울시 구별 인구밀도 순위 (상위 5개구):
  양천구 : 24953 명/㎢
  동대문구 : 25226 명/㎢
  ...
=== 안전성 분석용 데이터 처리 완료 ===
```

이 시스템은 향후 피어슨 상관분석에서 독립변수로 활용될 구별 인구밀도 계산의 기초 데이터를 제공합니다.