# 노래연습장 데이터 분석용 Oracle DB 설계 및 JPA 구현

**프로젝트명:** 안전성 점수 계산 시스템 - 노래연습장 밀도 분석 데이터 처리  
**버전:** 1.0  
**작성일:** 2025.08.31  
**목적:** 서울시 노래연습장 위치 정보를 Kakao API를 통한 지오코딩으로 정확한 좌표를 계산하여 피어슨 상관분석에 활용

---

## 프로젝트 개요

### 데이터 처리 목표
기존 `KARAOKE_ROOMS` 테이블의 원본 데이터에서 잘못된 좌표 정보(0 또는 부정확한 값)를 Kakao 지오코딩 API를 통해 정확한 위도/경도로 재계산하고, 분석 전용 테이블 `ANALYSIS_KARAOKE_ROOMS`로 복사하여 안전성 점수 계산 시스템에서 활용할 수 있도록 데이터 구조를 최적화한다.

### 핵심 특징
- **Kakao API 연동**: 지번주소와 도로명주소 기반 지오코딩으로 정확한 위도/경도 계산
- **이중 주소 처리**: JIBUN_ADDRESS와 ROAD_ADDRESS 모두 활용하여 지오코딩 성공률 향상
- **영업상태 필터링**: 영업 중인 업소만 선별하여 분석 정확도 제고
- **좌표 검증 시스템**: API 호출 실패 시 대체 주소로 재시도 로직 구현
- **분석 전용 설계**: 제약조건 완화, 순수 분석 목적의 테이블 구조

---

## 1. Oracle 테이블 DDL

**목적**: 분석 전용 노래연습장 테이블 생성 및 시퀀스 설정
**역할**: 피어슨 상관분석에 사용될 독립변수(노래연습장 밀도) 데이터 저장소 구축

```sql
-- 기존 테이블과 데이터를 완전히 삭제
DROP TABLE ANALYSIS_KARAOKE_ROOMS CASCADE CONSTRAINTS PURGE;
DROP SEQUENCE SEQ_ANALYSIS_KARAOKE_ROOMS;

-- 분석용 노래연습장 테이블 생성
CREATE TABLE ANALYSIS_KARAOKE_ROOMS (
    ID                      NUMBER,                     -- 제한 없음
    DISTRICT_CODE           VARCHAR2(4000),             -- 최대 크기
    MANAGEMENT_NUMBER       VARCHAR2(4000),             -- 최대 크기
    BUSINESS_STATUS_NAME    VARCHAR2(4000),             -- 최대 크기
    PHONE_NUMBER            VARCHAR2(4000),             -- 최대 크기
    JIBUN_ADDRESS           VARCHAR2(4000),             -- 최대 크기
    ROAD_ADDRESS            VARCHAR2(4000),             -- 최대 크기
    BUSINESS_NAME           VARCHAR2(4000),             -- 최대 크기
    COORD_X                 NUMBER,                     -- 경도 (Kakao API로 계산)
    COORD_Y                 NUMBER,                     -- 위도 (Kakao API로 계산)
    DISTRICT_NAME           VARCHAR2(4000),             -- 구별 분석용 추가 컬럼
    GEOCODING_STATUS        VARCHAR2(50),               -- 지오코딩 성공/실패 상태
    GEOCODING_ADDRESS_TYPE  VARCHAR2(50),               -- 사용된 주소 타입 (JIBUN/ROAD)
    API_RESPONSE_ADDRESS    VARCHAR2(4000)              -- Kakao API 응답 주소 (검증용)
);

-- 시퀀스 생성
CREATE SEQUENCE SEQ_ANALYSIS_KARAOKE_ROOMS 
    START WITH 1 
    INCREMENT BY 1 
    NOCACHE
    NOCYCLE;

-- 확인
DESC ANALYSIS_KARAOKE_ROOMS;
SELECT COUNT(*) FROM ANALYSIS_KARAOKE_ROOMS;
```

## 2. application.yml 추가 설정

**목적**: Kakao API 연동 및 노래연습장 분석 처리를 위한 설정 정보 추가
**역할**: 지오코딩 API 호출 및 배치 처리 설정

```yaml
# 기존 설정에 추가
kakao:
  api:
    key: "YOUR_KAKAO_REST_API_KEY"  # Kakao 개발자 콘솔에서 발급받은 REST API 키
    geocoding:
      url: "https://dapi.kakao.com/v2/local/search/address.json"
      timeout: 5000                 # 응답 대기 시간 (ms)
      retry-count: 3                # 실패 시 재시도 횟수
      rate-limit: 100               # 분당 요청 제한 (Kakao API 정책 준수)

# 노래연습장 분석 처리 설정
app:
  analysis:
    karaoke-rooms:
      batch-size: 50                # 배치 처리 단위
      geocoding-delay: 100          # API 호출 간격 (ms) - Rate Limit 준수
      seoul-bounds:                 # 서울시 영역 검증용 좌표 범위
        min-lat: 37.4269            # 최소 위도
        max-lat: 37.7019            # 최대 위도  
        min-lng: 126.7342           # 최소 경도
        max-lng: 127.2698           # 최대 경도
      active-status:                # 영업 중 상태 코드
        - "1"                       # 정상영업
        - "2"                       # 부분영업
```

## 3. JPA Entity

**목적**: 분석용 노래연습장 테이블과 Java 객체 간 ORM 매핑
**역할**: 데이터베이스 CRUD 작업 및 지오코딩 결과 저장을 위한 엔티티 클래스 정의

```java
package com.WhereHouse.AnalysisData.karaoke.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "ANALYSIS_KARAOKE_ROOMS")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AnalysisKaraokeRooms {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "analysis_karaoke_seq")
    @SequenceGenerator(name = "analysis_karaoke_seq", sequenceName = "SEQ_ANALYSIS_KARAOKE_ROOMS", allocationSize = 1)
    @Column(name = "ID")
    private Long id;

    @Column(name = "DISTRICT_CODE")
    private String districtCode;

    @Column(name = "MANAGEMENT_NUMBER")
    private String managementNumber;

    @Column(name = "BUSINESS_STATUS_NAME")
    private String businessStatusName;

    @Column(name = "PHONE_NUMBER")
    private String phoneNumber;

    @Column(name = "JIBUN_ADDRESS")
    private String jibunAddress;

    @Column(name = "ROAD_ADDRESS")
    private String roadAddress;

    @Column(name = "BUSINESS_NAME")
    private String businessName;

    @Column(name = "COORD_X")
    private Double coordX;  // 경도 (Longitude) - Kakao API로 계산

    @Column(name = "COORD_Y")
    private Double coordY;  // 위도 (Latitude) - Kakao API로 계산

    @Column(name = "DISTRICT_NAME")
    private String districtName;  // 구별 분석을 위한 추가 필드 (주소에서 파싱)

    @Column(name = "GEOCODING_STATUS")
    private String geocodingStatus;  // SUCCESS, FAILED, PENDING

    @Column(name = "GEOCODING_ADDRESS_TYPE")
    private String geocodingAddressType;  // JIBUN, ROAD (사용된 주소 타입)

    @Column(name = "API_RESPONSE_ADDRESS")
    private String apiResponseAddress;  // Kakao API 응답으로 받은 정제된 주소
}
```

## 4. Repository

**목적**: 분석용 노래연습장 데이터에 대한 데이터 접근 계층 구현
**역할**: JPA 기반 CRUD 연산 및 지리적 분석을 위한 맞춤형 쿼리 메서드 제공

```java
package com.WhereHouse.AnalysisData.karaoke.repository;

import com.WhereHouse.AnalysisData.karaoke.entity.AnalysisKaraokeRooms;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface AnalysisKaraokeRepository extends JpaRepository<AnalysisKaraokeRooms, Long> {
    
    // 구별 노래연습장 조회
    List<AnalysisKaraokeRooms> findByDistrictName(String districtName);
    
    // 영업상태별 조회
    List<AnalysisKaraokeRooms> findByBusinessStatusName(String businessStatusName);
    
    // 좌표 유효성 검증 (0, 0 좌표 제외)
    @Query("SELECT k FROM AnalysisKaraokeRooms k WHERE k.coordX != 0 AND k.coordY != 0")
    List<AnalysisKaraokeRooms> findValidCoordinates();
    
    // 지오코딩 실패 데이터 조회
    @Query("SELECT k FROM AnalysisKaraokeRooms k WHERE k.geocodingStatus = 'FAILED' OR k.coordX = 0 OR k.coordY = 0")
    List<AnalysisKaraokeRooms> findFailedGeocodingData();
    
    // 특정 영역 내 노래연습장 조회 (서울시 범위 검증용)
    @Query("SELECT k FROM AnalysisKaraokeRooms k WHERE k.coordY BETWEEN :minLat AND :maxLat AND k.coordX BETWEEN :minLng AND :maxLng")
    List<AnalysisKaraokeRooms> findByLocationBounds(
        @Param("minLat") Double minLat, @Param("maxLat") Double maxLat, 
        @Param("minLng") Double minLng, @Param("maxLng") Double maxLng);
    
    // 구별 노래연습장 밀도 계산용 (업소 수 카운트)
    @Query("SELECT k.districtName, COUNT(k) FROM AnalysisKaraokeRooms k WHERE k.coordX != 0 AND k.coordY != 0 GROUP BY k.districtName ORDER BY COUNT(k) DESC")
    List<Object[]> countKaraokeRoomsByDistrict();
    
    // 영업 중인 노래연습장만 조회
    @Query("SELECT k FROM AnalysisKaraokeRooms k WHERE k.businessStatusName IN ('정상', '영업') AND k.coordX != 0 AND k.coordY != 0")
    List<AnalysisKaraokeRooms> findActiveKaraokeRoomsWithValidCoords();
    
    // 지오코딩 성공률 통계
    @Query("SELECT k.geocodingStatus, COUNT(k) FROM AnalysisKaraokeRooms k GROUP BY k.geocodingStatus")
    List<Object[]> getGeocodingStatistics();
    
    // 주소 타입별 지오코딩 성공률 (지번주소 vs 도로명주소)
    @Query("SELECT k.geocodingAddressType, k.geocodingStatus, COUNT(k) FROM AnalysisKaraokeRooms k GROUP BY k.geocodingAddressType, k.geocodingStatus ORDER BY k.geocodingAddressType")
    List<Object[]> getGeocodingStatisticsByAddressType();
}
```

## 5. Kakao API 연동 Service

**목적**: Kakao 지오코딩 API 호출 및 좌표 변환 서비스
**역할**: 주소 기반 좌표 계산, API 응답 처리, 에러 핸들링

```java
package com.WhereHouse.AnalysisData.karaoke.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.net.URI;
import java.util.Map;
import java.util.List;

/**
 * 노래연습장 전용 Kakao 지오코딩 서비스
 * 
 * 지번주소와 도로명주소 모두 활용한 이중 지오코딩 처리
 * 
 * 주요 기능:
 * - Kakao Local API를 통한 주소 → 좌표 변환
 * - 도로명주소 우선, 실패 시 지번주소로 재시도
 * - 서울시 영역 유효성 검증
 * - 주소 타입별 성공률 추적
 * 
 * @author Safety Analysis System
 * @since 1.0
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class KaraokeGeocodingService {

    private final RestTemplate restTemplate = new RestTemplate();

    @Value("${kakao.api.key}")
    private String kakaoApiKey;

    @Value("${kakao.api.geocoding.url}")
    private String geocodingUrl;

    @Value("${app.analysis.karaoke-rooms.seoul-bounds.min-lat}")
    private Double seoulMinLat;

    @Value("${app.analysis.karaoke-rooms.seoul-bounds.max-lat}")
    private Double seoulMaxLat;

    @Value("${app.analysis.karaoke-rooms.seoul-bounds.min-lng}")
    private Double seoulMinLng;

    @Value("${app.analysis.karaoke-rooms.seoul-bounds.max-lng}")
    private Double seoulMaxLng;

    /**
     * 노래연습장 이중 주소 기반 지오코딩
     * 
     * @param jibunAddress 지번주소
     * @param roadAddress 도로명주소
     * @param businessName 업소명 (로깅용)
     * @return EnhancedGeocodingResult 객체 (위도, 경도, 사용된 주소 타입 포함)
     */
    public EnhancedGeocodingResult getCoordinatesWithDualAddress(
            String jibunAddress, String roadAddress, String businessName) {
        
        // 1차 시도: 도로명주소 우선 (일반적으로 더 정확함)
        if (roadAddress != null && !roadAddress.trim().isEmpty() && !"데이터없음".equals(roadAddress)) {
            log.debug("[{}] 도로명주소 지오코딩 시도: {}", businessName, roadAddress);
            
            GeocodingResult roadResult = getCoordinates(roadAddress);
                
            if (roadResult.isSuccess()) {
                log.debug("[{}] 도로명주소 지오코딩 성공", businessName);
                return EnhancedGeocodingResult.success(
                    roadResult.getLatitude(), roadResult.getLongitude(), 
                    "ROAD", roadResult.getApiResponseAddress(), roadAddress);
            }
        }
        
        // 2차 시도: 지번주소 (도로명주소 실패 시)
        if (jibunAddress != null && !jibunAddress.trim().isEmpty() && !"데이터없음".equals(jibunAddress)) {
            log.debug("[{}] 지번주소 지오코딩 시도: {}", businessName, jibunAddress);
            
            GeocodingResult jibunResult = getCoordinates(jibunAddress);
                
            if (jibunResult.isSuccess()) {
                log.debug("[{}] 지번주소 지오코딩 성공", businessName);
                return EnhancedGeocodingResult.success(
                    jibunResult.getLatitude(), jibunResult.getLongitude(), 
                    "JIBUN", jibunResult.getApiResponseAddress(), jibunAddress);
            }
        }
        
        // 모든 시도 실패
        log.warn("[{}] 모든 주소 지오코딩 실패 - 도로명: {}, 지번: {}", 
            businessName, roadAddress, jibunAddress);
        
        return EnhancedGeocodingResult.failed("모든 주소 지오코딩 실패");
    }

    /**
     * 단일 주소를 기반으로 좌표 정보를 조회
     * 
     * @param address 지오코딩할 주소
     * @return GeocodingResult 객체
     */
    private GeocodingResult getCoordinates(String address) {
        try {
            // 주소 전처리
            String cleanedAddress = preprocessAddress(address);
            log.debug("지오코딩 요청 - 원본: {}, 전처리: {}", address, cleanedAddress);

            // Kakao API 요청 URL 구성
            URI uri = UriComponentsBuilder
                .fromHttpUrl(geocodingUrl)
                .queryParam("query", cleanedAddress)
                .build()
                .encode()
                .toUri();

            // HTTP 헤더 설정
            HttpHeaders headers = new HttpHeaders();
            headers.set("Authorization", "KakaoAK " + kakaoApiKey);
            
            RequestEntity<Void> requestEntity = new RequestEntity<>(headers, HttpMethod.GET, uri);

            // API 호출 및 응답 처리
            ResponseEntity<Map> response = restTemplate.exchange(requestEntity, Map.class);
            
            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                return parseApiResponse(response.getBody(), address);
            } else {
                return GeocodingResult.failed(address, "API 호출 실패");
            }

        } catch (Exception e) {
            log.error("지오코딩 처리 중 예외 발생 - 주소: {}, 오류: {}", address, e.getMessage());
            return GeocodingResult.failed(address, "예외 발생: " + e.getMessage());
        }
    }

    /**
     * 주소 전처리 메서드
     */
    private String preprocessAddress(String address) {
        if (address == null || address.trim().isEmpty()) {
            return "";
        }

        String processed = address.trim()
            .replaceAll("\\s+", " ")
            .replaceAll("[()（）]", "")
            .replaceAll("\\d+층.*$", "")
            .trim();

        if (!processed.startsWith("서울") && !processed.startsWith("Seoul")) {
            processed = "서울특별시 " + processed;
        }

        return processed;
    }

    /**
     * API 응답 파싱 및 좌표 추출
     */
    @SuppressWarnings("unchecked")
    private GeocodingResult parseApiResponse(Map<String, Object> apiResponse, String originalAddress) {
        try {
            List<Map<String, Object>> documents = (List<Map<String, Object>>) apiResponse.get("documents");
            
            if (documents == null || documents.isEmpty()) {
                return GeocodingResult.failed(originalAddress, "좌표 정보 없음");
            }

            Map<String, Object> firstResult = documents.get(0);
            Map<String, Object> addressInfo = null;
            String resultAddress = null;
            
            if (firstResult.containsKey("road_address") && firstResult.get("road_address") != null) {
                addressInfo = (Map<String, Object>) firstResult.get("road_address");
                resultAddress = (String) addressInfo.get("address_name");
            } else if (firstResult.containsKey("address") && firstResult.get("address") != null) {
                addressInfo = (Map<String, Object>) firstResult.get("address");
                resultAddress = (String) addressInfo.get("address_name");
            }

            if (addressInfo == null) {
                return GeocodingResult.failed(originalAddress, "주소 정보 파싱 실패");
            }

            String xCoord = (String) addressInfo.get("x");
            String yCoord = (String) addressInfo.get("y");

            if (xCoord == null || yCoord == null) {
                return GeocodingResult.failed(originalAddress, "좌표 값 없음");
            }

            Double longitude = Double.parseDouble(xCoord);
            Double latitude = Double.parseDouble(yCoord);

            // 서울시 영역 유효성 검증
            if (!isValidSeoulCoordinate(latitude, longitude)) {
                return GeocodingResult.failed(originalAddress, "서울시 영역 외부 좌표");
            }

            return GeocodingResult.success(originalAddress, latitude, longitude, resultAddress);

        } catch (Exception e) {
            return GeocodingResult.failed(originalAddress, "응답 파싱 오류");
        }
    }

    /**
     * 서울시 영역 내 좌표인지 검증
     */
    private boolean isValidSeoulCoordinate(Double latitude, Double longitude) {
        return latitude >= seoulMinLat && latitude <= seoulMaxLat && 
               longitude >= seoulMinLng && longitude <= seoulMaxLng;
    }

    /**
     * 기본 지오코딩 결과 클래스
     */
    @lombok.Data
    @lombok.AllArgsConstructor
    @lombok.NoArgsConstructor
    @lombok.Builder
    public static class GeocodingResult {
        private String originalAddress;
        private Double latitude;
        private Double longitude;
        private String apiResponseAddress;
        private boolean success;
        private String errorMessage;

        public static GeocodingResult success(String originalAddress, Double latitude, Double longitude, String apiResponseAddress) {
            return GeocodingResult.builder()
                .originalAddress(originalAddress)
                .latitude(latitude)
                .longitude(longitude)
                .apiResponseAddress(apiResponseAddress)
                .success(true)
                .build();
        }

        public static GeocodingResult failed(String originalAddress, String errorMessage) {
            return GeocodingResult.builder()
                .originalAddress(originalAddress)
                .success(false)
                .errorMessage(errorMessage)
                .build();
        }
    }

    /**
     * 확장된 지오코딩 결과 클래스 (주소 타입 포함)
     */
    @lombok.Data
    @lombok.AllArgsConstructor
    @lombok.NoArgsConstructor
    @lombok.Builder
    public static class EnhancedGeocodingResult {
        private Double latitude;
        private Double longitude;
        private String addressType;           // JIBUN, ROAD
        private String apiResponseAddress;
        private String originalAddress;
        private boolean success;
        private String errorMessage;

        public static EnhancedGeocodingResult success(
                Double latitude, Double longitude, String addressType, 
                String apiResponseAddress, String originalAddress) {
            return EnhancedGeocodingResult.builder()
                .latitude(latitude)
                .longitude(longitude)
                .addressType(addressType)
                .apiResponseAddress(apiResponseAddress)
                .originalAddress(originalAddress)
                .success(true)
                .build();
        }

        public static EnhancedGeocodingResult failed(String errorMessage) {
            return EnhancedGeocodingResult.builder()
                .success(false)
                .errorMessage(errorMessage)
                .build();
        }
    }
}
```

## 6. 노래연습장 데이터 분석용 처리 Component

**목적**: 원본 노래연습장 데이터를 분석용 테이블로 변환하고 Kakao API를 통해 정확한 좌표 계산
**역할**: 
- 기존 `KARAOKE_ROOMS` 테이블에서 영업 중인 업소만 선별 조회
- 이중 주소 기반 지오코딩으로 정확한 위도/경도 계산
- 구별 정보 파싱 및 데이터 품질 검증

```java
package com.WhereHouse.AnalysisData.karaoke.processor;

import com.WhereHouse.AnalysisData.karaoke.entity.AnalysisKaraokeRooms;
import com.WhereHouse.AnalysisData.karaoke.repository.AnalysisKaraokeRepository;
import com.WhereHouse.AnalysisData.karaoke.service.KaraokeGeocodingService;
// 원본 데이터 접근을 위한 기존 패키지 import
import com.WhereHouse.AnalysisStaticData.KaraokeRoomsSave.entity.KaraokeRooms;
import com.WhereHouse.AnalysisStaticData.KaraokeRoomsSave.repository.KaraokeRoomsRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * 노래연습장 데이터 분석용 테이블 생성 및 지오코딩 처리 컴포넌트
 * 
 * @author Safety Analysis System
 * @since 1.0
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class KaraokeDataProcessor {

    private final KaraokeRoomsRepository originalKaraokeRepository;
    private final AnalysisKaraokeRepository analysisKaraokeRepository;
    private final KaraokeGeocodingService karaokeGeocodingService;

    @Value("${app.analysis.karaoke-rooms.batch-size}")
    private Integer batchSize;

    @Value("${app.analysis.karaoke-rooms.geocoding-delay}")
    private Integer geocodingDelay;

    private static final Pattern DISTRICT_PATTERN = Pattern.compile("서울특별시\\s+([가-힣]+구)");

    /**
     * 노래연습장 데이터 분석용 테이블 생성 메인 프로세스
     */
    @Transactional
    public void processAnalysisKaraokeData() {
        log.info("=== 노래연습장 데이터 분석용 테이블 생성 및 지오코딩 작업 시작 ===");
        
        // Step 1: 기존 분석용 데이터 존재 여부 확인
        long existingAnalysisDataCount = analysisKaraokeRepository.count();
        if (existingAnalysisDataCount > 0) {
            log.info("분석용 노래연습장 데이터가 이미 존재합니다 (총 {} 개). 작업을 스킵합니다.", existingAnalysisDataCount);
            return;
        }

        // Step 2: 원본 노래연습장 데이터 조회 및 영업상태 필터링
        List<KaraokeRooms> allKaraokeDataList = originalKaraokeRepository.findAll();
        if (allKaraokeDataList.isEmpty()) {
            log.warn("원본 노래연습장 데이터가 존재하지 않습니다.");
            return;
        }
        
        // 영업 중인 업소만 필터링
        List<KaraokeRooms> activeKaraokeDataList = allKaraokeDataList.stream()
            .filter(this::isActiveKaraoke)
            .collect(Collectors.toList());
        
        log.info("전체 노래연습장 데이터: {} 개, 영업 중인 업소: {} 개", 
            allKaraokeDataList.size(), activeKaraokeDataList.size());

        // Step 3: 배치 단위 지오코딩 처리
        int totalDataCount = activeKaraokeDataList.size();
        int processedCount = 0;
        int successfulGeocodingCount = 0;
        int failedGeocodingCount = 0;
        int roadAddressSuccessCount = 0;  // 도로명주소 성공 카운트
        int jibunAddressSuccessCount = 0; // 지번주소 성공 카운트

        log.info("배치 크기 {} 단위로 총 {} 개 노래연습장 지오코딩 처리 시작", batchSize, totalDataCount);

        for (int batchStart = 0; batchStart < totalDataCount; batchStart += batchSize) {
            int batchEnd = Math.min(batchStart + batchSize, totalDataCount);
            List<KaraokeRooms> currentBatch = activeKaraokeDataList.subList(batchStart, batchEnd);
            
            log.info("배치 처리 중: {}/{} ({}-{} 범위)", 
                batchStart / batchSize + 1, (totalDataCount + batchSize - 1) / batchSize, 
                batchStart + 1, batchEnd);

            for (KaraokeRooms originalKaraokeData : currentBatch) {
                try {
                    // 원본 데이터를 분석용 엔티티로 변환
                    AnalysisKaraokeRooms analysisTargetKaraokeData = convertToAnalysisEntity(originalKaraokeData);
                    
                    // 이중 주소 기반 Kakao API 지오코딩 처리
                    KaraokeGeocodingService.EnhancedGeocodingResult geocodingResult = 
                        karaokeGeocodingService.getCoordinatesWithDualAddress(
                            originalKaraokeData.getJibunAddress(),
                            originalKaraokeData.getRoadAddress(),
                            originalKaraokeData.getBusinessName()
                        );
                    
                    if (geocodingResult.isSuccess()) {
                        // 지오코딩 성공 시 좌표 정보 설정
                        analysisTargetKaraokeData.setCoordX(geocodingResult.getLongitude());
                        analysisTargetKaraokeData.setCoordY(geocodingResult.getLatitude());
                        analysisTargetKaraokeData.setGeocodingStatus("SUCCESS");
                        analysisTargetKaraokeData.setGeocodingAddressType(geocodingResult.getAddressType());
                        analysisTargetKaraokeData.setApiResponseAddress(geocodingResult.getApiResponseAddress());
                        successfulGeocodingCount++;
                        
                        // 주소 타입별 성공 카운트
                        if ("ROAD".equals(geocodingResult.getAddressType())) {
                            roadAddressSuccessCount++;
                        } else if ("JIBUN".equals(geocodingResult.getAddressType())) {
                            jibunAddressSuccessCount++;
                        }
                        
                        log.debug("지오코딩 성공: {} [{}] - 위도: {}, 경도: {}", 
                            originalKaraokeData.getBusinessName(), geocodingResult.getAddressType(),
                            geocodingResult.getLatitude(), geocodingResult.getLongitude());
                    } else {
                        // 지오코딩 실패 시 기본값 설정
                        analysisTargetKaraokeData.setCoordX(0.0);
                        analysisTargetKaraokeData.setCoordY(0.0);
                        analysisTargetKaraokeData.setGeocodingStatus("FAILED");
                        analysisTargetKaraokeData.setGeocodingAddressType("NONE");
                        analysisTargetKaraokeData.setApiResponseAddress(geocodingResult.getErrorMessage());
                        failedGeocodingCount++;
                        
                        log.warn("지오코딩 실패: {} - 도로명: {}, 지번: {}, 사유: {}", 
                            originalKaraokeData.getBusinessName(),
                            originalKaraokeData.getRoadAddress(),
                            originalKaraokeData.getJibunAddress(),
                            geocodingResult.getErrorMessage());
                    }
                    
                    // 분석용 테이블에 데이터 저장
                    analysisKaraokeRepository.save(analysisTargetKaraokeData);
                    processedCount++;
                    
                    // API Rate Limit 준수를 위한 지연 처리
                    if (geocodingDelay > 0) {
                        Thread.sleep(geocodingDelay);
                    }

                } catch (Exception dataConversionException) {
                    log.error("분석용 데이터 생성 실패 - 업소명: {}, 오류: {}", 
                        originalKaraokeData.getBusinessName(), dataConversionException.getMessage());
                    failedGeocodingCount++;
                }
            }
            
            // 배치별 진행 상황 로깅
            log.info("배치 처리 완료: {} / {} (성공: {}, 실패: {})", 
                processedCount, totalDataCount, successfulGeocodingCount, failedGeocodingCount);
        }

        // Step 4: 지오코딩 처리 결과 로깅
        log.info("노래연습장 데이터 분석용 테이블 생성 및 지오코딩 작업 완료");
        log.info("총 처리: {} 개, 지오코딩 성공: {} 개, 실패: {} 개", 
            processedCount, successfulGeocodingCount, failedGeocodingCount);
        log.info("지오코딩 성공률: {:.2f}%", 
            totalDataCount > 0 ? (double) successfulGeocodingCount / totalDataCount * 100 : 0);
        log.info("주소 타입별 성공률 - 도로명주소: {} 개, 지번주소: {} 개", 
            roadAddressSuccessCount, jibunAddressSuccessCount);
        
        // Step 5: 최종 데이터 검증 및 품질 확인
        performFinalDataValidation();
        
        log.info("=== 노래연습장 데이터 분석용 테이블 생성 작업 종료 ===");
    }
    
    /**
     * 영업 중인 노래연습장인지 확인
     */
    private boolean isActiveKaraoke(KaraokeRooms karaokeRoom) {
        String statusName = karaokeRoom.getBusinessStatusName();
        if (statusName == null) return false;
        
        // 영업 중인 상태로 판단되는 키워드들
        return statusName.contains("정상") || 
               statusName.contains("영업") || 
               statusName.contains("운영") ||
               "1".equals(karaokeRoom.getBusinessStatusCode());
    }
    
    /**
     * 원본 노래연습장 엔티티를 분석용 엔티티로 변환
     */
    private AnalysisKaraokeRooms convertToAnalysisEntity(KaraokeRooms originalKaraokeData) {
        // 주소에서 구별 정보 추출 (도로명주소 우선, 없으면 지번주소 사용)
        String addressForParsing = originalKaraokeData.getRoadAddress();
        if (addressForParsing == null || "데이터없음".equals(addressForParsing)) {
            addressForParsing = originalKaraokeData.getJibunAddress();
        }
        String districtName = extractDistrictFromAddress(addressForParsing);
        
        return AnalysisKaraokeRooms.builder()
            // 필수 정보만 선별 복사
            .districtCode(originalKaraokeData.getDistrictCode())
            .managementNumber(originalKaraokeData.getManagementNumber())
            .businessStatusName(originalKaraokeData.getBusinessStatusName())
            .phoneNumber(originalKaraokeData.getPhoneNumber())
            .jibunAddress(originalKaraokeData.getJibunAddress())
            .roadAddress(originalKaraokeData.getRoadAddress())
            .businessName(originalKaraokeData.getBusinessName())
            
            // 분석용 추가 정보
            .districtName(districtName)
            .geocodingStatus("PENDING")
            
            // 좌표 정보는 지오코딩 처리 후 별도 설정
            .coordX(0.0)
            .coordY(0.0)
            .build();
    }
    
    /**
     * 주소에서 서울시 구별 정보 추출
     */
    private String extractDistrictFromAddress(String address) {
        if (address == null || address.trim().isEmpty() || "데이터없음".equals(address)) {
            return "구정보없음";
        }

        // 1차: 정규식을 통한 정확한 패턴 매칭
        Matcher matcher = DISTRICT_PATTERN.matcher(address);
        if (matcher.find()) {
            String districtName = matcher.group(1);
            log.debug("구별 정보 추출 성공: {} -> {}", address, districtName);
            return districtName;
        }

        // 2차: "구" 단위 정보 직접 검색
        String[] addressParts = address.split("\\s+");
        for (String part : addressParts) {
            if (part.endsWith("구") && part.length() >= 2) {
                log.debug("구별 정보 백업 추출: {} -> {}", address, part);
                return part;
            }
        }

        log.warn("구별 정보 추출 실패: {}", address);
        return "구정보없음";
    }
    
    /**
     * 분석용 데이터의 최종 검증 및 품질 확인
     */
    private void performFinalDataValidation() {
        try {
            // 최종 저장된 분석용 데이터 개수 확인
            long finalAnalysisDataCount = analysisKaraokeRepository.count();
            log.info("최종 분석용 노래연습장 데이터 저장 완료: {} 개", finalAnalysisDataCount);
            
            // 지오코딩 성공률 통계 출력
            List<Object[]> geocodingStatsList = analysisKaraokeRepository.getGeocodingStatistics();
            log.info("지오코딩 처리 결과 통계:");
            geocodingStatsList.forEach(statRow -> {
                String status = (String) statRow[0];
                Long count = (Long) statRow[1];
                double percentage = finalAnalysisDataCount > 0 ? (double) count / finalAnalysisDataCount * 100 : 0;
                log.info("  {} : {} 개 ({:.1f}%)", status, count, percentage);
            });
            
            // 주소 타입별 지오코딩 성공률 통계
            List<Object[]> addressTypeStatsList = analysisKaraokeRepository.getGeocodingStatisticsByAddressType();
            log.info("주소 타입별 지오코딩 성공률:");
            addressTypeStatsList.forEach(statRow -> {
                String addressType = (String) statRow[0];
                String status = (String) statRow[1];
                Long count = (Long) statRow[2];
                log.info("  {} - {} : {} 개", addressType, status, count);
            });
            
            // 구별 노래연습장 밀도 순위 조회 및 로깅
            List<Object[]> districtKaraokeRankingList = analysisKaraokeRepository.countKaraokeRoomsByDistrict();
            log.info("서울시 구별 노래연습장 밀도 순위 (상위 10개구):");
            
            districtKaraokeRankingList.stream()
                .limit(10)
                .forEach(rankingRow -> {
                    String districtName = (String) rankingRow[0];
                    Long karaokeCount = (Long) rankingRow[1];
                    log.info("  {} : {} 개소", districtName, karaokeCount);
                });
            
            // 좌표 유효성 검증
            List<AnalysisKaraokeRooms> validCoordsList = analysisKaraokeRepository.findValidCoordinates();
            log.info("유효한 좌표를 가진 노래연습장: {} 개", validCoordsList.size());
            
            // 지오코딩 실패 데이터 분석
            List<AnalysisKaraokeRooms> failedGeocodingList = analysisKaraokeRepository.findFailedGeocodingData();
            if (!failedGeocodingList.isEmpty()) {
                log.warn("지오코딩 실패 데이터 {} 개 발견:", failedGeocodingList.size());
                failedGeocodingList.stream()
                    .limit(5)
                    .forEach(failedData -> {
                        log.warn("  실패 업소: {} (도로명: {}, 지번: {}, 사유: {})", 
                            failedData.getBusinessName(), 
                            failedData.getRoadAddress(),
                            failedData.getJibunAddress(),
                            failedData.getApiResponseAddress());
                    });
            }
                
        } catch (Exception dataValidationException) {
            log.error("분석용 데이터 검증 과정에서 오류가 발생했습니다: {}", 
                dataValidationException.getMessage(), dataValidationException);
        }
    }
}
```

## 7. Main 처리 클래스

**목적**: 전체 분석용 데이터 처리 작업의 통합 관리 및 실행
**역할**: 애플리케이션 시작 시 자동 실행되는 메인 진입점

```java
package com.WhereHouse.AnalysisData.main;

import com.WhereHouse.AnalysisData.karaoke.processor.KaraokeDataProcessor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class AnalysisDataProcessor implements CommandLineRunner {

    private final KaraokeDataProcessor karaokeDataProcessor;

    @Override
    public void run(String... args) throws Exception {
        log.info("=== 안전성 분석용 데이터 처리 시작 ===");
        
        try {
            // 1. 노래연습장 데이터 처리 (이중 주소 지오코딩 포함)
            log.info("1. 노래연습장 데이터 분석용 테이블 생성 및 지오코딩 시작");
            karaokeDataProcessor.processAnalysisKaraokeData();
            
        } catch (Exception e) {
            log.error("안전성 분석용 데이터 처리 중 오류 발생", e);
            throw e;
        }
        
        log.info("=== 안전성 분석용 데이터 처리 완료 ===");
    }
}
```

## 실행 방법 및 검증

### 1. Kakao API 설정
1. [Kakao Developers](https://developers.kakao.com/) 가입 및 앱 생성
2. REST API 키 발급 받기
3. `application.yml`에 API 키 설정

### 2. 데이터베이스 설정
```sql
-- DDL 스크립트 실행
-- 테이블 생성 및 시퀀스 확인
```

### 3. 애플리케이션 실행
```bash
./gradlew bootRun
```

### 4. 실행 결과 검증
```sql
-- 전체 데이터 개수 확인
SELECT COUNT(*) FROM ANALYSIS_KARAOKE_ROOMS;

-- 지오코딩 성공률 확인
SELECT GEOCODING_STATUS, COUNT(*) 
FROM ANALYSIS_KARAOKE_ROOMS 
GROUP BY GEOCODING_STATUS;

-- 주소 타입별 지오코딩 성공률 확인
SELECT GEOCODING_ADDRESS_TYPE, GEOCODING_STATUS, COUNT(*)
FROM ANALYSIS_KARAOKE_ROOMS 
GROUP BY GEOCODING_ADDRESS_TYPE, GEOCODING_STATUS;

-- 구별 노래연습장 밀도 확인
SELECT DISTRICT_NAME, COUNT(*) as KARAOKE_COUNT
FROM ANALYSIS_KARAOKE_ROOMS 
WHERE COORD_X != 0 AND COORD_Y != 0
GROUP BY DISTRICT_NAME 
ORDER BY KARAOKE_COUNT DESC;
```

## 예상 처리 결과

### 로그 출력 예시
```
=== 안전성 분석용 데이터 처리 시작 ===
1. 노래연습장 데이터 분석용 테이블 생성 및 지오코딩 시작
전체 노래연습장 데이터: 1,520 개, 영업 중인 업소: 1,240 개
배치 크기 50 단위로 총 1,240 개 노래연습장 지오코딩 처리 시작
지오코딩 성공률: 93.23%
주소 타입별 성공률 - 도로명주소: 892 개, 지번주소: 264 개

서울시 구별 노래연습장 밀도 순위 (상위 10개구):
  강남구 : 142 개소
  송파구 : 118 개소
  영등포구 : 105 개소
  ...
=== 안전성 분석용 데이터 처리 완료 ===
```

이 시스템은 향후 피어슨 상관분석에서 독립변수로 활용될 구별 노래연습장 밀도 계산의 기초 데이터를 제공합니다.