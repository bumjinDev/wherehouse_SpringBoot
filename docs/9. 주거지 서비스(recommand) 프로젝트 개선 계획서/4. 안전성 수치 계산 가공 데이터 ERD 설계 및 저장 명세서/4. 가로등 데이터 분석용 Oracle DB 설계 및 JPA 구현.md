# 가로등 데이터 분석용 Oracle DB 설계 및 JPA 구현

**프로젝트명:** 안전성 점수 계산 시스템 - 가로등 시설 분석 데이터 처리  
**버전:** 1.0  
**작성일:** 2025.09.08  
**목적:** 서울시 가로등 시설 데이터를 KakaoMap API 역지오코딩으로 주소 정보를 보강하여 피어슨 상관분석 계산에 활용하기 위한 분석용 테이블 구축

---

## 프로젝트 개요

### 데이터 처리 목표
기존 가로등 원본 테이블에서 좌표 데이터를 조회하여 KakaoMap API 역지오코딩을 통해 주소 정보를 보강한 후, 분석 전용 테이블 `ANALYSIS_STREETLIGHT_STATISTICS`로 저장하여 안전성 점수 계산 시스템에서 활용할 수 있도록 데이터 구조를 최적화한다.

### 핵심 특징
- **좌표 기반 주소 변환**: 위도/경도 좌표를 KakaoMap API로 구/동 주소 정보 획득
- **실시간 API 연동**: 역지오코딩을 통한 정확한 행정구역 정보 매핑
- **분석 전용 설계**: 제약조건 없이 순수 분석 목적의 테이블 구조
- **기존 인터페이스 재사용**: 원천 데이터 접근에 필요한 JPA Entity와 Repository는 기존 `AnalysisStaticData` 패키지에서 직접 import하여 사용

---

## 1. Oracle 테이블 DDL

**목적**: 분석 전용 가로등 시설 테이블 생성 및 시퀀스 설정
**역할**: 피어슨 상관분석에 사용될 독립변수(구별 가로등 개수) 데이터 저장소 구축

```sql
-- 기존 테이블과 데이터를 완전히 삭제
DROP TABLE ANALYSIS_STREETLIGHT_STATISTICS CASCADE CONSTRAINTS PURGE;
DROP SEQUENCE SEQ_ANALYSIS_STREETLIGHT_STATISTICS;

-- 분석용 가로등 시설 테이블 생성
CREATE TABLE ANALYSIS_STREETLIGHT_STATISTICS (
    ID                      NUMBER,                     -- 제한 없음
    MANAGEMENT_NUMBER       VARCHAR2(4000),             -- 관리번호
    DISTRICT_NAME           VARCHAR2(4000),             -- 구명 (최대 크기)
    DONG_NAME               VARCHAR2(4000),             -- 동명 (최대 크기)
    ROAD_ADDRESS            VARCHAR2(4000),             -- 도로명주소 (최대 크기)
    JIBUN_ADDRESS           VARCHAR2(4000),             -- 지번주소 (최대 크기)
    LATITUDE                NUMBER,                     -- 위도 (제한 없음)
    LONGITUDE               NUMBER                      -- 경도 (제한 없음)
);

-- 시퀀스 생성
CREATE SEQUENCE SEQ_ANALYSIS_STREETLIGHT_STATISTICS 
    START WITH 1 
    INCREMENT BY 1 
    NOCACHE
    NOCYCLE;

-- 확인
DESC ANALYSIS_STREETLIGHT_STATISTICS;
SELECT COUNT(*) FROM ANALYSIS_STREETLIGHT_STATISTICS;

```

## 2. JPA Entity

**목적**: 분석용 가로등 시설 테이블과 Java 객체 간 ORM 매핑
**역할**: 데이터베이스 CRUD 작업을 위한 엔티티 클래스 정의

```java
package com.WhereHouse.AnalysisData.streetlight.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;

@Entity
@Table(name = "ANALYSIS_STREETLIGHT_STATISTICS")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AnalysisStreetlightStatistics {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "analysis_streetlight_seq")
    @SequenceGenerator(name = "analysis_streetlight_seq", sequenceName = "SEQ_ANALYSIS_STREETLIGHT_STATISTICS", allocationSize = 1)
    @Column(name = "ID")
    private Long id;

    @Column(name = "MANAGEMENT_NUMBER")
    private String managementNumber;

    @Column(name = "DISTRICT_NAME")
    private String districtName;

    @Column(name = "DONG_NAME")
    private String dongName;

    @Column(name = "ROAD_ADDRESS")
    private String roadAddress;

    @Column(name = "JIBUN_ADDRESS")
    private String jibunAddress;

    @Column(name = "LATITUDE")
    private Double latitude;

    @Column(name = "LONGITUDE")
    private Double longitude;
}
```

## 3. Repository

**목적**: 분석용 가로등 시설 데이터에 대한 데이터 접근 계층 구현
**역할**: JPA 기반 CRUD 연산 및 맞춤형 쿼리 메서드 제공 (구별 순위 조회, 데이터 검증용)

```java
package com.WhereHouse.AnalysisData.streetlight.repository;

import com.WhereHouse.AnalysisData.streetlight.entity.AnalysisStreetlightStatistics;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface AnalysisStreetlightRepository extends JpaRepository<AnalysisStreetlightStatistics, Long> {

    // 기본 CRUD는 JpaRepository가 제공

    // 데이터 검증용 커스텀 쿼리
    @Query("SELECT COUNT(a) FROM AnalysisStreetlightStatistics a")
    long countAnalysisData();

    // 구별 가로등 개수 조회 (피어슨 상관분석용)
    @Query("SELECT a.districtName, COUNT(a) FROM AnalysisStreetlightStatistics a GROUP BY a.districtName ORDER BY COUNT(a) DESC")
    List<Object[]> findStreetlightCountByDistrict();

    // 특정 구의 가로등 목록 조회
    List<AnalysisStreetlightStatistics> findByDistrictName(String districtName);

    // 관리번호로 중복 확인
    boolean existsByManagementNumber(String managementNumber);
}
```

## 4. KakaoMap API 클라이언트

**목적**: 좌표 기반 역지오코딩을 통한 주소 정보 획득
**역할**: 
- 위도/경도 좌표를 도로명주소 및 지번주소로 변환
- 행정구역 정보(구, 동) 추출
- API 호출 제한 및 예외 처리

```java
package com.WhereHouse.AnalysisData.streetlight.client;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.util.List;

/**
 * Kakao Map API 역지오코딩 클라이언트
 *
 * 좌표(위도, 경도)를 입력받아 주소 정보를 반환하는 Kakao Map API 호출 클라이언트
 *
 * 주요 기능:
 * - 좌표 → 주소 변환 (역지오코딩)
 * - 도로명 주소 및 지번 주소 반환
 * - 행정구역 정보 (구, 동) 반환
 *
 * API 제한사항:
 * - 무료 플랜: 300,000회/일
 * - 호출 간격 제한: 없음 (하지만 100ms 대기 권장)
 *
 * @author Safety Analysis System
 * @since 1.0
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class StreetLightKakaoAddressApiClient {

    @Value("${kakao.rest-api-key}")
    private String kakaoApiKey;

    private final RestTemplate restTemplate;

    // Kakao Map API 역지오코딩 엔드포인트
    private static final String KAKAO_COORD2ADDRESS_URL = "https://dapi.kakao.com/v2/local/geo/coord2address.json";

    /**
     * 좌표를 주소로 변환하는 역지오코딩 API 호출
     *
     * @param longitude 경도 (x 좌표)
     * @param latitude 위도 (y 좌표)
     * @return 주소 정보가 포함된 응답 객체
     * @throws Exception API 호출 실패 시
     */
    public CoordinateToAddressResponse coordinateToAddress(String longitude, String latitude) throws Exception {

        // API 요청 URL 생성
        String requestUrl = UriComponentsBuilder.fromHttpUrl(KAKAO_COORD2ADDRESS_URL)
                .queryParam("x", longitude)  // 경도
                .queryParam("y", latitude)   // 위도
                .queryParam("input_coord", "WGS84")  // 입력 좌표계 (GPS 좌표계)
                .build()
                .toUriString();

        // HTTP 헤더 설정 (인증키 포함)
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "KakaoAK " + kakaoApiKey);
        headers.set("Content-Type", "application/json");

        HttpEntity<String> entity = new HttpEntity<>(headers);

        try {
            log.debug("Kakao API 호출: {}", requestUrl);

            // API 호출
            ResponseEntity<CoordinateToAddressResponse> response = restTemplate.exchange(
                    requestUrl,
                    HttpMethod.GET,
                    entity,
                    CoordinateToAddressResponse.class
            );

            CoordinateToAddressResponse responseBody = response.getBody();

            if (responseBody != null && responseBody.getDocuments() != null && !responseBody.getDocuments().isEmpty()) {
                log.debug("Kakao API 응답 성공: 좌표({}, {}) → 주소 {} 개 반환",
                        longitude, latitude, responseBody.getDocuments().size());
                return responseBody;
            } else {
                log.warn("Kakao API 응답에 주소 정보가 없습니다: 좌표({}, {})", longitude, latitude);
                return new CoordinateToAddressResponse(); // 빈 응답 반환
            }

        } catch (Exception e) {
            log.error("Kakao API 호출 실패: 좌표({}, {}), 오류: {}", longitude, latitude, e.getMessage());
            throw new Exception("Kakao Map API 호출 실패: " + e.getMessage(), e);
        }
    }

    /**
     * Kakao Map API 좌표→주소 변환 응답 DTO
     */
    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class CoordinateToAddressResponse {

        @JsonProperty("documents")
        private List<Document> documents;

        @JsonProperty("meta")
        private Meta meta;

        /**
         * 주소 문서 정보
         */
        @Data
        @JsonIgnoreProperties(ignoreUnknown = true)
        public static class Document {

            @JsonProperty("road_address")
            private RoadAddress roadAddress;

            @JsonProperty("address")
            private Address address;
        }

        /**
         * 도로명 주소 정보
         */
        @Data
        @JsonIgnoreProperties(ignoreUnknown = true)
        public static class RoadAddress {

            @JsonProperty("address_name")
            private String addressName;

            @JsonProperty("region_1depth_name")
            private String region1DepthName;

            @JsonProperty("region_2depth_name")
            private String region2DepthName;

            @JsonProperty("region_3depth_name")
            private String region3DepthName;

            @JsonProperty("road_name")
            private String roadName;

            @JsonProperty("underground_yn")
            private String undergroundYn;

            @JsonProperty("main_building_no")
            private String mainBuildingNo;

            @JsonProperty("sub_building_no")
            private String subBuildingNo;

            @JsonProperty("building_name")
            private String buildingName;

            @JsonProperty("zone_no")
            private String zoneNo;
        }

        /**
         * 지번 주소 정보
         */
        @Data
        @JsonIgnoreProperties(ignoreUnknown = true)
        public static class Address {

            @JsonProperty("address_name")
            private String addressName;

            @JsonProperty("region_1depth_name")
            private String region1DepthName;

            @JsonProperty("region_2depth_name")
            private String region2DepthName;

            @JsonProperty("region_3depth_name")
            private String region3DepthName;

            @JsonProperty("mountain_yn")
            private String mountainYn;

            @JsonProperty("main_address_no")
            private String mainAddressNo;

            @JsonProperty("sub_address_no")
            private String subAddressNo;

            @JsonProperty("zip_code")
            private String zipCode;
        }

        /**
         * 메타 정보
         */
        @Data
        @JsonIgnoreProperties(ignoreUnknown = true)
        public static class Meta {

            @JsonProperty("total_count")
            private Integer totalCount;
        }
    }
}
```

## 5. 가로등 데이터 분석용 처리 Component

**목적**: 원본 가로등 데이터를 KakaoMap API로 주소 정보를 보강하여 분석용 테이블로 변환하는 비즈니스 로직 처리
**역할**: 
- 기존 가로등 원본 테이블에서 좌표 데이터 조회
- KakaoMap API 역지오코딩을 통한 주소 정보 획득
- 데이터 품질 검증 및 구별 가로등 개수 순위 로깅

```java
package com.WhereHouse.AnalysisData.streetlight.processor;

import com.WhereHouse.AnalysisData.streetlight.entity.AnalysisStreetlightStatistics;
import com.WhereHouse.AnalysisData.streetlight.repository.AnalysisStreetlightRepository;
// 원본 데이터 접근을 위한 기존 패키지 import
import com.WhereHouse.AnalysisStaticData.StreetLightRaw.Entity.StreetlightRawData;
import com.WhereHouse.AnalysisStaticData.StreetLightRaw.Repository.StreetlightRawDataRepository;
// KakaoMap API 클라이언트 import
import com.WhereHouse.AnalysisData.streetlight.client.StreetLightKakaoAddressApiClient;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * 가로등 데이터 분석용 테이블 생성 처리 컴포넌트
 *
 * 기존 가로등 원본 테이블에서 데이터를 조회하여
 * KakaoMap API로 주소 정보를 보강한 후
 * 분석 전용 ANALYSIS_STREETLIGHT_STATISTICS 테이블로 저장하는 작업을 수행한다.
 *
 * 주요 기능:
 * - 원본 가로등 데이터 조회 및 검증
 * - KakaoMap API 역지오코딩을 통한 주소 정보 획득
 * - 분석용 테이블 데이터 품질 검증
 * - 구별 가로등 개수 통계 로깅
 *
 * @author Safety Analysis System
 * @since 1.0
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class StreetlightDataProcessor {

    // 원본 가로등 테이블 접근을 위한 Repository
    private final StreetlightRawDataRepository originalStreetlightRepository;

    // 분석용 가로등 테이블 접근을 위한 Repository
    private final AnalysisStreetlightRepository analysisStreetlightRepository;

    // KakaoMap API 클라이언트
    private final StreetLightKakaoAddressApiClient kakaoAddressApiClient;

    /**
     * 가로등 데이터 분석용 테이블 생성 메인 프로세스
     *
     * 작업 순서:
     * 1. 기존 분석용 데이터 존재 여부 확인
     * 2. 원본 가로등 데이터 조회 및 검증
     * 3. KakaoMap API 역지오코딩으로 주소 정보 획득
     * 4. 데이터 변환 및 분석용 테이블 저장
     * 5. 데이터 품질 검증 및 결과 로깅
     */
    @Transactional
    public void processAnalysisStreetlightData() {
        log.info("=== 가로등 데이터 분석용 테이블 생성 작업 시작 ===");

        // Step 1: 기존 분석용 데이터 중복 처리 방지를 위한 존재 여부 확인
        long existingAnalysisDataCount = analysisStreetlightRepository.count();
        if (existingAnalysisDataCount > 0) {
            log.info("분석용 가로등 데이터가 이미 존재합니다 (총 {} 개). 작업을 스킵합니다.", existingAnalysisDataCount);
            return;
        }

        // Step 2: 원본 가로등 데이터 조회 및 검증
        List<StreetlightRawData> originalStreetlightDataList = originalStreetlightRepository.findAll();
        if (originalStreetlightDataList.isEmpty()) {
            log.warn("원본 가로등 데이터가 존재하지 않습니다. 먼저 StreetlightRawDataLoader를 통해 CSV 데이터를 로드해주세요.");
            return;
        }

        log.info("원본 가로등 데이터 {} 개 발견", originalStreetlightDataList.size());

        // Step 3: 데이터 변환 및 저장 작업 수행
        int successfulConversionCount = 0;  // 성공적으로 변환된 데이터 개수
        int failedConversionCount = 0;      // 변환 실패한 데이터 개수
        int apiCallCount = 0;               // API 호출 횟수

        for (StreetlightRawData originalStreetlightData : originalStreetlightDataList) {
            try {
                // 진행률 출력 (100개마다)
                if ((successfulConversionCount + failedConversionCount) % 100 == 0) {
                    double progress = ((double)(successfulConversionCount + failedConversionCount) / originalStreetlightDataList.size()) * 100;
                    log.info("진행률: {:.1f}% ({}/{})", progress,
                            successfulConversionCount + failedConversionCount, originalStreetlightDataList.size());
                }

                // 원본 데이터를 분석용 엔티티로 변환 (KakaoMap API 호출 포함)
                AnalysisStreetlightStatistics analysisTargetStreetlightData = convertToAnalysisEntity(originalStreetlightData);
                apiCallCount++;

                // 분석용 테이블에 데이터 저장
                analysisStreetlightRepository.save(analysisTargetStreetlightData);
                successfulConversionCount++;

                log.debug("분석용 데이터 생성 완료: {} (구: {}, 동: {})",
                        originalStreetlightData.getManagementNumber(),
                        analysisTargetStreetlightData.getDistrictName(),
                        analysisTargetStreetlightData.getDongName());

                // API 호출 제한 대응 (100ms 대기)
                Thread.sleep(100);

            } catch (Exception dataConversionException) {
                log.error("분석용 데이터 생성 실패 - 관리번호: {}, 오류: {}",
                        originalStreetlightData.getManagementNumber(), dataConversionException.getMessage());
                failedConversionCount++;
            }
        }

        // Step 4: 변환 작업 결과 로깅
        log.info("가로등 데이터 분석용 테이블 생성 작업 완료 - 성공: {} 개, 실패: {} 개, API 호출: {} 회",
                successfulConversionCount, failedConversionCount, apiCallCount);

        // Step 5: 최종 데이터 검증 및 품질 확인
        performFinalDataValidation();

        log.info("=== 가로등 데이터 분석용 테이블 생성 작업 종료 ===");
    }

    /**
     * 원본 가로등 데이터를 KakaoMap API로 주소 정보를 보강하여 분석용 엔티티로 변환
     *
     * @param originalStreetlightData 원본 가로등 데이터 엔티티
     * @return 주소 정보가 보강된 분석용 가로등 엔티티
     * @throws Exception KakaoMap API 호출 실패 시
     */
    private AnalysisStreetlightStatistics convertToAnalysisEntity(StreetlightRawData originalStreetlightData) throws Exception {

        // 기본 정보 설정
        String managementNumber = originalStreetlightData.getManagementNumber();
        Double latitude = originalStreetlightData.getLatitude();
        Double longitude = originalStreetlightData.getLongitude();

        // 주소 정보 초기화
        String districtName = "주소정보없음";
        String dongName = "주소정보없음";
        String roadAddress = "주소정보없음";
        String jibunAddress = "주소정보없음";

        // KakaoMap API 역지오코딩 호출하여 주소 정보 획득
        try {
            if (latitude != null && longitude != null &&
                    latitude != 0 && longitude != 0) {

                // 좌표를 문자열로 변환
                String latitudeStr = latitude.toString();
                String longitudeStr = longitude.toString();

                // KakaoMap API 호출
                StreetLightKakaoAddressApiClient.CoordinateToAddressResponse response =
                        kakaoAddressApiClient.coordinateToAddress(longitudeStr, latitudeStr);

                if (response.getDocuments() != null && !response.getDocuments().isEmpty()) {
                    StreetLightKakaoAddressApiClient.CoordinateToAddressResponse.Document document = response.getDocuments().get(0);

                    // 도로명 주소 정보 추출
                    if (document.getRoadAddress() != null) {
                        StreetLightKakaoAddressApiClient.CoordinateToAddressResponse.RoadAddress roadAddr = document.getRoadAddress();
                        districtName = roadAddr.getRegion2DepthName(); // 구
                        dongName = roadAddr.getRegion3DepthName();     // 동
                        roadAddress = roadAddr.getAddressName();       // 전체 도로명 주소
                    }

                    // 지번 주소 정보 추출 (도로명 주소가 없을 경우 대안)
                    if (document.getAddress() != null) {
                        StreetLightKakaoAddressApiClient.CoordinateToAddressResponse.Address addr = document.getAddress();
                        if ("주소정보없음".equals(districtName)) {
                            districtName = addr.getRegion2DepthName(); // 구
                            dongName = addr.getRegion3DepthName();     // 동
                        }
                        jibunAddress = addr.getAddressName();         // 전체 지번 주소
                    }
                }
            }
        } catch (Exception apiException) {
            log.warn("KakaoMap API 호출 실패 - 관리번호: {}, 좌표: ({}, {}), 오류: {}",
                    managementNumber, latitude, longitude, apiException.getMessage());
            // API 호출이 실패해도 기본 정보는 저장하도록 처리
        }

        return AnalysisStreetlightStatistics.builder()
                .managementNumber(managementNumber)
                .districtName(districtName)
                .dongName(dongName)
                .roadAddress(roadAddress)
                .jibunAddress(jibunAddress)
                .latitude(latitude)
                .longitude(longitude)
                .build();
    }

    /**
     * 분석용 데이터의 최종 검증 및 품질 확인
     *
     * 작업 내용:
     * - 전체 데이터 개수 확인
     * - 구별 가로등 개수 상위 5개 로깅
     * - 데이터 검증 과정에서 발생하는 오류 처리
     */
    private void performFinalDataValidation() {
        try {
            // 최종 저장된 분석용 데이터 개수 확인
            long finalAnalysisDataCount = analysisStreetlightRepository.count();
            log.info("최종 분석용 가로등 데이터 저장 완료: {} 개", finalAnalysisDataCount);

            // 구별 가로등 개수 조회 및 로깅 (피어슨 상관분석 검증용)
            List<Object[]> districtStreetlightCountList = analysisStreetlightRepository.findStreetlightCountByDistrict();
            log.info("서울시 구별 가로등 개수 순위 (상위 5개구):");

            districtStreetlightCountList.stream()
                    .limit(5)
                    .forEach(rankingRow -> {
                        String districtName = (String) rankingRow[0];    // 구 이름
                        Long streetlightCount = (Long) rankingRow[1];    // 가로등 개수
                        log.info("  {} : {} 개", districtName, streetlightCount);
                    });

        } catch (Exception dataValidationException) {
            log.error("분석용 데이터 검증 과정에서 오류가 발생했습니다: {}",
                    dataValidationException.getMessage(), dataValidationException);
        }
    }
}
```

## 6. RestTemplate 설정

**목적**: HTTP 통신을 위한 RestTemplate Bean 설정
**역할**: KakaoMap API 호출에 필요한 HTTP 클라이언트 설정

```java
package com.WhereHouse.AnalysisData.streetlight.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class RestTemplateConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

## 7. Main 처리 클래스

**목적**: 전체 분석용 데이터 처리 작업의 통합 관리 및 실행
**역할**: 
- 애플리케이션 시작 시 자동 실행되는 메인 진입점 (`CommandLineRunner` 구현)
- 가로등 데이터를 포함한 19개 ERD별 프로세서들의 순차적 호출 관리
- 전체 작업 진행 상황 로깅 및 예외 처리

```java
package com.WhereHouse.AnalysisData.main;

import com.WhereHouse.AnalysisData.streetlight.processor.StreetlightDataProcessor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class AnalysisDataProcessor implements CommandLineRunner {

    private final StreetlightDataProcessor streetlightDataProcessor;
    // 향후 18개 ERD별 프로세서 추가 예정
    // private final CctvDataProcessor cctvDataProcessor;
    // private final BankDataProcessor bankDataProcessor;
    // ...

    @Override
    public void run(String... args) throws Exception {
        log.info("=== 안전성 분석용 데이터 처리 시작 ===");
        
        try {
            // 1. 가로등 데이터 처리
            log.info("1. 가로등 데이터 분석용 테이블 생성 시작");
            streetlightDataProcessor.processAnalysisStreetlightData();
            
            // 향후 추가될 18개 ERD별 데이터 처리
            // 2. CCTV 데이터 처리
            // log.info("2. CCTV 데이터 분석용 테이블 생성 시작");
            // cctvDataProcessor.processAnalysisCctvData();
            
            // 3. 은행 데이터 처리
            // log.info("3. 은행 데이터 분석용 테이블 생성 시작");
            // bankDataProcessor.processAnalysisBankData();
            
            // ... 추가 프로세서들
            
        } catch (Exception e) {
            log.error("안전성 분석용 데이터 처리 중 오류 발생", e);
            throw e;
        }
        
        log.info("=== 안전성 분석용 데이터 처리 완료 ===");
    }
}
```

## 실행 방법 및 검증

### 1. 데이터베이스 설정
1. Oracle DB에 DDL 스크립트 실행
2. 테이블 생성 및 시퀀스 확인

### 2. 환경 설정
```properties
# application.properties 또는 application.yml
kakao.rest-api-key=YOUR_KAKAO_API_KEY
```

### 3. 애플리케이션 실행
```bash
./gradlew bootRun
```

### 4. 실행 결과 검증
```sql
-- 데이터 개수 확인
SELECT COUNT(*) FROM ANALYSIS_STREETLIGHT_STATISTICS;

-- 구별 가로등 개수 확인
SELECT DISTRICT_NAME, COUNT(*) as STREETLIGHT_COUNT 
FROM ANALYSIS_STREETLIGHT_STATISTICS 
GROUP BY DISTRICT_NAME 
ORDER BY COUNT(*) DESC;

-- 주소 정보 품질 확인
SELECT 
    COUNT(*) as TOTAL_COUNT,
    COUNT(CASE WHEN DISTRICT_NAME != '주소정보없음' THEN 1 END) as SUCCESS_COUNT,
    COUNT(CASE WHEN DISTRICT_NAME = '주소정보없음' THEN 1 END) as FAILED_COUNT
FROM ANALYSIS_STREETLIGHT_STATISTICS;
```

## 예상 처리 결과

### 로그 출력 예시
```
=== 안전성 분석용 데이터 처리 시작 ===
1. 가로등 데이터 분석용 테이블 생성 시작
=== 가로등 데이터 분석용 테이블 생성 작업 시작 ===
원본 가로등 데이터 15847 개 발견
진행률: 0.6% (100/15847)
진행률: 1.3% (200/15847)
...
진행률: 99.4% (15800/15847)
가로등 데이터 분석용 테이블 생성 작업 완료 - 성공: 14523 개, 실패: 1324 개, API 호출: 15847 회
최종 분석용 가로등 데이터 저장 완료: 14523 개
서울시 구별 가로등 개수 순위 (상위 5개구):
  강남구 : 1847 개
  송파구 : 1634 개
  서초구 : 1456 개
  강서구 : 1298 개
  영등포구 : 1187 개
=== 가로등 데이터 분석용 테이블 생성 작업 종료 ===
=== 안전성 분석용 데이터 처리 완료 ===
```

### API 호출 제한 및 성능 고려사항

#### KakaoMap API 제한사항
- **일일 호출 제한**: 무료 플랜 기준 300,000회/일
- **호출 간격**: 100ms 대기 시간 적용으로 안정성 확보
- **예상 처리 시간**: 15,000개 데이터 기준 약 25분 소요

#### 데이터 품질 관리
- **좌표 유효성 검증**: 위도/경도가 0이거나 null인 경우 API 호출 생략
- **API 실패 처리**: 호출 실패 시에도 기본 정보는 저장하여 데이터 손실 방지
- **진행률 모니터링**: 100개마다 진행률 출력으로 처리 상황 실시간 확인

이 시스템은 향후 피어슨 상관분석에서 독립변수로 활용될 구별 가로등 시설 개수 계산의 기초 데이터를 제공합니다.