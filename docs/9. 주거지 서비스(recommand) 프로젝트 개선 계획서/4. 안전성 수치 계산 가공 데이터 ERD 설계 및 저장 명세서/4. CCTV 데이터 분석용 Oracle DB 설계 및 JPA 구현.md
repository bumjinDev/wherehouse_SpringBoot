# CCTV 데이터 분석용 Oracle DB 설계 및 JPA 구현

**프로젝트명:** 안전성 점수 계산 시스템 - CCTV 위치 분석 데이터 처리  
**버전:** 1.0  
**작성일:** 2025.08.30  
**목적:** 기존 `CCTV_STATISTICS` 테이블의 위치 정보를 피어슨 상관분석 계산에 활용하기 위한 분석용 테이블 구축

---

## 프로젝트 개요

### 데이터 처리 목표
기존 `CCTV_STATISTICS` 테이블에서 6개 핵심 필드(`id, management_agency, road_address, jibun_address, wgs84_latitude, wgs84_longitude`)만 선별하여 분석 전용 테이블 `ANALYSIS_CCTV_STATISTICS`로 복사하여 안전성 점수 계산 시스템에서 활용할 수 있도록 데이터 구조를 최적화한다.

### 핵심 특징
- **선별적 필드 복사**: 6개 핵심 필드만 선택하여 분석 성능 최적화
- **좌표 데이터 활용**: 기존 WGS84 좌표 정보를 그대로 활용
- **null 값 처리**: 문자열은 "데이터없음", 숫자는 0.0으로 기본값 설정
- **분석 전용 설계**: 제약조건 없이 순수 분석 목적의 테이블 구조
- **기존 인터페이스 재사용**: 원천 데이터 접근에 필요한 JPA Entity와 Repository는 기존 `AnalysisStaticData` 패키지에서 직접 import하여 사용

---

## 1. Oracle 테이블 DDL

**목적**: 분석용 CCTV 위치 테이블 생성 및 시퀀스 설정
**역할**: 피어슨 상관분석에 사용될 독립변수(지역별 CCTV 밀도) 데이터 저장소 구축

```sql
-- 기존 테이블과 데이터를 완전히 삭제
DROP TABLE ANALYSIS_CCTV_STATISTICS CASCADE CONSTRAINTS PURGE;
DROP SEQUENCE SEQ_ANALYSIS_CCTV_STATISTICS;

-- 분석용 CCTV 위치 테이블 생성
CREATE TABLE ANALYSIS_CCTV_STATISTICS (
    ID                      NUMBER,                     -- 제한 없음
    MANAGEMENT_AGENCY       VARCHAR2(4000),             -- 관리기관
    ROAD_ADDRESS           VARCHAR2(4000),             -- 도로명주소
    JIBUN_ADDRESS          VARCHAR2(4000),             -- 지번주소
    LATITUDE               NUMBER,                     -- 위도 (WGS84)
    LONGITUDE              NUMBER                      -- 경도 (WGS84)
);

-- 시퀀스 생성
CREATE SEQUENCE SEQ_ANALYSIS_CCTV_STATISTICS 
    START WITH 1 
    INCREMENT BY 1 
    NOCACHE
    NOCYCLE;

-- 확인
DESC ANALYSIS_CCTV_STATISTICS;
SELECT COUNT(*) FROM ANALYSIS_CCTV_STATISTICS;
```

## 2. JPA Entity

**목적**: 분석용 CCTV 위치 테이블과 Java 객체 간 ORM 매핑
**역할**: 데이터베이스 CRUD 작업을 위한 엔티티 클래스 정의

```java
package com.WhereHouse.AnalysisData.cctv.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;

@Entity
@Table(name = "ANALYSIS_CCTV_STATISTICS")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AnalysisCctvStatistics {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "analysis_cctv_seq")
    @SequenceGenerator(name = "analysis_cctv_seq", sequenceName = "SEQ_ANALYSIS_CCTV_STATISTICS", allocationSize = 1)
    @Column(name = "ID")
    private Long id;

    @Column(name = "MANAGEMENT_AGENCY", length = 100)
    private String managementAgency;

    @Column(name = "ROAD_ADDRESS", length = 200)
    private String roadAddress;

    @Column(name = "JIBUN_ADDRESS", length = 200)
    private String jibunAddress;

    @Column(name = "LATITUDE", precision = 10, scale = 8)
    private BigDecimal latitude;

    @Column(name = "LONGITUDE", precision = 10, scale = 8)
    private BigDecimal longitude;
}
```

## 3. Repository

**목적**: 분석용 CCTV 위치 데이터에 대한 데이터 접근 계층 구현
**역할**: JPA 기반 CRUD 연산 및 맞춤형 쿼리 메서드 제공 (구별 CCTV 밀도 조회, 데이터 검증용)

```java
package com.WhereHouse.AnalysisData.cctv.repository;

import com.WhereHouse.AnalysisData.cctv.entity.AnalysisCctvStatistics;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface AnalysisCctvRepository extends JpaRepository<AnalysisCctvStatistics, Long> {
    
    Optional<AnalysisCctvStatistics> findByRoadAddress(String roadAddress);
    
    List<AnalysisCctvStatistics> findByManagementAgency(String managementAgency);
    
    boolean existsByRoadAddress(String roadAddress);
    
    @Query("SELECT COUNT(a) FROM AnalysisCctvStatistics a")
    long countAnalysisData();
    
    @Query("SELECT COUNT(a) FROM AnalysisCctvStatistics a WHERE a.managementAgency = :agency")
    long countByManagementAgency(@Param("agency") String agency);
    
    @Query("SELECT a.managementAgency, COUNT(a) FROM AnalysisCctvStatistics a GROUP BY a.managementAgency ORDER BY COUNT(a) DESC")
    List<Object[]> findAgencyCctvDensityRanking();
    
    @Query(value = "SELECT SUBSTR(ROAD_ADDRESS, 1, INSTR(ROAD_ADDRESS, ' ', 1, 2) - 1) as district, COUNT(*) as cctv_count " +
                  "FROM ANALYSIS_CCTV_STATISTICS " +
                  "WHERE ROAD_ADDRESS LIKE '서울%' " +
                  "GROUP BY SUBSTR(ROAD_ADDRESS, 1, INSTR(ROAD_ADDRESS, ' ', 1, 2) - 1) " +
                  "ORDER BY cctv_count DESC", nativeQuery = true)
    List<Object[]> findDistrictCctvDensityRanking();
}
```

## 4. CCTV 위치 데이터 분석용 처리 Component

**목적**: 원본 CCTV 위치 데이터를 분석용 테이블로 변환하는 비즈니스 로직 처리
**역할**: 
- 기존 `CCTV_STATISTICS` 테이블에서 6개 핵심 필드만 선별 조회
- 선별된 필드를 분석용 테이블로 복사
- null 값 적절한 기본값으로 변환 처리
- 데이터 품질 검증 및 구별 CCTV 밀도 순위 로깅

```java
package com.WhereHouse.AnalysisData.cctv.processor;

import com.WhereHouse.AnalysisData.cctv.entity.AnalysisCctvStatistics;
import com.WhereHouse.AnalysisData.cctv.repository.AnalysisCctvRepository;
// 원본 데이터 접근을 위한 기존 패키지 import
import com.WhereHouse.AnalysisStaticData.safety.entity.CctvStatistics;
import com.WhereHouse.AnalysisStaticData.safety.repository.CctvStatisticsRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.List;

/**
 * CCTV 위치 데이터 분석용 테이블 생성 처리 컴포넌트
 * 
 * 기존 CCTV_STATISTICS 테이블에서 6개 핵심 필드만 선별하여
 * 분석 전용 ANALYSIS_CCTV_STATISTICS 테이블로 복사하는 작업을 수행한다.
 * 
 * 주요 기능:
 * - 원본 CCTV 위치 데이터 조회 및 검증
 * - 6개 핵심 필드(id, management_agency, road_address, jibun_address, wgs84_latitude, wgs84_longitude) 복사
 * - null 값을 적절한 기본값으로 변환 처리
 * - 분석용 테이블 데이터 품질 검증
 * - 관리기관별 및 구별 CCTV 밀도 순위 로깅
 * 
 * @author Safety Analysis System
 * @since 1.0
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class CctvDataProcessor {

    // 원본 CCTV 위치 테이블 접근을 위한 Repository
    private final CctvStatisticsRepository originalCctvRepository;
    
    // 분석용 CCTV 위치 테이블 접근을 위한 Repository  
    private final AnalysisCctvRepository analysisCctvRepository;

    /**
     * CCTV 위치 데이터 분석용 테이블 생성 메인 프로세스
     * 
     * 작업 순서:
     * 1. 기존 분석용 데이터 존재 여부 확인
     * 2. 원본 CCTV 위치 데이터 조회 및 검증
     * 3. 6개 핵심 필드 선별 및 분석용 테이블 저장
     * 4. 데이터 품질 검증 및 결과 로깅
     */
    @Transactional
    public void processAnalysisCctvData() {
        log.info("=== CCTV 위치 데이터 분석용 테이블 생성 작업 시작 ===");
        
        // Step 1: 기존 분석용 데이터 중복 처리 방지를 위한 존재 여부 확인
        long existingAnalysisDataCount = analysisCctvRepository.count();
        if (existingAnalysisDataCount > 0) {
            log.info("분석용 CCTV 위치 데이터가 이미 존재합니다 (총 {} 개). 작업을 스킵합니다.", existingAnalysisDataCount);
            return;
        }

        // Step 2: 원본 CCTV 위치 데이터 조회 및 검증
        List<CctvStatistics> originalCctvDataList = originalCctvRepository.findAll();
        if (originalCctvDataList.isEmpty()) {
            log.warn("원본 CCTV 위치 데이터가 존재하지 않습니다. 먼저 CctvDataLoader를 통해 CSV 데이터를 수집해주세요.");
            return;
        }
        
        log.info("원본 CCTV 위치 데이터 {} 개 지점 발견", originalCctvDataList.size());

        // Step 3: 데이터 변환 및 저장 작업 수행
        int successfulConversionCount = 0;  // 성공적으로 변환된 데이터 개수
        int failedConversionCount = 0;      // 변환 실패한 데이터 개수

        for (CctvStatistics originalCctvData : originalCctvDataList) {
            try {
                // 원본 데이터에서 6개 핵심 필드만 선별하여 분석용 엔티티로 변환
                AnalysisCctvStatistics analysisTargetCctvData = convertToAnalysisEntity(originalCctvData);
                
                // 분석용 테이블에 데이터 저장
                analysisCctvRepository.save(analysisTargetCctvData);
                successfulConversionCount++;
                
                log.debug("분석용 데이터 생성 완료: {} (관리기관: {}, 좌표: {}, {})", 
                    originalCctvData.getRoadAddress(), 
                    originalCctvData.getManagementAgency(),
                    originalCctvData.getWgs84Latitude(), 
                    originalCctvData.getWgs84Longitude());

            } catch (Exception dataConversionException) {
                log.error("분석용 데이터 생성 실패 - CCTV: {} (ID: {}), 오류: {}", 
                    originalCctvData.getRoadAddress(), originalCctvData.getId(), 
                    dataConversionException.getMessage());
                failedConversionCount++;
            }
        }

        // Step 4: 변환 작업 결과 로깅
        log.info("CCTV 위치 데이터 분석용 테이블 생성 작업 완료 - 성공: {} 개, 실패: {} 개", 
            successfulConversionCount, failedConversionCount);
        
        // Step 5: 최종 데이터 검증 및 품질 확인
        performFinalDataValidation();
        
        log.info("=== CCTV 위치 데이터 분석용 테이블 생성 작업 종료 ===");
    }
    
    /**
     * 원본 CCTV 위치 엔티티를 분석용 엔티티로 변환
     * 
     * 6개 핵심 필드(id, management_agency, road_address, jibun_address, wgs84_latitude, wgs84_longitude)만 복사한다.
     * null 값은 적절한 기본값으로 변환 처리한다.
     * 
     * @param originalCctvData 원본 CCTV 위치 엔티티
     * @return 분석용 CCTV 위치 엔티티
     */
    private AnalysisCctvStatistics convertToAnalysisEntity(CctvStatistics originalCctvData) {
        return AnalysisCctvStatistics.builder()
            // 관리 정보
            .managementAgency(handleNullString(originalCctvData.getManagementAgency()))       // 관리기관
            
            // 주소 정보
            .roadAddress(handleNullString(originalCctvData.getRoadAddress()))                 // 도로명주소
            .jibunAddress(handleNullString(originalCctvData.getJibunAddress()))               // 지번주소
            
            // 좌표 정보 (피어슨 상관분석 핵심 데이터)
            .latitude(handleNullDouble(originalCctvData.getWgs84Latitude()))                  // 위도
            .longitude(handleNullDouble(originalCctvData.getWgs84Longitude()))                // 경도
            .build();
    }
    
    /**
     * 문자열 null 값 처리 - null이면 "데이터없음"으로 변환
     * 
     * @param value 원본 문자열 값
     * @return null이면 "데이터없음", 아니면 원본 값
     */
    private String handleNullString(String value) {
        return value != null ? value : "데이터없음";
    }
    
    /**
     * Double null 값 처리 - null이면 0.0으로 변환하고 BigDecimal로 변환
     * 
     * @param value 원본 Double 값
     * @return null이면 BigDecimal.ZERO, 아니면 BigDecimal로 변환된 값
     */
    private BigDecimal handleNullDouble(Double value) {
        return value != null ? BigDecimal.valueOf(value) : BigDecimal.ZERO;
    }
    
    /**
     * 분석용 데이터의 최종 검증 및 품질 확인
     * 
     * 작업 내용:
     * - 전체 데이터 개수 확인
     * - 관리기관별 CCTV 밀도 순위 상위 5개 로깅
     * - 구별 CCTV 밀도 순위 상위 5개 로깅
     * - 데이터 검증 과정에서 발생하는 오류 처리
     */
    private void performFinalDataValidation() {
        try {
            // 최종 저장된 분석용 데이터 개수 확인
            long finalAnalysisDataCount = analysisCctvRepository.count();
            log.info("최종 분석용 CCTV 위치 데이터 저장 완료: {} 개 지점", finalAnalysisDataCount);
            
            // 관리기관별 CCTV 밀도 순위 조회 및 로깅 (피어슨 상관분석 검증용)
            List<Object[]> agencyCctvDensityRankingList = analysisCctvRepository.findAgencyCctvDensityRanking();
            log.info("관리기관별 CCTV 밀도 순위 (상위 5개 기관):");
            
            agencyCctvDensityRankingList.stream()
                .limit(5)
                .forEach(rankingRow -> {
                    String agencyName = (String) rankingRow[0];           // 관리기관 이름
                    Long totalCctvCount = (Long) rankingRow[1];           // 총 CCTV 개수
                    log.info("  {} : {} 개 지점", agencyName, totalCctvCount);
                });
            
            // 구별 CCTV 밀도 순위 조회 및 로깅
            List<Object[]> districtCctvDensityRankingList = analysisCctvRepository.findDistrictCctvDensityRanking();
            log.info("서울시 구별 CCTV 밀도 순위 (상위 5개구):");
            
            districtCctvDensityRankingList.stream()
                .limit(5)
                .forEach(districtRow -> {
                    String districtName = (String) districtRow[0];        // 구 이름
                    Number cctvCount = (Number) districtRow[1];           // CCTV 개수
                    log.info("  {} : {} 개 지점", districtName, cctvCount);
                });
                
        } catch (Exception dataValidationException) {
            log.error("분석용 데이터 검증 과정에서 오류가 발생했습니다: {}", 
                dataValidationException.getMessage(), dataValidationException);
        }
    }
}
```

## 5. Main 처리 클래스 수정

**목적**: 전체 분석용 데이터 처리 작업에 CCTV 위치 데이터 처리 추가
**역할**: 기존 데이터에 이어서 CCTV 위치 데이터 처리를 순차적으로 실행

```java
package com.WhereHouse.AnalysisData.main;

import com.WhereHouse.AnalysisData.crime.processor.CrimeDataProcessor;
import com.WhereHouse.AnalysisData.bankcount.processor.BankCountDataProcessor;
import com.WhereHouse.AnalysisData.banklocation.processor.BankLocationDataProcessor;
import com.WhereHouse.AnalysisData.cctv.processor.CctvDataProcessor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class AnalysisDataProcessor implements CommandLineRunner {

    private final CrimeDataProcessor crimeDataProcessor;
    private final BankCountDataProcessor bankCountDataProcessor;
    private final BankLocationDataProcessor bankLocationDataProcessor;
    private final CctvDataProcessor cctvDataProcessor;
    // 향후 15개 ERD별 프로세서 추가 예정
    // private final ConvenienceStoreDataProcessor convenienceStoreDataProcessor;
    // ...

    @Override
    public void run(String... args) throws Exception {
        log.info("=== 안전성 분석용 데이터 처리 시작 ===");
        
        try {
            // 1. 범죄 데이터 처리
            log.info("1. 범죄 데이터 분석용 테이블 생성 시작");
            crimeDataProcessor.processAnalysisCrimeData();
            
            // 2. 은행 지점 개수 데이터 처리
            log.info("2. 은행 지점 개수 데이터 분석용 테이블 생성 시작");
            bankCountDataProcessor.processAnalysisBankCountData();
            
            // 3. 은행 위치 데이터 처리
            log.info("3. 은행 위치 데이터 분석용 테이블 생성 시작");
            bankLocationDataProcessor.processAnalysisBankLocationData();
            
            // 4. CCTV 위치 데이터 처리
            log.info("4. CCTV 위치 데이터 분석용 테이블 생성 시작");
            cctvDataProcessor.processAnalysisCctvData();
            
            // 향후 추가될 15개 ERD별 데이터 처리
            // 5. 편의점 데이터 처리
            // log.info("5. 편의점 데이터 분석용 테이블 생성 시작");
            // convenienceStoreDataProcessor.processAnalysisConvenienceStoreData();
            
            // ... 추가 프로세서들
            
        } catch (Exception e) {
            log.error("안전성 분석용 데이터 처리 중 오류 발생", e);
            throw e;
        }
        
        log.info("=== 안전성 분석용 데이터 처리 완료 ===");
    }
}
```

## 실행 방법 및 검증

### 1. 사전 조건 확인
1. CSV를 통한 `CCTV_STATISTICS` 테이블 데이터 수집 완료
2. Oracle DB에 DDL 스크립트 실행
3. 테이블 생성 및 시퀀스 확인

### 2. 애플리케이션 실행
```bash
./gradlew bootRun
```

### 3. 실행 결과 검증
```sql
-- 데이터 개수 확인
SELECT COUNT(*) FROM ANALYSIS_CCTV_STATISTICS;

-- 관리기관별 CCTV 밀도 확인
SELECT MANAGEMENT_AGENCY, COUNT(*) as CCTV_COUNT 
FROM ANALYSIS_CCTV_STATISTICS 
WHERE MANAGEMENT_AGENCY != '데이터없음'
GROUP BY MANAGEMENT_AGENCY 
ORDER BY CCTV_COUNT DESC;

-- 좌표 데이터 품질 확인
SELECT COUNT(*) as TOTAL_COUNT,
       SUM(CASE WHEN LONGITUDE = 0.0 OR LATITUDE = 0.0 THEN 1 ELSE 0 END) as NULL_COORD_COUNT
FROM ANALYSIS_CCTV_STATISTICS;

-- 구별 CCTV 분포 확인 (주소에서 구 정보 추출)
SELECT SUBSTR(ROAD_ADDRESS, 1, INSTR(ROAD_ADDRESS, ' ', 1, 2) - 1) as DISTRICT, 
       COUNT(*) as CCTV_COUNT 
FROM ANALYSIS_CCTV_STATISTICS 
WHERE ROAD_ADDRESS LIKE '서울%'
GROUP BY SUBSTR(ROAD_ADDRESS, 1, INSTR(ROAD_ADDRESS, ' ', 1, 2) - 1) 
ORDER BY CCTV_COUNT DESC;
```

## 예상 처리 결과

### 로그 출력 예시
```
=== 안전성 분석용 데이터 처리 시작 ===
1. 범죄 데이터 분석용 테이블 생성 시작
범죄 데이터 분석용 테이블 생성 작업 완료 - 성공: 25 개, 실패: 0 개
2. 은행 지점 개수 데이터 분석용 테이블 생성 시작
은행 지점 개수 데이터 분석용 테이블 생성 작업 완료 - 성공: 423 개, 실패: 0 개
3. 은행 위치 데이터 분석용 테이블 생성 시작
은행 위치 데이터 분석용 테이블 생성 작업 완료 - 성공: 823 개, 실패: 0 개
4. CCTV 위치 데이터 분석용 테이블 생성 시작
원본 CCTV 위치 데이터 15,234 개 지점 발견
CCTV 위치 데이터 분석용 테이블 생성 작업 완료 - 성공: 15,234 개, 실패: 0 개
관리기관별 CCTV 밀도 순위 (상위 5개 기관):
  서울특별시 : 8,456 개 지점
  강남구청 : 1,234 개 지점
  종로구청 : 987 개 지점
  중구청 : 834 개 지점
  서초구청 : 723 개 지점
서울시 구별 CCTV 밀도 순위 (상위 5개구):
  서울 강남구 : 2,456 개 지점
  서울 종로구 : 1,987 개 지점
  서울 중구 : 1,834 개 지점
  서울 서초구 : 1,723 개 지점
  서울 영등포구 : 1,456 개 지점
=== 안전성 분석용 데이터 처리 완료 ===
```

이 시스템은 향후 피어슨 상관분석에서 독립변수로 활용될 지역별 CCTV 밀도 계산의 핵심 좌표 데이터를 제공합니다.