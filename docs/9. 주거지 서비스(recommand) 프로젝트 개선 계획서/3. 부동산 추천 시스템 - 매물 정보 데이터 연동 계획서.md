# 부동산 추천 시스템 - 전월세 데이터 연동 명세서

**프로젝트명:** Phase 2 추천 엔진 비즈니스 로직 설계 - 전월세 데이터 연동 부문  
**버전:** 2.3  
**작성일:** 2025.08.21  
**기반 문서:** 프로젝트 개선 기획서 3.1항목 (사용자 입력 데이터 처리 설계)  

---

## 목차

1. [데이터 연동 전략 개요](#1-데이터-연동-전략-개요)
2. [전월세 데이터 소스](#2-전월세-데이터-소스)
3. [API 연동 기술 명세](#3-api-연동-기술-명세)

---

## 1. 데이터 연동 전략 개요

### 1.1 현재 상황 분석

**핵심 비즈니스 요구사항**: 사용자 추천을 위한 **가격, 평수, 지역** 3개 핵심 데이터 확보

```
📊 추천 계산에 필요한 핵심 데이터
├── 가격 데이터: 보증금, 월세 (표준화된 가격으로 변환)
├── 평수 데이터: 전용면적 (평수로 변환)
└── 지역 데이터: 법정동 (지역 식별)

🎨 UI 표시용 보조 데이터 (추천 계산 미사용)
├── 아파트명, 층수, 건축연도
└── 계약일자, 지번 등
```

### 1.2 데이터 연동 원칙

| 원칙 | 내용 | 구현 방법 |
|------|------|-----------|
| **신뢰성 우선** | 공공데이터 중심 | 공공데이터포털 API 활용 |
| **단일 데이터 소스** | 복잡성 최소화 | 국토교통부 API 단일 사용 |
| **목적 중심 설계** | 추천 로직에 필요한 데이터만 | 핵심 3개 데이터 집중 |

---

## 2. 전월세 데이터 소스

### 국토교통부 전월세 실거래가 API

* **공공데이터포털**: https://www.data.go.kr
* **API 종류**: 
  - 아파트전월세 실거래정보 (`/getRTMSDataSvcAptRent`)
  - 오피스텔전월세 실거래정보 (`/getRTMSDataSvcOffiRent`)
* **설명**: 전월세 추천 시스템에 필요한 모든 데이터를 제공하는 단일 데이터 소스입니다. '아파트전월세 실거래정보' 등으로 검색하여 해당 API의 상세 명세를 확인할 수 있습니다.

#### A. 제공 데이터 항목 및 활용 방안

**📊 핵심 비즈니스 로직 데이터 (추천 계산용)**
| 항목 | 필드명 (API) | 활용 용도 | 데이터 처리 |
|------|-------------|----------|------------|
| **보증금/전세금** | deposit | 가격우선 점수 계산 | 만원 단위 정수 변환 |
| **월세금** | monthlyRent | 월세→전세 환산 계산 | 만원 단위, 0이면 전세 |
| **전용면적** | excluUseAr | 평수우선 점수 계산 | 평수 변환 (÷3.3058) |
| **법정동** | umdNm | 지역 매핑 | 지역코드 변환 |

**🎨 UI 표시용 보조 데이터 (추천 계산 미사용)**
| 항목 | 필드명 (API) | 활용 용도 |
|------|-------------|----------|
| **아파트명** | aptNm | 매물 식별 표시 |
| **층수** | floor | 사용자 참고 정보 |
| **건축연도** | buildYear | 사용자 참고 정보 |
| **계약일자** | dealYear/Month/Day | 거래 시점 정보 |
| **지번** | jibun | 상세 위치 정보 |

---

## 3. API 연동 기술 명세

### 국토교통부 API 연동 명세

#### A. API 기본 설정 및 환경 구성

**필수 라이브러리 및 의존성:**
```xml
<!-- pom.xml (Maven 기준) -->
<dependencies>
    <!-- Spring Boot Web (HTTP 통신용) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- XML 파싱용 (JDK 기본 포함) -->
    <!-- javax.xml.parsers.* -->
    <!-- org.w3c.dom.* -->
    <!-- org.xml.sax.* -->
</dependencies>
```

**주요 Import 라이브러리:**
```java
// Spring 관련
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

// XML 파싱 관련 (JDK 기본 제공)
import org.w3c.dom.*;                    // DOM 파싱용
import org.xml.sax.InputSource;          // XML 입력 소스
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

// HTTP 통신 관련 (JDK 기본 제공)
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLEncoder;

// I/O 관련 (JDK 기본 제공)
import java.io.*;

// 날짜/시간 처리 (JDK 8+)
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

// 컬렉션 (JDK 기본 제공)
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
```

```yaml
# application.yml 설정
molit:
  rent-api:
    service-key: ${MOLIT_RENT_SERVICE_KEY:your-api-key}
    base-url: https://apis.data.go.kr/1613000/RTMSDataSvcAptRent
    timeout: 30000

# Java 클래스 설정
@Value("${molit.rent-api.service-key}")
private String serviceKey;

@Value("${molit.rent-api.base-url}")
private String baseUrl;

private static final String API_ENDPOINT = "/getRTMSDataSvcAptRent";
private static final String NUM_OF_ROWS = "100";
private static final String PAGE_NO = "1";
```

#### B. API 호출 URL 구성 및 파라미터
```java
/**
 * API 호출 URL 구성 (실제 구현 기준)
 */
private String callRentAPI(String lawdCd, String dealYmd) {
    StringBuilder urlBuilder = new StringBuilder(baseUrl + API_ENDPOINT);
    
    // 필수 파라미터 구성
    urlBuilder.append("?").append(URLEncoder.encode("serviceKey", "UTF-8"))
            .append("=").append(serviceKey);
    urlBuilder.append("&").append(URLEncoder.encode("LAWD_CD", "UTF-8"))
            .append("=").append(URLEncoder.encode(lawdCd, "UTF-8"));      // 법정동코드 (5자리)
    urlBuilder.append("&").append(URLEncoder.encode("DEAL_YMD", "UTF-8"))
            .append("=").append(URLEncoder.encode(dealYmd, "UTF-8"));     // 계약년월 (YYYYMM)
    urlBuilder.append("&").append(URLEncoder.encode("numOfRows", "UTF-8"))
            .append("=").append(URLEncoder.encode(NUM_OF_ROWS, "UTF-8")); // 한 페이지 결과 수
    urlBuilder.append("&").append(URLEncoder.encode("pageNo", "UTF-8"))
            .append("=").append(URLEncoder.encode(PAGE_NO, "UTF-8"));     // 페이지번호
    
    return urlBuilder.toString();
}
```

**주요 파라미터 상세:**
| 파라미터 | 필수여부 | 설명 | 예시값 |
|----------|---------|------|--------|
| `serviceKey` | 필수 | 공공데이터포털 발급 인증키 | 발급받은 키 |
| `LAWD_CD` | 필수 | 지역코드 (5자리) | `11680` (강남구) |
| `DEAL_YMD` | 필수 | 계약년월 (6자리) | `202508` (2025년 8월) |
| `numOfRows` | 선택 | 한 페이지 결과 수 | `100` |
| `pageNo` | 선택 | 페이지번호 | `1` |

#### C. HTTP 연결 설정 및 호출

**사용 라이브러리: HttpURLConnection (JDK 기본 제공)**
- `java.net.HttpURLConnection`: HTTP 연결 관리
- `java.net.URL`: URL 객체 생성
- `java.net.URLEncoder`: URL 파라미터 인코딩
- `java.io.BufferedReader`: 응답 스트림 읽기
- `java.io.InputStreamReader`: 바이트→문자 변환

**HttpURLConnection 선택 이유:**
- JDK 기본 제공으로 별도 의존성 불필요
- 공공 API의 단순한 GET 요청에 적합
- 타임아웃, 헤더 설정 등 기본 기능 충분
- Spring RestTemplate 대비 가벼움

```java
/**
 * HTTP 연결 설정 (실제 구현 기준)
 */
URL url = new URL(apiUrl);
HttpURLConnection conn = (HttpURLConnection) url.openConnection();

// HTTP 설정
conn.setRequestMethod("GET");
conn.setRequestProperty("Content-type", "application/xml");
conn.setRequestProperty("Accept", "application/xml");
conn.setConnectTimeout(30000);  // 연결 타임아웃: 30초
conn.setReadTimeout(30000);     // 읽기 타임아웃: 30초

// 응답 처리
int responseCode = conn.getResponseCode();
if (responseCode == HttpURLConnection.HTTP_OK) {
    // 성공적인 응답 읽기
    BufferedReader reader = new BufferedReader(
        new InputStreamReader(conn.getInputStream(), "UTF-8"));
    // ... XML 응답 처리
}
```

#### D. XML 응답 구조 및 파싱

**사용 라이브러리: DOM Parser (JDK 기본 제공)**
- `javax.xml.parsers.DocumentBuilderFactory`: XML 파서 팩토리
- `javax.xml.parsers.DocumentBuilder`: XML 문서 빌더  
- `org.w3c.dom.Document`: XML 문서 객체
- `org.w3c.dom.Element`: XML 엘리먼트
- `org.w3c.dom.NodeList`: XML 노드 리스트

**DOM Parser 선택 이유:**
- JDK 기본 제공으로 별도 의존성 불필요
- 전체 XML을 메모리에 로드하여 안정적 파싱
- XPath 지원으로 복잡한 구조 탐색 가능
- 공공 API 응답 크기 고려시 적합

```java
/**
 * XML 응답 구조 파싱 (DOM Parser 사용)
 */
private void parseXmlWithDOM(String xmlResponse) {
    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
    factory.setNamespaceAware(true);
    DocumentBuilder builder = factory.newDocumentBuilder();
    
    Document document = builder.parse(new InputSource(new StringReader(xmlResponse)));
    document.getDocumentElement().normalize();
    
    // 1. 헤더 정보 파싱 (API 호출 결과 상태 확인)
    parseHeader(document);
    
    // 2. 바디 정보 파싱 (페이징 정보 등)
    parseBody(document);
    
    // 3. 실제 전월세 데이터 아이템들 파싱
    parseRentItems(document);
}
```

**XML 응답 구조:**
```xml
<response>
    <header>
        <resultCode>00</resultCode>        <!-- 성공: 00, 실패: 기타 -->
        <resultMsg>NORMAL_SERVICE</resultMsg>
    </header>
    <body>
        <totalCount>1234</totalCount>      <!-- 전체 건수 -->
        <numOfRows>100</numOfRows>         <!-- 페이지당 건수 -->
        <pageNo>1</pageNo>                 <!-- 현재 페이지 -->
        <items>
            <item>
                <aptNm>래미안강남팰리스</aptNm>     <!-- 아파트명 -->
                <excluUseAr>84.93</excluUseAr>     <!-- 전용면적 -->
                <floor>15</floor>                   <!-- 층 -->
                <buildYear>2010</buildYear>         <!-- 건축연도 -->
                <dealYear>2025</dealYear>           <!-- 계약연도 -->
                <dealMonth>8</dealMonth>            <!-- 계약월 -->
                <dealDay>15</dealDay>               <!-- 계약일 -->
                <deposit>50000</deposit>            <!-- 보증금 (만원) -->
                <monthlyRent>150</monthlyRent>      <!-- 월세금 (만원) -->
                <umdNm>역삼동</umdNm>               <!-- 법정동 -->
                <jibun>123-45</jibun>               <!-- 지번 -->
                <sggCd>11680</sggCd>               <!-- 시군구코드 -->
                <rgstDate>2025-08-15</rgstDate>    <!-- 등록일자 -->
            </item>
        </items>
    </body>
</response>
```

#### E. 핵심 데이터 추출 로직 (실제 구현)

**사용 컬렉션 및 유틸리티:**
- `java.util.HashMap<String, String>`: 파싱된 데이터 저장
- `java.util.ArrayList<Map<String, String>>`: 전체 매물 리스트
- `java.util.Arrays.stream()`: 필드명 배열 처리
- `String.trim()`: 공백 제거
- `Integer.parseInt()` / `Double.parseDouble()`: 숫자 변환

```java
/**
 * 개별 전월세 아이템의 상세 정보를 파싱
 */
private Map<String, String> parseIndividualRentItem(Element item) {
    Map<String, String> data = new HashMap<>();
    
    // 🔥 추천 계산용 핵심 필드 (비즈니스 로직 필수)
    String[] coreFields = {
        "deposit",      // 보증금 - 가격 계산용
        "monthlyRent",  // 월세금 - 가격 계산용  
        "excluUseAr",   // 전용면적 - 평수 계산용
        "umdNm"         // 법정동 - 지역 구분용
    };
    
    // 🎨 UI 표시용 보조 필드
    String[] displayFields = {
        "aptNm",        // 아파트명
        "floor",        // 층수
        "buildYear",    // 건축연도
        "dealYear",     // 계약연도
        "dealMonth",    // 계약월
        "dealDay",      // 계약일
        "jibun",        // 지번
        "sggCd",        // 시군구코드
        "rgstDate"      // 등록일자
    };
    
    // 모든 필드 추출
    String[] allFields = Stream.concat(Arrays.stream(coreFields), Arrays.stream(displayFields))
                              .toArray(String[]::new);
    
    for (String fieldName : allFields) {
        String value = getElementValue(item, fieldName);
        data.put(fieldName, value != null ? value.trim() : "정보없음");
    }
    
    return data;
}

/**
 * XML Element에서 지정된 태그명의 텍스트 값을 안전하게 추출
 */
private String getElementValue(Element parent, String tagName) {
    try {
        NodeList nodeList = parent.getElementsByTagName(tagName);
        if (nodeList.getLength() > 0) {
            Node node = nodeList.item(0);
            if (node != null) {
                Node firstChild = node.getFirstChild();
                if (firstChild != null) {
                    return firstChild.getNodeValue();
                }
            }
        }
    } catch (Exception e) {
        // 조용히 무시하고 null 반환
    }
    return null;
}
```

#### F. 전월세 구분 및 표준화 로직

**사용 라이브러리 및 유틸리티:**
- `java.time.LocalDate`: 현재 날짜 처리
- `java.time.format.DateTimeFormatter`: 날짜 포맷팅 (YYYYMM)
- `String.equals()` / `String.trim()`: 문자열 비교 및 정제
- `Math.round()`: 반올림 계산

**핵심 판단 로직:**
```java
/**
 * 전월세 데이터 표준화 (실제 비즈니스 로직)
 */
private void displayRentData(Map<String, String> data) {
    String deposit = data.get("deposit");
    String monthlyRent = data.get("monthlyRent");
    
    // 🔥 핵심: 월세 여부 판단 로직
    boolean isMonthlyRent = monthlyRent != null && 
                           !monthlyRent.equals("0") && 
                           !monthlyRent.equals("정보없음") && 
                           !monthlyRent.trim().isEmpty();
    
    if (isMonthlyRent) {
        // 월세인 경우
        System.out.println("💰 보증금: " + deposit + "만원");
        System.out.println("💰 월세금: " + monthlyRent + "만원");
        System.out.println("🏷️ 거래유형: 월세");
        
        // 🔥 표준화된 가격 계산 (추천 로직용)
        int standardizedPrice = Integer.parseInt(deposit) + 
                               (Integer.parseInt(monthlyRent) * 12);
        
    } else {
        // 전세인 경우
        System.out.println("💰 전세금: " + deposit + "만원");
        System.out.println("🏷️ 거래유형: 전세");
        
        // 🔥 표준화된 가격 계산 (추천 로직용)
        int standardizedPrice = Integer.parseInt(deposit);
    }
    
    // 🔥 평수 계산 (추천 로직용)
    double area = Double.parseDouble(data.get("excluUseAr"));
    double pyeong = area / 3.3058;  // 정확한 평수 변환 계수
}
```