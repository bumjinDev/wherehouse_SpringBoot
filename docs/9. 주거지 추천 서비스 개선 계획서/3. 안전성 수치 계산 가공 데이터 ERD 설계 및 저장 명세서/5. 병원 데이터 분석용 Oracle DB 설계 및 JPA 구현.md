# 병원 데이터 분석용 시스템 완전 구현 가이드

**프로젝트명:** 안전성 점수 계산 시스템 - 병원 통계 분석 데이터 처리  
**버전:** 1.0  
**작성일:** 2025.09.08  
**목적:** 전국 병원 정보를 피어슨 상관분석 계산에 활용하기 위한 분석용 테이블 구축

---

## 📁 프로젝트 구조

```
src/main/java/com/WhereHouse/AnalysisData/hospital/
├── entity/
│   └── AnalysisHospitalData.java
├── repository/
│   └── AnalysisHospitalDataRepository.java
├── service/
│   └── KakaoCoordinateService.java
├── processor/
│   └── HospitalDataProcessor.java
└── HospitalAnalysisMain.java

src/main/resources/
└── application.yml

database/
└── create_analysis_hospital_table.sql
```

---

## 1. Entity 클래스 (AnalysisHospitalData.java)

**파일 경로:** `src/main/java/com/WhereHouse/AnalysisData/hospital/entity/AnalysisHospitalData.java`

```java
package com.WhereHouse.AnalysisData.hospital.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "ANALYSIS_HOSPITAL_DATA")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AnalysisHospitalData {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "analysis_hospital_data_seq")
    @SequenceGenerator(name = "analysis_hospital_data_seq", sequenceName = "SEQ_ANALYSIS_HOSPITAL_DATA", allocationSize = 1)
    private Long id;

    @Column(name = "BUSINESS_NAME", length = 4000)
    private String businessName;

    @Column(name = "BUSINESS_TYPE_NAME", length = 4000)
    private String businessTypeName;

    @Column(name = "DETAILED_STATUS_NAME", length = 4000)
    private String detailedStatusName;

    @Column(name = "PHONE_NUMBER", length = 4000)
    private String phoneNumber;

    @Column(name = "LOT_ADDRESS", length = 4000)
    private String lotAddress;

    @Column(name = "ROAD_ADDRESS", length = 4000)
    private String roadAddress;

    @Column(name = "LATITUDE", precision = 10, scale = 7)
    private BigDecimal latitude;

    @Column(name = "LONGITUDE", precision = 10, scale = 7)
    private BigDecimal longitude;

    @Column(name = "CREATED_AT", updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "UPDATED_AT")
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}
```

---

## 2. Repository 인터페이스 (AnalysisHospitalDataRepository.java)

**파일 경로:** `src/main/java/com/WhereHouse/AnalysisData/hospital/repository/AnalysisHospitalDataRepository.java`

```java
package com.WhereHouse.AnalysisData.hospital.repository;

import com.WhereHouse.AnalysisData.hospital.entity.AnalysisHospitalData;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface AnalysisHospitalDataRepository extends JpaRepository<AnalysisHospitalData, Long> {

    /**
     * 좌표 완성도 확인
     */
    @Query("SELECT COUNT(*) FROM AnalysisHospitalData")
    Long getTotalCount();

    @Query("SELECT COUNT(*) FROM AnalysisHospitalData a WHERE a.latitude IS NOT NULL AND a.longitude IS NOT NULL")
    Long getCoordinateCount();

    /**
     * 업종별 분포 조회
     */
    @Query("SELECT a.businessTypeName, COUNT(a) FROM AnalysisHospitalData a GROUP BY a.businessTypeName ORDER BY COUNT(a) DESC")
    List<Object[]> countByBusinessType();

    /**
     * 상세영업상태별 분포 조회
     */
    @Query("SELECT a.detailedStatusName, COUNT(a) FROM AnalysisHospitalData a GROUP BY a.detailedStatusName ORDER BY COUNT(a) DESC")
    List<Object[]> countByDetailedStatus();

    /**
     * 데이터 품질 검증용 통계 조회
     */
    @Query("SELECT " +
           "COUNT(*) as totalCount, " +
           "COUNT(a.latitude) as coordinateCount, " +
           "COUNT(a.businessName) as businessNameCount, " +
           "COUNT(a.businessTypeName) as businessTypeCount " +
           "FROM AnalysisHospitalData a")
    Object[] getDataQualityStats();
}
```

---

## 3. Kakao API 좌표 계산 서비스 (KakaoCoordinateService.java)

**파일 경로:** `src/main/java/com/WhereHouse/AnalysisData/hospital/service/KakaoCoordinateService.java`

```java
package com.WhereHouse.AnalysisData.hospital.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.math.BigDecimal;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;

@Service
@Slf4j
public class KakaoCoordinateService {

    @Value("${kakao.api.key}")
    private String kakaoApiKey;

    private final RestTemplate restTemplate = new RestTemplate();
    private final ObjectMapper objectMapper = new ObjectMapper();

    // 병원 관련 키워드 목록
    private static final List<String> HOSPITAL_KEYWORDS = Arrays.asList(
        "병원", "의원", "한의원", "치과", "요양병원", "재활병원", "정신병원",
        "클리닉", "센터", "의료센터", "건강센터", "보건소", "한방",
        "치과의원", "정형외과", "내과", "외과", "산부인과", "소아과",
        "피부과", "안과", "이비인후과", "의료", "진료소", "요양원", "한방진료실"
    );

    // 특별시/광역시 표기 통일을 위한 패턴
    private static final Pattern SPECIAL_CITY_PATTERN = Pattern.compile("서울특별시");
    private static final Pattern METRO_CITY_PATTERN = Pattern.compile("(부산|대구|인천|광주|대전|울산)광역시");

    /**
     * 주소를 기반으로 좌표를 계산합니다.
     * @param roadAddress 도로명주소
     * @param lotAddress 지번주소
     * @param businessName 사업장명 (로깅용)
     * @return [위도, 경도] 배열, 실패시 null
     */
    public BigDecimal[] getCoordinates(String roadAddress, String lotAddress, String businessName) {
        // 도로명주소 우선 시도
        if (roadAddress != null && !roadAddress.trim().isEmpty()) {
            BigDecimal[] coordinates = tryGetCoordinatesWithVariations(roadAddress, businessName);
            if (coordinates != null) {
                return coordinates;
            }
        }

        // 지번주소로 재시도
        if (lotAddress != null && !lotAddress.trim().isEmpty()) {
            BigDecimal[] coordinates = tryGetCoordinatesWithVariations(lotAddress, businessName);
            if (coordinates != null) {
                return coordinates;
            }
        }

        log.error("좌표 계산 실패 - 사업장명: {}, 도로명주소: {}, 지번주소: {}", 
                 businessName, roadAddress, lotAddress);
        return null;
    }

    /**
     * 주소 변형을 통한 좌표 계산 시도
     */
    private BigDecimal[] tryGetCoordinatesWithVariations(String address, String businessName) {
        List<String> addressVariations = generateAddressVariations(address);
        
        for (String variation : addressVariations) {
            BigDecimal[] coordinates = callKakaoApi(variation);
            if (coordinates != null) {
                log.debug("좌표 계산 성공 - 사업장명: {}, 사용된 주소: {}, 위도: {}, 경도: {}", 
                         businessName, variation, coordinates[0], coordinates[1]);
                return coordinates;
            }
        }
        
        return null;
    }

    /**
     * 주소 변형 패턴 생성
     */
    private List<String> generateAddressVariations(String originalAddress) {
        String cleaned = originalAddress.trim();
        
        // 1. 원본 주소
        String variation1 = cleaned;
        
        // 2. 병원 키워드 제거
        String variation2 = removeHospitalKeywords(cleaned);
        
        // 3. 건물 정보 제거 (층수, 호수)
        String variation3 = removeBuildingInfo(variation2);
        
        // 4. 괄호 내용 제거
        String variation4 = removeParentheses(variation3);
        
        // 5. 핵심 주소 추출 (시/도/구/동/번지)
        String variation5 = extractCoreAddress(variation4);
        
        return Arrays.asList(variation1, variation2, variation3, variation4, variation5)
                .stream()
                .distinct()
                .filter(addr -> addr.length() >= 5) // 최소 길이 보장
                .toList();
    }

    /**
     * 병원 관련 키워드 제거
     */
    private String removeHospitalKeywords(String address) {
        String result = address;
        for (String keyword : HOSPITAL_KEYWORDS) {
            result = result.replaceAll(keyword, "");
        }
        return normalizeAddress(result);
    }

    /**
     * 건물 정보 제거 (층수, 호수, 건물명)
     */
    private String removeBuildingInfo(String address) {
        return address
                .replaceAll("\\d+층", "")
                .replaceAll("\\d+호", "")
                .replaceAll("지하\\d*", "")
                .replaceAll("[가-힣]+빌딩", "")
                .replaceAll("[가-힣]+타워", "")
                .replaceAll("[가-힣]+상가", "")
                .trim();
    }

    /**
     * 괄호 내용 제거
     */
    private String removeParentheses(String address) {
        return address.replaceAll("\\([^)]*\\)", "").trim();
    }

    /**
     * 핵심 주소 추출
     */
    private String extractCoreAddress(String address) {
        // 기본적인 주소 구성요소만 남기기
        String result = address
                .replaceAll("[,\\-]+$", "") // 끝의 특수문자 제거
                .replaceAll("\\s+", " ") // 연속 공백 정리
                .trim();
        
        return normalizeAddress(result);
    }

    /**
     * 주소 표기 통일
     */
    private String normalizeAddress(String address) {
        String result = address;
        
        // 특별시/광역시 표기 통일
        result = SPECIAL_CITY_PATTERN.matcher(result).replaceAll("서울시");
        result = METRO_CITY_PATTERN.matcher(result).replaceAll("$1시");
        
        // 연속 공백 정리
        result = result.replaceAll("\\s+", " ").trim();
        
        return result;
    }

    /**
     * Kakao API 호출 (수동 URL 조합)
     */
    private BigDecimal[] callKakaoApi(String address) {
        try {
            // 수동으로 URL 조합 (UriComponentsBuilder 사용하지 않음)
//            String encodedAddress = java.net.URLEncoder.encode(address, "UTF-8");
//            String url = "https://dapi.kakao.com/v2/local/search/address.json?query=" + encodedAddress;
            String url = "https://dapi.kakao.com/v2/local/search/address.json?query=" + address;

            log.debug("=== Kakao API 호출 디버깅 ===");
            log.debug("원본 주소: {}", address);
//            log.debug("인코딩된 주소: {}", encodedAddress);
//            log.debug("최종 URL: {}", url);
            log.debug("최종 URL: {}", address);

            HttpHeaders headers = new HttpHeaders();
            headers.set("Authorization", "KakaoAK " + kakaoApiKey);
            headers.set("Content-Type", "application/json;charset=UTF-8");

            HttpEntity<String> entity = new HttpEntity<>(headers);
            ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);


            log.debug("응답 상태 코드: {}", response.getStatusCode());
            log.debug("응답 헤더: {}", response.getHeaders());
            log.debug("응답 본문: {}", response.getBody());
            log.debug("=============================");

            if (response.getStatusCode().is2xxSuccessful()) {
                return parseCoordinatesFromResponse(response.getBody());
            } else {
                log.warn("API 호출 실패 - 상태코드: {}, 주소: {}", response.getStatusCode(), address);
            }
        } catch (Exception e) {
            log.error("Kakao API 호출 중 오류 발생 - 주소: {}, 오류: {}", address, e.getMessage(), e);
        }

        return null;
    }

    /**
     * API 응답에서 좌표 추출
     */
    private BigDecimal[] parseCoordinatesFromResponse(String responseBody) {
        try {
            JsonNode root = objectMapper.readTree(responseBody);
            JsonNode documents = root.get("documents");
            
            if (documents != null && documents.isArray() && documents.size() > 0) {
                JsonNode firstDoc = documents.get(0);
                
                // road_address 우선 확인
                JsonNode roadAddress = firstDoc.get("road_address");
                if (roadAddress != null && !roadAddress.isNull()) {
                    String lat = roadAddress.get("y").asText();
                    String lon = roadAddress.get("x").asText();
                    BigDecimal[] coordinates = {new BigDecimal(lat), new BigDecimal(lon)};
                    
                    if (isValidKoreanCoordinate(coordinates)) {
                        return coordinates;
                    }
                }
                
                // address 확인
                JsonNode address = firstDoc.get("address");
                if (address != null && !address.isNull()) {
                    String lat = address.get("y").asText();
                    String lon = address.get("x").asText();
                    BigDecimal[] coordinates = {new BigDecimal(lat), new BigDecimal(lon)};
                    
                    if (isValidKoreanCoordinate(coordinates)) {
                        return coordinates;
                    }
                }
            }
        } catch (Exception e) {
            log.warn("좌표 파싱 중 오류 발생: {}", e.getMessage());
        }
        
        return null;
    }

    /**
     * 한국 영역 내 좌표인지 검증
     */
    private boolean isValidKoreanCoordinate(BigDecimal[] coordinates) {
        if (coordinates == null || coordinates.length != 2) {
            return false;
        }
        
        BigDecimal lat = coordinates[0];
        BigDecimal lon = coordinates[1];
        
        // 한국 영역: 위도 33.0~38.7, 경도 124.0~132.0
        return lat.compareTo(new BigDecimal("33.0")) >= 0 && 
               lat.compareTo(new BigDecimal("38.7")) <= 0 &&
               lon.compareTo(new BigDecimal("124.0")) >= 0 && 
               lon.compareTo(new BigDecimal("132.0")) <= 0;
    }
}
```

---

## 4. 데이터 처리 프로세서 (HospitalDataProcessor.java)

**파일 경로:** `src/main/java/com/WhereHouse/AnalysisData/hospital/processor/HospitalDataProcessor.java`

```java
package com.WhereHouse.AnalysisData.hospital.processor;

import com.WhereHouse.AnalysisData.hospital.entity.AnalysisHospitalData;
import com.WhereHouse.AnalysisData.hospital.repository.AnalysisHospitalDataRepository;
import com.WhereHouse.AnalysisData.hospital.service.KakaoCoordinateService;
import com.WhereHouse.AnalysisStaticData.HospitalSave.entity.HospitalData;
import com.WhereHouse.AnalysisStaticData.HospitalSave.repository.HospitalDataRepository;
import jakarta.persistence.EntityManager;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Component
@RequiredArgsConstructor
@Slf4j
public class HospitalDataProcessor {

    private final HospitalDataRepository hospitalDataRepository;
    private final AnalysisHospitalDataRepository analysisHospitalDataRepository;
    private final KakaoCoordinateService kakaoCoordinateService;
    private final EntityManager entityManager;

    private static final int BATCH_SIZE = 1000;

    /**
     * 병원 데이터 분석용 테이블 생성 메인 프로세스
     */
    @Transactional
    public void processHospitalDataForAnalysis() {
        log.info("=== 병원 데이터 분석용 테이블 생성 작업 시작 ===");
        LocalDateTime startTime = LocalDateTime.now();

        // 기존 분석용 데이터 삭제 (선택사항)
        log.info("기존 분석용 데이터 삭제 중...");
        analysisHospitalDataRepository.deleteAll();
        entityManager.flush();
        entityManager.clear();

        // 전체 데이터 개수 조회
        long totalCount = hospitalDataRepository.count();
        log.info("처리 대상 원천 데이터: {} 개", totalCount);

        // 통계 변수 초기화
        ProcessingStats stats = new ProcessingStats();
        stats.totalSourceData = (int) totalCount;

        // 배치 처리
        int totalPages = (int) Math.ceil((double) totalCount / BATCH_SIZE);
        
        for (int page = 0; page < totalPages; page++) {
            processBatch(page, stats);
            
            // 메모리 관리
            entityManager.flush();
            entityManager.clear();
            
            // 진행률 로깅
            int processed = (page + 1) * BATCH_SIZE;
            int actualProcessed = Math.min(processed, (int) totalCount);
            log.info("진행률: {}/{} ({:.1f}%)", 
                    actualProcessed, totalCount, 
                    (actualProcessed * 100.0 / totalCount));
        }

        // 최종 결과 출력
        LocalDateTime endTime = LocalDateTime.now();
        printFinalResults(stats, startTime, endTime);
    }

    /**
     * 배치 단위 데이터 처리
     */
    private void processBatch(int page, ProcessingStats stats) {
        PageRequest pageRequest = PageRequest.of(page, BATCH_SIZE);
        Page<HospitalData> hospitalDataPage = hospitalDataRepository.findAll(pageRequest);
        
        List<AnalysisHospitalData> batchList = new ArrayList<>();
        
        for (HospitalData sourceData : hospitalDataPage.getContent()) {
            try {
                AnalysisHospitalData analysisData = convertToAnalysisData(sourceData, stats);
                if (analysisData != null) {
                    batchList.add(analysisData);
                    stats.successfulConversions++;
                }
            } catch (Exception e) {
                stats.failedConversions++;
                log.error("데이터 변환 실패 - ID: {}, 사업장명: {}, 오류: {}", 
                         sourceData.getId(), sourceData.getBusinessName(), e.getMessage());
            }
        }
        
        // 배치 저장
        if (!batchList.isEmpty()) {
            analysisHospitalDataRepository.saveAll(batchList);
        }
    }

    /**
     * 원천 데이터를 분석용 데이터로 변환
     */
    private AnalysisHospitalData convertToAnalysisData(HospitalData sourceData, ProcessingStats stats) {
        AnalysisHospitalData.AnalysisHospitalDataBuilder builder = AnalysisHospitalData.builder();
        
        // 기본 정보 변환 (NULL 처리 적용)
        builder.businessName(processStringField(sourceData.getBusinessName()))
               .businessTypeName(processStringField(sourceData.getBusinessTypeName()))
               .detailedStatusName(processStringField(sourceData.getDetailedStatusName()))
               .phoneNumber(processStringField(sourceData.getPhoneNumber()))
               .lotAddress(processStringField(sourceData.getLotAddress()))
               .roadAddress(processStringField(sourceData.getRoadAddress()));

        // 상세영업상태별 통계 업데이트
        String statusName = sourceData.getDetailedStatusName();
        stats.statusDistribution.merge(statusName != null ? statusName : "데이터없음", 1, Integer::sum);

        // 업종별 통계 업데이트
        String businessType = sourceData.getBusinessTypeName();
        stats.businessTypeDistribution.merge(businessType != null ? businessType : "데이터없음", 1, Integer::sum);

        // 좌표 계산 (기존 좌표는 무시하고 Kakao API로만 계산)
        BigDecimal[] coordinates = kakaoCoordinateService.getCoordinates(
            sourceData.getRoadAddress(),
            sourceData.getLotAddress(),
            sourceData.getBusinessName()
        );

        if (coordinates != null) {
            builder.latitude(coordinates[0])
                   .longitude(coordinates[1]);
            stats.successfulCoordinates++;
        } else {
            // 좌표 계산 실패 시 NULL로 저장
            builder.latitude(null)
                   .longitude(null);
            stats.failedCoordinates++;
        }

        return builder.build();
    }

    /**
     * 문자열 필드 NULL 처리
     */
    private String processStringField(String value) {
        if (value == null || value.trim().isEmpty()) {
            return "데이터없음";
        }
        return value.trim();
    }

    /**
     * 최종 결과 출력
     */
    private void printFinalResults(ProcessingStats stats, LocalDateTime startTime, LocalDateTime endTime) {
        long processingTimeSeconds = java.time.Duration.between(startTime, endTime).getSeconds();
        long minutes = processingTimeSeconds / 60;
        long seconds = processingTimeSeconds % 60;

        log.info("\n=== 병원 데이터 분석용 테이블 생성 작업 완료 ===");
        log.info("- 원천 데이터: {} 개", stats.totalSourceData);
        log.info("- 데이터 변환: 성공 {} 개, 실패 {} 개", 
                stats.successfulConversions, stats.failedConversions);
        
        if (stats.successfulConversions > 0) {
            double coordinateSuccessRate = (stats.successfulCoordinates * 100.0) / stats.successfulConversions;
            log.info("- 좌표 계산: 성공 {} 개 ({:.1f}%), 실패 {} 개 ({:.1f}%)", 
                    stats.successfulCoordinates, coordinateSuccessRate,
                    stats.failedCoordinates, (100.0 - coordinateSuccessRate));
        }

        // 업종별 분포 (상위 10개)
        log.info("- 업종별 분포:");
        stats.businessTypeDistribution.entrySet().stream()
                .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
                .limit(10)
                .forEach(entry -> log.info("  {} : {} 개", entry.getKey(), entry.getValue()));

        // 상세영업상태별 분포
        log.info("- 상세영업상태별 분포:");
        stats.statusDistribution.entrySet().stream()
                .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
                .forEach(entry -> log.info("  {} : {} 개", entry.getKey(), entry.getValue()));

        log.info("- 처리 시간: {}분 {}초", minutes, seconds);
        log.info("- 완료 시각: {}", endTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
        log.info("===========================================\n");
    }

    /**
     * 데이터 품질 검증 메서드
     */
    public void validateDataQuality() {
        log.info("\n=== 데이터 품질 검증 ===");
        
        Long totalCount = analysisHospitalDataRepository.getTotalCount();
        Long coordinateCount = analysisHospitalDataRepository.getCoordinateCount();
        
        if (totalCount != null && coordinateCount != null) {
            double completionRate = (coordinateCount * 100.0) / totalCount;
            log.info("전체 데이터: {} 개", totalCount);
            log.info("좌표 보유: {} 개 ({:.1f}%)", coordinateCount, completionRate);
        }

        // 업종별 분포 확인
        List<Object[]> businessTypeStats = analysisHospitalDataRepository.countByBusinessType();
        log.info("업종별 분포:");
        businessTypeStats.forEach(stat -> 
            log.info("  {} : {} 개", stat[0], stat[1]));

        // 상세영업상태별 분포 확인
        List<Object[]> statusStats = analysisHospitalDataRepository.countByDetailedStatus();
        log.info("상세영업상태별 분포:");
        statusStats.forEach(stat -> 
            log.info("  {} : {} 개", stat[0], stat[1]));
            
        log.info("========================\n");
    }

    /**
     * 처리 통계 클래스
     */
    private static class ProcessingStats {
        int totalSourceData = 0;
        int successfulConversions = 0;
        int failedConversions = 0;
        int successfulCoordinates = 0;
        int failedCoordinates = 0;
        Map<String, Integer> businessTypeDistribution = new HashMap<>();
        Map<String, Integer> statusDistribution = new HashMap<>();
    }
}
```

---

## 5. 메인 실행 클래스 (HospitalAnalysisMain.java)

**파일 경로:** `src/main/java/com/WhereHouse/AnalysisData/hospital/HospitalAnalysisMain.java`

```java
package com.WhereHouse.AnalysisData.hospital;

import com.WhereHouse.AnalysisData.hospital.processor.HospitalDataProcessor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Profile;

@SpringBootApplication(scanBasePackages = "com.WhereHouse")
@RequiredArgsConstructor
@Slf4j
@Profile("hospital-analysis") // 프로파일을 통한 실행 제어
public class HospitalAnalysisMain implements CommandLineRunner {

    private final HospitalDataProcessor hospitalDataProcessor;

    public static void main(String[] args) {
        System.setProperty("spring.profiles.active", "hospital-analysis");
        SpringApplication.run(HospitalAnalysisMain.class, args);
    }

    @Override
    public void run(String... args) throws Exception {
        try {
            log.info("병원 데이터 분석용 시스템 실행 시작");
            
            // 메인 처리 프로세스 실행
            hospitalDataProcessor.processHospitalDataForAnalysis();
            
            // 데이터 품질 검증
            hospitalDataProcessor.validateDataQuality();
            
            log.info("병원 데이터 분석용 시스템 실행 완료");
            
        } catch (Exception e) {
            log.error("병원 데이터 처리 중 오류 발생", e);
            throw e;
        }
    }
}
```

---

## 6. DDL 스크립트 (create_analysis_hospital_table.sql)

**파일 경로:** `database/create_analysis_hospital_table.sql`

```sql
-- 병원 데이터 분석용 테이블 생성 DDL 스크립트
-- 작성일: 2025.09.08
-- 목적: 피어슨 상관분석용 병원 데이터 테이블 구축

-- 기존 테이블 및 시퀀스 삭제 (필요시)
-- DROP TABLE ANALYSIS_HOSPITAL_DATA CASCADE CONSTRAINTS;
-- DROP SEQUENCE SEQ_ANALYSIS_HOSPITAL_DATA;

-- 시퀀스 생성
CREATE SEQUENCE SEQ_ANALYSIS_HOSPITAL_DATA
    START WITH 1
    INCREMENT BY 1
    NOCACHE
    NOCYCLE;

-- 분석용 병원 데이터 테이블 생성
CREATE TABLE ANALYSIS_HOSPITAL_DATA (
    ID NUMBER PRIMARY KEY,
    BUSINESS_NAME VARCHAR2(4000),
    BUSINESS_TYPE_NAME VARCHAR2(4000), 
    DETAILED_STATUS_NAME VARCHAR2(4000),
    PHONE_NUMBER VARCHAR2(4000),
    LOT_ADDRESS VARCHAR2(4000),
    ROAD_ADDRESS VARCHAR2(4000),
    LATITUDE NUMBER(10,7),
    LONGITUDE NUMBER(10,7),
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 테이블 및 컬럼 코멘트 추가
COMMENT ON TABLE ANALYSIS_HOSPITAL_DATA IS '병원 데이터 분석용 테이블 - 피어슨 상관분석 독립변수(의료기관 밀도) 데이터';
COMMENT ON COLUMN ANALYSIS_HOSPITAL_DATA.ID IS '기본키 (자동생성)';
COMMENT ON COLUMN ANALYSIS_HOSPITAL_DATA.BUSINESS_NAME IS '사업장명';
COMMENT ON COLUMN ANALYSIS_HOSPITAL_DATA.BUSINESS_TYPE_NAME IS '업종명 (병원, 의원, 치과의원 등)';
COMMENT ON COLUMN ANALYSIS_HOSPITAL_DATA.DETAILED_STATUS_NAME IS '상세영업상태명 (영업, 폐업, 휴업 등)';
COMMENT ON COLUMN ANALYSIS_HOSPITAL_DATA.PHONE_NUMBER IS '전화번호';
COMMENT ON COLUMN ANALYSIS_HOSPITAL_DATA.LOT_ADDRESS IS '지번주소';
COMMENT ON COLUMN ANALYSIS_HOSPITAL_DATA.ROAD_ADDRESS IS '도로명주소';
COMMENT ON COLUMN ANALYSIS_HOSPITAL_DATA.LATITUDE IS '위도 (Kakao API 계산)';
COMMENT ON COLUMN ANALYSIS_HOSPITAL_DATA.LONGITUDE IS '경도 (Kakao API 계산)';
COMMENT ON COLUMN ANALYSIS_HOSPITAL_DATA.CREATED_AT IS '생성일시';
COMMENT ON COLUMN ANALYSIS_HOSPITAL_DATA.UPDATED_AT IS '수정일시';

-- 테이블 생성 확인
SELECT TABLE_NAME, COMMENTS 
FROM USER_TAB_COMMENTS 
WHERE TABLE_NAME = 'ANALYSIS_HOSPITAL_DATA';

-- 컬럼 정보 확인
SELECT COLUMN_NAME, DATA_TYPE, NULLABLE, COMMENTS
FROM USER_COL_COMMENTS 
WHERE TABLE_NAME = 'ANALYSIS_HOSPITAL_DATA'
ORDER BY COLUMN_ID;
```

---

## 7. Application 설정 파일 (application.yml)

**파일 경로:** `src/main/resources/application.yml`

```yaml
# 병원 데이터 분석용 시스템 설정
spring:
  profiles:
    active: hospital-analysis
  
  # 데이터베이스 설정
  datasource:
    driver-class-name: oracle.jdbc.OracleDriver
    url: jdbc:oracle:thin:@localhost:1521:XE  # 실제 DB 정보로 변경
    username: your_username  # 실제 사용자명으로 변경
    password: your_password  # 실제 비밀번호로 변경
    
    # 커넥션 풀 설정
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 60000
      idle-timeout: 300000
      max-lifetime: 900000
      leak-detection-threshold: 60000

  # JPA 설정
  jpa:
    hibernate:
      ddl-auto: none  # 테이블은 수동으로 생성
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
    show-sql: false  # 운영 시에는 false로 설정
    properties:
      hibernate:
        dialect: org.hibernate.dialect.OracleDialect
        format_sql: true
        jdbc:
          batch_size: 1000  # 배치 크기와 동일하게 설정
        order_inserts: true
        order_updates: true
        batch_versioned_data: true
        connection:
          provider_disables_autocommit: true

# Kakao API 설정
kakao:
  api:
    key: your_kakao_api_key  # 실제 Kakao API 키로 변경
    url: https://dapi.kakao.com/v2/local/search/address.json

# 로깅 설정
logging:
  level:
    com.WhereHouse.AnalysisData.hospital: DEBUG
    org.springframework.web.client.RestTemplate: DEBUG
    org.hibernate.SQL: WARN  # SQL 로그는 필요시에만 DEBUG로 변경
    org.hibernate.type.descriptor.sql.BasicBinder: WARN
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: logs/hospital-analysis.log
    max-size: 100MB
    max-history: 30

# 시스템 성능 설정
server:
  tomcat:
    threads:
      max: 200
      min-spare: 10

# 커스텀 설정
hospital-analysis:
  batch:
    size: 1000  # 배치 처리 크기
    log-interval: 1000  # 로그 출력 간격
  coordinate:
    retry-count: 5  # 주소 변형 시도 횟수
    validation:
      latitude:
        min: 33.0  # 한국 최남단 위도
        max: 38.7  # 한국 최북단 위도
      longitude:
        min: 124.0  # 한국 최서단 경도
        max: 132.0  # 한국 최동단 경도

---
# 개발환경 설정
spring:
  config:
    activate:
      on-profile: development
  jpa:
    show-sql: true
    properties:
      hibernate:
        format_sql: true

logging:
  level:
    com.WhereHouse.AnalysisData.hospital: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE

---
# 운영환경 설정
spring:
  config:
    activate:
      on-profile: production
  jpa:
    show-sql: false
    properties:
      hibernate:
        format_sql: false

logging:
  level:
    com.WhereHouse.AnalysisData.hospital: INFO
    org.hibernate.SQL: WARN
    org.hibernate.type.descriptor.sql.BasicBinder: WARN
```

---

## 📋 구현 순서 및 실행 가이드

### **1단계: 데이터베이스 설정**
```bash
# DDL 스크립트 실행
sqlplus username/password@database < create_analysis_hospital_table.sql
```

### **2단계: 설정 파일 수정**
1. `application.yml`에서 데이터베이스 정보 수정
2. Kakao API 키 설정

### **3단계: 프로젝트 빌드 및 실행**
```bash
# 프로젝트 빌드
./gradlew build

# 실행
java -jar build/libs/your-project-name.jar --spring.profiles.active=hospital-analysis
```

### **4단계: 실행 결과 확인**
1. 로그 파일 확인: `logs/hospital-analysis.log`
2. 데이터베이스에서 결과 테이블 조회

---

## 🎯 주요 기능 및 특징

- **기존 좌표 무시**: COORDINATE_X, COORDINATE_Y 완전 무시하고 Kakao API로만 계산
- **병원 특화 전처리**: 의료기관명, 진료과목 체계적 제거로 API 인식률 향상
- **5단계 주소 변형**: 원본 → 병원키워드제거 → 건물정보제거 → 괄호제거 → 핵심주소추출
- **1000개 단위 배치 처리**: 메모리 효율성과 성능 최적화
- **상세한 디버깅**: API 호출 URL, 응답 상태, 응답 본문 전체 로그 출력
- **품질 검증**: 좌표 완성도, 업종별/상태별 분포, 데이터 무결성 검증