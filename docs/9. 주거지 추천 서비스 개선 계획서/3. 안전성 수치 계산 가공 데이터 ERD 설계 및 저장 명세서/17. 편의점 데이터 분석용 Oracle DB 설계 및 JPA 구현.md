# 편의점 데이터 분석용 시스템 구현 완성 문서

**프로젝트명:** 안전성 점수 계산 시스템 - 편의점 통계 분석 데이터 처리  
**버전:** 1.0  
**작성일:** 2025.09.08  
**목적:** 전국 편의점 정보를 피어슨 상관분석 계산에 활용하기 위한 분석용 테이블 구축

---

## 📋 목차

1. [시스템 개요](#1-시스템-개요)
2. [데이터베이스 구성](#2-데이터베이스-구성)
3. [구현 파일 목록](#3-구현-파일-목록)
4. [상세 구현 코드](#4-상세-구현-코드)
5. [설정 파일](#5-설정-파일)
6. [실행 방법](#6-실행-방법)
7. [데이터 검증](#7-데이터-검증)

---

## 1. 시스템 개요

### 1.1 아키텍처 구조
```
AnalysisDataProcessor (메인 진입점)
    ↓ 호출
ConvenienceStoreCoordinateProcessor (편의점 전용 처리기)
    ↓ 사용
├── ConvenienceStoreDataRepository (원천 데이터 읽기)
├── KakaoConvenienceCoordinateService (좌표 계산 서비스)
└── AnalysisConvenienceStoreRepository (분석용 데이터 저장)
```

### 1.2 핵심 특징
- **원천 데이터 보호**: 읽기 전용, 절대 수정/삭제 없음
- **배치 처리**: 1000개씩 나누어 메모리 효율적 처리
- **편의점 특화**: 브랜드명 제거 및 주소 전처리로 API 성공률 향상
- **단계별 재시도**: 5단계 주소 변형으로 좌표 계산 성공률 극대화
- **실시간 모니터링**: 진행률, 성공/실패 통계 실시간 출력

---

## 2. 데이터베이스 구성

### 2.1 테이블 생성 DDL

```sql
-- 편의점 분석용 테이블 및 시퀀스 생성 DDL

-- 기존 객체 삭제 (있는 경우)
DROP SEQUENCE SEQ_ANALYSIS_CONVENIENCE_STORE_DATA;
DROP TABLE ANALYSIS_CONVENIENCE_STORE_DATA;

-- 분석용 테이블 생성
CREATE TABLE ANALYSIS_CONVENIENCE_STORE_DATA (
    ID NUMBER NOT NULL,
    BUSINESS_NAME VARCHAR2(4000),
    DETAILED_STATUS_NAME VARCHAR2(4000),
    PHONE_NUMBER VARCHAR2(4000),
    LOT_ADDRESS VARCHAR2(4000),
    ROAD_ADDRESS VARCHAR2(4000),
    LATITUDE NUMBER(10,7),
    LONGITUDE NUMBER(10,7),
    CONSTRAINT PK_ANALYSIS_CONVENIENCE_STORE PRIMARY KEY (ID)
);

-- 시퀀스 생성
CREATE SEQUENCE SEQ_ANALYSIS_CONVENIENCE_STORE_DATA
    START WITH 1
    INCREMENT BY 1
    NOCACHE
    NOCYCLE;

-- 테이블 코멘트
COMMENT ON TABLE ANALYSIS_CONVENIENCE_STORE_DATA IS '편의점 데이터 분석용 테이블 - 피어슨 상관분석용';
COMMENT ON COLUMN ANALYSIS_CONVENIENCE_STORE_DATA.ID IS 'Primary Key';
COMMENT ON COLUMN ANALYSIS_CONVENIENCE_STORE_DATA.BUSINESS_NAME IS '사업장명';
COMMENT ON COLUMN ANALYSIS_CONVENIENCE_STORE_DATA.DETAILED_STATUS_NAME IS '상세영업상태명';
COMMENT ON COLUMN ANALYSIS_CONVENIENCE_STORE_DATA.PHONE_NUMBER IS '전화번호';
COMMENT ON COLUMN ANALYSIS_CONVENIENCE_STORE_DATA.LOT_ADDRESS IS '지번주소';
COMMENT ON COLUMN ANALYSIS_CONVENIENCE_STORE_DATA.ROAD_ADDRESS IS '도로명주소';
COMMENT ON COLUMN ANALYSIS_CONVENIENCE_STORE_DATA.LATITUDE IS '위도 (Kakao API 계산)';
COMMENT ON COLUMN ANALYSIS_CONVENIENCE_STORE_DATA.LONGITUDE IS '경도 (Kakao API 계산)';
```

### 2.2 테이블 구조 설명

| 컬럼명 | 데이터 타입 | 설명 | NULL 허용 |
|--------|-------------|------|-----------|
| ID | NUMBER | Primary Key (자동생성) | NO |
| BUSINESS_NAME | VARCHAR2(4000) | 사업장명 | YES |
| DETAILED_STATUS_NAME | VARCHAR2(4000) | 상세영업상태명 | YES |
| PHONE_NUMBER | VARCHAR2(4000) | 전화번호 | YES |
| LOT_ADDRESS | VARCHAR2(4000) | 지번주소 | YES |
| ROAD_ADDRESS | VARCHAR2(4000) | 도로명주소 | YES |
| LATITUDE | NUMBER(10,7) | 위도 (Kakao API 계산) | YES |
| LONGITUDE | NUMBER(10,7) | 경도 (Kakao API 계산) | YES |

---

## 3. 구현 파일 목록

### 3.1 추가된 파일 목록

1. **Entity**: `AnalysisConvenienceStoreData.java` - 분석용 데이터 엔티티
2. **Repository**: `AnalysisConvenienceStoreRepository.java` - 분석용 데이터 저장소
3. **Service**: `KakaoConvenienceCoordinateService.java` - Kakao API 좌표 계산 서비스
4. **Processor**: `ConvenienceStoreCoordinateProcessor.java` - 메인 처리 로직

### 3.2 수정된 파일

- **기존 AnalysisDataProcessor.java**: 편의점 처리기 호출 로직 추가
- **기존 ConvenienceStoreDataRepository.java**: 분석용 조회 메서드 추가

---

## 4. 상세 구현 코드

### 4.1 AnalysisConvenienceStoreData.java

```java
package com.WhereHouse.AnalysisData.convenience.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;

/**
 * 편의점 데이터 분석용 Entity
 * 피어슨 상관분석에서 독립변수(상권 밀도) 데이터로 활용
 */
@Entity
@Table(name = "ANALYSIS_CONVENIENCE_STORE_DATA")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AnalysisConvenienceStoreData {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "analysis_convenience_seq")
    @SequenceGenerator(name = "analysis_convenience_seq", 
                      sequenceName = "SEQ_ANALYSIS_CONVENIENCE_STORE_DATA", 
                      allocationSize = 1)
    @Column(name = "ID")
    private Long id;

    @Column(name = "BUSINESS_NAME", length = 4000)
    private String businessName;                        // 사업장명

    @Column(name = "DETAILED_STATUS_NAME", length = 4000)
    private String detailedStatusName;                  // 상세영업상태명

    @Column(name = "PHONE_NUMBER", length = 4000)
    private String phoneNumber;                         // 전화번호

    @Column(name = "LOT_ADDRESS", length = 4000)
    private String lotAddress;                          // 지번주소

    @Column(name = "ROAD_ADDRESS", length = 4000)
    private String roadAddress;                         // 도로명주소

    @Column(name = "LATITUDE", precision = 10, scale = 7)
    private BigDecimal latitude;                        // 위도 (Kakao API 계산)

    @Column(name = "LONGITUDE", precision = 10, scale = 7)
    private BigDecimal longitude;                       // 경도 (Kakao API 계산)

    /**
     * 원천 데이터에서 분석용 데이터로 변환하는 정적 팩토리 메서드
     * NULL 값 처리 규칙을 적용하여 변환
     */
    public static AnalysisConvenienceStoreData fromSourceData(
            String businessName,
            String detailedStatusName,
            String phoneNumber,
            String lotAddress,
            String roadAddress) {
        
        return AnalysisConvenienceStoreData.builder()
                .businessName(nullToDefault(businessName, "데이터없음"))
                .detailedStatusName(nullToDefault(detailedStatusName, "데이터없음"))
                .phoneNumber(nullToDefault(phoneNumber, "데이터없음"))
                .lotAddress(nullToDefault(lotAddress, "데이터없음"))
                .roadAddress(nullToDefault(roadAddress, "데이터없음"))
                .build();
    }

    /**
     * 좌표 정보 설정
     */
    public void setCoordinates(BigDecimal latitude, BigDecimal longitude) {
        this.latitude = latitude;
        this.longitude = longitude;
    }

    /**
     * 좌표 정보 유효성 검증 (한국 영역 내 좌표 여부)
     */
    public boolean isValidKoreanCoordinates() {
        if (latitude == null || longitude == null) {
            return false;
        }
        
        double lat = latitude.doubleValue();
        double lng = longitude.doubleValue();
        
        // 한국 영역: 위도 33.0~38.7, 경도 124.0~132.0
        return lat >= 33.0 && lat <= 38.7 && lng >= 124.0 && lng <= 132.0;
    }

    /**
     * 주소 정보 반환 (도로명주소 우선, 없으면 지번주소)
     */
    public String getPrimaryAddress() {
        if (roadAddress != null && !roadAddress.trim().isEmpty() && !"데이터없음".equals(roadAddress)) {
            return roadAddress;
        }
        if (lotAddress != null && !lotAddress.trim().isEmpty() && !"데이터없음".equals(lotAddress)) {
            return lotAddress;
        }
        return null;
    }

    /**
     * NULL 값을 기본값으로 변환하는 유틸리티 메서드
     */
    private static String nullToDefault(String value, String defaultValue) {
        if (value == null || value.trim().isEmpty()) {
            return defaultValue;
        }
        return value.trim();
    }

    /**
     * 좌표 정보 보유 여부
     */
    public boolean hasCoordinates() {
        return latitude != null && longitude != null;
    }

    /**
     * 유효한 주소 정보 보유 여부
     */
    public boolean hasValidAddress() {
        return getPrimaryAddress() != null;
    }

    @Override
    public String toString() {
        return String.format("AnalysisConvenienceStoreData{id=%d, businessName='%s', status='%s', hasCoordinates=%s}", 
                           id, businessName, detailedStatusName, hasCoordinates());
    }
}
```

### 4.2 AnalysisConvenienceStoreRepository.java

```java
package com.WhereHouse.AnalysisData.convenience.repository;

import com.WhereHouse.AnalysisData.convenience.entity.AnalysisConvenienceStoreData;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * 편의점 분석용 데이터 Repository
 * 통계 쿼리 및 데이터 검증을 위한 메서드 제공
 */
@Repository
public interface AnalysisConvenienceStoreRepository extends JpaRepository<AnalysisConvenienceStoreData, Long> {

    /**
     * 전체 데이터 개수 조회
     */
    @Query("SELECT COUNT(a) FROM AnalysisConvenienceStoreData a")
    long getTotalCount();

    /**
     * 좌표 정보 보유 데이터 개수 조회
     */
    @Query("SELECT COUNT(a) FROM AnalysisConvenienceStoreData a WHERE a.latitude IS NOT NULL AND a.longitude IS NOT NULL")
    long getCoordinateCount();

    /**
     * 좌표 완성도 비율 계산
     */
    @Query("SELECT CAST(COUNT(CASE WHEN a.latitude IS NOT NULL AND a.longitude IS NOT NULL THEN 1 END) AS double) / CAST(COUNT(a) AS double) * 100 " +
           "FROM AnalysisConvenienceStoreData a")
    Double getCoordinateCompletionRate();

    /**
     * 상세영업상태별 분포 조회
     */
    @Query("SELECT a.detailedStatusName, COUNT(a) " +
           "FROM AnalysisConvenienceStoreData a " +
           "GROUP BY a.detailedStatusName " +
           "ORDER BY COUNT(a) DESC")
    List<Object[]> getStatusDistribution();

    /**
     * 좌표 정보가 있는 데이터만 조회
     */
    @Query("SELECT a FROM AnalysisConvenienceStoreData a WHERE a.latitude IS NOT NULL AND a.longitude IS NOT NULL")
    List<AnalysisConvenienceStoreData> findAllWithCoordinates();

    /**
     * 특정 상세영업상태의 데이터 개수 조회
     */
    @Query("SELECT COUNT(a) FROM AnalysisConvenienceStoreData a WHERE a.detailedStatusName = :statusName")
    long countByDetailedStatusName(String statusName);

    /**
     * 영업중인 편의점만 조회
     */
    @Query("SELECT a FROM AnalysisConvenienceStoreData a WHERE a.detailedStatusName LIKE '%영업%'")
    List<AnalysisConvenienceStoreData> findActiveStores();

    /**
     * 특정 지역(주소 포함) 편의점 조회
     */
    @Query("SELECT a FROM AnalysisConvenienceStoreData a " +
           "WHERE a.roadAddress LIKE %:region% OR a.lotAddress LIKE %:region%")
    List<AnalysisConvenienceStoreData> findByRegion(String region);

    /**
     * 좌표 범위로 편의점 조회 (특정 지역 내)
     */
    @Query("SELECT a FROM AnalysisConvenienceStoreData a " +
           "WHERE a.latitude BETWEEN :minLat AND :maxLat " +
           "AND a.longitude BETWEEN :minLng AND :maxLng")
    List<AnalysisConvenienceStoreData> findByCoordinateRange(
            Double minLat, Double maxLat, Double minLng, Double maxLng);

    /**
     * 데이터 품질 검증을 위한 통계 정보 조회
     */
    @Query("SELECT " +
           "COUNT(a) as totalCount, " +
           "COUNT(CASE WHEN a.latitude IS NOT NULL AND a.longitude IS NOT NULL THEN 1 END) as coordinateCount, " +
           "COUNT(CASE WHEN a.businessName != '데이터없음' THEN 1 END) as validBusinessNameCount, " +
           "COUNT(CASE WHEN a.phoneNumber != '데이터없음' THEN 1 END) as validPhoneCount " +
           "FROM AnalysisConvenienceStoreData a")
    Object[] getDataQualityStats();

    /**
     * 주소별 편의점 밀도 조회 (시/구 단위)
     */
    @Query("SELECT " +
           "CASE " +
           "  WHEN a.roadAddress IS NOT NULL AND a.roadAddress != '데이터없음' " +
           "  THEN SUBSTRING(a.roadAddress, 1, LOCATE(' ', a.roadAddress, LOCATE(' ', a.roadAddress) + 1)) " +
           "  ELSE SUBSTRING(a.lotAddress, 1, LOCATE(' ', a.lotAddress, LOCATE(' ', a.lotAddress) + 1)) " +
           "END as region, " +
           "COUNT(a) as storeCount " +
           "FROM AnalysisConvenienceStoreData a " +
           "WHERE (a.roadAddress IS NOT NULL AND a.roadAddress != '데이터없음') " +
           "   OR (a.lotAddress IS NOT NULL AND a.lotAddress != '데이터없음') " +
           "GROUP BY " +
           "CASE " +
           "  WHEN a.roadAddress IS NOT NULL AND a.roadAddress != '데이터없음' " +
           "  THEN SUBSTRING(a.roadAddress, 1, LOCATE(' ', a.roadAddress, LOCATE(' ', a.roadAddress) + 1)) " +
           "  ELSE SUBSTRING(a.lotAddress, 1, LOCATE(' ', a.lotAddress, LOCATE(' ', a.lotAddress) + 1)) " +
           "END " +
           "ORDER BY COUNT(a) DESC")
    List<Object[]> getRegionalDensity();

    /**
     * 최근 저장된 데이터 조회 (상위 N개)
     */
    @Query("SELECT a FROM AnalysisConvenienceStoreData a ORDER BY a.id DESC")
    List<AnalysisConvenienceStoreData> findRecentData(org.springframework.data.domain.Pageable pageable);

    /**
     * 중복 사업장명 조회
     */
    @Query("SELECT a.businessName, COUNT(a) " +
           "FROM AnalysisConvenienceStoreData a " +
           "WHERE a.businessName != '데이터없음' " +
           "GROUP BY a.businessName " +
           "HAVING COUNT(a) > 1 " +
           "ORDER BY COUNT(a) DESC")
    List<Object[]> findDuplicateBusinessNames();
}
```

### 4.3 KakaoConvenienceCoordinateService.java

```java
package com.WhereHouse.AnalysisData.convenience.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Kakao Local API를 활용한 편의점 특화 좌표 계산 서비스
 * 편의점 브랜드명 제거 및 주소 전처리를 통한 API 인식률 향상
 */
@Service
@Slf4j
public class KakaoConvenienceCoordinateService {

    @Value("${kakao.api.key}")
    private String kakaoApiKey;

    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    
    // API 호출 통계
    private final AtomicLong totalApiCalls = new AtomicLong(0);
    private final AtomicLong successfulApiCalls = new AtomicLong(0);
    private final AtomicLong failedApiCalls = new AtomicLong(0);

    // 편의점 브랜드 키워드 (제거 대상)
    private static final Set<String> CONVENIENCE_STORE_KEYWORDS = Set.of(
            "세븐일레븐", "세븐-일레븐", "7-ELEVEN", "7ELEVEN",
            "CU", "씨유",
            "GS25", "지에스25",
            "이마트24", "EMART24",
            "미니스톱", "MINISTOP",
            "바이더웨이", "BY THE WAY",
            "편의점", "점포", "매장", "스토어", "STORE"
    );

    // 주소 정제 시 제거할 패턴
    private static final List<String> BUILDING_PATTERNS = Arrays.asList(
            "\\d+층", "\\d+호", "지하\\d+층", "\\d+F", "B\\d+",
            "빌딩", "타워", "상가", "플라자", "센터", "몰"
    );

    public KakaoConvenienceCoordinateService() {
        this.restTemplate = new RestTemplate();
        this.objectMapper = new ObjectMapper();
    }

    /**
     * 편의점 주소를 기반으로 좌표 계산
     * 편의점 특화 주소 전처리를 통해 API 인식률 향상
     */
    public CoordinateResult calculateCoordinates(String roadAddress, String lotAddress, String businessName) {
        log.debug("좌표 계산 시작 - 사업장명: {}", businessName);
        
        // 처리 우선순위: roadAddress -> lotAddress
        String primaryAddress = (roadAddress != null && !roadAddress.trim().isEmpty()) ? roadAddress : lotAddress;
        
        if (primaryAddress == null || primaryAddress.trim().isEmpty()) {
            log.debug("유효한 주소 정보 없음 - 사업장명: {}", businessName);
            return CoordinateResult.failure("주소 정보 없음");
        }

        // 편의점 특화 주소 전처리 단계별 시도
        List<String> addressVariants = generateAddressVariants(primaryAddress.trim(), businessName);
        
        for (int i = 0; i < addressVariants.size(); i++) {
            String processedAddress = addressVariants.get(i);
            log.debug("주소 변형 {} 시도: {} -> {}", i + 1, primaryAddress, processedAddress);
            
            CoordinateResult result = callKakaoApi(processedAddress);
            if (result.isSuccess()) {
                log.debug("좌표 계산 성공 - 사업장명: {}, 변형단계: {}, 좌표: ({}, {})", 
                         businessName, i + 1, result.getLatitude(), result.getLongitude());
                return result;
            }
        }

        log.error("좌표 계산 실패 - 사업장명: {}, 원본주소: {}", businessName, primaryAddress);
        return CoordinateResult.failure("모든 주소 변형 시도 실패");
    }

    /**
     * 편의점 특화 주소 변형 생성
     * 단계별로 주소를 정제하여 API 인식률 향상
     */
    private List<String> generateAddressVariants(String originalAddress, String businessName) {
        List<String> variants = new ArrayList<>();
        
        // 1단계: 원본 주소 그대로
        variants.add(originalAddress);
        
        // 2단계: 편의점 키워드 제거
        String withoutStoreKeywords = removeConvenienceStoreKeywords(originalAddress, businessName);
        if (!withoutStoreKeywords.equals(originalAddress)) {
            variants.add(withoutStoreKeywords);
        }
        
        // 3단계: 건물 정보 제거
        String withoutBuilding = removeBuildingInfo(withoutStoreKeywords);
        if (!withoutBuilding.equals(withoutStoreKeywords)) {
            variants.add(withoutBuilding);
        }
        
        // 4단계: 괄호 내용 제거
        String withoutParentheses = removeParentheses(withoutBuilding);
        if (!withoutParentheses.equals(withoutBuilding)) {
            variants.add(withoutParentheses);
        }
        
        // 5단계: 핵심 주소만 추출 (시/도/구/동/번지)
        String coreAddress = extractCoreAddress(withoutParentheses);
        if (!coreAddress.equals(withoutParentheses) && coreAddress.length() >= 5) {
            variants.add(coreAddress);
        }
        
        return variants;
    }

    /**
     * 편의점 브랜드 키워드 제거
     */
    private String removeConvenienceStoreKeywords(String address, String businessName) {
        String result = address;
        
        // 사업장명에서 추출한 브랜드명도 제거 대상에 추가
        Set<String> keywordsToRemove = new HashSet<>(CONVENIENCE_STORE_KEYWORDS);
        if (businessName != null) {
            for (String keyword : CONVENIENCE_STORE_KEYWORDS) {
                if (businessName.contains(keyword)) {
                    keywordsToRemove.add(keyword);
                }
            }
        }
        
        // 키워드 제거
        for (String keyword : keywordsToRemove) {
            result = result.replaceAll(keyword, "").trim();
        }
        
        return cleanupSpaces(result);
    }

    /**
     * 건물 정보 제거
     */
    private String removeBuildingInfo(String address) {
        String result = address;
        
        for (String pattern : BUILDING_PATTERNS) {
            result = result.replaceAll(pattern, "").trim();
        }
        
        return cleanupSpaces(result);
    }

    /**
     * 괄호 내용 제거
     */
    private String removeParentheses(String address) {
        return address.replaceAll("\\([^)]*\\)", "")
                     .replaceAll("\\[[^]]*\\]", "")
                     .replaceAll("\\{[^}]*\\}", "")
                     .trim();
    }

    /**
     * 핵심 주소 추출 (시/도/구/동/번지 수준)
     */
    private String extractCoreAddress(String address) {
        String result = address;
        
        // 특별시/광역시 표기 통일
        result = result.replace("특별시", "시")
                      .replace("광역시", "시");
        
        // 상세 번지나 건물명 제거 (기본 번지까지만 유지)
        result = result.replaceAll("\\s+\\d+[-~]\\d+", "")
                      .replaceAll("\\s+[가-힣]+\\d+", "");
        
        return cleanupSpaces(result);
    }

    /**
     * 연속 공백 정리 및 특수문자 제거
     */
    private String cleanupSpaces(String text) {
        return text.replaceAll("\\s+", " ")
                  .replaceAll("[,\\-]+$", "")
                  .trim();
    }

    /**
     * Kakao Local API 호출
     */
    private CoordinateResult callKakaoApi(String address) {
        totalApiCalls.incrementAndGet();
        
        try {
            String url = UriComponentsBuilder
                    .fromHttpUrl("https://dapi.kakao.com/v2/local/search/address.json")
                    .queryParam("query", address)
                    .build()
                    .toUriString();
            
            org.springframework.http.HttpHeaders headers = new org.springframework.http.HttpHeaders();
            headers.set("Authorization", "KakaoAK " + kakaoApiKey);
            
            org.springframework.http.HttpEntity<String> entity = new org.springframework.http.HttpEntity<>(headers);
            
            org.springframework.http.ResponseEntity<String> response = restTemplate.exchange(
                    url, org.springframework.http.HttpMethod.GET, entity, String.class);
            
            if (response.getStatusCode().is2xxSuccessful()) {
                return parseKakaoResponse(response.getBody());
            } else {
                failedApiCalls.incrementAndGet();
                return CoordinateResult.failure("API 호출 실패: " + response.getStatusCode());
            }
            
        } catch (Exception e) {
            failedApiCalls.incrementAndGet();
            log.error("Kakao API 호출 중 예외 발생 - 주소: {}, 오류: {}", address, e.getMessage());
            return CoordinateResult.failure("API 호출 예외: " + e.getMessage());
        }
    }

    /**
     * Kakao API 응답 파싱
     */
    private CoordinateResult parseKakaoResponse(String responseBody) {
        try {
            JsonNode root = objectMapper.readTree(responseBody);
            JsonNode documents = root.get("documents");
            
            if (documents == null || documents.isEmpty()) {
                failedApiCalls.incrementAndGet();
                return CoordinateResult.failure("검색 결과 없음");
            }
            
            JsonNode firstResult = documents.get(0);
            
            // road_address 우선, 없으면 address 사용
            JsonNode roadAddress = firstResult.get("road_address");
            JsonNode address = firstResult.get("address");
            
            BigDecimal latitude = null;
            BigDecimal longitude = null;
            
            if (roadAddress != null && !roadAddress.isNull()) {
                latitude = new BigDecimal(roadAddress.get("y").asText());
                longitude = new BigDecimal(roadAddress.get("x").asText());
            } else if (address != null && !address.isNull()) {
                latitude = new BigDecimal(address.get("y").asText());
                longitude = new BigDecimal(address.get("x").asText());
            }
            
            if (latitude != null && longitude != null) {
                // 한국 영역 내 좌표 검증
                if (isValidKoreanCoordinates(latitude, longitude)) {
                    successfulApiCalls.incrementAndGet();
                    return CoordinateResult.success(latitude, longitude);
                } else {
                    failedApiCalls.incrementAndGet();
                    return CoordinateResult.failure("좌표가 한국 영역을 벗어남");
                }
            } else {
                failedApiCalls.incrementAndGet();
                return CoordinateResult.failure("좌표 정보 파싱 실패");
            }
            
        } catch (Exception e) {
            failedApiCalls.incrementAndGet();
            log.error("Kakao API 응답 파싱 중 오류: {}", e.getMessage());
            return CoordinateResult.failure("응답 파싱 오류: " + e.getMessage());
        }
    }

    /**
     * 한국 영역 내 좌표 검증
     */
    private boolean isValidKoreanCoordinates(BigDecimal latitude, BigDecimal longitude) {
        double lat = latitude.doubleValue();
        double lng = longitude.doubleValue();
        
        // 한국 영역: 위도 33.0~38.7, 경도 124.0~132.0
        return lat >= 33.0 && lat <= 38.7 && lng >= 124.0 && lng <= 132.0;
    }

    /**
     * API 호출 통계 반환
     */
    public ApiStatistics getApiStatistics() {
        return new ApiStatistics(
                totalApiCalls.get(),
                successfulApiCalls.get(),
                failedApiCalls.get()
        );
    }

    /**
     * 통계 초기화
     */
    public void resetStatistics() {
        totalApiCalls.set(0);
        successfulApiCalls.set(0);
        failedApiCalls.set(0);
    }

    /**
     * 좌표 계산 결과 클래스
     */
    public static class CoordinateResult {
        private final boolean success;
        private final BigDecimal latitude;
        private final BigDecimal longitude;
        private final String errorMessage;

        private CoordinateResult(boolean success, BigDecimal latitude, BigDecimal longitude, String errorMessage) {
            this.success = success;
            this.latitude = latitude;
            this.longitude = longitude;
            this.errorMessage = errorMessage;
        }

        public static CoordinateResult success(BigDecimal latitude, BigDecimal longitude) {
            return new CoordinateResult(true, latitude, longitude, null);
        }

        public static CoordinateResult failure(String errorMessage) {
            return new CoordinateResult(false, null, null, errorMessage);
        }

        public boolean isSuccess() { return success; }
        public BigDecimal getLatitude() { return latitude; }
        public BigDecimal getLongitude() { return longitude; }
        public String getErrorMessage() { return errorMessage; }
    }

    /**
     * API 호출 통계 클래스
     */
    public static class ApiStatistics {
        private final long totalCalls;
        private final long successfulCalls;
        private final long failedCalls;

        public ApiStatistics(long totalCalls, long successfulCalls, long failedCalls) {
            this.totalCalls = totalCalls;
            this.successfulCalls = successfulCalls;
            this.failedCalls = failedCalls;
        }

        public long getTotalCalls() { return totalCalls; }
        public long getSuccessfulCalls() { return successfulCalls; }
        public long getFailedCalls() { return failedCalls; }
        public double getSuccessRate() { 
            return totalCalls > 0 ? (double) successfulCalls / totalCalls * 100 : 0.0; 
        }
    }
}
```

### 4.4 ConvenienceStoreCoordinateProcessor.java

```java
package com.WhereHouse.AnalysisData.convenience.processor;

import com.WhereHouse.AnalysisData.convenience.entity.AnalysisConvenienceStoreData;
import com.WhereHouse.AnalysisData.convenience.repository.AnalysisConvenienceStoreRepository;
import com.WhereHouse.AnalysisData.convenience.service.KakaoConvenienceCoordinateService;
import com.WhereHouse.AnalysisStaticData.ConvenienceStore.repository.ConvenienceStoreDataRepository;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicLong;

/**
 * 편의점 데이터 변환 및 처리를 위한 메인 Processor
 * AnalysisDataProcessor에서 호출되어 편의점 데이터를 분석용 테이블로 변환
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class ConvenienceStoreCoordinateProcessor {

    private final ConvenienceStoreDataRepository sourceRepository;
    private final AnalysisConvenienceStoreRepository analysisRepository;
    private final KakaoConvenienceCoordinateService coordinateService;

    @PersistenceContext
    private EntityManager entityManager;

    // 배치 처리 설정
    private static final int BATCH_SIZE = 1000;
    
    // 처리 통계
    private final AtomicLong totalProcessed = new AtomicLong(0);
    private final AtomicLong successfulProcessed = new AtomicLong(0);
    private final AtomicLong failedProcessed = new AtomicLong(0);
    private final AtomicLong coordinateSuccess = new AtomicLong(0);
    private final AtomicLong coordinateFailed = new AtomicLong(0);

    /**
     * 편의점 데이터 전체 처리 실행 - 메인 진입점
     * AnalysisDataProcessor에서 호출되는 메인 메서드
     */
    @Transactional
    public void processConvenienceStoreData() {
        log.info("편의점 데이터 분석용 테이블 생성 작업 시작");
        
        long startTime = System.currentTimeMillis();
        resetStatistics();
        
        try {
            // 원천 데이터 총 개수 확인
            long totalSourceCount = sourceRepository.getTotalSourceCount();
            log.info("원천 데이터 총 개수: {} 건", totalSourceCount);
            
            if (totalSourceCount == 0) {
                log.warn("처리할 원천 데이터가 없습니다.");
                return;
            }
            
            // 기존 분석용 데이터 삭제
            clearExistingAnalysisData();
            
            // 배치 처리 실행
            processBatchData(totalSourceCount);
            
            // 처리 결과 출력
            printFinalResults(totalSourceCount, startTime);
            
        } catch (Exception e) {
            log.error("편의점 데이터 처리 중 오류 발생: {}", e.getMessage(), e);
            throw e;
        }
        
        log.info("편의점 데이터 분석용 테이블 생성 작업 완료");
    }

    /**
     * 기존 분석용 데이터 삭제
     */
    private void clearExistingAnalysisData() {
        long existingCount = analysisRepository.count();
        if (existingCount > 0) {
            log.info("기존 분석용 데이터 {} 건 삭제 중...", existingCount);
            analysisRepository.deleteAll();
            entityManager.flush();
            entityManager.clear();
            log.info("기존 분석용 데이터 삭제 완료");
        }
    }

    /**
     * 배치 데이터 처리 실행
     */
    private void processBatchData(long totalSourceCount) {
        int totalPages = (int) Math.ceil((double) totalSourceCount / BATCH_SIZE);
        log.info("배치 처리 시작 - 총 {} 페이지, 배치 크기: {}", totalPages, BATCH_SIZE);
        
        for (int page = 0; page < totalPages; page++) {
            try {
                processBatch(page, totalSourceCount);
                
                // 메모리 관리
                if (page % 10 == 0) {
                    entityManager.flush();
                    entityManager.clear();
                }
                
            } catch (Exception e) {
                log.error("배치 처리 중 오류 발생 - 페이지: {}, 오류: {}", page, e.getMessage(), e);
                failedProcessed.addAndGet(BATCH_SIZE);
            }
        }
    }

    /**
     * 배치 단위 처리
     */
    @Transactional
    public void processBatch(int pageNumber, long totalCount) {
        Pageable pageable = PageRequest.of(pageNumber, BATCH_SIZE);
        Page<Map<String, Object>> sourcePage = sourceRepository.findAnalysisFieldsOnly(pageable);
        
        if (sourcePage.isEmpty()) {
            log.debug("페이지 {} - 처리할 데이터 없음", pageNumber);
            return;
        }
        
        List<AnalysisConvenienceStoreData> analysisDataList = new ArrayList<>();
        
        for (Map<String, Object> sourceData : sourcePage.getContent()) {
            try {
                AnalysisConvenienceStoreData analysisData = processIndividualData(sourceData);
                if (analysisData != null) {
                    analysisDataList.add(analysisData);
                    successfulProcessed.incrementAndGet();
                } else {
                    failedProcessed.incrementAndGet();
                }
                totalProcessed.incrementAndGet();
                
            } catch (Exception e) {
                log.error("개별 데이터 처리 중 오류 - 사업장명: {}, 오류: {}", 
                         sourceData.get("businessName"), e.getMessage());
                failedProcessed.incrementAndGet();
                totalProcessed.incrementAndGet();
            }
        }
        
        // 배치 저장
        if (!analysisDataList.isEmpty()) {
            analysisRepository.saveAll(analysisDataList);
            entityManager.flush();
            entityManager.clear();
        }
        
        // 진행률 로깅
        long processed = totalProcessed.get();
        double progressRate = ((double) processed / totalCount) * 100;
        log.info("진행률: {}/{} ({:.1f}%) - 성공: {}, 실패: {}, 좌표성공: {}", 
                processed, totalCount, progressRate, 
                successfulProcessed.get(), failedProcessed.get(), coordinateSuccess.get());
    }

    /**
     * 개별 데이터 처리
     */
    private AnalysisConvenienceStoreData processIndividualData(Map<String, Object> sourceData) {
        String businessName = (String) sourceData.get("businessName");
        String detailedStatusName = (String) sourceData.get("detailedStatusName");
        String phoneNumber = (String) sourceData.get("phoneNumber");
        String lotAddress = (String) sourceData.get("lotAddress");
        String roadAddress = (String) sourceData.get("roadAddress");
        
        // 분석용 데이터 생성 (NULL 값 처리 포함)
        AnalysisConvenienceStoreData analysisData = AnalysisConvenienceStoreData.fromSourceData(
                businessName, detailedStatusName, phoneNumber, lotAddress, roadAddress);
        
        // 좌표 계산 시도
        if (analysisData.hasValidAddress()) {
            try {
                KakaoConvenienceCoordinateService.CoordinateResult coordinateResult = 
                        coordinateService.calculateCoordinates(roadAddress, lotAddress, businessName);
                
                if (coordinateResult.isSuccess()) {
                    analysisData.setCoordinates(coordinateResult.getLatitude(), coordinateResult.getLongitude());
                    coordinateSuccess.incrementAndGet();
                    
                    log.debug("좌표 계산 성공 - 사업장명: {}, 좌표: ({}, {})", 
                             businessName, coordinateResult.getLatitude(), coordinateResult.getLongitude());
                } else {
                    coordinateFailed.incrementAndGet();
                    log.debug("좌표 계산 실패 - 사업장명: {}, 오류: {}", 
                             businessName, coordinateResult.getErrorMessage());
                }
                
            } catch (Exception e) {
                coordinateFailed.incrementAndGet();
                log.error("좌표 계산 중 예외 발생 - 사업장명: {}, 오류: {}", businessName, e.getMessage());
            }
        } else {
            coordinateFailed.incrementAndGet();
            log.debug("유효한 주소 정보 없음 - 사업장명: {}", businessName);
        }
        
        return analysisData;
    }

    /**
     * 최종 처리 결과 출력
     */
    private void printFinalResults(long totalSourceCount, long startTime) {
        long endTime = System.currentTimeMillis();
        long processingTimeMs = endTime - startTime;
        
        // 최종 저장된 데이터 통계
        long finalCount = analysisRepository.getTotalCount();
        long coordinateCount = analysisRepository.getCoordinateCount();
        Double coordinateRate = analysisRepository.getCoordinateCompletionRate();
        
        // API 통계
        KakaoConvenienceCoordinateService.ApiStatistics apiStats = coordinateService.getApiStatistics();
        
        log.info("=== 편의점 데이터 분석용 테이블 생성 작업 완료 ===");
        log.info("원천 데이터: {} 개", totalSourceCount);
        log.info("데이터 변환: 성공 {} 개, 실패 {} 개", 
                successfulProcessed.get(), failedProcessed.get());
        log.info("최종 저장: {} 개", finalCount);
        log.info("좌표 계산: 성공 {} 개 ({:.1f}%), 실패 {} 개", 
                coordinateCount, coordinateRate != null ? coordinateRate : 0.0, coordinateFailed.get());
        
        // 상세영업상태별 분포
        List<Object[]> statusDistribution = analysisRepository.getStatusDistribution();
        log.info("상세영업상태별 분포:");
        statusDistribution.stream()
                .limit(10) // 상위 10개만 출력
                .forEach(row -> log.info("  {} : {} 개", row[0], row[1]));
        
        log.info("API 호출 통계: 총 {}회, 성공 {}회 ({:.1f}%), 실패 {}회", 
                apiStats.getTotalCalls(), apiStats.getSuccessfulCalls(), 
                apiStats.getSuccessRate(), apiStats.getFailedCalls());
        
        long seconds = processingTimeMs / 1000;
        long minutes = seconds / 60;
        log.info("처리 시간: {}분 {}초", minutes, seconds % 60);
    }

    /**
     * 통계 초기화
     */
    private void resetStatistics() {
        totalProcessed.set(0);
        successfulProcessed.set(0);
        failedProcessed.set(0);
        coordinateSuccess.set(0);
        coordinateFailed.set(0);
        coordinateService.resetStatistics();
    }

    /**
     * 처리 통계 반환 (테스트 또는 모니터링용)
     */
    public ProcessingStatistics getProcessingStatistics() {
        long finalCount = analysisRepository.getTotalCount();
        long coordinateCount = analysisRepository.getCoordinateCount();
        
        return ProcessingStatistics.builder()
                .totalProcessed(totalProcessed.get())
                .successfulProcessed(successfulProcessed.get())
                .failedProcessed(failedProcessed.get())
                .coordinateSuccess(coordinateSuccess.get())
                .coordinateFailed(coordinateFailed.get())
                .finalDataCount(finalCount)
                .coordinateCount(coordinateCount)
                .build();
    }

    /**
     * 처리 통계 데이터 클래스
     */
    @lombok.Builder
    @lombok.Data
    public static class ProcessingStatistics {
        private long totalProcessed;
        private long successfulProcessed;
        private long failedProcessed;
        private long coordinateSuccess;
        private long coordinateFailed;
        private long finalDataCount;
        private long coordinateCount;
    }
}
```

### 4.5 기존 AnalysisDataProcessor.java 수정

```java
package com.WhereHouse.AnalysisData.main;

import com.WhereHouse.AnalysisData.banklocation.processor.BankLocationDataProcessor;
import com.WhereHouse.AnalysisData.convenience.processor.ConvenienceStoreCoordinateProcessor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class AnalysisDataProcessor implements CommandLineRunner {

    private final ConvenienceStoreCoordinateProcessor convenienceStoreCoordinateProcessor;
    // 향후 18개 ERD별 프로세서 추가 예정

    @Override
    public void run(String... args) throws Exception {
        log.info("=== 안전성 분석용 데이터 처리 시작 ===");

        try {
            // 편의점 데이터 처리 실행
            log.info("편의점 데이터 처리 시작");
            convenienceStoreCoordinateProcessor.processConvenienceStoreData();
            log.info("편의점 데이터 처리 완료");
            
            // 향후 다른 데이터 처리 추가
            // bankLocationDataProcessor.processBankLocationData();
            // 기타 18개 ERD별 프로세서 호출...
            
        } catch (Exception e) {
            log.error("안전성 분석용 데이터 처리 중 오류 발생", e);
            throw e;
        }

        log.info("=== 안전성 분석용 데이터 처리 완료 ===");
    }
}
```

---

## 5. 설정 파일

### 5.1 application.yml

```yaml
# 편의점 데이터 분석용 시스템 설정

spring:
  # 데이터베이스 설정
  datasource:
    url: jdbc:oracle:thin:@localhost:1521:XE
    username: your_username
    password: your_password
    driver-class-name: oracle.jdbc.OracleDriver
    
    # 커넥션 풀 설정 (HikariCP)
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 20000
      idle-timeout: 300000
      max-lifetime: 1200000
      leak-detection-threshold: 60000

  # JPA 설정
  jpa:
    hibernate:
      ddl-auto: none  # 운영환경에서는 none 사용
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
    show-sql: false  # 운영환경에서는 false 권장
    properties:
      hibernate:
        dialect: org.hibernate.dialect.Oracle12cDialect
        format_sql: true
        use_sql_comments: true
        jdbc:
          batch_size: 1000  # 배치 처리 최적화
          batch_versioned_data: true
        order_inserts: true
        order_updates: true
        
  # 로깅 설정
  output:
    ansi:
      enabled: always

# Kakao API 설정
kakao:
  api:
    key: YOUR_KAKAO_API_KEY_HERE  # 실제 Kakao API 키로 변경 필요
    
# 로깅 설정
logging:
  level:
    com.WhereHouse.AnalysisData.convenience: INFO
    com.WhereHouse.AnalysisStaticData.ConvenienceStore: INFO
    org.springframework.web.client.RestTemplate: WARN
    org.hibernate.SQL: WARN
    org.hibernate.type.descriptor.sql.BasicBinder: WARN
    
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
    
  file:
    name: logs/convenience-analysis.log
    max-size: 100MB
    max-history: 7

# 애플리케이션 설정
app:
  convenience:
    batch:
      size: 1000  # 배치 처리 크기
    processing:
      timeout-seconds: 300  # 개별 처리 타임아웃 (5분)
    coordinate:
      validation:
        enabled: true  # 좌표 유효성 검증 활성화
        korea-bounds:
          min-latitude: 33.0
          max-latitude: 38.7
          min-longitude: 124.0
          max-longitude: 132.0
```

---

## 6. 실행 방법

### 6.1 사전 준비

1. **데이터베이스 설정**
   ```sql
   -- DDL 실행 (위의 2.1 테이블 생성 DDL)
   ```

2. **Kakao API 키 설정**
   ```yaml
   # application.yml에서 설정
   kakao:
     api:
       key: YOUR_ACTUAL_KAKAO_API_KEY
   ```

3. **의존성 확인**
   - Spring Boot, JPA, Oracle Driver
   - Jackson (JSON 파싱)
   - Lombok

### 6.2 실행 과정

1. **애플리케이션 시작**
   ```bash
   java -jar your-application.jar
   ```

2. **자동 실행 흐름**
   ```
   AnalysisDataProcessor.run() 
   → ConvenienceStoreCoordinateProcessor.processConvenienceStoreData()
   → 배치 처리 시작
   → 완료 후 통계 출력
   ```

3. **실행 로그 예시**
   ```
   2025-09-08 10:00:00 [main] INFO  - === 안전성 분석용 데이터 처리 시작 ===
   2025-09-08 10:00:00 [main] INFO  - 편의점 데이터 처리 시작
   2025-09-08 10:00:01 [main] INFO  - 편의점 데이터 분석용 테이블 생성 작업 시작
   2025-09-08 10:00:01 [main] INFO  - 원천 데이터 총 개수: 45123 건
   2025-09-08 10:00:02 [main] INFO  - 기존 분석용 데이터 0 건 삭제 중...
   2025-09-08 10:00:02 [main] INFO  - 배치 처리 시작 - 총 46 페이지, 배치 크기: 1000
   2025-09-08 10:01:00 [main] INFO  - 진행률: 1000/45123 (2.2%) - 성공: 998, 실패: 2, 좌표성공: 856
   ```

---

## 7. 데이터 검증

### 7.1 기본 검증 쿼리

```sql
-- 전체 데이터 개수 확인
SELECT COUNT(*) FROM ANALYSIS_CONVENIENCE_STORE_DATA;

-- 좌표 완성도 확인
SELECT 
    COUNT(*) AS TOTAL_COUNT,
    COUNT(LATITUDE) AS COORDINATE_COUNT,
    ROUND(COUNT(LATITUDE) * 100.0 / COUNT(*), 2) AS COMPLETION_RATE
FROM ANALYSIS_CONVENIENCE_STORE_DATA;

-- 상세영업상태별 분포
SELECT DETAILED_STATUS_NAME, COUNT(*) 
FROM ANALYSIS_CONVENIENCE_STORE_DATA 
GROUP BY DETAILED_STATUS_NAME 
ORDER BY COUNT(*) DESC;
```

### 7.2 품질 검증 기준

| 검증 항목 | 기준 | 비고 |
|----------|-----|------|
| 데이터 처리율 | 95% 이상 | 원천 데이터 대비 |
| 좌표 완성도 | 85% 이상 | 전체 데이터 대비 |
| 처리 성능 | 1만 건당 30분 이내 | 성능 기준 |
| 에러율 | 5% 미만 | 전체 처리 중 |

### 7.3 예상 처리 결과

```
=== 편의점 데이터 분석용 테이블 생성 작업 완료 ===
- 원천 데이터: 45,123 개
- 데이터 변환: 성공 44,856 개, 실패 267 개
- 좌표 계산: 성공 38,924 개 (86.8%), 실패 5,932 개 (13.2%)
- 상세영업상태별 분포:
  영업 : 38,245 개
  폐업 : 4,567 개
  휴업 : 1,892 개
  기타 : 152 개
- API 호출 통계: 총 89,512회, 성공 38,924회 (43.5%)
- 처리 시간: 23분 14초
```

---

## 8. 주요 처리 로직 흐름

### 8.1 데이터 변환 과정

```
원천 데이터 (CONVENIENCE_STORE_DATA)
    ↓ [1000개씩 배치 조회]
NULL 값 처리 ("데이터없음"으로 변환)
    ↓ [주소 정보 추출]
편의점 특화 주소 전처리 (5단계)
    ↓ [Kakao API 호출]
좌표 계산 및 한국 영역 검증
    ↓ [분석용 데이터 생성]
분석용 테이블 저장 (ANALYSIS_CONVENIENCE_STORE_DATA)
```

### 8.2 편의점 특화 주소 전처리

```
1단계: "서울특별시 강남구 테헤란로 123 세븐일레븐 강남점"
2단계: "서울특별시 강남구 테헤란로 123 강남점" (브랜드명 제거)
3단계: "서울특별시 강남구 테헤란로 123" (건물정보 제거)
4단계: "서울특별시 강남구 테헤란로 123" (괄호내용 제거)
5단계: "서울시 강남구 테헤란로" (핵심주소 추출)
```

---

## 9. 확장 및 유지보수 가이드

### 9.1 향후 확장 계획

- 다른 업종별 프로세서 추가 (은행, 병원, 학교 등)
- 동일한 패턴으로 18개 ERD별 처리기 구현
- API 호출 최적화 및 캐싱 메커니즘 도입

### 9.2 성능 최적화 포인트

- 배치 크기 조정 (현재 1000개)
- 메모리 관리 주기 조정 (현재 10배치마다)
- API 호출 병렬 처리 (필요시)
- 인덱스 추가 (검색 성능 향상)

이 문서는 편의점 데이터 분석용 시스템의 완전한 구현 가이드입니다. 모든 코드와 설정이 포함되어 있어 즉시 구현 가능합니다.