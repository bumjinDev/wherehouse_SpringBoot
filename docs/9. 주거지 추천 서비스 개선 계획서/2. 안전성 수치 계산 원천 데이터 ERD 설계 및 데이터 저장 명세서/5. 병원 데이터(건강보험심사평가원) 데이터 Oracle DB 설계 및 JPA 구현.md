# 병원 데이터 CSV 파일 로더 구현

## 1. Oracle 테이블 DDL

```sql
CREATE TABLE HOSPITAL_DATA (
    ID                          NUMBER(19) PRIMARY KEY,
    OPEN_LOCAL_GOV_CODE        VARCHAR2(50),
    MANAGEMENT_NUMBER          VARCHAR2(50) NOT NULL,
    LICENSE_DATE               DATE,
    LICENSE_CANCEL_DATE        DATE,
    BUSINESS_STATUS_CODE       VARCHAR2(50),
    BUSINESS_STATUS_NAME       VARCHAR2(50),
    DETAILED_STATUS_CODE       VARCHAR2(50),
    DETAILED_STATUS_NAME       VARCHAR2(50),
    CLOSURE_DATE               DATE,
    SUSPENSION_START_DATE      DATE,
    SUSPENSION_END_DATE        DATE,
    REOPENING_DATE             DATE,
    PHONE_NUMBER               VARCHAR2(255),
    LOCATION_AREA              NUMBER(20,2),
    LOCATION_POSTAL_CODE       VARCHAR2(50),
    LOT_ADDRESS                VARCHAR2(500),
    ROAD_ADDRESS               VARCHAR2(500),
    ROAD_POSTAL_CODE           VARCHAR2(50),
    BUSINESS_NAME              VARCHAR2(200),
    LAST_MODIFIED_DATE         TIMESTAMP,
    DATA_UPDATE_TYPE           VARCHAR2(50),
    DATA_UPDATE_TIME           VARCHAR2(50),
    BUSINESS_TYPE_NAME         VARCHAR2(100),
    COORDINATE_X               NUMBER(20,10),
    COORDINATE_Y               NUMBER(20,10),
    CREATED_AT                 TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT                 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE SEQUENCE SEQ_HOSPITAL_DATA START WITH 1 INCREMENT BY 1;
```

## 2. JPA Entity

```java
package com.WhereHouse.AnalysisStaticData.HospitalSave.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "HOSPITAL_DATA")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class HospitalData {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "hospital_data_seq")
    @SequenceGenerator(name = "hospital_data_seq", sequenceName = "SEQ_HOSPITAL_DATA", allocationSize = 1)
    private Long id;

    @Column(name = "OPEN_LOCAL_GOV_CODE", length = 50)
    private String openLocalGovCode;

    @Column(name = "MANAGEMENT_NUMBER", length = 50, nullable = false)
    private String managementNumber;

    @Column(name = "LICENSE_DATE")
    private LocalDate licenseDate;

    @Column(name = "LICENSE_CANCEL_DATE")
    private LocalDate licenseCancelDate;

    @Column(name = "BUSINESS_STATUS_CODE", length = 50)
    private String businessStatusCode;

    @Column(name = "BUSINESS_STATUS_NAME", length = 50)
    private String businessStatusName;

    @Column(name = "DETAILED_STATUS_CODE", length = 50)
    private String detailedStatusCode;

    @Column(name = "DETAILED_STATUS_NAME", length = 50)
    private String detailedStatusName;

    @Column(name = "CLOSURE_DATE")
    private LocalDate closureDate;

    @Column(name = "SUSPENSION_START_DATE")
    private LocalDate suspensionStartDate;

    @Column(name = "SUSPENSION_END_DATE")
    private LocalDate suspensionEndDate;

    @Column(name = "REOPENING_DATE")
    private LocalDate reopeningDate;

    @Column(name = "PHONE_NUMBER", length = 255)
    private String phoneNumber;

    @Column(name = "LOCATION_AREA", precision = 20, scale = 2)
    private BigDecimal locationArea;

    @Column(name = "LOCATION_POSTAL_CODE", length = 50)
    private String locationPostalCode;

    @Column(name = "LOT_ADDRESS", length = 500)
    private String lotAddress;

    @Column(name = "ROAD_ADDRESS", length = 500)
    private String roadAddress;

    @Column(name = "ROAD_POSTAL_CODE", length = 50)
    private String roadPostalCode;

    @Column(name = "BUSINESS_NAME", length = 200)
    private String businessName;

    @Column(name = "LAST_MODIFIED_DATE")
    private LocalDateTime lastModifiedDate;

    @Column(name = "DATA_UPDATE_TYPE", length = 50)
    private String dataUpdateType;

    @Column(name = "DATA_UPDATE_TIME", length = 50)
    private String dataUpdateTime;

    @Column(name = "BUSINESS_TYPE_NAME", length = 100)
    private String businessTypeName;

    @Column(name = "COORDINATE_X", precision = 20, scale = 10)
    private BigDecimal coordinateX;

    @Column(name = "COORDINATE_Y", precision = 20, scale = 10)
    private BigDecimal coordinateY;

    @Column(name = "CREATED_AT", updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "UPDATED_AT")
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}
```

## 3. Repository

```java
package com.WhereHouse.AnalysisStaticData.HospitalSave.repository;

import com.WhereHouse.AnalysisStaticData.HospitalSave.entity.HospitalData;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface HospitalDataRepository extends JpaRepository<HospitalData, Long> {

    @Query("SELECT h.businessStatusName, COUNT(h) FROM HospitalData h GROUP BY h.businessStatusName")
    List<Object[]> countByBusinessStatus();
}
```

## 4. CSV 데이터 로더 컴포넌트

```java
package com.WhereHouse.AnalysisStaticData.HospitalSave.component;

import com.WhereHouse.AnalysisStaticData.HospitalSave.entity.HospitalData;
import com.WhereHouse.AnalysisStaticData.HospitalSave.repository.HospitalDataRepository;
import com.opencsv.CSVReader;
import com.opencsv.exceptions.CsvValidationException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@Component
@RequiredArgsConstructor
@Slf4j
public class HospitalCsvLoader {  // 수동 실행을 위해 CommandLineRunner 미구현

    private final HospitalDataRepository repository;

    @Value("${app.csv.hospital-path}")
    private Resource csvFileResource;

    @Value("${app.csv.header-row:1}")
    private int headerRowIndex;

    @Value("${app.csv.batch-size:1000}")
    private int batchSize;

    // 날짜 파싱을 위한 포맷터들
    private static final DateTimeFormatter[] DATE_FORMATTERS = {
            DateTimeFormatter.ofPattern("yyyy-MM-dd"),
            DateTimeFormatter.ofPattern("yyyyMMdd")
    };
    
    private static final DateTimeFormatter[] DATETIME_FORMATTERS = {
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.S"),
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
    };

    /**
     * CSV 데이터 로딩 메서드 (수동 호출용)
     */
    @Transactional
    public void run(String... args) throws Exception {
        log.info("병원 CSV 데이터 로딩 시작...");
        log.info("파일 경로: {}", csvFileResource.getFilename());

        // 기존 데이터가 있으면 삭제
        if (repository.count() > 0) {
            log.info("기존 데이터 존재. 전체 삭제 후 새로 로드합니다.");
            repository.deleteAllInBatch();
        }

        // CSV 데이터 로드
        List<HospitalData> dataList = loadCsvData();

        if (!dataList.isEmpty()) {
            log.info("총 {}개 데이터 로드 완료. 배치 저장 시작...", dataList.size());
            saveDataInBatches(dataList);
            log.info("병원 데이터 로딩 완료: {}개 데이터 저장", repository.count());
            printDataStatistics();
        } else {
            log.warn("로드할 데이터가 없습니다.");
        }
    }

    /**
     * CSV 파일을 읽어서 엔티티 리스트로 변환
     */
    private List<HospitalData> loadCsvData() throws IOException, CsvValidationException {
        List<HospitalData> dataList = new ArrayList<>();
        
        try (InputStream is = csvFileResource.getInputStream();
             InputStreamReader reader = new InputStreamReader(is, "EUC-KR");  // 인코딩 하드코딩
             CSVReader csvReader = new CSVReader(reader)) {

            // 헤더 행 스킵
            for (int i = 0; i < headerRowIndex; i++) {
                csvReader.readNext();
            }

            String[] line;
            int rowNumber = headerRowIndex;
            while ((line = csvReader.readNext()) != null) {
                rowNumber++;
                try {
                    HospitalData hospitalData = mapRowToEntity(line);
                    if (hospitalData != null) {
                        dataList.add(hospitalData);
                    }
                } catch (Exception e) {
                    log.error("행 {} 처리 중 오류 발생. 데이터: {}", rowNumber, Arrays.toString(line), e);
                }
            }
        }
        
        return dataList;
    }

    /**
     * CSV 행 데이터를 엔티티로 매핑 (유효성 검증 없음)
     */
    private HospitalData mapRowToEntity(String[] row) {
        return HospitalData.builder()
                .openLocalGovCode(getStringValue(row, 0))
                .managementNumber(getStringValue(row, 1))
                .licenseDate(getDateValue(row, 2))
                .licenseCancelDate(getDateValue(row, 3))
                .businessStatusCode(getStringValue(row, 4))
                .businessStatusName(getStringValue(row, 5))
                .detailedStatusCode(getStringValue(row, 6))
                .detailedStatusName(getStringValue(row, 7))
                .closureDate(getDateValue(row, 8))
                .suspensionStartDate(getDateValue(row, 9))
                .suspensionEndDate(getDateValue(row, 10))
                .reopeningDate(getDateValue(row, 11))
                .phoneNumber(getStringValue(row, 12))
                .locationArea(getBigDecimalValue(row, 13))
                .locationPostalCode(getStringValue(row, 14))
                .lotAddress(getStringValue(row, 15))
                .roadAddress(getStringValue(row, 16))
                .roadPostalCode(getStringValue(row, 17))
                .businessName(getStringValue(row, 18))
                .lastModifiedDate(getDateTimeValue(row, 19))
                .dataUpdateType(getStringValue(row, 20))
                .dataUpdateTime(getStringValue(row, 21))
                .businessTypeName(getStringValue(row, 22))
                .coordinateX(getBigDecimalValue(row, 23))
                .coordinateY(getBigDecimalValue(row, 24))
                .build();
    }

    /**
     * 문자열 값 추출 및 정제 (null/empty 체크)
     */
    private String getStringValue(String[] row, int index) {
        if (index >= row.length || row[index] == null || row[index].trim().isEmpty()) {
            return null;
        }
        return row[index].trim();
    }

    /**
     * BigDecimal 값 변환 (예외처리 포함)
     */
    private BigDecimal getBigDecimalValue(String[] row, int index) {
        String val = getStringValue(row, index);
        if (val == null) {
            return null;
        }
        try {
            return new BigDecimal(val);
        } catch (NumberFormatException e) {
            return null;
        }
    }

    /**
     * LocalDate 값 변환 (2가지 포맷 지원)
     */
    private LocalDate getDateValue(String[] row, int index) {
        String val = getStringValue(row, index);
        if (val == null) {
            return null;
        }
        
        for (DateTimeFormatter formatter : DATE_FORMATTERS) {
            try {
                return LocalDate.parse(val, formatter);
            } catch (DateTimeParseException e) {
                // 다음 포맷터 시도
            }
        }
        
        return null;
    }

    /**
     * LocalDateTime 값 변환 (2가지 포맷 지원)
     */
    private LocalDateTime getDateTimeValue(String[] row, int index) {
        String val = getStringValue(row, index);
        if (val == null) {
            return null;
        }
        
        for (DateTimeFormatter formatter : DATETIME_FORMATTERS) {
            try {
                return LocalDateTime.parse(val, formatter);
            } catch (DateTimeParseException e) {
                // 다음 포맷터 시도
            }
        }
        
        return null;
    }

    /**
     * 배치 단위로 데이터 저장 (단순 배치 처리)
     */
    private void saveDataInBatches(List<HospitalData> dataList) {
        for (int i = 0; i < dataList.size(); i += batchSize) {
            int end = Math.min(i + batchSize, dataList.size());
            repository.saveAll(dataList.subList(i, end));
        }
    }

    /**
     * 데이터 로딩 통계 출력 (간소화된 버전)
     */
    private void printDataStatistics() {
        log.info("========== 데이터 로드 통계 ==========");
        repository.countByBusinessStatus().forEach(row ->
                log.info("영업상태: {}, 개수: {}", row[0], row[1])
        );
        log.info("======================================");
    }
}
```

## 5. 설정 파일

### 5.1. application.yml

```yaml
app:
  csv:
    hospital-path: classpath:data/hospital_data.csv  # CSV 파일 경로
    header-row: 1                                    # 헤더 행 개수 (스킵할 행)
    batch-size: 1000                                 # 배치 저장 크기

spring:
  datasource:
    driver-class-name: oracle.jdbc.OracleDriver
    url: jdbc:oracle:thin:@localhost:1521:xe
    username: your_username
    password: your_password
    
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.Oracle12cDialect
        format_sql: true
        
logging:
  level:
    com.WhereHouse.AnalysisStaticData.HospitalSave: INFO
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql: TRACE
```

## 6. 의존성 설정

### 6.1. pom.xml (Maven)

```xml
<dependencies>
    <!-- Spring Boot Starters -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    
    <!-- Oracle JDBC Driver -->
    <dependency>
        <groupId>com.oracle.database.jdbc</groupId>
        <artifactId>ojdbc8</artifactId>
        <scope>runtime</scope>
    </dependency>
    
    <!-- OpenCSV for CSV parsing -->
    <dependency>
        <groupId>com.opencsv</groupId>
        <artifactId>opencsv</artifactId>
        <version>5.8</version>
    </dependency>
    
    <!-- Lombok -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

## 7. CSV 파일 구조 및 매핑

### 7.1. CSV 컬럼 순서 (인덱스 기준)

| 인덱스 | 필드명 | 설명 | 타입 |
|--------|--------|------|------|
| 0 | 개방자치단체코드 | OPEN_LOCAL_GOV_CODE | String |
| 1 | 관리번호 | MANAGEMENT_NUMBER | String |
| 2 | 인허가일자 | LICENSE_DATE | LocalDate |
| 3 | 인허가취소일자 | LICENSE_CANCEL_DATE | LocalDate |
| 4 | 영업상태구분코드 | BUSINESS_STATUS_CODE | String |
| 5 | 영업상태명 | BUSINESS_STATUS_NAME | String |
| 6 | 상세영업상태코드 | DETAILED_STATUS_CODE | String |
| 7 | 상세영업상태명 | DETAILED_STATUS_NAME | String |
| 8 | 폐업일자 | CLOSURE_DATE | LocalDate |
| 9 | 휴업시작일자 | SUSPENSION_START_DATE | LocalDate |
| 10 | 휴업종료일자 | SUSPENSION_END_DATE | LocalDate |
| 11 | 재개업일자 | REOPENING_DATE | LocalDate |
| 12 | 소재지전화 | PHONE_NUMBER | String |
| 13 | 소재지면적 | LOCATION_AREA | BigDecimal |
| 14 | 소재지우편번호 | LOCATION_POSTAL_CODE | String |
| 15 | 지번주소 | LOT_ADDRESS | String |
| 16 | 도로명주소 | ROAD_ADDRESS | String |
| 17 | 도로명우편번호 | ROAD_POSTAL_CODE | String |
| 18 | 사업장명 | BUSINESS_NAME | String |
| 19 | 최종수정시점 | LAST_MODIFIED_DATE | LocalDateTime |
| 20 | 데이터갱신구분 | DATA_UPDATE_TYPE | String |
| 21 | 데이터갱신일자 | DATA_UPDATE_TIME | String |
| 22 | 업태구분명 | BUSINESS_TYPE_NAME | String |
| 23 | 좌표정보(X) | COORDINATE_X | BigDecimal |
| 24 | 좌표정보(Y) | COORDINATE_Y | BigDecimal |

## 8. 주요 특징

- **수동 실행**: `CommandLineRunner`를 구현하지 않아 애플리케이션 시작 시 자동 실행되지 않음
- **하드코딩된 인코딩**: `EUC-KR` 인코딩이 코드 내에 하드코딩됨
- **간소화된 오류 처리**: 개별 행 파싱 오류 시에도 전체 프로세스는 계속 진행
- **제한된 날짜 형식**: 2가지 날짜 포맷만 지원 (`yyyy-MM-dd`, `yyyyMMdd`)
- **배치 처리**: 대용량 데이터를 배치 단위로 처리하여 메모리 효율성 확보
- **단순한 통계**: 로딩 완료 후 영업상태별 분포만 출력
- **트랜잭션 처리**: 전체 로딩 과정을 하나의 트랜잭션으로 처리

## 9. 사용 방법

CSV 데이터 로딩을 위해서는 별도의 컨트롤러나 서비스에서 `HospitalCsvLoader`의 `run()` 메서드를 직접 호출해야 합니다.

```java
@RestController
@RequiredArgsConstructor
public class DataLoadController {
    
    private final HospitalCsvLoader csvLoader;
    
    @PostMapping("/load-hospital-data")
    public ResponseEntity<String> loadHospitalData() {
        try {
            csvLoader.run();
            return ResponseEntity.ok("병원 데이터 로딩 완료");
        } catch (Exception e) {
            return ResponseEntity.status(500).body("로딩 실패: " + e.getMessage());
        }
    }
}
```

## 10. 데이터 소스

본 구현체는 공공데이터포털에서 제공하는 **전국 병의원 찾기 서비스**의 CSV 데이터를 활용합니다.

**데이터 소스**: [전국 병의원 찾기 서비스](https://www.data.go.kr/data/15071553/fileData.do#)

- **제공기관**: 건강보험심사평가원
- **데이터 형식**: CSV 파일
- **갱신주기**: 월 1회
- **인코딩**: EUC-KR
- **포함 정보**: 전국 병의원의 기본정보, 영업상태, 위치정보 등