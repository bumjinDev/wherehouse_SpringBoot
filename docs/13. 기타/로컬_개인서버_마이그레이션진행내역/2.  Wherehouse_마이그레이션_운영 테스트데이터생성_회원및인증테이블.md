# Wherehouse 프로젝트 — 운영 테스트 데이터 생성 작업 이력서

> 작성일: 2026-02-09  
> 작업자: 정범진 (Back-end Engineer) + Claude AI  
> 프로젝트: Wherehouse (주거지 추천 서비스)  
> 문서 버전: v1.0  

---

## 목차

1. [작업 배경 및 목적](#1-작업-배경-및-목적)
2. [프로젝트 구조 분석](#2-프로젝트-구조-분석)
3. [ERD 분석](#3-erd-분석)
4. [데이터 삽입 전략 수립](#4-데이터-삽입-전략-수립)
5. [Phase 1 실행 — 회원 데이터 생성](#5-phase-1-실행--회원-데이터-생성)
6. [Phase 1 결과 검증](#6-phase-1-결과-검증)
7. [Phase 2 사전 계획 — 리뷰 데이터 생성](#7-phase-2-사전-계획--리뷰-데이터-생성)
8. [산출물 목록](#8-산출물-목록)
9. [부록 — 주요 결정 사항 및 근거](#9-부록--주요-결정-사항-및-근거)

---

## 1. 작업 배경 및 목적

### 1.1 배경

Wherehouse 프로젝트는 리뷰 시스템 고도화(Phase 2)를 완료한 상태이나, 실 운영에 필요한 테스트 데이터가 부재하여 다음 항목에 대한 검증이 불가능한 상태였다.

- 하이브리드 추천 점수(LegacyScore 50% + ReviewScore 50%) 정상 작동
- Cold Start 분기(리뷰 5건 미만 → LegacyScore 100% 폴백) 검증
- 리뷰 CRUD 및 페이징 동작
- 키워드 점수 분포(긍정 우세/부정 우세/중립) 테스트
- UK 제약 `(PROPERTY_ID, USER_ID)` 중복 방지 검증

### 1.2 목적

회원, 리뷰, 키워드, 통계 테이블에 실 패턴 기반의 유의미한 대량 테스트 데이터를 자동 생성하여 시스템 전반의 기능 검증 및 성능 테스트를 가능하게 한다.

### 1.3 작업 범위

| 단계 | 대상 테이블 | 상태 |
|------|-----------|------|
| **Phase 1** | MEMBERTBL, USERENTITY, USERENTITY_ROLES | ✅ 완료 |
| **Phase 2** | REVIEWS, REVIEW_KEYWORDS, REVIEW_STATISTICS | ⏳ 대기 (배치 실행 후 진행) |
| **제외** | PROPERTIES_CHARTER, PROPERTIES_MONTHLY | 배치 스케줄러로 실 데이터 적재 예정 |
| **제외** | WHEREBOARD, COMMENTTBL | 최후순위 (현재 미진행) |

---

## 2. 프로젝트 구조 분석

### 2.1 분석 대상

프로젝트 경로: `E:\devSpace\SpringBootProjects\wherehouse_SpringBoot-master\wherehouse`

### 2.2 기술 스택 확인 결과

| 항목 | 값 |
|------|-----|
| 프레임워크 | Spring Boot 3.3.5 |
| 빌드 도구 | Gradle |
| JDK | 17 |
| 패키징 | WAR |
| ORM | JPA + MyBatis 하이브리드 |
| 데이터베이스 | Oracle XE (61.75.54.208:1521) |
| 캐시 | Redis (Lettuce, 61.75.54.208:6379) |
| 인증 | JWT (jjwt 0.11.5) + Spring Security |
| 커넥션 풀 | HikariCP (최대 6개) |
| OSIV | OFF |

### 2.3 패키지 구조

```
com.wherehouse
├── board/          # 게시판 (WHEREBOARD, COMMENTTBL)
├── members/        # 회원 관리 (MEMBERTBL)
├── JWT/            # 인증/인가 (USERENTITY, USERENTITY_ROLES)
├── review/         # 리뷰 시스템 (REVIEWS, REVIEW_KEYWORDS, REVIEW_STATISTICS)
├── recommand/      # 추천 서비스 (CharterRecommendationService, MonthlyRecommendationService)
│   └── batch/      # 배치 처리 (BatchScheduler, RdbSyncListener)
├── information/    # 정보 조회
├── redis/          # Redis 핸들러
├── restapi/        # 외부 API 연동
├── logger/         # 로깅
└── page/           # 페이지 라우팅
```

### 2.4 인프라 설정 (application.properties 분석 결과)

```properties
# Oracle DB
spring.datasource.url=jdbc:oracle:thin:@61.75.54.208:1521:xe
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver
spring.datasource.hikari.maximum-pool-size=6

# Redis
spring.data.redis.host=61.75.54.208
spring.data.redis.port=6379

# JPA
spring.jpa.hibernate.ddl-auto=update
spring.jpa.open-in-view=false

# 테스트 코드: 없음
```

---

## 3. ERD 분석

### 3.1 분석 방법

Entity 클래스(`@Entity`, `@Table`, `@Column`, `@JoinColumn`, `@ElementCollection`)의 어노테이션과 필드 정의를 분석하여 실제 Oracle DB 테이블 구조를 도출하였다.

### 3.2 분석 대상 Entity 클래스

| Entity 클래스 | 파일 경로 | 대응 테이블 |
|-------------|---------|-----------|
| `MembersEntity` | `members/model/MembersEntity.java` | MEMBERTBL |
| `AuthenticationEntity` | `JWT/DTO/AuthenticationEntity.java` | USERENTITY |
| (ElementCollection) | AuthenticationEntity 내부 | USERENTITY_ROLES |
| `Review` | `review/domain/Review.java` | REVIEWS |
| `ReviewKeyword` | `review/domain/ReviewKeyword.java` | REVIEW_KEYWORDS |
| `ReviewStatistics` | `review/domain/ReviewStatistics.java` | REVIEW_STATISTICS |
| `BoardEntity` | `board/model/BoardEntity.java` | WHEREBOARD |
| `CommentEntity` | `board/model/CommentEntity.java` | COMMENTTBL |

### 3.3 총 8개 테이블 구조 요약

#### 회원 도메인 (이중 테이블 구조)

**설계 특징**: 회원 프로필 정보(MEMBERTBL)와 Spring Security 인증 정보(USERENTITY)가 물리적으로 분리되어 있으며, `MEMBERTBL.id = USERENTITY.userid`로 논리적 1:1 매핑된다. 회원 가입 시 반드시 두 테이블에 동시 INSERT가 필요하다.

**MEMBERTBL (회원 프로필)**

| 컬럼명 | 데이터 타입 | 제약조건 | 설명 |
|--------|-----------|---------|------|
| ID | VARCHAR2 | PK | 사용자 아이디 (4~20자) |
| PW | VARCHAR2 | NOT NULL | 비밀번호 (BCrypt 암호화) |
| NICKNAME | VARCHAR2(20) | UNIQUE | 닉네임 |
| TEL | VARCHAR2 | | 전화번호 (010-XXXX-XXXX) |
| EMAIL | VARCHAR2 | | 이메일 |
| JOINDATE | DATE | | 가입일 |

**USERENTITY (JWT 인증 전용)**

| 컬럼명 | 데이터 타입 | 제약조건 | 설명 |
|--------|-----------|---------|------|
| USERID | VARCHAR2 | PK | 사용자 아이디 |
| USERNAME | VARCHAR2 | | 사용자 닉네임 |
| PASSWORD | VARCHAR2 | | BCrypt 암호화 비밀번호 |

**USERENTITY_ROLES (@ElementCollection)**

| 컬럼명 | 데이터 타입 | 제약조건 | 설명 |
|--------|-----------|---------|------|
| USERID | VARCHAR2 | FK → USERENTITY.USERID (CASCADE) | 사용자 아이디 |
| ROLES | VARCHAR2 | | 권한 (ROLE_USER 등) |

#### 리뷰 도메인 (3계층 구조)

**REVIEWS (리뷰 원본)**

| 컬럼명 | 데이터 타입 | 제약조건 | 설명 |
|--------|-----------|---------|------|
| REVIEW_ID | NUMBER | PK (SEQ: SEQ_REVIEW_ID) | 리뷰 고유 식별자 |
| PROPERTY_ID | VARCHAR2(32) | UK(property_id, user_id) | 매물 참조 (MD5 해시) |
| USER_ID | VARCHAR2 | UK(property_id, user_id), NOT NULL | 작성자 ID |
| RATING | NUMBER(1) | NOT NULL, CHECK(1~5) | 별점 |
| CONTENT | CLOB | NOT NULL | 리뷰 내용 |
| CREATED_AT | TIMESTAMP | NOT NULL | 작성 일시 |
| UPDATED_AT | TIMESTAMP | | 수정 일시 |

**핵심 제약**: `(PROPERTY_ID, USER_ID)` 복합 유니크 — 한 매물당 한 유저 하나의 리뷰만 허용.

**REVIEW_KEYWORDS (리뷰 키워드)**

| 컬럼명 | 데이터 타입 | 제약조건 | 설명 |
|--------|-----------|---------|------|
| KEYWORD_ID | NUMBER | PK (SEQ: SEQ_KEYWORD_ID) | 키워드 식별자 |
| REVIEW_ID | NUMBER | FK → REVIEWS.REVIEW_ID (CASCADE) | 참조 리뷰 ID |
| KEYWORD | VARCHAR2(50) | NOT NULL | 키워드 (채광, 소음 등) |
| SCORE | NUMBER(1) | | 감성 점수 (+1 긍정 / -1 부정) |

**REVIEW_STATISTICS (리뷰 통계)**

| 컬럼명 | 데이터 타입 | 제약조건 | 설명 |
|--------|-----------|---------|------|
| PROPERTY_ID | VARCHAR2(32) | PK (매물과 1:1) | 매물 ID |
| REVIEW_COUNT | NUMBER(10) | DEFAULT 0 | 총 리뷰 개수 |
| AVG_RATING | DECIMAL(3,2) | DEFAULT 0.0 | 평균 별점 |
| POSITIVE_KEYWORD_COUNT | NUMBER(10) | DEFAULT 0 | 긍정 키워드 누적 수 |
| NEGATIVE_KEYWORD_COUNT | NUMBER(10) | DEFAULT 0 | 부정 키워드 누적 수 |
| LAST_CALCED | TIMESTAMP | | 최종 집계 일시 |

#### 게시판 도메인 (최후순위 — 현재 미진행)

- **WHEREBOARD** (BoardEntity) — SEQ: whereboarder_seq
- **COMMENTTBL** (CommentEntity) — SEQ: commenttbl_seq

### 3.4 ERD 문서 산출

ERD 분석 결과를 Mermaid 다이어그램 포함 마크다운 문서로 작성 완료.

**산출물**: `wherehouse_erd.md`

---

## 4. 데이터 삽입 전략 수립

### 4.1 삽입 순서 확정

```
① MEMBERTBL ──────────────────────┐
② USERENTITY + USERENTITY_ROLES ──┘ (반드시 ①과 동시 - Phase 1)

     ↓ 배치 실행으로 매물 데이터 적재 ↓

③ REVIEWS ─────────────────────────┐
④ REVIEW_KEYWORDS ─────────────────┤ (Phase 2)
⑤ REVIEW_STATISTICS ───────────────┘
```

### 4.2 핵심 제약사항

| 제약 | 상세 |
|------|------|
| 회원 3테이블 동시 삽입 | MEMBERTBL + USERENTITY + USERENTITY_ROLES 원자적 처리 필수 |
| BCrypt 암호화 | USERENTITY.PASSWORD와 MEMBERTBL.PW 모두 BCrypt 해시 필수 |
| 시퀀스 동기화 | 직접 SQL INSERT 후 SEQ_REVIEW_ID, SEQ_KEYWORD_ID 동기화 필수 |
| UK 제약 | REVIEWS의 (PROPERTY_ID, USER_ID) 중복 시 ORA-00001 에러 |
| 매물 테이블 | 배치 스케줄러(BatchScheduler + RdbSyncListener)로 실 데이터 적재 — 직접 INSERT 불필요 |

### 4.3 비밀번호 처리 전략 결정

`MemberService.validJoin()` 코드 분석 결과:
```java
memberDTO.setPw(passwordEncoder.encode(memberDTO.getPw()));
```

**BCryptPasswordEncoder**를 사용하므로, Oracle PL/SQL에서 직접 BCrypt 해시 생성은 불가능하다(Oracle 내장 `DBMS_CRYPTO`는 MD5/SHA만 지원). 따라서 **공통 비밀번호 1개(`Test1234!`)의 BCrypt 해시를 사전 생성하여 하드코딩**하는 방식을 채택하였다.

생성된 BCrypt 해시:
```
$2b$10$/1NrMXh4D03wnQeA50GljeDIFjYOfH/G9ECxe9XYznqJQVvm9a1om
```

### 4.4 데이터 규모 결정 과정

#### 4.4.1 초기 계획 (회원 45명)

최초 사용자 요청은 회원 45명이었으나, 리뷰 테이블 10만건 이상 필요 조건이 추가되면서 재산정이 필요하게 되었다.

#### 4.4.2 역산 논리

**UK 제약** `(PROPERTY_ID, USER_ID)` 기준 — 한 유저가 한 매물에 1건만 리뷰 가능.

| 유저당 평균 리뷰 | 10만건 달성에 필요한 회원 수 |
|----------------|--------------------------|
| 10건 | 10,000명 |
| 20건 | 5,000명 |
| 30건 | 3,334명 |
| 50건 (헤비 유저 포함) | 2,000명 |

실 서비스 패턴(대부분 유저 1~5건, 일부 활발 유저 50~100건)을 유지하면서 10만건을 달성하기 위해 **회원 2,500명**으로 최종 결정하였다.

#### 4.4.3 최종 데이터 규모

매물 데이터: 전세 ~58,000건 + 월세 ~58,000건 = 총 ~116,000건 (배치 적재)

| 테이블 | 건수 | 근거 |
|--------|------|------|
| MEMBERTBL | 2,500 | 리뷰 10만건 역산 + 실 패턴 유저 분포 |
| USERENTITY | 2,500 | MEMBERTBL과 1:1 |
| USERENTITY_ROLES | 2,500 | USERENTITY와 1:1 |
| REVIEWS | ~100,000+ | Hot/Warm/Cold/Zero 매물 분포 |
| REVIEW_KEYWORDS | ~350,000 | 리뷰당 평균 3.5개 키워드 |
| REVIEW_STATISTICS | ~3,000~5,000 | 리뷰 달린 매물 수 |

#### 4.4.4 리뷰 분배 전략 (Phase 2 계획)

| 구분 | 유저 그룹 | 인원 | 유저당 리뷰 | 소계 |
|------|---------|------|-----------|------|
| 비활성 | 가입만 한 유저 | ~500명 | 0건 | 0 |
| 저활동 | 일반 유저 | ~1,000명 | 5~15건 | ~10,000 |
| 중활동 | 활발한 유저 | ~800명 | 20~50건 | ~28,000 |
| 고활동 | 헤비 유저 | ~200명 | 80~150건 | ~23,000 |
| **합계** | | **2,500명** | | **~100,000+** |

---

## 5. Phase 1 실행 — 회원 데이터 생성

### 5.1 스크립트 개요

| 항목 | 값 |
|------|-----|
| 파일명 | `phase1_members_insert.sql` |
| 언어 | Oracle PL/SQL (DECLARE ~ END 블록) |
| 대상 테이블 | MEMBERTBL, USERENTITY, USERENTITY_ROLES |
| 생성 건수 | 2,500명 |
| 실행 환경 | Oracle SQL Developer |
| 실행 시간 | 약 1~3분 |

### 5.2 생성 로직 상세

#### 5.2.1 ID 생성

```
패턴: user0001 ~ user2500
생성: 'user' || LPAD(TO_CHAR(i), 4, '0')
```

#### 5.2.2 닉네임 생성

한글 형용사(prefix 50개) × 명사(suffix 50개) = 2,500개 유니크 조합.

```
prefix: 행복한, 즐거운, 빠른, 느긋한, 용감한, 조용한, 밝은, 따뜻한, ...
suffix: 고양이, 강아지, 토끼, 여우, 곰, 사슴, 다람쥐, 펭귄, ...
조합: 행복한고양이, 즐거운고양이, ..., 행복한강아지, 즐거운강아지, ...
```

수학적 보장: `MOD(i-1, 50) + 1` × `TRUNC((i-1) / 50) + 1`로 2,500개 전부 유니크.

#### 5.2.3 전화번호 생성

```sql
'010-' || LPAD(TO_CHAR(TRUNC(DBMS_RANDOM.VALUE(1000, 9999))), 4, '0') 
      || '-' 
      || LPAD(TO_CHAR(TRUNC(DBMS_RANDOM.VALUE(1000, 9999))), 4, '0')
```

#### 5.2.4 이메일 생성

10개 도메인 순환: gmail.com, naver.com, daum.net, kakao.com, hanmail.net, nate.com, outlook.com, yahoo.co.kr, icloud.com, proton.me

```
user0001@gmail.com, user0002@naver.com, ..., user0011@gmail.com, ...
```

#### 5.2.5 가입일 생성

```sql
DATE '2024-01-01' + TRUNC(DBMS_RANDOM.VALUE(0, 770))
-- 범위: 2024-01-01 ~ 2026-02-09 (약 2년간 랜덤 분포)
```

#### 5.2.6 비밀번호

전 회원 공통: `Test1234!` → BCrypt 해시 `$2b$10$/1NrMXh4D03wnQeA50GljeDIFjYOfH/G9ECxe9XYznqJQVvm9a1om`

MEMBERTBL.PW와 USERENTITY.PASSWORD 모두 동일 해시값 사용.

#### 5.2.7 커밋 전략

```
500건마다 중간 COMMIT → UNDO 세그먼트(롤백 세그먼트) 과부하 방지
최종 잔여분 COMMIT
예외 발생 시 ROLLBACK + 마지막 커밋 지점 출력
```

### 5.3 INSERT 순서 (루프 내부)

```sql
-- 매 루프(i = 1..2500) 마다:
1. INSERT INTO MEMBERTBL (ID, PW, NICKNAME, TEL, EMAIL, JOINDATE)
2. INSERT INTO USERENTITY (USERID, USERNAME, PASSWORD)
3. INSERT INTO USERENTITY_ROLES (USERID, ROLES) VALUES (v_user_id, 'ROLE_USER')
```

3개 테이블을 동일 루프에서 순차 삽입하여 정합성 보장.

---

## 6. Phase 1 결과 검증

### 6.1 건수 검증

```sql
SELECT 'MEMBERTBL' AS TBL, COUNT(*) AS CNT FROM MEMBERTBL
UNION ALL
SELECT 'USERENTITY', COUNT(*) FROM USERENTITY
UNION ALL
SELECT 'USERENTITY_ROLES', COUNT(*) FROM USERENTITY_ROLES;
```

| 테이블 | 건수 | 상태 |
|--------|------|------|
| MEMBERTBL | 2,500 | ✅ |
| USERENTITY | 2,500 | ✅ |
| USERENTITY_ROLES | 2,500 | ✅ |

### 6.2 샘플 데이터 확인

```sql
SELECT ID, NICKNAME, TEL, EMAIL, JOINDATE 
FROM MEMBERTBL WHERE ROWNUM <= 10 ORDER BY ID;
```

| ID | NICKNAME | TEL | EMAIL | JOINDATE |
|----|----------|-----|-------|----------|
| user0001 | 행복한고양이 | 010-1086-9121 | user0001@gmail.com | 24/02/19 |
| user0002 | 즐거운고양이 | 010-1546-2112 | user0002@naver.com | 25/09/09 |
| user0003 | 빠른고양이 | 010-2305-6561 | user0003@daum.net | 24/02/21 |
| user0004 | 느긋한고양이 | 010-4557-2189 | user0004@kakao.com | 25/02/19 |
| user0005 | 용감한고양이 | 010-3798-7298 | user0005@hanmail.net | 24/12/05 |
| ... | ... | ... | ... | ... |

### 6.3 정합성 검증

```sql
-- MEMBERTBL ↔ USERENTITY 양방향 정합성 (0건이어야 정상)
SELECT m.ID AS MEMBER_ONLY FROM MEMBERTBL m
LEFT JOIN USERENTITY u ON m.ID = u.USERID WHERE u.USERID IS NULL
UNION ALL
SELECT u.USERID AS AUTH_ONLY FROM USERENTITY u
LEFT JOIN MEMBERTBL m ON u.USERID = m.ID WHERE m.ID IS NULL;
```

**결과**: 0건 ✅ (양쪽 테이블 완벽 일치)

### 6.4 레거시 데이터 정리

스크립트 실행 전 기존 테이블에 남아있던 레거시 데이터(잘못된 ID, 테스트 계정 등)가 정합성 검증에서 검출되어 정리하였다.

#### 1차 정리: MEMBERTBL 고아 데이터

```sql
DELETE FROM MEMBERTBL WHERE ID NOT IN (SELECT USERID FROM USERENTITY);
COMMIT;
```

제거 대상: 숫자 ID(`1`, `2`), 이전 테스트 계정(`yhjj210`, `yhjj815`~`yhjj819`), BCrypt 해시값이 ID로 들어간 잘못된 데이터 — 총 8건

#### 2차 정리: USERENTITY 고아 데이터

```sql
DELETE FROM USERENTITY_ROLES WHERE USERID NOT IN (SELECT ID FROM MEMBERTBL);
DELETE FROM USERENTITY WHERE USERID NOT IN (SELECT ID FROM MEMBERTBL);
COMMIT;
```

제거 대상: USERENTITY에만 존재하던 BCrypt 해시값 ID 데이터 — 총 8건

#### 정리 후 최종 확인

3개 테이블 모두 **2,500건**으로 정합성 100% 확인 완료.

### 6.5 가입일 분포 확인

```sql
SELECT TO_CHAR(JOINDATE, 'YYYY-MM') AS MONTH, COUNT(*) AS CNT
FROM MEMBERTBL GROUP BY TO_CHAR(JOINDATE, 'YYYY-MM') ORDER BY MONTH;
```

| 월 | 건수 | 월 | 건수 |
|----|------|-----|------|
| 2024-01 | 100 | 2025-01 | 114 |
| 2024-02 | 89 | 2025-02 | 79 |
| 2024-03 | 85 | 2025-03 | 103 |
| 2024-04 | 102 | 2025-04 | 96 |
| 2024-05 | 111 | 2025-05 | 110 |
| 2024-06 | 80 | 2025-06 | 93 |
| 2024-07 | 81 | 2025-07 | 119 |
| 2024-08 | 94 | 2025-08 | 99 |
| 2024-09 | 95 | 2025-09 | 109 |
| 2024-10 | 90 | 2025-10 | 108 |
| 2024-11 | 96 | 2025-11 | 108 |
| 2024-12 | 104 | 2025-12 | 96 |
| | | 2026-01 | 110 |
| | | 2026-02 | 30 |

월별 80~119건으로 자연스러운 랜덤 분포 확인. ✅

---

## 7. Phase 2 사전 계획 — 리뷰 데이터 생성

### 7.1 선행 조건

1. **BatchScheduler 실행**: 국토교통부 API에서 매물 데이터 수집
2. **RdbSyncListener 동작**: 수집된 매물을 PROPERTIES_CHARTER, PROPERTIES_MONTHLY 테이블에 Upsert
3. **매물 데이터 확인**: 실제 PROPERTY_ID 값 확보

### 7.2 실행 전 확인 쿼리

```sql
-- 매물 총 건수 확인
SELECT 'CHARTER' AS TYPE, COUNT(*) AS CNT FROM PROPERTIES_CHARTER
UNION ALL
SELECT 'MONTHLY', COUNT(*) FROM PROPERTIES_MONTHLY;

-- 전세 매물 ID 샘플 (상위 20건)
SELECT PROPERTY_ID, APT_NM, DISTRICT_NAME FROM PROPERTIES_CHARTER WHERE ROWNUM <= 20;

-- 월세 매물 ID 샘플 (상위 20건)
SELECT PROPERTY_ID, APT_NM, DISTRICT_NAME FROM PROPERTIES_MONTHLY WHERE ROWNUM <= 20;
```

### 7.3 Phase 2 스크립트 생성 계획

| 항목 | 값 |
|------|-----|
| 스크립트 언어 | Oracle PL/SQL |
| REVIEWS 목표 건수 | 100,000건 이상 |
| REVIEW_KEYWORDS 목표 건수 | ~350,000건 (리뷰당 평균 3.5개) |
| REVIEW_STATISTICS 목표 건수 | 리뷰 달린 매물 수만큼 |
| 리뷰 분배 패턴 | Hot(8~15건)/Warm(5~7건)/Cold(1~3건)/Zero(0건) |
| 키워드 사전 | KeywordDictionary Enum 기반 (6카테고리, 19개 키워드) |
| 시퀀스 동기화 | SEQ_REVIEW_ID, SEQ_KEYWORD_ID 사후 동기화 필수 |

### 7.4 시퀀스 동기화 절차 (Phase 2 완료 후)

```sql
-- 1. 현재 최대값 확인
SELECT MAX(REVIEW_ID) FROM REVIEWS;
SELECT MAX(KEYWORD_ID) FROM REVIEW_KEYWORDS;

-- 2. 시퀀스를 최대값+1로 점프
ALTER SEQUENCE SEQ_REVIEW_ID INCREMENT BY {MAX_REVIEW_ID};
SELECT SEQ_REVIEW_ID.NEXTVAL FROM DUAL;
ALTER SEQUENCE SEQ_REVIEW_ID INCREMENT BY 1;

ALTER SEQUENCE SEQ_KEYWORD_ID INCREMENT BY {MAX_KEYWORD_ID};
SELECT SEQ_KEYWORD_ID.NEXTVAL FROM DUAL;
ALTER SEQUENCE SEQ_KEYWORD_ID INCREMENT BY 1;
```

---

## 8. 산출물 목록

| # | 파일명 | 유형 | 설명 | 상태 |
|---|--------|------|------|------|
| 1 | `wherehouse_erd.md` | 문서 | 회원+리뷰 도메인 ERD (Mermaid 다이어그램 포함) | ✅ 완료 |
| 2 | `phase1_members_insert.sql` | SQL 스크립트 | 회원 2,500명 대량 생성 PL/SQL | ✅ 완료/실행 완료 |
| 3 | `phase2_reviews_insert.sql` | SQL 스크립트 | 리뷰 10만건+ 대량 생성 PL/SQL | ⏳ Phase 2 |
| 4 | 본 문서 | 문서 | 전체 작업 이력서 | ✅ 완료 |

---

## 9. 부록 — 주요 결정 사항 및 근거

### 9.1 의사결정 로그

| # | 결정 사항 | 선택지 | 최종 결정 | 근거 |
|---|----------|-------|----------|------|
| 1 | 매물 데이터 삽입 방식 | SQL 직접 INSERT vs 배치 스케줄러 | **배치 스케줄러** | MD5 해시 ID 생성 로직, Redis 동기화, 인덱스 구축이 배치 내부에서 처리됨. 직접 INSERT 시 이 모든 것을 수동 재현해야 해서 비효율적. |
| 2 | 비밀번호 처리 | 공통 비밀번호 vs 개별 비밀번호 | **공통 비밀번호** (`Test1234!`) | 테스트 환경이므로 단순화. Oracle PL/SQL에서 BCrypt 생성 불가로 사전 해시 하드코딩. |
| 3 | 회원 수 | 45명 → 2,500명 | **2,500명** | 리뷰 10만건 이상 요구 + UK 제약(매물당 유저 1건) + 실 패턴 유저 분포(유저당 5~150건) 역산. |
| 4 | 삽입 방식 | Spring Boot API 경유 vs SQL 직접 | **SQL 직접 (PL/SQL)** | 사용자 지정. Oracle 환경에서 대량 INSERT 시 PL/SQL 프로시저가 가장 효율적. |
| 5 | 커밋 전략 | 전체 1회 COMMIT vs 분할 COMMIT | **500건 단위 분할 COMMIT** | Oracle XE의 UNDO 세그먼트 크기 제한 고려. 2,500건 단일 트랜잭션 시 UNDO 부족 위험. |

### 9.2 설계 명세서 참조 사항

Phase 2 스크립트 생성 시 참조해야 할 설계 명세서 핵심 사항:

| 참조 섹션 | 내용 | 스크립트 영향 |
|----------|------|------------|
| 7.1.2-A REVIEWS 스키마 | PROPERTY_ID CHAR(32), UK(property_id, user_id) | 리뷰 생성 시 중복 방지 로직 필수 |
| 8.1.5 Cold Start | reviewCount < 5 → LegacyScore 100% | Hot/Warm/Cold 분배로 양쪽 분기 테스트 |
| 8.2.3 키워드 사전 | 6카테고리, 19개 키워드, +1/-1 점수 | 키워드 생성 시 사전 기반 매칭 |
| 8.4.3 키워드 통계 집계 | SCORE > 0 긍정, SCORE < 0 부정 | REVIEW_STATISTICS 계산 기준 |
| 8.5 중복 작성 방지 | 복합 유니크 인덱스 | 삽입 시 (property_id, user_id) 유니크 보장 필수 |
