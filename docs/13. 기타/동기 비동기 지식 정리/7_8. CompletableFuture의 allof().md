# CompletableFuture.allOf() 다중 비동기 작업 완료 감지 메커니즘

## 문서 개요

### 작성 배경

Java의 CompletableFuture는 여러 비동기 작업의 완료를 조율하는 `allOf()` 메서드를 제공한다. 그러나 강의 수준의 설명에서는 표면적인 동작 방식에 머물며, 실제 동작 메커니즘과 설계 철학을 다루지 않는다. 특히 `Thread.sleep()`을 사용한 잘못된 동기화 패턴이 왜 구조적 결함을 갖는지, `thenRun()` 같은 Non-Blocking 방식이 어떤 아키텍처적 의의를 갖는지에 대한 깊이 있는 이해가 부족한 경우가 많다.

### 문서의 목적

이 문서는 `allOf()`를 중심으로 CompletableFuture의 완료 감지 메커니즘을 다음 세 가지 관점에서 체계적으로 설명한다:

1. **Non-Blocking 체이닝 메커니즘**: `thenRun()`이 어떻게 Main 스레드를 블로킹하지 않고 후속 작업을 등록하는가
2. **allOf()의 내부 구조**: N개의 독립적인 비동기 작업을 하나의 완료 지점으로 조율하는 바이너리 트리 구조
3. **안티패턴 분석**: `Thread.sleep()`이 왜 완료 통지 체계에서 배제되며, 어떤 구조적 문제를 초래하는가

---

## Non-Blocking 체이닝: thenRun()의 후속 작업 등록 메커니즘

`allOf(cf1, cf2, cf3).thenRun(() -> { System.out.println("완료"); })`를 호출하면, Main 스레드는 블로킹되지 않는다. 대신 "완료되면 이 코드를 실행해줘"라는 후속 작업을 등록하고 즉시 다음 라인으로 진행하거나 종료한다.

내부적으로는 `thenRun()`이 UniRun이라는 Completion 객체를 생성하여 CompletableFuture의 completion stack에 push한다. 이 시점에서 두 가지 경우가 존재한다.

### 경우 A: 이미 완료된 경우

`thenRun()` 호출 시점에 allOf가 이미 완료 상태라면, Main 스레드가 즉시 람다 내부 코드를 실행한다. "워커가 실행한다"는 것은 오해이며, 실제로는 완료를 감지한 최초의 스레드가 실행한다.

### 경우 B: 아직 미완료인 경우

후속 작업만 등록하고 Main 스레드는 떠난다. 나중에 마지막 워커가 작업을 완료하면서 `postComplete()`를 호출할 때, 등록된 Completion들을 순차적으로 발화시킨다. 이때 워커 스레드가 람다 내부 코드를 직접 실행한다.

### 구조적 변화: 스레드 활용률의 극대화

이 설계가 가져온 구조적 변화는 **스레드 활용률의 극대화**이다. 서버 환경을 예로 들면, HTTP 요청을 처리하는 Tomcat 스레드가 데이터베이스 쿼리 완료를 `join()`으로 기다린다면, 그 스레드는 쿼리가 끝날 때까지 블로킹되어 다른 요청을 처리할 수 없다. 

만약 `thenRun()`으로 "쿼리 완료되면 응답 전송"이라는 후속 작업만 등록한다면, Tomcat 스레드는 즉시 다음 요청을 받을 수 있다. 응답 전송은 쿼리를 수행한 DB I/O 워커 스레드가 이어서 처리하므로, Tomcat 스레드 풀의 처리량이 증가한다.

### 절충: 불확실성의 수용

대신 프로그래머는 "이 코드가 어느 스레드에서 실행될지 예측할 수 없다"는 불확실성을 받아들여야 한다. ThreadLocal 변수나 스레드 이름에 의존하는 코드는 예상과 다르게 동작할 수 있다. 명확한 제어 흐름을 포기하고 처리량을 얻는 상충관계이다.

---

## allOf()의 다중 완료 조율

`allOf(cf1, cf2, cf3)`는 3개의 독립적인 CompletableFuture를 하나의 통합된 완료 지점으로 변환한다. 내부 구현은 바이너리 트리 형태의 중간 CompletableFuture들을 생성한다. 트리의 각 노드는 "내 두 자식이 모두 완료되었는가?"를 감시하는 조율 지점으로 작동한다.

### 바이너리 트리 구조

예를 들어 `allOf(cf1, cf2, cf3)`는 다음과 같은 트리를 생성한다:

```
       result (allOf 반환값)
          |
      중간노드    cf3
          |
      cf1    cf2
```

### 완료 신호의 계층적 전파

cf1이 완료되면 중간노드에 통지되지만, 중간노드는 아직 반응하지 않는다. cf2가 완료되면 중간노드가 "두 자식이 모두 완료됨"을 감지하고 자신도 완료 상태로 전환되며 상위 노드를 트리거한다. 최종적으로 cf3까지 완료되면 result가 완료 상태가 되고, 여기에 등록된 모든 대기자들이 깨어나거나 후속 작업들이 발화된다.

각 중간 노드는 두 개의 자식 CompletableFuture를 감시하며, 첫 번째 완료는 기록만 하고 두 번째 완료가 도착할 때 비로소 자신의 완료를 선언한다. 이 방식으로 N개의 작업은 log(N) 깊이의 트리를 통해 하나의 완료 지점으로 수렴된다.

### 조합 가능성

이 계층적 전파 구조의 의의는 **조합 가능성**이다. 단순히 "N개가 끝났다"를 확인하는 것을 넘어, 여러 `allOf()` 결과를 다시 `allOf()`로 묶거나, 각 완료 지점에 서로 다른 후속 작업을 체이닝할 수 있다. 

### 메모리 비용 절충

반면 N개 작업당 약 N개의 중간 객체가 생성되므로 메모리 비용이 발생한다. CountDownLatch 같은 단순 카운터 방식은 메모리 효율적이지만 체이닝이 불가능하다. CompletableFuture는 메모리를 희생하여 유연성을 확보한 설계이다.