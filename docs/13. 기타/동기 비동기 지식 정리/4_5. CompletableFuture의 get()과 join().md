# CompletableFuture의 두 가지 대기 메커니즘: get()과 join()의 설계 철학과 내부 구현

## 서장: 비동기 프로그래밍의 근본적 모순

비동기 프로그래밍은 작업의 병렬 실행을 통해 대기 시간을 제거하는 것을 목표로 한다. 그러나 최종적으로는 작업의 결과를 수집해야 하므로 어느 시점에서는 완료를 확인해야 한다. 이 동기화 지점에서 CompletableFuture는 get()과 join()이라는 두 가지 메서드를 제공한다. 두 메서드가 공존하는 이유는 Java 5의 Future 인터페이스 계약과 Java 8의 함수형 프로그래밍 요구사항이 서로 다른 설계 원칙을 요구하기 때문이다.

## 1부: 개념적 토대

### 비동기 작업 완료의 두 가지 철학

Java 5에서 도입된 Future 인터페이스는 비동기 작업의 결과를 표현하는 최초의 표준화된 방법이었다. 이 인터페이스는 get() 메서드를 통해 명시적 예외 처리를 요구했다. 모든 잠재적 오류 상황 - 작업의 실패, 외부 중단 요청, 무한 대기 - 을 checked exception으로 표현하여 컴파일 시점에 처리를 강제했다.

Java 8에서 등장한 CompletableFuture는 Future 인터페이스를 구현하면서 동시에 새로운 메서드를 추가했다. get() 메서드는 Future 인터페이스의 계약을 구현하기 위해 유지되었고, 새로 추가된 join() 메서드는 다른 설계 원칙을 구현했다. join()은 checked exception을 제거하고, 인터럽트를 무시하며, 타임아웃을 지원하지 않는다.

### 동기화 지점의 필연성과 제어권의 문제

모든 비동기 시스템에는 동기화 지점이 필요하다. 이 지점에서 제어권 처리 방식이 두 메서드의 핵심 차이다. get() 메서드는 호출자에게 완전한 제어권을 제공한다. 인터럽트로 중단 가능하고, 타임아웃으로 대기를 제한할 수 있으며, 각 예외 상황을 구분하여 처리할 수 있다. join()은 작업 완료를 보장하는 방식으로 설계되었다. 시작하면 완료까지 대기하며, 외부 중단 신호를 처리하지 않는다.

이러한 차이는 프로그램 실행 흐름의 제어 방식에 대한 서로 다른 접근법을 반영한다. get()은 호출자가 실행 흐름을 제어하는 명령형 프로그래밍 모델을, join()은 시스템이 실행을 보장하는 선언형 프로그래밍 모델을 각각 구현한다.

## 2부: Future 인터페이스와 get() 메서드의 역사적 맥락

### Future 인터페이스의 탄생 배경

2004년, Java 5의 java.util.concurrent 패키지는 Doug Lea의 주도로 만들어진 동시성 프레임워크였다. 멀티코어 프로세서의 보편화와 함께 병렬 처리를 위한 표준화된 추상화가 필요했다. Future 인터페이스는 이러한 요구사항을 충족시키기 위해 설계되었다.

Future의 설계는 방어적 프로그래밍 원칙을 따랐다. 네트워크 통신, 데이터베이스 쿼리, 파일 I/O 같은 불확실한 작업들을 다루기 위해, 모든 가능한 실패 시나리오를 명시적으로 모델링했다. InterruptedException은 작업의 취소를, ExecutionException은 작업 자체의 실패를, TimeoutException은 시간 제한 초과를 각각 표현했다.

### get() 메서드의 설계 원칙

get() 메서드는 세 가지 핵심 원칙을 구현한다. 첫째, "명시적 오류 처리"다. checked exception을 통해 개발자가 실패 가능성을 잊을 수 없도록 한다. 둘째, "협조적 중단"이다. 인터럽트 메커니즘을 통해 장시간 실행되는 작업을 안전하게 중단할 수 있다. 셋째, "제한된 대기"다. 타임아웃을 통해 무한 대기의 위험을 제거한다.

이러한 원칙들은 엔터프라이즈 환경의 요구사항을 반영한다. 트랜잭션 처리 시스템, 웹 서버, 데이터베이스 연결 풀 등은 모두 자원의 효율적 사용과 장애 상황의 빠른 복구를 요구한다. get() 메서드는 이러한 요구사항을 충족시키기 위해 설계되었다.

### CompletableFuture에서의 get() 구현

CompletableFuture는 Future 인터페이스를 구현하면서도, 내부적으로는 훨씬 정교한 메커니즘을 사용한다. 단순한 블로킹 대기가 아닌, 적응형 대기 전략을 구현한다. 초기에는 스핀 대기로 CPU를 활용하고, 이후 점진적으로 무거운 블로킹으로 전환한다. 이는 짧은 대기와 긴 대기 모두에 대해 최적의 성능을 제공한다.

## 3부: join() 메서드의 등장과 함수형 프로그래밍의 요구

### Java 8과 패러다임의 전환

2014년 출시된 Java 8은 Java 언어에 중요한 변화를 가져왔다. 람다 표현식, 스트림 API, 메서드 레퍼런스 등 함수형 프로그래밍 기능이 도입되었다. 이러한 변화는 기존의 명령형 API들과 구조적 불일치를 발생시켰고, CompletableFuture는 이러한 불일치를 해결해야 했다.

함수형 프로그래밍에서 함수는 부수 효과 없이 동작해야 한다. checked exception은 이러한 요구사항과 맞지 않는다. 람다 표현식 내에서 try-catch를 작성해야 한다면, 함수형 프로그래밍의 간결성이 손상된다. 또한 함수 조합(function composition)이 복잡해진다.

### join()의 설계 결정

join() 메서드는 세 가지 주요 설계 결정을 구현했다. 첫째, checked exception을 완전히 제거했다. 모든 예외를 CompletionException이라는 unchecked exception으로 포장한다. 둘째, 인터럽트를 처리하지 않는다. 외부의 중단 요청이 와도 작업이 완료될 때까지 대기한다. 셋째, 타임아웃을 지원하지 않는다. 대기를 시작하면 완료까지 계속한다.

이러한 결정들은 함수형 파이프라인의 결정론적 실행을 보장하기 위한 것이다. 스트림 처리나 CompletableFuture 체인에서 중간 단계가 예측 불가능하게 중단되면, 전체 연산의 일관성이 보장되지 않는다.

### 인터럽트 불감증의 의미론

join()이 인터럽트를 무시한다는 것은 InterruptedException을 던지지 않는다는 의미를 넘어선다. join()의 대기 로직은 스레드의 인터럽트 상태를 확인하는 코드 경로 자체가 없다. LockSupport.park()가 인터럽트 신호로 인해 반환될 수 있지만, join()은 반환 이유를 구분하지 않고 단지 CompletableFuture의 완료 여부만 확인한다. 결과적으로 스레드의 인터럽트 플래그는 set된 채로 유지되며, join() 호출이 완료된 후 이후 코드에서 이 상태를 확인할 수 있다. 이는 현재 시점에서는 중단을 허용하지 않지만, 중단 요청 자체는 보존하는 설계다.

## 4부: 내부 구현의 심층 분석

### CompletableFuture의 상태 모델

CompletableFuture의 모든 동작은 단일 volatile Object result 필드를 중심으로 한다. 이 필드는 세 가지 상태를 표현한다. null은 미완료를, 실제 값은 정상 완료를, AltResult 래퍼는 예외나 취소를 의미한다. 이 단순한 상태 모델이 복잡한 비동기 연산을 가능하게 하는 기반이다.

상태 전환은 compare-and-swap(CAS) 연산으로 원자적으로 수행된다. 한 번 완료된 future는 절대 다시 미완료 상태로 돌아갈 수 없다. 이 불변성이 동시성 환경에서의 안전성을 보장한다.

### get()과 join()의 내부 구현 구조

get()과 join()은 유사한 대기 메커니즘을 사용하지만, 서로 다른 코드 경로를 통해 구현된다. 두 메서드의 핵심 차이는 대기 루프 내에서 인터럽트 상태를 확인하는지 여부다.

**get() 메서드의 구현 흐름:**

1. result 필드를 확인하여 이미 완료되었다면 즉시 결과 반환
2. 미완료 상태라면 대기 로직 진입
3. 짧은 스핀 대기 수행 (플랫폼과 JDK 버전에 따라 다름)
4. 스핀 대기 중 매 반복마다 Thread.interrupted() 호출하여 인터럽트 확인
5. 인터럽트 감지 시 즉시 InterruptedException 발생
6. 스핀이 끝나면 Signaller 객체를 생성하고 completion 스택에 등록
7. LockSupport.park()로 실제 블로킹
8. park()에서 반환될 때마다 인터럽트 상태 확인
9. 완료되면 reportGet()을 통해 결과를 ExecutionException으로 포장하여 반환

**join() 메서드의 구현 흐름:**

1. result 필드를 확인하여 이미 완료되었다면 즉시 결과 반환
2. 미완료 상태라면 대기 로직 진입
3. 짧은 스핀 대기 수행 (get()과 동일한 메커니즘)
4. 스핀 대기 중 인터럽트 확인을 하지 않음
5. 스핀이 끝나면 Signaller 객체를 생성하고 completion 스택에 등록
6. LockSupport.park()로 실제 블로킹
7. park()에서 반환되어도 인터럽트 상태를 확인하지 않음
8. 오직 result 필드의 완료 여부만 확인
9. 완료되면 reportJoin()을 통해 결과를 CompletionException으로 포장하여 반환


### 예외 처리와 포장 메커니즘

작업 실행 중 발생한 예외는 AltResult 객체에 포장되어 result 필드에 저장된다. get()과 join()은 이를 추출할 때 다른 타입으로 재포장한다.

```java
// get()의 예외 처리
private static <T> T reportGet(Object r)
        throws InterruptedException, ExecutionException {
    if (r instanceof AltResult) {
        Throwable x = ((AltResult)r).ex;
        if (x == null)  // 취소된 경우
            throw new CancellationException();
        if (x instanceof CancellationException)
            throw (CancellationException)x;
        if (x instanceof CompletionException)
            x = x.getCause();  // 언래핑
        throw new ExecutionException(x);  // checked로 포장
    }
    return (T)r;
}

// join()의 예외 처리
private static <T> T reportJoin(Object r) {
    if (r instanceof AltResult) {
        Throwable x = ((AltResult)r).ex;
        if (x == null)  // 취소된 경우
            throw new CancellationException();
        if (x instanceof CancellationException)
            throw (CancellationException)x;
        if (x instanceof CompletionException)
            throw (CompletionException)x;
        throw new CompletionException(x);  // unchecked로 포장
    }
    return (T)r;
}
```

ExecutionException은 checked exception으로서 명시적 처리를 강제한다. CompletionException은 unchecked exception으로서 투명한 전파를 허용한다. 이 차이가 두 메서드의 사용성을 크게 좌우한다.

### 타임아웃 메커니즘의 정밀한 구현

get(long timeout, TimeUnit unit)은 정확한 타임아웃을 보장하기 위해 System.nanoTime()을 사용한다. 이는 시스템 시간 변경에 영향받지 않는 단조 시계(monotonic clock)다.

```java
public T get(long timeout, TimeUnit unit) 
        throws InterruptedException, ExecutionException, TimeoutException {
    long nanos = unit.toNanos(timeout);
    Object r;
    if ((r = result) == null) {
        long deadline = System.nanoTime() + nanos;
        Signaller q = new Signaller(true, nanos, deadline);
        
        // completion 스택에 등록하고 대기
        while ((r = result) == null) {
            if (!tryPushStack(q)) {
                // 푸시 실패, 재시도
                continue;
            }
            ForkJoinPool.managedBlock(q);
            // 여기서 반환되면 완료 또는 타임아웃
            if (q.nanos <= 0L) {
                cleanStack();
                throw new TimeoutException();
            }
        }
    }
    return reportGet(r);
}
```

Signaller의 isReleasable()과 block()에서 deadline을 확인하며, 매번 남은 시간을 재계산하여 스퓨리어스 웨이크업에도 정확한 타임아웃을 보장한다.

## 5부: 함수형 프로그래밍과의 통합

### 람다 표현식과 checked exception의 구조적 충돌

Java 8의 함수형 인터페이스들은 checked exception을 선언하지 않는다. 이는 의도적인 설계 결정이었다. checked exception은 함수 조합을 복잡하게 만들고, 타입 시스템을 복잡하게 한다.

```java
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);  // throws 절이 없음
}
```

이로 인해 get()을 람다 내에서 사용하려면 번거로운 예외 처리가 필요하다:

```java
// get()을 사용한 스트림 처리 - 매우 복잡
List<Result> results = futures.stream()
    .map(f -> {
        try {
            return f.get();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        } catch (ExecutionException e) {
            throw new RuntimeException(e);
        }
    })
    .collect(Collectors.toList());

// join()을 사용한 스트림 처리 - 간결
List<Result> results = futures.stream()
    .map(CompletableFuture::join)  // 메서드 레퍼런스 가능
    .collect(Collectors.toList());
```

## 6부: 실전 적용 가이드

### 선택 기준 결정 트리

어떤 메서드를 선택할지는 작업의 특성과 실행 환경에 따라 결정된다.

**get()을 선택해야 하는 경우:**

1. **외부 시스템과의 통신**: 네트워크, 데이터베이스, 파일 시스템 등 제어할 수 없는 요소가 개입할 때
2. **사용자 상호작용**: 취소 가능성이 있는 UI 작업, 웹 요청 처리
3. **자원 제약 환경**: 스레드 풀이 제한적이거나 메모리가 부족한 상황
4. **명시적 오류 처리가 필요한 경우**: 감사(audit), 규정 준수가 중요한 시스템

**join()을 선택해야 하는 경우:**

1. **함수형 파이프라인**: 스트림 처리, CompletableFuture 체인
2. **내부 계산 작업**: 외부 의존성 없는 순수 연산
3. **트랜잭션 일관성**: 모든 작업이 완료되어야 하는 배치 처리
4. **테스트 코드**: 간단명료한 검증 로직

## 결론: 이중 구조의 필요성

CompletableFuture가 get()과 join() 두 메서드를 모두 제공하는 것은 서로 다른 프로그래밍 패러다임과 사용 사례를 지원하기 위한 설계다. 각 메서드는 특정 요구사항에 최적화되어 있다.

get()은 전통적인 동시성 프로그래밍의 요구사항을 충족한다. 명시적 오류 처리, 협조적 중단, 제한된 대기 등 엔터프라이즈 Java 환경에서 축적된 패턴들을 구현한다. 외부 시스템과 상호작용하는 경계에서 필수적인 기능들을 제공한다.

join()은 함수형 프로그래밍 모델을 지원한다. 순수성, 조합 가능성, 참조 투명성 등 함수형 프로그래밍의 요구사항을 충족한다. 내부 로직을 간결하게 표현하는 데 적합하다.

두 메서드의 공존은 Java가 기존 코드베이스와의 호환성을 유지하면서 새로운 프로그래밍 모델을 지원하는 방법을 보여준다. 개발자는 각 상황에 맞는 메서드를 선택할 수 있으며, 필요시 두 가지를 혼용할 수도 있다.

get()과 join()의 차이를 이해하는 것은 API 사용법을 넘어 동시성 프로그래밍의 본질과 함수형 프로그래밍의 원칙을 이해하는 것이다. 이러한 이해를 바탕으로 더 안정적이고 유지보수 가능한 비동기 시스템을 구축할 수 있다.