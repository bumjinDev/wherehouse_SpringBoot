# Future: 비동기 작업 결과 참조의 표준 추상화

## 서론: 작업 제출과 결과 수신의 시간적 분리

Thread를 직접 생성하는 방식에서는 워커 Thread가 계산한 결과를 메인 Thread로 전달할 표준화된 방법이 없었다. 이유는 호출자인 메인 Thread 와 실제 워커 Thread 는 각자의 호출 스택이 물리적으로 별도로 구현되어 있기 때문이다. 개발자는 공유 변수를 선언하고 synchronized 블록으로 동기화하거나, BlockingQueue를 사용해 결과 전달 채널을 수동으로 구현해야 했다. 이는 모든 개발자가 동일한 문제를 반복적으로 해결하며, 각 구현마다 미묘한 동기화 버그를 양산하는 구조적 비효율을 초래했다.

ExecutorService는 작업 제출과 실행의 분리를 구현했지만, "제출한 작업의 결과를 나중에 어떻게 조회할 것인가"에 대한 추상화가 필요했다. Future는 이 시간적 분리를 해결하기 위해 도입된 인터페이스다. 작업 제출 시점에 "미래의 결과를 참조할 수 있는 핸들"을 반환함으로써, 작업 실행과 결과 수신을 독립적인 시간 축에서 제어할 수 있게 되었다.

---

## 본론: Future의 설계 구조와 내부 메커니즘

### Future 인터페이스: 결과 참조의 계약

Future는 비동기 작업의 결과를 참조하기 위한 표준 인터페이스다. 이 인터페이스는 작업이 어떻게 실행되는지에 대해서는 아무것도 정의하지 않으며, 오직 "이미 제출된 작업의 결과를 어떻게 조회하고 제어할 것인가"만을 명세한다.

```java
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit) 
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

**get() 메서드**는 작업이 완료될 때까지 호출 Thread를 블로킹하며 결과를 반환한다. 작업이 정상 완료되면 결과 값을 반환하고, 예외로 완료되면 ExecutionException으로 래핑하여 던지며, 대기 중 인터럽트가 발생하면 InterruptedException을 던진다. 이 메서드의 설계적 의의는 "아직 존재하지 않는 값을 필요한 시점까지 대기하며 수신"하는 블로킹 동기화를 표준화했다는 점이다.

**타임아웃 버전의 get() 메서드**는 지정된 시간 내에 작업이 완료되지 않으면 TimeoutException을 던진다. 이것은 무한 대기를 방지하기 위한 안전장치로, 네트워크 타임아웃이나 외부 시스템 지연으로 인한 영구 블로킹을 차단한다. 타임아웃이 발생해도 작업 자체는 취소되지 않으며, 백그라운드에서 계속 실행된다.

**isDone() 메서드**는 작업의 완료 여부를 논블로킹 방식으로 조회한다. 정상 완료, 예외 완료, 취소 모두 완료로 간주되어 true를 반환한다. 이 메서드는 폴링 기반 대기 구현을 가능하게 하지만, 반복 호출 시 CPU를 소비하는 busy-waiting이 발생할 수 있어 권장되지 않는다.

**cancel() 메서드**는 작업 취소를 시도한다. mayInterruptIfRunning 플래그가 true면 실행 중인 Thread에 인터럽트를 시도하고, false면 아직 시작되지 않은 작업만 취소한다. 하지만 이것은 "강제 중단"이 아니라 "협력적 취소"다. 작업 내부에서 인터럽트를 확인하고 스스로 중단해야 실제 취소가 이루어진다. 이미 완료된 작업은 취소할 수 없으며 false를 반환한다.

**isCancelled() 메서드**는 작업이 취소되었는지 조회한다. 이것은 완료 상태를 세분화하여, 정상 완료와 취소에 의한 완료를 구분할 수 있게 한다.

### Runnable과 Callable: 작업 표현의 두 인터페이스

ExecutorService의 작업 큐가 저장하는 것은 Runnable 인터페이스를 구현한 객체다. Runnable은 Java 1.0부터 존재한 Thread 작업의 표준 인터페이스로, 단일 메서드만을 정의한다.

```java
public interface Runnable {
    void run();
}
```

Runnable의 근본적 한계는 **반환값이 없고 체크 예외를 던질 수 없다**는 점이다. run() 메서드는 void를 반환하므로, 작업의 결과를 호출자에게 전달할 방법이 없다. 또한 throws 절이 없으므로, 체크 예외가 발생하면 run() 내부에서 처리하거나 언체크 예외로 래핑해야 한다.

Java 5는 이 한계를 극복하기 위해 Callable 인터페이스를 도입했다.

```java
public interface Callable<V> {
    V call() throws Exception;
}
```

Callable은 제네릭 타입 V를 반환하며, throws Exception 절로 모든 체크 예외를 던질 수 있다. 이것은 **값을 생성하는 작업**을 표현하기 위한 인터페이스다.

하지만 ExecutorService의 작업 큐는 `BlockingQueue<Runnable>` 타입이다. Callable을 직접 큐에 넣을 수 없다. 따라서 Callable을 Runnable로 변환하면서 동시에 반환값을 어딘가에 저장하는 어댑터가 필요하다. **FutureTask가 바로 이 어댑터 역할을 수행한다.**

### FutureTask: 실행 가능한 Future 구현체

FutureTask는 Runnable과 Future 두 인터페이스를 동시에 구현하는 클래스다. 더 정확히는 RunnableFuture 인터페이스를 구현한다.

```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    void run();
}

public class FutureTask<V> implements RunnableFuture<V> {
    // 구현
}
```

FutureTask의 설계 의도를 이해하려면 다음 문제를 생각해야 한다. Callable은 값을 반환하지만 Runnable이 아니므로 작업 큐에 넣을 수 없다. Callable을 Runnable로 래핑하려면, Runnable의 run() 메서드 내부에서 Callable의 call()을 호출하고, 그 반환값을 어딘가에 저장해야 한다. 그리고 나중에 그 저장된 값을 조회할 방법도 필요하다.

**FutureTask는 이 모든 것을 단일 객체로 통합한다.** FutureTask는 Runnable이므로 작업 큐에 넣을 수 있고, 내부에 Callable을 담고 있으며, run() 메서드 내부에서 Callable.call()을 실행하고 결과인 작업 상태 등을 run() 메서드 동작 과정 내 자신의 필드에 저장한다. 동시에 Future이므로 get() 메서드로 저장된 결과를 조회할 수 있다.

즉, FutureTask는 "실행 가능한 작업"이면서 동시에 "그 작업의 결과를 참조하는 핸들"이라는 이중 정체성을 갖는다. 제출 시점의 핸들과 실행 시점의 작업이 동일한 객체이므로, 별도의 결과 전달 채널이 불필요하다.

### ExecutorService.submit(): FutureTask 생성과 반환

개발자가 `executor.submit(() -> "결과")`를 호출하면 ExecutorService 내부에서 다음 과정이 실행된다.

ExecutorService의 submit() 메서드 실제 구현은 AbstractExecutorService 클래스에 있다.

```java
public <T> Future<T> submit(Callable<T> task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture<T> ftask = newTaskFor(task);
    execute(ftask);
    return ftask;
}

protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
    return new FutureTask<T>(callable);
}
```

**첫 번째 단계는 Callable을 FutureTask로 래핑하는 것이다.** newTaskFor() 메서드가 새 FutureTask 객체를 생성한다. 이때 FutureTask 생성자가 호출된다.

```java
public FutureTask(Callable<V> callable) {
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;
}
```

생성자는 전달받은 Callable을 callable 필드에 저장하고 state를 NEW로 초기화한다. 이 시점에서 outcome은 null, runner는 null, waiters는 null이다.

**두 번째 단계는 execute(ftask)를 호출하는 것이다.** execute()는 Runnable을 작업 큐에 삽입하는 메서드다. ThreadPoolExecutor의 execute() 구현을 보면, 워커 Thread 수와 큐 상태에 따라 분기하지만, 최종적으로는 workQueue.offer(ftask)를 호출하여 FutureTask를 큐에 넣는다.

FutureTask는 Runnable이므로 `BlockingQueue<Runnable>` 타입의 workQueue에 직접 삽입될 수 있다. 큐에 들어간 FutureTask는 워커 Thread가 꺼내기를 대기한다.

**세 번째 단계는 동일한 FutureTask 객체를 호출자에게 반환하는 것이다.** submit() 메서드는 ftask를 반환하며, 이것은 방금 큐에 넣은 바로 그 객체다. 이 시점에서 submit() 메서드는 즉시 반환되고, 개발자는 FutureTask 참조를 받아 다음 코드로 진행한다.

이 설계의 핵심은 **제출한 객체와 반환받은 객체가 동일하다**는 점이다. 개발자가 받은 Future는 작업 큐 안에 있는 Runnable과 같은 메모리 주소를 가리킨다. 워커 Thread가 이 객체를 실행하면, 실행 결과가 같은 객체 내부에 저장되고, 개발자는 같은 객체의 get()을 호출하여 결과를 조회한다.

람다를 Callable로 변환하는 과정도 간단하다. `executor.submit(() -> "결과")`에서 람다 표현식은 컴파일러에 의해 자동으로 Callable 인터페이스의 익명 구현체로 변환된다. 람다의 반환 타입이 String이면 `Callable<String>`이 되고, void를 반환하면 `Runnable`이 된다.

### FutureTask의 내부 필드: 상태 관리 구조

FutureTask는 작업의 생명주기를 관리하기 위해 다섯 개의 핵심 필드를 갖는다.

```java
public class FutureTask<V> implements RunnableFuture<V> {
    private volatile int state;
    private Callable<V> callable;
    private Object outcome;
    private volatile Thread runner;
    private volatile WaitNode waiters;
}
```

**state 필드**는 작업의 현재 상태를 나타내는 정수다. 상태는 7개의 상수로 정의된다.

```java
private static final int NEW          = 0;
private static final int COMPLETING   = 1;
private static final int NORMAL       = 2;
private static final int EXCEPTIONAL  = 3;
private static final int CANCELLED    = 4;
private static final int INTERRUPTING = 5;
private static final int INTERRUPTED  = 6;
```

NEW는 생성 직후 상태로 아직 실행되지 않았음을 의미한다. COMPLETING은 작업이 완료되어 결과를 설정 중인 과도 상태다. NORMAL은 정상 완료, EXCEPTIONAL은 예외로 인한 완료, CANCELLED는 취소를 나타낸다. INTERRUPTING과 INTERRUPTED는 인터럽트 진행 중과 완료 상태다.

state 필드는 volatile로 선언되어, 한 Thread가 이 값을 변경하면 다른 모든 Thread가 CPU 캐시를 거치지 않고 메인 메모리에서 최신 값을 읽는다. 멀티 Thread 환경에서 상태 변경의 즉각적 가시성은 정확한 완료 감지를 위한 필수 조건이다.

**callable 필드**는 실행할 작업을 담는다. submit()에서 전달받은 Callable이 여기 저장된다. 작업이 완료되면 이 필드는 null로 설정되어 메모리 누수를 방지한다.

**outcome 필드**는 타입이 Object인데, 정상 결과(V 타입)와 예외(Throwable)를 모두 담아야 하기 때문이다. 작업이 성공하면 실제 결과 객체가 이 필드에 저장되고, 실패하면 예외 객체(Throwable)가 직접 저장된다. 정상 완료와 예외 완료는 state 필드(NORMAL vs EXCEPTIONAL)로 구분한다.

**runner 필드**는 현재 이 작업을 실행 중인 워커 Thread의 참조다. 작업 실행 전에는 null이며, run() 메서드 진입 시 현재 Thread로 설정되고, 완료 후 다시 null로 초기화된다. 이 필드도 volatile로 선언되어 가시성이 보장된다.

**waiters 필드**는 결과를 기다리며 블로킹된 Thread들의 단일 연결 리스트다. 각 노드는 WaitNode 객체로, Thread 참조와 다음 노드 포인터를 담는다.

```java
static final class WaitNode {
    volatile Thread thread;
    volatile WaitNode next;
    WaitNode() { thread = Thread.currentThread(); }
}
```

### 상태 전이: 불변성 보장 메커니즘

FutureTask의 상태는 단방향으로만 전이된다. NEW에서 시작하여 반드시 최종 상태(NORMAL, EXCEPTIONAL, CANCELLED, INTERRUPTED) 중 하나로 종료되며, 절대 되돌아가지 않는다.

정상 완료 경로는 `NEW → COMPLETING → NORMAL`이다. 워커 Thread가 callable.call()을 실행하여 결과를 받으면, 먼저 CAS로 상태를 NEW에서 COMPLETING으로 전이하고, outcome에 결과를 저장한 다음, 최종적으로 NORMAL로 전이한다.

예외 완료 경로는 `NEW → COMPLETING → EXCEPTIONAL`이다. callable.call()에서 예외가 발생하면, 예외를 AltResult로 래핑하여 outcome에 저장하고 상태를 EXCEPTIONAL로 전이한다.

취소 경로는 `NEW → CANCELLED` 또는 `NEW → INTERRUPTING → INTERRUPTED`다. cancel(false)를 호출하면 직접 CANCELLED로 전이하고, cancel(true)를 호출하면 INTERRUPTING을 거쳐 INTERRUPTED로 전이한다.

이 단방향 전이는 **작업의 결과가 한 번 결정되면 절대 변경되지 않는 불변성**을 보장한다. 모든 상태 전이는 CAS 연산으로 이루어져, 오직 한 Thread만 전이에 성공한다. 여러 Thread가 동시에 결과를 설정하려 해도, 첫 번째 Thread만 성공하고 나머지는 실패한다.

### 작업 실행: run()의 동작

워커 Thread는 작업 큐에서 Runnable을 꺼낸다. 이때 꺼낸 객체가 FutureTask다. 워커 Thread는 이것의 run() 메서드를 호출한다.

```java
public void run() {
    if (state != NEW ||
        !RUNNER.compareAndSet(this, null, Thread.currentThread()))
        return;
    try {
        Callable<V> c = callable;
        if (c != null && state == NEW) {
            V result;
            boolean ran;
            try {
                result = c.call();
                ran = true;
            } catch (Throwable ex) {
                result = null;
                ran = false;
                setException(ex);
            }
            if (ran)
                set(result);
        }
    } finally {
        runner = null;
        int s = state;
        if (s >= INTERRUPTING)
            handlePossibleCancellationInterrupt(s);
    }
}
```

run() 메서드는 먼저 이중 검증을 수행한다. 첫 번째 검증은 `state != NEW`로, 상태가 NEW가 아니면 이미 다른 Thread가 실행했거나 취소되었으므로 즉시 반환한다.

두 번째 검증은 CAS 연산 `RUNNER.compareAndSet(this, null, Thread.currentThread())`다. RUNNER는 VarHandle로, runner 필드에 대한 원자적 연산을 제공한다. 이 CAS는 runner가 null일 때만 현재 Thread로 설정하고 true를 반환한다. 다른 Thread가 이미 runner를 설정했다면 false를 반환하며, 이 경우에도 메서드는 즉시 종료된다.

이 이중 검증은 **실행 권한의 원자적 획득**을 구현한다. 동일한 FutureTask가 우연히 작업 큐에 두 번 삽입되더라도, 오직 첫 번째 워커 Thread만 실행을 진행하고 나머지는 모두 배제된다.

실행 권한을 획득하면 `result = c.call()`을 호출한다. 이것이 개발자가 작성한 람다의 실제 실행 지점이다. 람다 내부의 모든 코드가 이 워커 Thread에서 동기적으로 실행된다. call()이 블로킹되면 워커 Thread도 블로킹된다.

call()이 정상 반환하면 result에 값을 담고 ran을 true로 설정한 후 `set(result)`를 호출한다. 예외가 발생하면 ran을 false로 두고 `setException(ex)`를 호출한다.

finally 블록에서 runner를 null로 초기화한다. 이는 실행이 종료되었음을 표시하며, GC가 Thread 객체를 수거할 수 있게 한다.

### 결과 저장: set()의 원자성

set() 메서드는 정상 완료 시 결과를 저장하는 핵심 메커니즘이다.

```java
protected void set(V v) {
    if (STATE.compareAndSet(this, NEW, COMPLETING)) {
        outcome = v;
        STATE.setRelease(this, NORMAL);
        finishCompletion();
    }
}
```

첫 번째 CAS 연산 `STATE.compareAndSet(this, NEW, COMPLETING)`은 상태를 원자적으로 NEW에서 COMPLETING으로 전이한다. 이 CAS는 "완료 처리의 소유권"을 획득하는 행위다. 만약 다른 Thread(예: cancel()을 호출한 Thread)가 이미 상태를 변경했다면 CAS는 실패하고 메서드는 아무것도 하지 않는다.

CAS가 성공하면 `outcome = v`로 결과를 저장한다. 이 시점에서 state는 COMPLETING이다. COMPLETING 상태의 존재 이유는 **메모리 가시성 보장**이다. outcome에 값을 쓰는 동안 다른 Thread가 state를 보고 NORMAL이라 판단하여 outcome을 읽으면, 아직 완전히 설정되지 않은 값을 읽을 수 있다. COMPLETING은 "결과는 설정 중이지만 아직 읽으면 안 됨"을 의미하는 메모리 장벽이다.

outcome 저장이 완료되면 `STATE.setRelease(this, NORMAL)`로 상태를 NORMAL로 최종 전이한다. setRelease()는 release 시맨틱을 갖는 특수한 쓰기 연산으로, 이 연산 이전의 모든 쓰기(outcome 저장)가 이 연산 이전에 완료됨을 보장한다. 다른 Thread가 acquire 시맨틱으로 state를 읽으면, outcome의 최신 값도 함께 보게 된다.

마지막으로 `finishCompletion()`을 호출하여 대기 중인 모든 Thread를 깨운다.

```java
private void finishCompletion() {
    for (WaitNode q; (q = waiters) != null;) {
        if (WAITERS.weakCompareAndSet(this, q, null)) {
            for (;;) {
                Thread t = q.thread;
                if (t != null) {
                    q.thread = null;
                    LockSupport.unpark(t);
                }
                WaitNode next = q.next;
                if (next == null)
                    break;
                q.next = null;
                q = next;
            }
            break;
        }
    }
    done();
    callable = null;
}
```

finishCompletion()은 waiters 리스트를 순회하며 각 WaitNode의 Thread에 대해 `LockSupport.unpark(t)`를 호출한다. 이것은 블로킹된 Thread를 OS 레벨에서 WAITING 상태에서 RUNNABLE 상태로 전환하는 시스템 콜이다. 깨어난 Thread들은 OS 스케줄러에 의해 다시 실행 가능 큐에 추가된다.

마지막으로 callable을 null로 설정하여, 람다가 참조하는 객체들이 GC에 의해 수거될 수 있게 한다.

### 결과 조회: get()의 블로킹 메커니즘

개발자가 future.get()을 호출하면 먼저 현재 상태를 확인한다.

```java
public V get() throws InterruptedException, ExecutionException {
    int s = state;
    if (s <= COMPLETING)
        s = awaitDone(false, 0L);
    return report(s);
}
```

상태가 COMPLETING 이하(NEW 또는 COMPLETING)면 작업이 아직 완료되지 않았으므로 `awaitDone()`으로 블로킹 대기에 진입한다. COMPLETING보다 크면(NORMAL, EXCEPTIONAL 등) 이미 완료되었으므로 즉시 `report()`로 결과를 반환한다.

awaitDone()은 무한 루프를 실행하며 완료를 대기한다.

```java
private int awaitDone(boolean timed, long nanos)
        throws InterruptedException {
    long startTime = 0L;
    WaitNode q = null;
    boolean queued = false;
    for (;;) {
        int s = state;
        if (s > COMPLETING) {
            if (q != null)
                q.thread = null;
            return s;
        }
        else if (s == COMPLETING)
            Thread.yield();
        else if (Thread.interrupted()) {
            removeWaiter(q);
            throw new InterruptedException();
        }
        else if (q == null) {
            if (timed && nanos <= 0L)
                return s;
            q = new WaitNode();
        }
        else if (!queued)
            queued = WAITERS.weakCompareAndSet(this, q.next = waiters, q);
        else if (timed) {
            // 타임아웃 처리
        }
        else
            LockSupport.park(this);
    }
}
```

루프의 첫 번째 분기는 `s > COMPLETING`으로 완료 확인이다. 작업이 완료되었으면 즉시 상태를 반환한다.

두 번째 분기는 `s == COMPLETING` 처리로, 과도 상태에서는 `Thread.yield()`로 CPU를 양보하고 다음 루프에서 재확인한다. 워커 Thread가 set()을 실행 중이므로 곧 NORMAL로 전이될 것이다.

세 번째 분기는 `Thread.interrupted()` 처리로, 현재 Thread가 인터럽트되었으면 waiters 리스트에서 자신을 제거하고 InterruptedException을 던진다.

네 번째 분기는 `q == null` 처리로, WaitNode를 생성한다. WaitNode 생성자에서 자동으로 thread 필드가 현재 Thread로 설정된다.

다섯 번째 분기는 `!queued` 처리로, WaitNode를 waiters 리스트에 추가한다. `WAITERS.weakCompareAndSet(this, q.next = waiters, q)`는 CAS 연산으로 waiters 필드의 현재 값을 q.next에 설정하고, waiters를 q로 원자적으로 교체한다. 이는 연결 리스트의 헤드에 노드를 추가하는 전형적인 lock-free 알고리즘이다.

마지막 분기는 `LockSupport.park(this)` 호출로 실제 블로킹이다. 이것은 현재 Thread를 OS 레벨에서 WAITING 상태로 전환하는 시스템 콜이다. Thread는 이 시점에서 CPU를 완전히 반납하고, OS 스케줄러는 이 Thread를 실행 가능 큐에서 제거한다. Thread는 누군가 `LockSupport.unpark()`를 호출하거나 인터럽트가 발생하기 전까지 깨어나지 않는다.

워커 Thread가 finishCompletion()에서 unpark()를 호출하면, 블로킹된 Thread는 RUNNABLE 상태로 전환되고 다시 루프를 실행한다. 이번에는 state가 NORMAL이므로 첫 번째 분기에서 루프를 탈출하여 상태를 반환한다.

awaitDone()이 반환한 상태로 `report()` 메서드를 호출한다.

```java
private V report(int s) throws ExecutionException {
    Object x = outcome;
    if (s == NORMAL)
        return (V)x;
    if (s >= CANCELLED)
        throw new CancellationException();
    throw new ExecutionException((Throwable)x);
}
```

상태가 NORMAL이면 outcome을 V 타입으로 캐스팅하여 반환한다. CANCELLED 이상이면 CancellationException을 던지고, EXCEPTIONAL이면 outcome에 저장된 예외를 ExecutionException으로 래핑하여 던진다.

---

## 결론: Future의 설계적 의의와 구조적 한계

Future는 ExecutorService와 결합하여 비동기 작업의 결과 참조를 Java 표준으로 정의했다. Future 인터페이스는 작업 실행과 무관하게 결과 조회만을 명세하며, FutureTask 구현체는 Callable을 Runnable로 변환하면서 결과 저장까지 단일 객체로 통합한다. ExecutorService.submit()은 Callable을 FutureTask로 래핑하여 작업 큐에 넣고, 동일한 객체를 반환함으로써 제출자와 실행자가 같은 객체를 공유한다.

FutureTask는 volatile 필드와 CAS 연산으로 멀티 Thread 안전성을 보장하며, 단방향 상태 전이로 결과의 불변성을 보장한다. LockSupport의 park/unpark를 사용한 이벤트 기반 블로킹은 CPU를 낭비하지 않으면서도 완료 즉시 반응하는 효율적 대기를 구현한다.

하지만 Future는 결과 조회가 필연적으로 블로킹하며, 작업 조합을 선언적으로 표현할 방법이 없고, 완료 시점 콜백을 등록할 메커니즘도 존재하지 않는다. Future는 비동기 작업 결과 참조를 표준화했지만, 비동기 작업 흐름의 조합과 제어는 여전히 개발자의 책임으로 남겨두었다.

---

## 부록: 인터페이스 및 구현체 관계도

### 전체 구조 다이어그램

```
┌─────────────────────────────────────────────────────────────────┐
│                         인터페이스 계층                           │
└─────────────────────────────────────────────────────────────────┘

    ┌──────────────┐              ┌──────────────┐
    │  Runnable    │              │  Callable<V> │
    │              │              │              │
    │ + run()      │              │ + call(): V  │
    └──────┬───────┘              └──────────────┘
           │                              │
           │                              │ (작업 표현)
           │ (실행 가능)                   │
           │                              │
    ┌──────▼──────────────────────────────▼─────────┐
    │            Future<V>                           │
    │                                                │
    │  + get(): V                                    │
    │  + get(timeout): V                             │
    │  + cancel(mayInterrupt): boolean               │
    │  + isCancelled(): boolean                      │
    │  + isDone(): boolean                           │
    └────────────────────┬───────────────────────────┘
                         │
                         │ (결과 참조)
                         │
           ┌─────────────▼─────────────┐
           │   RunnableFuture<V>       │
           │   (extends Runnable,      │
           │    extends Future<V>)     │
           │                           │
           │   + run()                 │
           └─────────────┬─────────────┘
                         │
                         │ (통합 인터페이스)
                         │
┌────────────────────────▼────────────────────────────┐
│                  구현 계층                           │
└─────────────────────────────────────────────────────┘
                         │
           ┌─────────────▼─────────────┐
           │     FutureTask<V>         │
           │   (implements             │
           │    RunnableFuture<V>)     │
           │                           │
           │  - state: int             │
           │  - callable: Callable<V>  │
           │  - outcome: Object        │
           │  - runner: Thread         │
           │  - waiters: WaitNode      │
           │                           │
           │  + run()                  │
           │  + get(): V               │
           │  + cancel(): boolean      │
           └───────────────────────────┘
```

### 인터페이스 관계 명세

#### 1. Runnable 인터페이스

```
역할: 실행 가능한 작업의 최소 계약
특징: 반환값 없음, 체크 예외 불가
제약: void run() - 결과를 전달할 방법이 없음
```

Runnable은 Java 1.0부터 존재한 Thread 작업의 표준이다. ExecutorService의 작업 큐 타입이 `BlockingQueue<Runnable>`이므로, 큐에 삽입되려면 반드시 이 인터페이스를 구현해야 한다.

#### 2. Callable<V> 인터페이스

```
역할: 값을 반환하는 작업의 표현
특징: 제네릭 반환값, 체크 예외 허용
제약: Runnable이 아니므로 작업 큐에 직접 삽입 불가
```

Callable은 Java 5에서 Runnable의 한계를 극복하기 위해 도입되었다. `V call() throws Exception` 시그니처로 결과 반환과 예외 전파가 모두 가능하다. 하지만 Runnable이 아니므로 ExecutorService의 작업 큐에 직접 넣을 수 없다.

#### 3. Future<V> 인터페이스

```
역할: 비동기 작업의 결과 참조
특징: 완료 대기, 결과 조회, 취소 제어
제약: 작업 실행과는 무관, 오직 결과 참조만 담당
```

Future는 "어떻게 실행할 것인가"와 완전히 분리되어 "어떻게 결과를 조회할 것인가"만을 정의한다. 이 인터페이스는 Runnable이나 Callable과 무관하며, 순수하게 결과 핸들의 계약만을 명세한다.

#### 4. RunnableFuture<V> 인터페이스

```
역할: Runnable과 Future의 통합
특징: 실행 가능하면서 동시에 결과 참조 가능
의의: FutureTask가 구현할 통합 계약
```

RunnableFuture는 Runnable과 Future를 모두 상속한다. 이것은 "실행할 수 있고(Runnable) 동시에 결과를 조회할 수 있는(Future)" 객체의 계약이다. 이 인터페이스 자체는 새로운 메서드를 추가하지 않으며, 단지 두 인터페이스를 결합한다.

```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    void run();  // Runnable에서 상속
}
```

### FutureTask 구현체의 역할

FutureTask는 RunnableFuture를 구현하여 다음을 통합한다:

```
1. Callable 저장소      → callable 필드에 작업 보관
2. Runnable 구현       → run() 메서드에서 callable.call() 실행
3. 결과 저장소         → outcome 필드에 반환값 보관
4. Future 구현         → get() 메서드로 outcome 조회
5. 상태 관리           → state 필드로 생명주기 추적
6. Thread 대기 관리    → waiters 리스트로 블로킹 Thread 추적
```

### ExecutorService와의 상호작용 흐름

```
┌──────────────┐
│  개발자      │
└──────┬───────┘
       │
       │ 1. submit(Callable)
       ▼
┌──────────────────────────────────────┐
│     ExecutorService                  │
│                                      │
│  submit(Callable task) {             │
│    FutureTask ftask = new            │
│      FutureTask(task);      ─────┐   │
│    execute(ftask);                │   │
│    return ftask;            ◀─────┘   │
│  }                                    │
└──────┬──────────────────────┬────────┘
       │                      │
       │ 2. offer(ftask)     │ 3. return ftask
       ▼                      ▼
┌──────────────────┐   ┌──────────────┐
│  BlockingQueue   │   │   개발자     │
│  <Runnable>      │   │  (Future 보유)│
│                  │   └──────────────┘
│  [FutureTask]    │
│  [FutureTask]    │
│  [...]           │
└──────┬───────────┘
       │
       │ 4. take()
       ▼
┌──────────────────┐
│  워커 Thread     │
│                  │
│  ftask.run() {   │
│    result =      │
│      callable    │
│        .call();  │
│    outcome =     │
│      result;     │
│    state =       │
│      NORMAL;     │
│    unpark(       │
│      waiters);   │
│  }               │
└──────────────────┘
```

### 객체 생명주기와 상태 전이

```
시간 축:  T0          T1            T2             T3           T4
        생성        제출          실행           완료         조회
         │          │             │              │            │
         ▼          ▼             ▼              ▼            ▼
    
FutureTask  →  workQueue   →   워커가    →    결과      →   get()
생성            삽입            실행         저장           반환
                                           완료 통지
                                           
state:    NEW     NEW         NEW      COMPLETING     NORMAL
                                       → NORMAL
                                       
callable: [λ]     [λ]         [λ]         [λ]          null
outcome:  null    null        null      [결과]        [결과]
runner:   null    null      [Thread]    [Thread]      null
waiters:  null    null        null        null         null
                              ↓
                            [대기중인
                             Thread들]
```

### 메서드 호출 체인

#### 제출 단계

```
개발자.submit(λ)
  └→ ExecutorService.submit(Callable)
       └→ newTaskFor(Callable)
            └→ new FutureTask(Callable)
                 └→ this.callable = Callable
                 └→ this.state = NEW
       └→ execute(FutureTask)
            └→ workQueue.offer(FutureTask)
       └→ return FutureTask
```

#### 실행 단계

```
워커Thread.run()
  └→ workQueue.take()
       └→ FutureTask
            └→ FutureTask.run()
                 └→ RUNNER.compareAndSet(null, currentThread)
                 └→ result = callable.call()
                 └→ set(result)
                      └→ STATE.compareAndSet(NEW, COMPLETING)
                      └→ outcome = result
                      └→ STATE.setRelease(NORMAL)
                      └→ finishCompletion()
                           └→ unpark(waiters)
```

#### 조회 단계

```
개발자.get()
  └→ FutureTask.get()
       └→ if (state <= COMPLETING)
            └→ awaitDone()
                 └→ new WaitNode()
                 └→ WAITERS.compareAndSet(waiters, newNode)
                 └→ LockSupport.park()  ← 블로킹
                 └→ (unpark 되면 깨어남)
                 └→ return state
       └→ report(state)
            └→ return outcome
```

### 핵심 설계 패턴

#### 1. 어댑터 패턴

```
Callable (호환 불가) ─┐
                    └→ FutureTask (어댑터) → Runnable (호환)
Future (결과 참조)   ─┘
```

FutureTask는 Callable을 Runnable로 변환하는 어댑터이면서, 동시에 Future 역할도 수행한다.

#### 2. 프록시 패턴

```
개발자 ─→ Future 인터페이스 ─→ FutureTask (실제 객체)
                                    │
                                    └→ outcome (실제 결과)
```

개발자는 Future 인터페이스를 통해 작업과 상호작용하며, FutureTask는 실제 결과와 상태를 캡슐화한다.

#### 3. 관찰자 패턴 (변형)

```
FutureTask (주체)
    │
    └→ waiters (관찰자 리스트)
         ├→ Thread 1
         ├→ Thread 2
         └→ Thread 3
         
완료 시: 모든 관찰자(대기 Thread)에게 통지 (unpark)
```

FutureTask가 완료되면 waiters 리스트의 모든 Thread에게 완료를 통지한다.

### 타입 계층 정리

```
┌─────────────────────────────────────────┐
│          <<interface>>                  │
│           Runnable                      │
│                                         │
│  + run(): void                          │
└───────────────────┬─────────────────────┘
                    │
                    │ extends
                    │
┌───────────────────▼─────────────────────┐
│          <<interface>>                  │
│         RunnableFuture<V>               │
│    extends Runnable, Future<V>          │
│                                         │
│  + run(): void      (from Runnable)     │
│  + get(): V         (from Future)       │
│  + cancel(): boolean (from Future)      │
│  + isDone(): boolean (from Future)      │
│  + isCancelled(): boolean (from Future) │
└───────────────────┬─────────────────────┘
                    │
                    │ implements
                    │
┌───────────────────▼─────────────────────┐
│          <<class>>                      │
│         FutureTask<V>                   │
│                                         │
│  - state: int                           │
│  - callable: Callable<V>                │
│  - outcome: Object                      │
│  - runner: Thread                       │
│  - waiters: WaitNode                    │
│                                         │
│  + run(): void                          │
│  + get(): V                             │
│  + cancel(boolean): boolean             │
│  + isDone(): boolean                    │
│  + isCancelled(): boolean               │
│  # set(V): void                         │
│  # setException(Throwable): void        │
│  - awaitDone(boolean, long): int        │
│  - finishCompletion(): void             │
└─────────────────────────────────────────┘
```

### 동시성 제어 메커니즘

#### CAS 연산 지점

```
1. runner 설정
   RUNNER.compareAndSet(this, null, currentThread)
   → 실행 권한의 원자적 획득

2. state 전이
   STATE.compareAndSet(this, NEW, COMPLETING)
   → 완료 처리의 원자적 획득

3. waiters 추가
   WAITERS.weakCompareAndSet(this, q.next = waiters, q)
   → 대기 리스트 추가의 원자성
```

#### volatile 필드

```
state    → 모든 Thread에게 완료 상태 가시성 보장
runner   → 실행 중인 Thread 정보 가시성 보장
waiters  → 대기 리스트 변경 가시성 보장
```

#### 메모리 순서 보장

```
set() 메서드:
  1. outcome = result       (일반 쓰기)
  2. STATE.setRelease(NORMAL)  (release 쓰기)
  
get() 메서드:
  1. s = state              (acquire 읽기)
  2. return outcome         (일반 읽기)
  
보장: get()이 NORMAL을 보면, set()의 outcome 쓰기도 반드시 본다
```

이 관계도와 명세를 통해 Future 시스템의 전체 구조와 각 구성 요소 간의 상호작용을 명확히 이해할 수 있다.