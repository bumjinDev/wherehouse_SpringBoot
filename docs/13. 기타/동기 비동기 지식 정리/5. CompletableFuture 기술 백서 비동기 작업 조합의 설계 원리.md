# CompletableFuture 기술 백서: 비동기 작업 조합의 설계 원리

## 1. 서론: Future 패턴의 근본적 한계

### 1.1 완료 알림 메커니즘의 부재

Future 패턴은 비동기 작업의 결과를 나타내는 추상화지만, 작업 완료 시점을 **능동적으로 알려주는 메커니즘**이 없다. 호출자는 작업이 완료되었는지 지속적으로 확인하거나(폴링), 완료될 때까지 스레드를 블로킹해야 한다. 이는 비동기 프로그래밍의 핵심 가치인 "스레드 자원의 효율적 활용"을 근본적으로 제한한다. Main 스레드가 결과를 필요로 하는 순간, 불가피하게 블로킹 상태로 전환되며, 이는 Thread-per-Request 모델의 한계를 극복하지 못한다.

### 1.2 작업 조합의 불가능성

더 심각한 문제는 **여러 비동기 작업을 조합하는 선언적 방법이 존재하지 않는다**는 점이다. "A 작업이 완료되면 그 결과로 B 작업을 시작하고, B가 완료되면 C를 실행한다"는 단순한 의존성 체인조차 명령형 코드로 수동 구현해야 한다. 각 단계마다 `get()`을 호출해 Main 스레드를 블로킹하거나, 복잡한 콜백 지옥을 직접 구현해야 한다. 이는 비동기 로직의 복잡도를 기하급수적으로 증가시킨다.

Wherehouse R-04 최적화에서 "주소 변환 완료 → 범죄율 조회 시작"이라는 의존성과 "15개 카테고리 검색이 모두 완료되면 결과 수집"이라는 조합 로직을 Future로 표현하려면, 명시적인 블로킹과 복잡한 동기화 코드가 필요하다. 이는 비동기화의 장점을 상쇄한다.

#### Future로 작업 체이닝을 시도하면

```java
ExecutorService executor = Executors.newFixedThreadPool(10);

// 1단계: 주소 변환 제출 (비동기)
Future<String> addressFuture = executor.submit(() -> getAddress(lat, lon));

// 2단계: 결과를 받기 위해 블로킹
String address = addressFuture.get();  // ← Main 스레드 블로킹 (100ms)

// 3단계: 주소로 범죄율 조회 제출
Future<Crime> crimeFuture = executor.submit(() -> getCrime(address));

// 4단계: 또 블로킹
Crime crime = crimeFuture.get();  // ← 또 블로킹 (200ms)

// 총 300ms 동안 Main 스레드가 2번 블로킹됨
```

이 코드의 문제는 Worker 스레드가 백그라운드에서 작업하는 동안 Main 스레드가 `get()`에서 블로킹되어 아무 일도 하지 못한다는 점이다. "비동기"로 시작했지만 결과를 받는 순간 "동기"로 전환된다.

#### 왜 이렇게 설계했는가: 역사적 배경

Future 패턴이 도입된 2004년(Java 5)에는 람다식이 존재하지 않았다. 콜백을 표현하려면 익명 클래스를 중첩해야 했고, 이는 코드를 극도로 복잡하게 만들었다. 설계자들은 이 문제를 인지하고 있었지만, "복잡한 콜백 지옥"보다는 "단순한 블로킹 방식"이 대부분의 개발자에게 더 이해하기 쉽다고 판단했다.

```java
// 2004년에 콜백 기반 설계를 시도하면
executor.submit(task, new Callback() {
    public void onComplete(String address) {
        executor.submit(new Task(address), new Callback() {
            public void onComplete(Crime crime) {
                // 콜백 중첩... 가독성 최악
            }
        });
    }
});
```

Doug Lea(Executor Framework 설계자)는 이 한계를 명시적으로 인정했으며, "언어 수준의 개선(람다식)이 필요하다"고 언급했다. 실제로 10년 후 Java 8(2014)에서 람다식이 도입되자 즉시 CompletableFuture가 함께 도입되었다. 이는 "설계의 문제"가 아니라 "언어 도구의 부재" 때문이었다.

### 1.3 예외 전파의 복잡성

비동기 환경에서 예외는 작업을 실행한 Worker 스레드의 스택에 갇힌다. Future는 예외를 `ExecutionException`으로 래핑하여 `get()` 시점에 던지지만, 이는 **각 Future마다 개별적으로 예외 처리**를 강제한다. "이 체인 중 어디서든 오류가 발생하면 전체 작업을 취소하고 폴백 값을 반환"과 같은 패턴을 표현할 방법이 없다.

---

## 2. CompletableFuture의 설계 철학

### 2.1 Promise 패턴의 구현

CompletableFuture는 JavaScript의 Promise, Scala의 Future와 같은 **"완료 가능한 값"** 추상화를 Java에 도입한 것이다. 핵심 아이디어는 "미래에 완료될 값"을 나타내는 객체에 **완료 시 실행할 콜백을 등록**할 수 있다는 점이다. 이는 블로킹 대기를 콜백 기반 비블로킹 처리로 전환하는 패러다임 전환이다.

전통적 Future는 "작업을 시작하고 나중에 결과를 가져온다"는 pull 모델이다. CompletableFuture는 "작업을 시작하고 완료되면 나에게 알려달라"는 push 모델이다. Main 스레드는 결과를 기다리며 블로킹되는 대신, "완료되면 이 함수를 실행해달라"는 콜백을 등록하고 다른 작업을 계속한다. 작업이 완료되면 시스템이 자동으로 콜백을 실행한다.

### 2.2 비동기 작업의 조합 가능성

Future의 가장 치명적인 문제는 **여러 비동기 작업을 조립할 방법이 없다**는 점이다. "A가 끝나면 B를 시작하고, B와 C가 모두 끝나면 D를 실행"이라는 단순한 로직도 수동으로 구현해야 한다. 각 작업마다 `get()`을 호출하며 블로킹하거나, 복잡한 콜백과 동기화 코드를 직접 작성해야 한다.

CompletableFuture는 이 문제를 **비동기 작업을 조립 가능한 부품처럼 만들어** 해결한다. 각 CompletableFuture는 독립적으로 실행되는 작업이면서, 동시에 다른 작업과 연결될 수 있는 "연결 지점"을 제공한다. 이는 레고 블록처럼 비동기 작업을 자유롭게 조립할 수 있게 만든다.

#### 조합의 세 가지 기본 패턴

**1. 순차 실행 (A 완료 → B 시작)**: `thenCompose`를 사용한다. 첫 번째 작업의 결과를 받아 두 번째 작업을 시작한다. Wherehouse의 "주소 변환 완료 → 범죄율 조회"가 이 패턴이다.

**2. 병렬 실행 후 조합 (A와 B 동시 → 둘 다 완료되면 합침)**: `thenCombine`을 사용한다. 두 작업이 독립적으로 실행되고, 둘 다 완료되면 결과를 합친다.

**3. 다중 작업 대기 (여러 작업 모두 완료 대기)**: `allOf`를 사용한다. 15개 카테고리 검색처럼 독립적인 작업들을 모두 실행하고, 전부 완료될 때까지 대기한다.

#### 안전한 조합의 의미

이러한 조합 메커니즘은 단순히 "코드를 짧게 만드는 편의 기능"이 아니다. 각 단계가 명확히 분리되어 있고, 예외가 발생하면 체인 전체로 자동 전파되며, 중간 단계를 건너뛰고 예외 처리 로직으로 이동한다. 수동으로 try-catch를 중첩하거나 플래그 변수로 상태를 추적할 필요가 없다.

또한 각 단계는 독립적으로 테스트 가능하며, 새로운 단계를 추가하거나 순서를 변경할 때 다른 부분을 수정하지 않아도 된다. 이는 복잡한 비동기 로직을 안전하게 구성할 수 있는 아키텍처 수준의 개선이다.

### 2.3 ExecutorService와의 역할 분리

CompletableFuture와 ExecutorService는 **완전히 다른 책임**을 가진 별개의 컴포넌트다. 이 둘은 상속 관계가 아니라 **협력 관계**다.

#### 각자의 역할

**ExecutorService (ThreadPoolExecutor)의 역할:**
- Worker 스레드 생성 및 관리
- 작업 큐에서 작업을 꺼내 스레드에 배정
- 스레드 라이프사이클 제어 (생성, 재사용, 종료)

**CompletableFuture의 역할:**
- 비동기 작업의 결과를 담는 컨테이너
- "완료되면 실행할 콜백" 목록 관리
- 콜백 체인 자동 실행

#### 실제 협력 방식

CompletableFuture는 ExecutorService를 **도구로 사용**한다:

```java
// 1. 커스텀 Executor 생성 (스레드 풀)
ExecutorService ioExecutor = Executors.newFixedThreadPool(20);

// 2. CompletableFuture가 이 Executor를 사용
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    return getData();  // ← ioExecutor의 Worker 스레드가 실행
}, ioExecutor);

// 내부 동작:
// - CompletableFuture: "이 작업을 실행해줘" → ioExecutor에게 전달
// - ioExecutor: Worker 스레드에 작업 배정
// - Worker 스레드: 작업 실행 완료
// - CompletableFuture: 결과 받아서 저장 + 콜백 실행
```

**비유**: ExecutorService는 "배달 회사", CompletableFuture는 "주문서 + 알림 시스템"이다. 주문서가 배달 회사에게 "이거 배달해줘"라고 요청하고, 배달 완료되면 자동으로 알림을 실행한다.

#### 왜 커스텀 Executor가 필요한가

CompletableFuture는 기본적으로 `ForkJoinPool.commonPool()`을 사용한다. 이 풀은 `Runtime.getRuntime().availableProcessors() - 1`개의 스레드를 생성한다 (예: 8코어 CPU → 7개 스레드). Main 스레드를 제외한 나머지 코어를 활용하는 설계다. 이는 CPU-bound 작업(계산 위주)에는 적합하지만, I/O-bound 작업(네트워크 대기)에는 부족하다.

Wherehouse R-04는 최대 17개의 동시 API 호출이 필요하다 (주소 1 + 카테고리 15 + 범죄율 1). 그런데 commonPool이 7개 스레드만 제공하면, 나머지 10개 작업은 큐에서 대기하며 순차 실행된다. 이는 병렬도를 떨어뜨려 성능 개선 효과를 반감시킨다.

따라서 I/O 작업에서는 **충분한 수의 스레드를 가진 커스텀 Executor**를 명시적으로 지정해야 한다:

```java
// I/O 작업용: 20개 스레드
ExecutorService ioExecutor = Executors.newFixedThreadPool(20);

CompletableFuture.supplyAsync(() -> apiCall(), ioExecutor);
```

이렇게 하면 CompletableFuture의 "콜백 자동 실행 메커니즘"과 ThreadPoolExecutor의 "스레드 풀 관리"를 모두 활용할 수 있다.

---

## 3. CompletableFuture의 내부 구조와 동작 원리

### 3.1 콜백 저장소: Completion Stack의 설계 목적

#### 문제 정의: 비동기 완료를 어떻게 통지할 것인가

Future 패턴은 "완료 여부를 확인"하는 `isDone()`과 "결과를 가져오는" `get()`만 제공한다. 이는 근본적으로 **폴링(polling) 또는 블로킹 대기**를 전제로 한 설계다. 비동기 작업이 완료되었을 때 "호출자에게 능동적으로 알리는" 메커니즘이 존재하지 않는다.

CompletableFuture는 이 문제를 **완료 시 실행할 작업들을 내부에 저장**하는 방식으로 해결한다. 작업이 완료되면 저장된 목록을 순회하며 모든 콜백을 실행한다. 이는 Observer 패턴의 구현이며, "상태 변화(완료)를 관찰하는 객체들(콜백)에게 자동 통지"하는 메커니즘이다.

이 패턴은 단순히 "완료 알림"을 넘어서, Completion 체인을 통해 복잡한 비동기 로직을 구조화한다. 각 Completion은 자신의 완료 조건, 실행할 함수, 결과를 전달할 다음 CompletableFuture를 알고 있다. 이는 단순한 Observer가 아닌 "실행 가능한 의존성 그래프"를 형성한다.

#### 내부 자료구조: Completion Stack

CompletableFuture는 내부적으로 두 개의 핵심 필드를 가진다:

```java
public class CompletableFuture<T> {
    volatile Object result;      // 작업 결과 (또는 예외)
    volatile Completion stack;   // 완료 시 실행할 콜백 체인
}
```

**result 필드**: 작업이 완료되면 결과 객체가 저장된다. `volatile` 키워드는 멀티 스레드 환경에서 가시성(visibility)을 보장한다. Worker 스레드가 result에 값을 쓰면, 다른 모든 스레드가 즉시 변경된 값을 볼 수 있다.

**stack 필드**: 연결 리스트(linked list) 형태로 Completion 객체들이 체인처럼 연결되어 있다. 각 Completion은 "완료되면 실행할 작업"을 나타낸다. `thenApply()`, `thenCompose()` 같은 메소드를 호출할 때마다 새로운 Completion이 생성되어 이 스택에 추가된다.

```
CompletableFuture@A {
    result: null
    stack: [Completion-3] → [Completion-2] → [Completion-1] → null
}
```

#### FutureTask와의 설계 차이

FutureTask는 "대기 중인 스레드 목록(waiters)"을 관리한다. `get()`을 호출한 스레드들은 waiters 리스트에 추가되고, 작업 완료 시 `LockSupport.unpark()`로 깨워진다. 이는 **"누가 기다리는가"**에 초점을 둔 설계다.

CompletableFuture는 "완료 시 실행할 작업 목록(stack)"을 관리한다. 콜백이 등록되면 Completion 객체가 생성되어 stack에 추가되고, 작업 완료 시 모든 Completion이 실행된다. 이는 **"완료되면 무엇을 할 것인가"**에 초점을 둔 설계다.

이 차이가 블로킹 대기와 비블로킹 콜백의 근본적 차이다. FutureTask는 스레드를 재우고 깨우는 방식이고, CompletableFuture는 함수를 등록하고 실행하는 방식이다.

---

### 3.2 콜백 등록 메커니즘: thenApply의 내부 동작

#### 등록 시점의 정확한 동작

`thenApply()`를 호출하면 다음과 같은 과정이 일어난다:

**1단계 - 새 CompletableFuture 생성:**
```java
CompletableFuture<String> source = ...;
CompletableFuture<Integer> result = source.thenApply(s -> s.length());
```

내부적으로 새로운 CompletableFuture 객체(result)가 즉시 생성된다. 이 객체는 아직 완료되지 않은 상태다.

**2단계 - Completion 객체 생성:**

`UniApply`라는 Completion 구현체가 생성된다. 이 객체는 다음 정보를 담고 있다:
- 의존 대상: source (원본 CompletableFuture)
- 변환 함수: `s -> s.length()`
- 결과 저장소: result (새 CompletableFuture)

**3단계 - Stack에 추가:**

생성된 UniApply가 source의 stack에 추가된다. 만약 source가 이미 완료된 상태라면 stack에 추가하지 않고 즉시 실행한다 (최적화).

```java
// CompletableFuture 내부 (의사코드)
public <U> CompletableFuture<U> thenApply(Function<T, U> fn) {
    CompletableFuture<U> result = new CompletableFuture<>();
    UniApply<T, U> completion = new UniApply<>(this, fn, result);
    
    if (this.result == null) {
        // 아직 완료 안됨 → stack에 추가
        this.push(completion);
    } else {
        // 이미 완료됨 → 즉시 실행
        completion.tryFire();
    }
    
    return result;  // 즉시 반환 (비블로킹)
}
```

**4단계 - 즉시 반환:**

Main 스레드는 새로 생성된 CompletableFuture(result)를 즉시 반환받는다. 이 시점에 블로킹은 전혀 없다.

#### 완료 시점의 정확한 동작

Worker 스레드가 작업을 완료하면 `complete(value)` 메소드를 호출한다:

**1단계 - 결과 저장:**
```java
public boolean complete(T value) {
    if (this.result == null) {  // CAS 기반 원자적 연산
        this.result = value;
        return true;
    }
    return false;
}
```

`result` 필드에 값이 저장된다. 이 연산은 Compare-And-Swap(CAS)을 사용하여 원자적으로 수행되므로, 여러 스레드가 동시에 `complete()`를 호출해도 하나만 성공한다.

**2단계 - Stack 순회:**

저장된 Completion 체인을 순회하며 각 Completion의 `tryFire()` 메소드를 호출한다:

```java
// 의사코드
private void postComplete() {
    CompletableFuture<?> f = this;
    Completion h;
    
    while ((h = f.stack) != null) {
        f.stack = h.next;  // Stack에서 제거
        h.tryFire();       // 콜백 실행
    }
}
```

**3단계 - 개별 Completion 실행:**

UniApply의 `tryFire()`는 다음을 수행한다:
1. 원본 CompletableFuture의 result 읽기
2. 변환 함수 적용: `fn.apply(result)`
3. 새 CompletableFuture의 complete() 호출

```java
// UniApply 내부 (의사코드)
class UniApply<T, U> extends Completion {
    CompletableFuture<T> source;
    Function<T, U> fn;
    CompletableFuture<U> target;
    
    void tryFire() {
        T value = source.result;
        U transformed = fn.apply(value);  // 변환 함수 실행
        target.complete(transformed);     // 결과 저장 + 체인 전파
    }
}
```

**4단계 - 체인 전파:**

target.complete()가 호출되면 target의 stack도 순회되며, 이어진 모든 Completion이 연쇄적으로 실행된다. 이것이 "체인"의 자동 실행 메커니즘이다.

#### 설계의 핵심: 왜 Stack 구조인가

Completion을 Stack(LIFO) 구조로 관리하는 이유는 **추가와 제거가 O(1)**이기 때문이다. 멀티 스레드 환경에서 여러 스레드가 동시에 콜백을 등록할 때, CAS 연산으로 안전하게 Stack의 top을 교체할 수 있다. Queue 구조였다면 tail을 찾아야 하므로 더 복잡해진다.

또한 실행 순서는 중요하지 않다. 모든 Completion은 "완료되면 실행"이라는 동일한 조건을 가지므로, FIFO든 LIFO든 최종 결과는 동일하다. Stack이 구현이 더 간단하고 효율적이므로 선택되었다.

---

### 3.3 비동기 평탄화: thenCompose의 구현 원리

#### 중첩 문제와 평탄화의 필요성

`thenApply()`는 동기 변환 함수(`Function<T, U>`)를 받는다. 만약 변환 함수가 또 다른 CompletableFuture를 반환하면 중첩 구조가 생긴다:

```java
CompletableFuture<String> address = getAddressAsync();
CompletableFuture<CompletableFuture<Crime>> nested = 
    address.thenApply(addr -> getCrimeAsync(addr));
```

`nested`는 `CompletableFuture<CompletableFuture<Crime>>` 타입이다. 이는 두 번 `join()`을 호출해야 하며, 내부 CompletableFuture의 완료를 대기하는 로직을 수동으로 작성해야 한다.

`thenCompose()`는 이 중첩을 자동으로 평탄화(flatten)한다. 함수형 프로그래밍에서 이를 flatMap 연산이라고 부른다.

#### thenCompose의 내부 구조

`thenCompose()`는 `UniCompose`라는 특수한 Completion을 생성한다:

```java
// CompletableFuture 내부 (의사코드)
public <U> CompletableFuture<U> thenCompose(Function<T, CompletableFuture<U>> fn) {
    CompletableFuture<U> result = new CompletableFuture<>();
    UniCompose<T, U> completion = new UniCompose<>(this, fn, result);
    this.push(completion);
    return result;
}
```

#### UniCompose의 2단계 실행

**1단계 - 첫 번째 작업 완료 시:**

source가 완료되면 UniCompose의 `tryFire()`가 호출된다:

```java
class UniCompose<T, U> extends Completion {
    CompletableFuture<T> source;
    Function<T, CompletableFuture<U>> fn;
    CompletableFuture<U> target;
    
    void tryFire() {
        T value = source.result;
        CompletableFuture<U> inner = fn.apply(value);  // 두 번째 비동기 작업 시작
        
        // inner가 완료되면 target을 완료하도록 연결
        inner.whenComplete((result, ex) -> {
            if (ex != null) {
                target.completeExceptionally(ex);
            } else {
                target.complete(result);
            }
        });
    }
}
```

핵심은 **inner CompletableFuture의 완료를 target에 전달**하는 연결 고리를 만드는 것이다.

**2단계 - 두 번째 작업 완료 시:**

`fn.apply(value)`로 생성된 inner CompletableFuture가 완료되면, `whenComplete()`에 등록된 콜백이 실행되어 target을 완료한다. 이로써 중첩 없이 `CompletableFuture<U>`가 완성된다.

#### 설계 의도: 명시적 대기의 제거

만약 thenCompose가 없었다면 개발자가 직접 다음과 같이 작성해야 한다:

```java
CompletableFuture<String> address = getAddressAsync();
CompletableFuture<Crime> crime = new CompletableFuture<>();

address.thenAccept(addr -> {
    CompletableFuture<Crime> inner = getCrimeAsync(addr);
    inner.thenAccept(c -> crime.complete(c));
    inner.exceptionally(ex -> {
        crime.completeExceptionally(ex);
        return null;
    });
});
```

이는 복잡하고 오류가 발생하기 쉽다. `thenCompose()`는 이 패턴을 표준화하고 자동화한 것이다.

---

### 3.4 병렬 조율: allOf의 카운터 메커니즘

#### 설계 과제: N개의 완료를 어떻게 감지하는가

15개의 독립적인 CompletableFuture가 있을 때, "모두 완료되면 후속 작업 실행"을 구현하려면 두 가지 문제를 해결해야 한다:

1. **완료 카운팅**: 15개 중 몇 개가 완료되었는지 추적
2. **원자적 검사**: 마지막 하나가 완료되는 순간을 정확히 감지

`allOf()`는 이를 **AtomicInteger 카운터**로 해결한다.

#### allOf의 내부 구현

```java
// CompletableFuture 내부 (간소화)
public static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs) {
    CompletableFuture<Void> result = new CompletableFuture<>();
    AtomicInteger counter = new AtomicInteger(cfs.length);
    
    for (CompletableFuture<?> cf : cfs) {
        cf.whenComplete((value, ex) -> {
            if (counter.decrementAndGet() == 0) {
                // 마지막 작업 완료
                result.complete(null);
            }
        });
    }
    
    return result;
}
```

실제 구현은 예외 처리가 더 복잡하지만, 핵심은 AtomicInteger 카운터로 완료를 추적하는 메커니즘이다.

#### 동작 과정의 상세 분석

**초기화 단계:**
- 결과를 담을 새 CompletableFuture 생성
- 카운터를 15로 초기화
- 15개 CompletableFuture 각각에 `whenComplete()` 콜백 등록

**실행 단계:**
- 각 Worker 스레드가 독립적으로 작업 수행
- Worker-3이 완료 → `decrementAndGet()` 호출 → 카운터 14
- Worker-7이 완료 → 카운터 13
- Worker-1이 완료 → 카운터 12
- ... (순서 무관)
- Worker-15가 완료 (마지막) → 카운터 0 → `result.complete()` 호출

**완료 단계:**
- `result`의 stack에 등록된 모든 Completion 실행
- 결과 수집 로직 자동 실행

#### AtomicInteger의 필요성

`counter--`와 같은 단순 연산은 멀티 스레드 환경에서 안전하지 않다. 두 스레드가 동시에 14를 읽고 13을 쓰면 카운터가 12가 아닌 13이 될 수 있다.

`decrementAndGet()`은 CPU의 원자적 명령어를 사용하여 "읽기-감소-쓰기-반환"을 하나의 불가분한 연산으로 수행한다. x86 아키텍처에서는 일반적으로 `LOCK CMPXCHG` (compare-and-swap) 또는 `LOCK DEC` 명령어를 사용한다. 이는 락(lock) 없이도 스레드 안전성을 보장하는 lock-free 알고리즘이다.

#### 설계 선택: CountDownLatch를 쓰지 않은 이유

Java의 `CountDownLatch`도 유사한 카운팅 메커니즘을 제공하지만, `await()` 메소드는 스레드를 블로킹한다. CompletableFuture는 블로킹을 피하기 위해 콜백 기반으로 설계되었으므로, CountDownLatch 대신 AtomicInteger + 콜백 조합을 선택했다.

---

### 3.5 예외 전파: CompletionException의 설계

#### 예외 처리의 근본 문제

비동기 환경에서 예외는 작업을 실행한 Worker 스레드의 스택에 갇힌다. Main 스레드는 이 예외를 직접 catch할 수 없다. Future는 `get()`을 호출할 때 `ExecutionException`으로 래핑하여 던지지만, 이는 블로킹을 전제로 한다.

CompletableFuture는 예외를 **result 필드에 특수 객체로 저장**하여 전파한다.

#### 예외 저장 메커니즘

```java
// CompletableFuture 내부
public boolean completeExceptionally(Throwable ex) {
    this.result = new AltResult(ex);  // 예외를 객체로 래핑
    postComplete();  // Stack 순회
    return true;
}
```

`result`가 정상 값이 아닌 `AltResult` 객체를 담고 있으면, 이는 예외 상태를 의미한다. Completion들은 result를 읽을 때 이를 확인하고 예외 처리 로직으로 분기한다.

#### 체인을 통한 예외 전파

```java
source.thenApply(x -> transform(x))  // 여기서 예외 발생
      .thenApply(y -> process(y))     // 건너뜀
      .exceptionally(ex -> fallback); // 여기로 점프
```

`thenApply()`의 UniApply는 다음과 같이 동작한다:

```java
class UniApply<T, U> extends Completion {
    void tryFire() {
        Object r = source.result;
        
        if (r instanceof AltResult) {
            // 예외 상태 → 그대로 전파
            target.result = r;
            target.postComplete();
        } else {
            // 정상 상태 → 변환 수행
            try {
                U transformed = fn.apply((T) r);
                target.complete(transformed);
            } catch (Throwable ex) {
                target.completeExceptionally(ex);
            }
        }
    }
}
```

예외가 발생하면 중간 단계들은 모두 건너뛰고, `exceptionally()` 같은 예외 처리 Completion만 실행된다.

#### exceptionally의 구현

```java
public CompletableFuture<T> exceptionally(Function<Throwable, T> fn) {
    CompletableFuture<T> result = new CompletableFuture<>();
    
    whenComplete((value, ex) -> {
        if (ex != null) {
            try {
                T fallback = fn.apply(ex);  // 예외 → 폴백 값 변환
                result.complete(fallback);
            } catch (Throwable ex2) {
                result.completeExceptionally(ex2);
            }
        } else {
            result.complete(value);  // 정상 → 그대로 전달
        }
    });
    
    return result;
}
```

예외를 값으로 변환하는 것이 핵심이다. 이후 체인은 정상 흐름으로 계속된다.

---

### 3.6 핵심 메커니즘 종합

CompletableFuture의 내부 구조는 다음 설계 원칙으로 구성된다:

**1. Observer 패턴**: Completion Stack을 통해 "완료 이벤트"를 구독자들에게 통지한다.

**2. 불변 체인**: 각 `thenApply()`, `thenCompose()` 호출은 새로운 CompletableFuture를 반환하며, 원본을 변경하지 않는다.

**3. Lock-free 알고리즘**: CAS 연산과 volatile 필드로 락 없이 스레드 안전성을 보장한다.

**4. 예외의 값 변환**: 예외를 특수 객체로 저장하여 체인을 통해 자연스럽게 전파한다.

이러한 메커니즘은 Future의 블로킹 대기를 완전히 제거하고, 복잡한 비동기 로직을 선언적으로 구성할 수 있게 만든다. Wherehouse R-04의 "주소 변환 → 범죄율 조회 + 15개 카테고리 병렬 검색"이라는 복잡한 의존성 그래프를 몇 줄의 코드로 표현할 수 있는 것은, 이러한 내부 메커니즘이 모든 복잡성을 자동화하기 때문이다.

---

## 4. 실행 모델의 이해

### 4.1 ForkJoinPool vs ThreadPoolExecutor

CompletableFuture는 기본적으로 ForkJoinPool.commonPool을 사용한다. 이는 work-stealing 알고리즘으로 CPU-bound 작업의 부하 분산에 최적화된 풀이다. `Runtime.getRuntime().availableProcessors() - 1`개의 스레드를 생성하며 (예: 8코어 → 7개 스레드), 각 스레드는 자신의 작업 큐를 가지고, 큐가 비면 다른 스레드의 큐에서 작업을 훔쳐온다.

하지만 Wherehouse R-04처럼 네트워크 I/O 대기가 주된 작업에서는, 스레드가 WAITING 상태로 대부분의 시간을 보내므로 work-stealing의 이점이 없다. 오히려 CPU 코어 수(예: 7개)보다 훨씬 많은 수(예: 20개)의 스레드가 필요하다. 

스레드 풀 크기는 동시에 처리해야 할 I/O 작업 수를 기준으로 결정된다. Wherehouse R-04는 최대 17개의 동시 API 호출(주소 1 + 카테고리 15 + 범죄율 1)이 발생할 수 있으므로, 최소 17개 이상의 스레드가 필요하다. 일반적으로 여유를 두어 20~30개 정도로 설정한다.

따라서 I/O-bound 작업에서는 `Executors.newFixedThreadPool(N)`으로 생성한 커스텀 ExecutorService를 `supplyAsync`의 두 번째 인자로 명시해야 한다. 이는 CompletableFuture가 제공하는 콜백 체인 메커니즘과 ThreadPoolExecutor가 제공하는 스레드 관리를 조합하는 방식이다.

### 4.2 동기 vs 비동기 메소드의 선택

`thenApply`와 `thenApplyAsync`의 차이는 **어느 스레드에서 실행되는가**다. `thenApply`는 원본 작업을 완료한 Worker 스레드에서 즉시 실행된다. 추가적인 스레드 전환(context switching)이 없으므로 오버헤드가 적지만, 해당 Worker는 `thenApply` 작업이 끝날 때까지 다른 작업을 처리할 수 없다.

`thenApplyAsync`는 새로운 스레드에 작업을 제출한다. Worker 스레드는 즉시 다음 작업을 처리할 수 있지만, 스레드 전환 비용이 발생한다.

**선택 기준:**
- **CPU-bound 작업** (필터링, 계산): `thenApply` 사용 - 스레드 전환 비용 절약
- **I/O-bound 작업** (API 호출, DB 조회): 이미 `supplyAsync`에서 별도 스레드 사용 중이므로 후속 처리는 `thenApply`로 충분
- **작업 분리가 필요한 경우**: `thenApplyAsync` 사용 - 작업 간 격리 필요 시

Wherehouse R-04에서는 API 호출은 `supplyAsync(..., ioExecutor)`, 결과 필터링이나 점수 계산 같은 CPU 작업은 `thenApply`를 사용하는 것이 적절하다. 이는 불필요한 스레드 전환을 줄이면서도 I/O 대기 시 스레드가 블로킹되지 않도록 보장한다.

### 4.3 예외 처리 전략

CompletableFuture의 예외 처리는 체인 전체에 걸쳐 자동으로 전파된다. 중간 단계에서 예외가 발생하면, 이후의 모든 `thenApply`, `thenCompose`는 건너뛰고 `exceptionally`나 `handle`로 제어가 이동한다.

`exceptionally`는 예외를 폴백 값으로 변환한다. "데이터베이스 조회 실패 → 캐시에서 가져오기"와 같은 복구 로직을 표현한다. `handle`은 정상 결과와 예외를 모두 받아 새로운 값을 반환하므로, "성공이면 A, 실패면 B"라는 분기 로직을 표현한다. `whenComplete`는 예외를 소비하지 않고 전파하므로, 로깅이나 리소스 정리 같은 부수 효과에 사용한다.

이러한 예외 처리는 동기 코드의 try-catch와 동일한 제어 흐름을 비동기 환경에서 제공한다. 15개 카테고리 중 일부가 실패해도 나머지는 계속 진행하고, 실패한 것만 기본값으로 대체하는 복잡한 로직을 선언적으로 표현할 수 있다.

---

## 5. Wherehouse R-04 적용 전략

### 5.1 의존성 그래프 분석

현재 Wherehouse R-04는 다음과 같은 의존성 구조를 가진다:

1. **주소 변환** (100ms) - 독립 작업, 즉시 시작 가능
2. **범죄율 조회** (200ms) - 주소 변환 완료 후에만 시작 가능
3. **15개 카테고리 검색** (각 150ms) - 독립 작업들, 병렬 실행 가능

Future로는 이를 "주소 변환 `get()` → 범죄율 제출 → 15개 제출 → 15개 `get()` 순회"로 구현해야 하며, 각 `get()` 시점에 Main이 블로킹된다. CompletableFuture로는 이를 비블로킹 체인으로 표현할 수 있다.

주소 변환을 `supplyAsync`로 시작하고, `thenCompose`로 범죄율 조회를 연결한다. 이는 주소 변환 완료 시 자동으로 범죄율 조회를 시작하며, Main 스레드는 개입하지 않는다. 15개 카테고리는 각각 `supplyAsync`로 시작하고, `allOf`로 모두 완료를 대기한다.

### 5.2 Thread Pool 크기 결정

I/O-bound 작업의 최적 스레드 수는 대략 "동시 I/O 요청 수 × 2" 정도다. Wherehouse R-04는 최대 17개 동시 요청(주소 1 + 카테고리 15 + 범죄율 1)이 발생할 수 있으므로, 20~30개 정도의 스레드가 적절하다.

너무 적으면 일부 작업이 큐에서 대기하며 병렬도가 떨어진다. 너무 많으면 context switching 비용과 메모리 사용량이 증가한다. JMeter로 부하 테스트를 하며 스레드 수를 조정하고, VisualVM으로 스레드 상태(WAITING 비율)를 모니터링하여 최적값을 찾아야 한다.

### 5.3 성능 개선 예상치

순차 실행 시간은 100(주소) + 150×15(카테고리) + 200(범죄율) = 2,550ms다. CompletableFuture로 병렬화하면 이론적으로 max(100, 150, 100+200) = 300ms까지 단축 가능하다. 실제로는 스레드 전환 비용, 네트워크 지터, 카카오 API Rate Limit 등으로 350~400ms 정도가 예상된다.

---

## 6. 검증 방법

Wherehouse R-04에 CompletableFuture를 적용한 후 다음을 측정하여 개선 효과를 정량적으로 증명한다:

**성능 지표:**
- 평균 응답 시간: 2,681ms → 350~400ms (목표)
- P95 응답 시간: 순차 대비 80% 이상 감소
- 처리량(TPS): 순차 대비 7~8배 증가

**Thread 상태 모니터링:**
- ThreadMXBean으로 스레드 상태 수집
- WAITING 상태 비율: 순차는 95% 이상, 병렬은 90% 이상 (I/O 대기)
- Active Thread: 순차는 1개, 병렬은 15~17개

**부하 테스트:**
- JMeter로 동시 사용자 50명, 5분간 부하
- CPU 사용률: 10% 미만 유지 (I/O-bound 특성)
- 메모리: Thread 증가에 따른 Stack 메모리 증가 확인

이를 통해 "CompletableFuture 적용으로 응답 시간을 X배 개선하고, 동일 하드웨어에서 처리 가능한 동시 사용자를 Y배 증가시켰다"는 구체적 수치를 포트폴리오에 기록할 수 있다.