# CompletableFuture 완전 통합 기술 문서

## 1. 서론: Future 패턴의 근본적 한계

### 1.1 완료 알림 메커니즘의 부재

Future 패턴은 비동기 작업의 결과를 나타내는 추상화지만, 작업 완료 시점을 **능동적으로 알려주는 메커니즘**이 없다. 호출자는 작업이 완료되었는지 지속적으로 확인하는 폴링 등의 매커니즘을 별도로 구현 하거나, 완료될 때까지 스레드를 블로킹(Future.get())해야 한다. 이는 비동기 프로그래밍의 핵심 가치인 "스레드 자원의 효율적 활용"을 근본적으로 제한한다. Main 스레드가 결과를 필요로 하는 순간, 불가피하게 블로킹 상태로 전환되며, 이는 Thread-per-Request 모델의 한계를 극복하지 못한다.

### 1.2 작업 조합의 불가능성

더 중요한 문제는 **여러 비동기 작업을 조합하는 선언적 방법이 존재하지 않는다**는 점이다. "A 작업이 완료되면 그 결과로 B 작업을 시작하고, B가 완료되면 C를 실행한다"는 단순한 의존성 체인조차 명령형 코드로 수동 구현해야 한다. 각 단계마다 `get()`을 호출해 Main 스레드를 블로킹하거나, 복잡한 콜백 지옥을 직접 구현해야 한다. 이는 비동기 로직의 복잡도를 기하급수적으로 증가시킨다.

Wherehouse R-04 최적화에서 "주소 변환 완료 → 범죄율 조회 시작"이라는 의존성과 "15개 카테고리 검색이 모두 완료되면 결과 수집"이라는 조합 로직을 Future로 표현하려면, 명시적인 블로킹과 복잡한 동기화 코드가 필요하다. 이는 비동기화의 장점을 상쇄한다.

#### Future로 작업 체이닝을 시도하면

```java
ExecutorService executor = Executors.newFixedThreadPool(10);

// 1단계: 주소 변환 제출 (비동기)
Future<String> addressFuture = executor.submit(() -> getAddress(lat, lon));

// 2단계: 결과를 받기 위해 블로킹
String address = addressFuture.get();  // ← Main 스레드 블로킹 (100ms)

// 3단계: 주소로 범죄율 조회 제출
Future<Crime> crimeFuture = executor.submit(() -> getCrime(address));

// 4단계: 또 블로킹
Crime crime = crimeFuture.get();  // ← 또 블로킹 (200ms)

// 총 300ms 동안 Main 스레드가 2번 블로킹됨
```

이 코드의 문제는 Worker 스레드가 백그라운드에서 작업하는 동안 Main 스레드가 `get()`에서 블로킹되어 아무 일도 하지 못한다는 점이다. "비동기"로 시작했지만 결과를 받는 순간 "동기"로 전환된다.

#### 왜 이렇게 설계했는가: 역사적 배경

Future 패턴이 도입된 2004년(Java 5)에는 람다식이 존재하지 않았다. 콜백을 표현하려면 익명 클래스를 중첩해야 했고, 이는 코드를 극도로 복잡하게 만들었다. 설계자들은 이 문제를 인지하고 있었지만, "복잡한 콜백 지옥"보다는 "단순한 블로킹 방식"이 대부분의 개발자에게 더 이해하기 쉽다고 판단했다.

```java
// 2004년에 콜백 기반 설계를 시도하면
executor.submit(task, new Callback() {
    public void onComplete(String address) {
        executor.submit(new Task(address), new Callback() {
            public void onComplete(Crime crime) {
                // 콜백 중첩... 가독성 최악
            }
        });
    }
});
```

Doug Lea(Executor Framework 설계자)는 이 한계를 명시적으로 인정했으며, "언어 수준의 개선(람다식)이 필요하다"고 언급했다. 실제로 10년 후 Java 8(2014)에서 람다식이 도입되자 즉시 CompletableFuture가 함께 도입되었다. 이는 "설계의 문제"가 아니라 "언어 도구의 부재" 때문이었다.

### 1.3 예외 전파의 복잡성

비동기 환경에서 예외는 작업을 실행한 Worker 스레드의 스택에 갇힌다. Future는 예외를 `ExecutionException`으로 래핑하여 `get()` 시점에 던지지만, 이는 **각 Future마다 개별적으로 예외 처리**를 강제한다. "이 체인 중 어디서든 오류가 발생하면 전체 작업을 취소하고 폴백 값을 반환"과 같은 패턴을 표현할 방법이 없다.

---

## 2. CompletableFuture의 설계 철학

### 2.1 Promise 패턴의 구현

CompletableFuture는 JavaScript의 Promise, Scala의 Future와 같은 **"완료 가능한 값"** 추상화를 Java에 도입한 것이다. 핵심 아이디어는 "미래에 완료될 값"을 나타내는 객체에 **완료 시 실행할 콜백을 등록**할 수 있다는 점이다. 이는 블로킹 대기를 콜백 기반 비블로킹 처리로 전환하는 패러다임 전환이다.

전통적 Future는 "작업을 시작하고 나중에 결과를 가져온다"는 pull 모델이다. CompletableFuture는 "작업을 시작하고 완료되면 나에게 알려달라"는 push 모델이다. Main 스레드는 결과를 기다리며 블로킹되는 대신, "완료되면 이 함수를 실행해달라"는 콜백을 등록하고 다른 작업을 계속한다. 작업이 완료되면 시스템이 자동으로 콜백을 실행하여 이 비동기 작업간 의존 관계를 설정하여 단순 FutureTask.get() 처럼 비동기간 의존관계로 인한 명시적인 블록킹으로 인한 성능 저하 및 유지보수성 하락을 방지한다.

### 2.2 비동기 작업의 조합 가능성

Future의 가장 치명적인 문제는 **여러 비동기 작업을 조립할 방법이 없다**는 점이다. "A가 끝나면 B를 시작하고, B와 C가 모두 끝나면 D를 실행"이라는 단순한 로직도 수동으로 구현해야 한다. 각 작업마다 `get()`을 호출하며 블로킹하거나, 복잡한 콜백과 동기화 코드를 직접 작성해야 한다.

CompletableFuture는 이 문제를 **비동기 작업을 조립 가능한 부품처럼 만들어** 해결한다. 각 CompletableFuture는 독립적으로 실행되는 작업이면서, 동시에 다른 작업과 연결될 수 있는 "연결 지점"을 제공한다. 이는 레고 블록처럼 비동기 작업을 자유롭게 조립할 수 있게 만든다.

#### 조합의 세 가지 기본 패턴

**1. 순차 실행 (A 완료 → B 시작)**: `thenCompose`를 사용한다. 첫 번째 작업의 결과를 받아 두 번째 작업을 시작한다. Wherehouse의 "주소 변환 완료 → 범죄율 조회"가 이 패턴이다.

**2. 병렬 실행 후 조합 (A와 B 동시 → 둘 다 완료되면 합침)**: `thenCombine`을 사용한다. 두 작업이 독립적으로 실행되고, 둘 다 완료되면 결과를 합친다.

**3. 다중 작업 대기 (여러 작업 모두 완료 대기)**: `allOf`를 사용한다. 15개 카테고리 검색처럼 독립적인 작업들을 모두 실행하고, 전부 완료될 때까지 대기한다.

#### 안전한 조합의 의미

이러한 조합 메커니즘은 단순히 "코드를 짧게 만드는 편의 기능"이 아니다. 각 단계가 명확히 분리되어 있고, 예외가 발생하면 체인 전체로 자동 전파되며, 중간 단계를 건너뛰고 예외 처리 로직으로 이동한다. 수동으로 try-catch를 중첩하거나 플래그 변수로 상태를 추적할 필요가 없다.

또한 각 단계는 독립적으로 테스트 가능하며, 새로운 단계를 추가하거나 순서를 변경할 때 다른 부분을 수정하지 않아도 된다. 이는 복잡한 비동기 로직을 안전하게 구성할 수 있는 아키텍처 수준의 개선이다.

### 2.3 스레드 풀과의 역할 분리

CompletableFuture와 스레드 풀은 **완전히 다른 책임**을 가진 별개의 컴포넌트다. 이 둘은 상속 관계가 아니라 **협력 관계**다.

#### 각자의 역할

**스레드 풀의 역할:**
- Worker 스레드 생성 및 관리
- 작업 큐에서 작업을 꺼내 스레드에 배정
- 스레드 라이프사이클 제어 (생성, 재사용, 종료)

**CompletableFuture의 역할:**
- 비동기 작업의 결과를 담는 컨테이너를 생성 및 이를 반환 객체로써 스레드 풀에 전달 및 그에 따른 객체를 반환 받기로 약속(CompotubleFuture 객체 그 자체)
- "완료되면 실행할 콜백" 목록 관리
- 콜백 체인 자동 실행

#### 실제 협력 방식

CompletableFuture의 스레드 풀을 ThreadPoolExecutor를 적용한다. (CompletableFuture의 기본 스레드 풀은 ForkJoinPool 이다)

```java
// 1. 커스텀 ThreadPoolExecutor 생성
ExecutorService ioExecutor = Executors.newFixedThreadPool(20);

// 2. CompletableFuture가 이 Executor를 사용
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    return getData();  // ← ioExecutor의 Worker 스레드가 실행
}, ioExecutor);

// 내부 동작:
// - CompletableFuture: "이 작업을 실행해줘" → ioExecutor에게 전달
// - ioExecutor: Worker 스레드에 작업 배정
// - Worker 스레드: 작업 실행 완료
// - CompletableFuture: 결과 받아서 저장 + 콜백 실행
```

#### 왜 커스텀 스레드 풀이 필요한가

CompletableFuture는 기본적으로 `ForkJoinPool.commonPool()`을 사용한다. 이 풀은 `Runtime.getRuntime().availableProcessors() - 1`개의 스레드를 생성한다 (예: 8코어 CPU → 7개 스레드). Main 스레드를 제외한 나머지 코어를 활용하는 설계다. 이는 CPU-bound 작업(계산 위주)에는 적합하지만, I/O-bound 작업(네트워크 대기)에는 부족하다.

Wherehouse R-04는 최대 17개의 동시 API 호출이 필요하다 (주소 1 + 카테고리 15 + 범죄율 1). 그런데 commonPool이 7개 스레드만 제공하면, 나머지 10개 작업은 큐에서 대기하며 순차 실행된다. 이는 병렬도를 떨어뜨려 성능 개선 효과를 반감시킨다.

따라서 I/O 작업에서는 **충분한 수의 스레드를 가진 커스텀 Executor**를 명시적으로 지정해야 한다:

```java
// I/O 작업용: 20개 스레드
ExecutorService ioExecutor = Executors.newFixedThreadPool(20);

CompletableFuture.supplyAsync(() -> apiCall(), ioExecutor);
```

이렇게 하면 CompletableFuture의 "콜백 자동 실행 메커니즘"과 ThreadPoolExecutor의 "스레드 풀 관리"를 모두 활용할 수 있다.

---

## 3. supplyAsync() 메서드의 내부 실행 메커니즘

### 3.1 AsyncSupply 객체의 생명주기

`supplyAsync()`는 단순히 "작업을 비동기로 실행한다"는 추상적 개념이 아니라, 정확한 3단계 실행 메커니즘을 가진다. 이 과정의 핵심은 **AsyncSupply라는 특수한 Runnable 구현체**다.

메서드 호출 시점에서 즉시 새로운 CompletableFuture 객체가 생성되며, 이와 동시에 AsyncSupply 객체가 생성되어 Executor의 작업 큐에 삽입된다. 중요한 점은 **메인 스레드가 이 시점에서 즉시 반환받는다**는 것이다. 실제 람다 실행은 워커 스레드가 큐에서 AsyncSupply를 꺼낼 때 비로소 시작된다.

AsyncSupply는 두 가지 핵심 참조를 보유한다: 실행할 Supplier 구현체(람다 방식으로 전달)와 작업 완료 시 반환 받을 CompletableFuture 객체 두 가지 이다. 워커 스레드가 `run()` 메서드를 실행하면, 람다를 호출하여 결과를 얻고, 이를 CompletableFuture의 result 필드에 CAS 연산으로 저장한 후, `postComplete()`를 호출하여 등록된 모든 콜백을 트리거한다.

### 3.2 Completion Stack: 콜백 저장과 실행의 내부 구조

#### 콜백 저장 필드의 설계

CompletableFuture는 작업 완료 결과와 콜백 체인을 분리된 두 필드로 관리한다. `result` 필드는 작업의 완료 여부와 결과값을 동시에 표현하는 단일 참조다. `null`이면 작업이 진행 중이며, 값이 설정되면 완료 상태를 나타낸다. 반면 `stack` 필드는 완료 시 실행할 콜백들을 역순 연결 리스트 형태로 보관한다.

```java
public class CompletableFuture<T> {
    volatile Object result;     // 작업 완료 결과 저장
    volatile Completion stack;  // 등록된 콜백들의 LIFO 연결 리스트
}
```

이 두 필드의 분리는 작업 완료와 완료 통지를 독립적으로 처리할 수 있게 만든다. `result`는 워커 스레드에 의해 단 한 번만 CAS 연산으로 설정되지만, `stack`은 작업 완료 전까지 여러 스레드가 동시에 새로운 콜백을 추가할 수 있다. 이는 비동기 환경에서 "결과 생성"과 "결과 소비"의 타이밍이 일치하지 않는 근본적 비동기성을 수용하는 설계다.

#### Completion 객체: 콜백의 실체적 표현

사용자가 `thenApply()`, `thenAccept()`, `thenCompose()` 같은 메서드를 호출할 때마다, 해당 CompletableFuture 객체는 내부적으로 새로운 `Completion` 객체를 생성하여 자신의 `stack` 필드에 추가한다. 이 객체는 다음 구조를 갖는다:

```java
abstract static class Completion extends ForkJoinTask<Void> {
    volatile Completion next;  // 다음 Completion을 가리키는 포인터 (연결 리스트)
    
    abstract CompletableFuture<?> tryFire(int mode);  // 등록된 콜백을 실행하는 메서드
}
```

각 Completion은 특정 변환 동작을 담당한다. `thenApply()`로 생성된 Completion은 입력값을 받아 사용자가 정의한 함수를 적용하여 새로운 값으로 변환하는 책임을 진다. `thenAccept()`의 Completion은 입력값을 받아 지정된 동작을 수행하되, 다음 단계로 전달할 결과값은 생성하지 않는다. `thenCompose()`의 경우, 생성된 Completion은 중첩된 비동기 작업을 자동으로 연결하여 이중 포장 구조를 평탄화한다. 즉, 각 Completion은 "어떤 동작을 수행할 것인가"와 "그 결과를 다음 단계로 어떻게 전달할 것인가"를 스스로 알고 있는 자기 완결적 실행 단위다.

실제 구현체는 다음과 같다:

1) **UniApply** 클래스: "Uni"는 하나의 입력을 받는다는 의미이고, "Apply"는 입력에 함수를 적용하여 새로운 값을 만든다는 의미다. 이 객체는 사용자가 전달한 Function과 입력 Future, 출력 Future의 참조를 필드로 보유하며, 실행 시점에 입력 Future의 result를 읽어 Function을 적용한 후 출력 Future의 result에 저장한다.

2) **UniAccept** 클래스: "Accept"는 입력을 받아 처리하되 반환값이 없다는 의미다. 이 객체는 Consumer와 입력 Future, 출력 Future(Void 타입)의 참조를 필드로 보유하며, 실행 시점에 입력 Future의 result를 읽어 Consumer를 실행한 후 출력 Future의 result를 null로 설정한다.

3) **UniCompose** 클래스: "Compose"는 중첩된 구조를 하나로 합친다는 의미다. 사용자 함수가 또 다른 CompletableFuture를 반환하므로, 이 객체는 실행 시점에 내부 Future가 완료될 때까지 대기한 후 그 결과를 최종 출력 Future에 복사하여 `Future<Future<T>>`를 `Future<T>`로 평탄화한다.

#### 콜백 등록의 동시성 제어

`thenApply()` 메서드를 호출하면 CompletableFuture는 즉시 새로운 CompletableFuture 객체를 생성하여 반환한다. 이 시점에서 원본 작업이 이미 완료되었는지에 따라 두 가지 경로가 갈린다. 완료된 상태라면 `thenApply()` 메서드가 생성된 Completion 객체에 등록된 콜백을 즉시 실행하지만, 미완료 상태라면 생성된 Completion 객체를 원본 CompletableFuture의 `stack` 필드에 CAS 연산으로 추가한다.

이 CAS 기반 push 연산은 여러 스레드가 동시에 콜백을 등록해도 안전하게 처리한다. 새로운 Completion 객체의 `next` 포인터를 현재 `stack` 필드의 head로 설정한 후, CompletableFuture 객체는 자신의 `stack` 필드를 이 새 Completion으로 교체하려 CAS 연산을 시도한다. 다른 스레드가 먼저 새로운 Completion을 추가했다면 CAS는 실패하고, 다시 현재 head를 읽어 재시도한다. 이는 Treiber Stack이라 불리는 lock-free 자료구조의 표준 구현 방식이다.

결과적으로 여러 스레드가 `.thenApply().thenAccept()`를 연달아 호출하면, 각 단계의 CompletableFuture 객체가 생성한 Completion 객체들이 역순으로 각자의 stack에 쌓인다. 마지막에 등록된 콜백이 stack의 head에 위치하게 되지만, 이는 실행 순서와 무관하다. 각 Completion 객체가 실행될 때 다음 단계의 CompletableFuture 객체를 완료시키는 구조이기 때문에, 최종적으로는 등록 순서대로 결과가 전파된다.

#### postComplete()의 콜백 순회 메커니즘

워커 스레드가 람다 실행을 완료하고 원본 CompletableFuture 객체의 `result` 필드를 설정한 직후, 워커 스레드는 해당 CompletableFuture 객체의 `postComplete()` 메서드를 호출한다. 이 메서드는 해당 객체의 `stack` 필드에 쌓인 모든 Completion을 순회하며 각 Completion 객체에 등록된 콜백을 실행한다. 순회는 stack의 head부터 시작하여 CAS 연산으로 다음 노드로 이동하는 방식으로 진행된다.

워커 스레드가 각 Completion 객체의 콜백을 실행하면, 해당 Completion은 원본 CompletableFuture의 `result` 필드를 읽어 등록된 함수를 적용하거나 값을 소비한다. 이후 Completion은 자신이 담당하는 다음 단계 CompletableFuture 객체의 `result` 필드를 설정하고, 워커 스레드는 다음 단계 CompletableFuture 객체의 `postComplete()` 메서드를 재귀적으로 호출한다. 이는 연쇄 반응처럼 모든 연결된 단계를 자동으로 완료시키는 도미노 효과를 만든다. 모든 과정이 워커 스레드의 콜 스택에서 실행되므로, 추가적인 스레드 컨텍스트 스위칭이나 동기화 오버헤드가 발생하지 않는다.

---
## 4. CompletableFuture 생성 메소드의 설계 의도

### 4.1 supplyAsync vs runAsync: 반환값의 유무가 만드는 차이

CompletableFuture는 두 가지 핵심 생성 메소드를 제공한다. `supplyAsync()`는 **값을 생산하는 작업**을, `runAsync()`는 **부수 효과만 있는 작업**을 표현한다. 이 구분은 단순한 편의가 아니라, 함수형 프로그래밍의 순수 함수와 부수 효과 함수를 명확히 분리하는 설계 철학의 반영이다.

```java
// 값을 생산하는 작업: Supplier<T> → CompletableFuture<T>
CompletableFuture<AddressDto> addressFuture = CompletableFuture.supplyAsync(() -> {
    return kakaoApiService.getAddress(lat, lon);  // 결과 반환
}, ioExecutor);

// 부수 효과만 있는 작업: Runnable → CompletableFuture<Void>
CompletableFuture<Void> loggingFuture = CompletableFuture.runAsync(() -> {
    performanceLogger.logApiCall("kakao", startTime);  // 로깅만 수행
}, loggingExecutor);
```

`supplyAsync()`가 `Supplier<T>`를 받는 이유는 **작업의 결과를 후속 체인에 전달**하기 위함이다. Wherehouse R-04에서 주소 변환 API의 결과는 범죄율 조회의 입력이 되므로, 반드시 값을 반환해야 한다. 반면 성능 로깅이나 캐시 갱신 같은 작업은 결과값이 필요 없으므로 `runAsync()`를 사용한다.

### 4.2 completedFuture: 이미 알고 있는 값의 비동기 체인 진입

때로는 이미 계산된 값을 CompletableFuture 체인에 주입해야 할 때가 있다. `completedFuture()`는 **즉시 완료된 상태의 CompletableFuture**를 생성한다.

```java
// 캐시에서 즉시 반환 가능한 경우
CompletableFuture<Crime> crimeFuture;
Crime cached = crimeCache.get(gu);

if (cached != null) {
    crimeFuture = CompletableFuture.completedFuture(cached);  // 즉시 완료
} else {
    crimeFuture = CompletableFuture.supplyAsync(() -> {
        return crimeRepository.findByGu(gu);  // DB 조회
    }, dbExecutor);
}

// 이후 체인은 캐시 히트/미스와 무관하게 동일
crimeFuture.thenApply(crime -> calculateSafetyScore(crime));
```

이 패턴의 핵심은 **동기와 비동기 경로를 통일된 인터페이스로 처리**하는 것이다. 호출자는 값이 캐시에서 왔는지 DB에서 왔는지 알 필요 없이, 동일한 CompletableFuture 체인으로 처리할 수 있다.

---

## 5. 변환 메소드: 함수형 파이프라인의 구축

### 5.1 thenApply vs thenApplyAsync: 스레드 전환의 트레이드오프

`thenApply()`는 **이전 작업을 완료한 스레드에서 즉시 실행**되고, `thenApplyAsync()`는 **새로운 스레드에 작업을 제출**한다. 이 차이는 단순한 동기/비동기의 구분이 아니라, 스레드 자원 활용의 전략적 선택이다.

```java
// thenApply: 같은 워커 스레드에서 연속 실행
CompletableFuture<Integer> scoreFuture = addressFuture
    .thenApply(address -> extractGu(address))        // Worker-1에서 실행
    .thenApply(gu -> calculateBaseScore(gu))         // 여전히 Worker-1
    .thenApply(score -> applyLocalModifier(score));  // 계속 Worker-1

// thenApplyAsync: 스레드 전환
CompletableFuture<Report> reportFuture = scoreFuture
    .thenApplyAsync(score -> {
        // CPU 집약적 PDF 생성 → 별도 스레드로 분리
        return generatePdfReport(score);
    }, cpuExecutor);
```

**선택 기준의 핵심 원칙:**

1. **가벼운 변환 작업** (필터링, 매핑, 간단한 계산): `thenApply()` 사용. Context switching 비용을 절약하고, CPU 캐시 지역성을 활용한다.

2. **무거운 작업이나 블로킹 I/O**: `thenApplyAsync()` 사용. 현재 워커 스레드를 즉시 해방시켜 다른 작업을 처리할 수 있게 한다.

3. **다른 Executor로 전환 필요**: `thenApplyAsync(fn, newExecutor)` 사용. I/O용 스레드 풀에서 CPU용 스레드 풀로 작업을 이관한다.

Wherehouse R-04에서는 API 응답 파싱과 점수 계산은 `thenApply()`로, 새로운 API 호출이나 DB 조회는 `thenApplyAsync()`로 처리한다.

### 5.2 thenAccept vs thenRun: 소비와 트리거의 차이

`thenAccept()`는 **이전 결과를 소비**하고, `thenRun()`은 **이전 작업 완료를 트리거로만 사용**한다.

```java
// thenAccept: 결과를 받아서 소비 (Consumer<T>)
addressFuture.thenAccept(address -> {
    // address를 사용하여 부수 효과 수행
    metricsCollector.recordApiResponse("address", address.getResponseTime());
    cacheManager.put(cacheKey, address);
});

// thenRun: 완료 신호만 필요 (Runnable)
allOf(futures).thenRun(() -> {
    // 모든 작업 완료 후 실행, 개별 결과는 불필요
    logger.info("All {} API calls completed", futures.length);
    performanceMonitor.recordBatchCompletion();
});
```

`thenAccept()`는 결과를 로깅하거나 캐시에 저장하는 등 **결과에 의존하는 부수 효과**에 사용된다. `thenRun()`은 단순히 "작업이 끝났다"는 사실만 중요할 때, 예를 들어 진행 표시기 업데이트나 완료 카운터 증가에 사용된다.

### 5.3 thenCompose: 중첩된 CompletableFuture의 평탄화

`thenCompose()`는 **CompletableFuture를 반환하는 함수**를 받아, 중첩을 평탄화한다. 이는 함수형 프로그래밍의 `flatMap`과 동일한 개념이다.

```java
// thenApply를 사용하면 중첩 발생
CompletableFuture<CompletableFuture<Crime>> nested = addressFuture
    .thenApply(address -> {
        String gu = extractGu(address);
        // 새로운 비동기 작업 시작 → CompletableFuture 반환
        return CompletableFuture.supplyAsync(() -> crimeService.getCrime(gu));
    });

// thenCompose를 사용하면 평탄화
CompletableFuture<Crime> flat = addressFuture
    .thenCompose(address -> {
        String gu = extractGu(address);
        return CompletableFuture.supplyAsync(() -> crimeService.getCrime(gu));
    });
```

`thenCompose()`의 존재 이유는 **연속적인 비동기 작업을 체인으로 연결**하기 위함이다. Wherehouse R-04에서 "주소 변환 → 구 추출 → 범죄율 조회"처럼 각 단계가 비동기 작업인 경우, `thenCompose()`로 자연스럽게 연결된다.

---
## 6. thenApply()의 스레드 실행 메커니즘 상세 분석

### 6.1 기존 Future API의 구조적 한계

Java의 초기 비동기 프로그래밍 모델인 Future는 단순한 producer-consumer(생산자-소비자) 패턴을 구현했다. ExecutorService가 작업을 실행하고, 호출자는 Future.get()을 통해 블로킹 방식으로 결과를 기다렸다. 이 모델은 명확했지만, 연속적인 비동기 작업을 체이닝하거나 복잡한 의존성 그래프를 구성하는 데 있어 근본적인 한계를 드러냈다.

블로킹 기반 Future의 가장 큰 문제는 **스레드 자원의 비효율적 사용**이었다. 각 Future.get() 호출은 스레드를 정지시켰고, 이는 대규모 동시성 처리에서 thread starvation(스레드 고갈)로 이어졌다. 더욱이 여러 Future를 조합하려면 추가 스레드를 할당해야 했고, 이는 시스템 자원 관리를 복잡하게 만들었다.

### 6.2 Completion-Driven Model의 등장 배경

CompletableFuture는 이러한 한계를 극복하기 위해 **completion-driven execution model(완료 주도 실행 모델)**을 도입했다. 이 모델의 핵심은 "작업의 완료 시점"을 기준으로 후속 작업의 실행 주체를 동적으로 결정하는 것이다. 이는 단순히 비동기 작업을 체이닝하는 것을 넘어, **스레드 자원을 최적화하면서도 예측 가능한 실행 흐름을 보장**하는 정교한 스케줄링 메커니즘이다.

### 6.3 핵심 제어 메커니즘: Completion Stack Architecture(완료 스택 아키텍처)

CompletableFuture는 내부적으로 **Completion Stack(완료 스택)**이라는 자료구조를 유지한다. 이는 단순한 콜백 리스트가 아니라, 각 completion stage(완료 단계)의 의존성과 실행 조건을 관리하는 복잡한 그래프 구조다.

```java
// CompletableFuture 내부 구조 (간략화)
class CompletableFuture<T> {
    volatile Object result;       // 결과 또는 예외
    volatile Completion stack;    // completion 노드들의 스택
    
    // thenApply 호출 시 생성되는 completion 노드
    static final class UniApply<T,V> extends UniCompletion<T,V> {  // UniApply: 단일 적용 완료 노드
        Function<? super T,? extends V> fn;
        // 실행 로직 포함
    }
}
```

`thenApply()` 같은 메서드가 호출되면, CompletableFuture는 즉시 새로운 CompletableFuture 인스턴스를 생성하고 반환한다. 동시에 **UniApply(단일 적용 노드)** 노드를 생성하여 원본 CompletableFuture의 completion stack(완료 스택)에 추가한다. 이 시점에서 중요한 분기가 발생한다.

### 6.4 실행 주체 결정의 두 가지 경로

#### Fast Path(빠른 경로): 이미 완료된 경우
CompletableFuture가 이미 완료된 상태라면, `thenApply()`를 호출한 스레드(주로 main)가 즉시 transformation(변환) 함수를 실행한다. 이는 **불필요한 컨텍스트 스위칭을 방지**하는 최적화다.

```java
// Fast Path(빠른 경로) 실행 흐름
if (CompletableFuture.isDone()) {
    // 호출자 스레드가 직접 실행
    V result = fn.apply(previousResult);
    newCompletableFuture.complete(result);
}
```

이 최적화는 작은 작업들을 체이닝할 때 성능상 큰 이점을 제공한다. 스레드 간 동기화 오버헤드가 없고, CPU cache locality(캐시 지역성)도 유지된다.

#### Slow Path(느린 경로): 아직 완료되지 않은 경우
CompletableFuture가 아직 실행 중이라면, completion 노드만 등록되고 호출자 스레드는 즉시 다음 코드로 진행한다. 나중에 원본 작업을 완료하는 스레드(워커 스레드)가 **completion stack(완료 스택)을 순회하며 등록된 모든 completion을 연쇄적으로 실행**한다.

```java
// Slow Path(느린 경로) 실행 흐름
// 워커 스레드가 supplyAsync 완료 후:
completeValue(result);
postComplete();  // stack(스택)에 등록된 모든 completion(완료 작업) 실행
```

### 6.5 스레드 할당 전략의 설계 철학

#### 비동기 작업의 이중적 본질과 메서드 분리의 필연성

CompletableFuture가 supplyAsync()와 thenApply()를 분리한 것은 **비동기 작업이 가진 두 가지 본질적으로 다른 특성**을 명확히 구분하기 위한 아키텍처적 결정이다. supplyAsync()는 **초기 비동기 컨텍스트의 생성(initiation)**을, thenApply()는 **기존 컨텍스트 내에서의 값 변환(continuation)**을 담당한다.

이 두 연산의 시스템 자원과의 상호작용 방식은 근본적으로 다르다. supplyAsync()는 호출 즉시 새로운 워커 스레드를 할당받아 작업을 시작해야 한다. 이는 main 스레드가 블로킹되지 않고 다른 작업을 계속 수행해야 하기 때문에 불가피한 선택이다. 반면 thenApply()는 **독립적인 새 작업을 시작하는 것이 아니라, 이미 진행 중인 비동기 작업의 결과값을 받아서 변환만 수행**한다. 즉, supplyAsync()가 생성한 비동기 작업 흐름에 "매달려서" 그 결과를 기다렸다가 변환하는 후속 처리기(post-processor)일 뿐이므로, 새로운 스레드 할당이 필수적이지 않다. 오히려 상황에 따라 최적의 실행 주체를 선택할 수 있는 유연성을 갖는다.

#### 함수형 컴포지션과 모나드 패턴의 구현

이 분리는 **함수형 프로그래밍의 모나드(Monad) 패턴**을 비동기 영역으로 확장한 것이다. 모나드에서 '감싸기(wrap)'와 '변환(map)'은 서로 다른 관심사를 다루는 독립적인 연산이며, CompletableFuture는 이를 정확히 구현한다:

```java
// 모나드 패턴의 일관된 구현
Optional.of(value)              // wrap
    .map(transformer);          // transform

CompletableFuture
    .supplyAsync(() -> value)   // wrap (비동기 컨테이너로)
    .thenApply(transformer);     // transform (컨테이너 내 값을)
```

이러한 분리가 없었다면, 각 변환 단계마다 강제적으로 새로운 스레드를 할당해야 하여 시스템 자원의 극심한 낭비가 발생한다. 간단한 문자열 변환에 10μs가 걸리는데 스레드 컨텍스트 스위칭에 1000μs가 소요된다면, 이는 명백한 설계 실패다.

#### adaptive execution strategy(적응적 실행 전략)의 세 가지 축

CompletableFuture의 스레드 할당 전략은 다음 세 가지 원칙을 통해 **런타임 효율성을 극대화**한다:

**작업 지역성 최대화(Work Locality Maximization)**: CPU 캐시에 이미 로드된 데이터를 그대로 활용하기 위해, 가능한 한 동일 스레드에서 연속 작업을 처리한다. Fast Path에서 main 스레드가 계속 작업을 수행하는 것은 이 원칙의 직접적 구현이다.

**컨텍스트 스위칭 오버헤드 제거(Context Switch Elimination)**: 스레드 간 전환은 CPU 레지스터 저장/복원, TLB(Translation Lookaside Buffer) 무효화, 캐시 라인 재로드 등의 비용을 발생시킨다. thenApply()가 상황에 따라 호출자 스레드에서 직접 실행되는 것은 이러한 오버헤드를 원천적으로 제거한다.

**스레드 풀 포화 방지(Thread Pool Saturation Prevention)**: ForkJoinPool.commonPool()은 제한된 수의 워커 스레드를 관리한다. 모든 변환이 새 작업을 풀에 제출한다면, 풀이 포화되어 전체 시스템의 처리량이 급격히 저하된다. Fast Path는 이미 완료된 작업에 대해 추가 스레드 할당 없이 처리함으로써 풀의 압력을 감소시킨다.

#### 실행 시점과 실행 주체의 의미론적 분리

더 깊은 수준에서, 이 설계는 **"언제(when)"와 "누가(who)"의 결정을 분리**한다. supplyAsync()는 "지금 즉시, 워커 스레드가"라는 명확한 의미를 갖는 반면, thenApply()는 "완료되면, 그때 최적의 주체가"라는 적응적 의미를 갖는다. 이는 비동기 프로그래밍의 복잡성을 관리하기 위한 필수적인 추상화다.

### 6.6 실제 코드에서의 증명

```java
CompletableFuture<Integer> cf = CompletableFuture
    .supplyAsync(() -> {
        // Case 1: 빠른 완료
        return 42;
    })
    .thenApply(result -> {
        System.out.println("Executor: " + Thread.currentThread().getName());
        // 출력: "main" - Fast Path(빠른 경로) 동작
        return result * 2;
    });

CompletableFuture<Integer> cf2 = CompletableFuture
    .supplyAsync(() -> {
        // Case 2: 지연된 완료
        Thread.sleep(1000);
        return 42;
    })
    .thenApply(result -> {
        System.out.println("Executor: " + Thread.currentThread().getName());
        // 출력: "ForkJoinPool.commonPool-worker-1" - Slow Path(느린 경로) 동작
        return result * 2;
    });
```

### 6.7 패러다임의 변화

CompletableFuture의 completion-driven model(완료 주도 모델)은 비동기 프로그래밍에서 **"누가 실행하는가"에서 "언제 실행되는가"로 관심사를 전환**시켰다. 이는 단순한 구현상의 차이가 아니라, 비동기 시스템 설계의 근본적인 사고 전환이다.

전통적인 스레드 기반 동시성 모델에서는 개발자가 명시적으로 실행 주체를 지정했다. CompletableFuture는 이를 추상화하여, 시스템이 최적의 실행 전략을 선택하도록 위임한다. 이는 **선언적 프로그래밍 패러다임**의 비동기 영역으로의 확장이다.

### 6.8 아키텍처적 영향

이 모델은 마이크로서비스 아키텍처와 리액티브 시스템 설계에 깊은 영향을 미쳤다. 특히 **back-pressure(역압) 처리**와 **비동기 파이프라인 구성**에서 CompletableFuture의 실행 모델은 표준적인 패턴이 되었다.

시스템 아키텍트는 이제 개별 스레드 관리 대신, **completion chain(완료 체인)의 구조와 의존성 그래프**를 설계한다. 이는 더 높은 수준의 추상화에서 시스템을 바라보게 하며, 복잡한 비동기 워크플로우를 더 명확하게 표현할 수 있게 한다.

### 6.9 설계적 책임과 주의사항

CompletableFuture의 적응적 실행 모델은 강력하지만, 개발자에게 새로운 책임을 부여한다:

**스레드 안전성 보장**: completion chain(완료 체인)에서 어떤 스레드가 실행할지 예측할 수 없으므로, 공유 상태 접근 시 항상 스레드 안전성을 고려해야 한다.

**실행 순서와 타이밍**: Fast Path(빠른 경로)와 Slow Path(느린 경로)의 존재로 인해, 동일한 코드가 다른 타이밍에 다른 스레드에서 실행될 수 있다. 이는 디버깅과 테스팅을 복잡하게 만든다.

**리소스 관리**: ForkJoinPool.commonPool()의 기본 사용은 편리하지만, 대용량 I/O 작업이나 블로킹 작업에는 부적합하다. 적절한 Executor 선택이 성능에 결정적 영향을 미친다.

### 6.10 실무 적용 가이드라인

#### 스레드 실행 주체 예측 방법

```java
// supplyAsync 내부에 지연 추가로 실행 주체 확인
CompletableFuture
    .supplyAsync(() -> {
        Thread.sleep(100);  // 충분한 지연 추가
        return computation();
    })
    .thenApply(result -> {
        // 워커 스레드에서 실행될 가능성 높음
        System.out.println("Thread: " + Thread.currentThread().getName());
        return transformation(result);
    });
```

#### 디버깅 전략

```java
// 실행 스레드 추적을 위한 로깅
.thenApply(result -> {
    logger.debug("Thread: {}, Stage: thenApply", Thread.currentThread().getName());
    return process(result);
})
```

#### 성능 최적화 패턴

```java
// Fast Path 최적화 활용: 빠른 작업은 main 스레드에서 처리
CompletableFuture<String> result = CompletableFuture
    .supplyAsync(() -> "Quick Result")  // 빠른 완료
    .thenApply(s -> s.toUpperCase())    // main 스레드에서 실행
    .thenApply(s -> s + "!");           // 연속적으로 main 스레드에서 실행

// 의도적 워커 스레드 활용: 무거운 작업 체이닝
CompletableFuture<Integer> heavy = CompletableFuture
    .supplyAsync(() -> {
        // 무거운 계산 작업
        Thread.sleep(500);
        return heavyComputation();
    })
    .thenApply(n -> n * 2)  // 워커 스레드가 계속 처리
    .thenApply(n -> n + 100); // 동일 워커 스레드에서 연속 처리
```

---
## 7. thenApplyAsync()의 강제 비동기 실행 메커니즘

### 7.1 왜 thenApplyAsync()라는 별도 메서드가 필요한가

#### 적응적 실행의 한계와 예측 가능성의 필요성

CompletableFuture의 thenApply()는 Fast Path/Slow Path를 통한 적응적 실행 전략을 제공한다. 이는 대부분의 상황에서 최적의 성능을 보장하지만, **실행 주체의 비결정성(non-determinism)**이라는 근본적인 특성을 갖는다. 동일한 코드가 실행 시점의 타이밍에 따라 main 스레드에서 실행될 수도, 워커 스레드에서 실행될 수도 있다는 것이다.

이러한 비결정성은 특정 상황에서 심각한 문제를 야기한다. CPU 집약적 작업이 main 스레드에서 실행되어 전체 애플리케이션이 블로킹되거나, ThreadLocal을 사용하는 코드에서 예상치 못한 컨텍스트 오염이 발생할 수 있다. 더 중요한 것은, 개발자가 **명시적으로 작업을 다른 스레드로 분리하고자 할 때** 이를 보장할 방법이 없다는 점이다.

#### 명시적 비동기 실행의 설계 요구사항

thenApplyAsync()는 이러한 한계를 극복하기 위해 설계되었다. 이 메서드의 핵심 보장사항은 **"호출자 스레드가 절대 변환 작업을 직접 실행하지 않는다"**는 것이다. 이는 단순히 성능 최적화의 포기가 아니라, 특정 아키텍처 패턴을 구현하기 위한 필수적인 도구다.

비동기 파이프라인에서 각 단계가 서로 다른 특성의 작업(I/O-bound vs CPU-bound)을 수행하거나, 서로 다른 자원 제약(데이터베이스 연결 풀 vs 계산 스레드 풀)을 가질 때, 명시적 스레드 분리는 시스템의 안정성과 처리량을 보장하는 핵심 메커니즘이 된다.

### 7.2 AsyncApply 노드와 강제 비동기 실행 구조

thenApplyAsync()가 호출되면 CompletableFuture는 내부적으로 **AsyncApply** 노드를 생성한다. 이는 thenApply()의 UniApply와 유사하지만, 결정적인 차이점을 갖는다:

```java
// CompletableFuture 내부 구조 (간략화)
static final class AsyncApply<T,V> extends AsyncCompletion<T,V> {
    Function<? super T,? extends V> fn;
    
    void tryFire(int mode) {
        // mode와 무관하게 항상 비동기 실행
        if (mode == SYNC) {
            // SYNC 모드에서도 풀에 제출
            ForkJoinPool.commonPool().execute(this);
            return;
        }
        // ASYNC 모드에서 실제 작업 실행
        applyFunction();
    }
}
```

### 7.3 스레드 할당 타이밍과 논블로킹 보장

#### 이전 작업이 완료되지 않은 경우

```java
CompletableFuture<Integer> future = CompletableFuture
    .supplyAsync(() -> {
        Thread.sleep(5000);  // 워커 스레드에서 실행 중
        return 42;
    })
    .thenApplyAsync(x -> x * 2);  // main 스레드가 호출
```

main 스레드가 thenApplyAsync()를 호출하는 시점에 다음이 발생한다:

1. **AsyncApply 노드 생성**: 변환 함수를 캡슐화한 completion 노드 생성
2. **Completion Stack 등록**: 원본 CompletableFuture의 stack에 추가
3. **즉시 반환**: main 스레드는 새 CompletableFuture를 받고 즉시 다음 작업 진행

이 시점에서 **어떤 새로운 스레드도 생성되거나 할당되지 않는다**. AsyncApply는 단지 "나중에 실행될 작업"으로 등록될 뿐이다.

5초 후 supplyAsync()가 완료되면:

```java
// 워커 스레드가 실행
completeValue(42);
postComplete() {
    // AsyncApply 발견
    ForkJoinPool.commonPool().execute(() -> {
        result = fn.apply(42);  // x * 2 실행
        nextCompletableFuture.complete(result);
    });
}
```

#### 이전 작업이 이미 완료된 경우

```java
CompletableFuture<Integer> future = CompletableFuture
    .completedFuture(42)  // 이미 완료된 상태
    .thenApplyAsync(x -> x * 2);  // main 스레드가 호출
```

이 경우에도 main 스레드는 직접 작업을 실행하지 않는다:

1. **즉시 풀 제출**: ForkJoinPool.commonPool().execute(asyncApplyTask)
2. **논블로킹 반환**: main은 제출만 하고 결과를 기다리지 않음
3. **비동기 실행**: 풀의 워커 스레드가 나중에 작업 수행

### 7.4 폴링 없는 이벤트 기반 실행 모델

CompletableFuture는 **폴링(polling)을 전혀 사용하지 않는다**. 이는 흔한 오해인데, 많은 개발자가 "어떤 스레드가 주기적으로 완료 상태를 확인한다"고 잘못 이해한다.

실제로는 **push 기반 이벤트 모델**을 사용한다:

```java
// 폴링이 아닌 콜백 체인
class CompletableFuture<T> {
    volatile Object result;
    volatile Completion stack;  // 콜백 체인
    
    boolean complete(T value) {
        this.result = value;
        postComplete();  // 즉시 모든 대기 중인 작업 실행
        return true;
    }
    
    void postComplete() {
        Completion h;
        while ((h = stack) != null) {
            h.tryFire(NESTED);  // 각 completion 실행
        }
    }
}
```

작업을 완료하는 스레드가 직접 다음 작업들을 트리거한다. 어떤 스레드도 "대기"하지 않으며, CPU 자원 낭비가 없다.

### 7.5 thenApplyAsync()가 필요한 아키텍처 패턴

#### I/O와 CPU 작업의 명시적 분리

```java
ExecutorService ioExecutor = Executors.newCachedThreadPool();
ExecutorService cpuExecutor = Executors.newFixedThreadPool(4);

CompletableFuture
    .supplyAsync(() -> fetchFromNetwork(), ioExecutor)  // I/O 스레드
    .thenApplyAsync(data -> parseJson(data), cpuExecutor)  // CPU 스레드
    .thenApplyAsync(json -> compress(json), cpuExecutor)   // CPU 스레드
    .thenApplyAsync(compressed -> saveToFile(compressed), ioExecutor); // I/O 스레드
```

각 작업 특성에 맞는 스레드 풀을 사용하여 자원 활용을 최적화한다. I/O 스레드는 대기 시간이 길어도 많은 수를 유지할 수 있지만, CPU 스레드는 코어 수에 맞춰 제한한다.

### 7.6 성능 특성과 트레이드오프

#### 컨텍스트 스위칭 오버헤드

thenApplyAsync()는 **항상 컨텍스트 스위칭을 발생**시킨다:

```java
// 성능 비교
CompletableFuture<String> fast = CompletableFuture
    .completedFuture("data")
    .thenApply(String::toUpperCase);  // ~100ns (캐시 히트)

CompletableFuture<String> slow = CompletableFuture
    .completedFuture("data")
    .thenApplyAsync(String::toUpperCase);  // ~10,000ns (컨텍스트 스위칭)
```

간단한 변환에 thenApplyAsync()를 사용하면 100배 이상의 성능 저하가 발생할 수 있다.

#### 스레드 풀 압력과 처리량

```java
// 안티패턴: 모든 변환에 Async 사용
CompletableFuture
    .supplyAsync(() -> getData())
    .thenApplyAsync(x -> x + 1)  // 불필요한 풀 압력
    .thenApplyAsync(x -> x * 2)  // 불필요한 풀 압력
    .thenApplyAsync(x -> x.toString());  // 불필요한 풀 압력

// 올바른 패턴: 필요한 곳에만 Async
CompletableFuture
    .supplyAsync(() -> getData())
    .thenApply(x -> x + 1)  // 빠른 변환은 동기
    .thenApply(x -> x * 2)
    .thenApplyAsync(x -> heavyComputation(x));  // 무거운 작업만 비동기
```

### 7.7 명시적 제어와 자동 최적화의 균형

#### 패러다임의 공존

CompletableFuture가 thenApply()와 thenApplyAsync()를 모두 제공하는 것은 **두 가지 설계 철학의 공존**을 보여준다:

- **thenApply()**: "시스템이 최적을 선택" - 신뢰 기반 자동화
- **thenApplyAsync()**: "개발자가 명시적 제어" - 예측 가능성 우선

이는 Java 생태계의 전형적인 접근법으로, 편의성과 제어권을 모두 제공하여 다양한 요구사항을 충족시킨다.

#### 아키텍처적 의의

thenApplyAsync()의 존재는 CompletableFuture가 단순한 비동기 유틸리티가 아니라 **복잡한 비동기 아키텍처를 구현하는 도구**임을 보여준다. 마이크로서비스 간 비동기 통신, 리액티브 스트림 처리, CQRS 패턴 구현 등에서 명시적 스레드 제어는 필수적이다.

#### 설계적 책임

개발자는 thenApplyAsync() 사용 시 다음을 고려해야 한다:

**정당한 사용 사례인지 검증**: CPU 집약적 작업, 스레드 격리 필요성, 특정 Executor 사용 등 명확한 이유가 있어야 한다.

**성능 영향 측정**: 컨텍스트 스위칭 오버헤드가 실제 작업보다 클 수 있음을 인지하고, 프로파일링을 통해 검증해야 한다.

**스레드 풀 관리**: 기본 commonPool() 대신 작업 특성에 맞는 커스텀 Executor 사용을 고려해야 한다.

---

## 8. thenAccept()의 부수 효과 실행 메커니즘

### 8.1 왜 thenAccept()라는 별도 메서드가 필요한가

#### 값 변환과 부수 효과의 본질적 차이

CompletableFuture의 체인 구성에서 모든 작업이 새로운 값을 생성하는 것은 아니다. 로깅, 캐싱, 메트릭 수집, 알림 전송 등 **결과를 소비하되 새로운 값을 반환하지 않는 작업**이 필연적으로 존재한다. thenApply()가 Function<T, R>을 받아 값을 변환하는 반면, thenAccept()는 Consumer<T>를 받아 **부수 효과(side effect)만 수행**한다.

이 구분은 단순한 API 편의성이 아니라, **함수형 프로그래밍의 순수 함수와 부수 효과의 명확한 분리**를 반영한다. 값 변환과 부수 효과는 시스템 설계에서 서로 다른 관심사를 다루며, 이를 타입 시스템 수준에서 구분함으로써 코드의 의도를 명확히 전달할 수 있다.

```java
// thenApply: 값 변환 - 새로운 값 생성
CompletableFuture<Integer> scoreFuture = addressFuture
    .thenApply(address -> calculateScore(address));  // Integer 반환

// thenAccept: 부수 효과 - 반환값 없음
CompletableFuture<Void> loggingFuture = addressFuture
    .thenAccept(address -> {
        logger.info("Address: {}", address);
        cache.put(cacheKey, address);
        metrics.recordApiCall("address", address.getResponseTime());
    });  // void, CompletableFuture<Void> 반환
```

#### 파이프라인 종료와 체인 분기의 표현

thenAccept()는 종종 **비동기 파이프라인의 종료 지점**을 나타낸다. 더 이상 값을 전파할 필요가 없을 때, 최종 결과를 소비하고 체인을 종료하는 명시적인 방법을 제공한다. 또한 하나의 결과를 여러 Consumer에게 분기시켜 독립적인 부수 효과를 병렬로 수행할 수 있다.

### 8.2 UniAccept 노드와 내부 실행 구조

thenAccept()가 호출되면 CompletableFuture는 내부적으로 **UniAccept** 노드를 생성한다. 이는 thenApply()의 UniApply와 구조적으로 유사하지만, 반환 타입이 Void라는 결정적 차이를 갖는다.

```java
// CompletableFuture 내부 구조 (간략화)
static final class UniAccept<T> extends UniCompletion<T,Void> {
    Consumer<? super T> fn;
    
    CompletableFuture<Void> tryFire(int mode) {
        // 입력 Future의 결과를 읽어 Consumer 실행
        T input = dep.result;
        fn.accept(input);
        
        // 출력 Future를 null로 완료 (Void 타입)
        d.completeNull();
        return d;
    }
}
```

핵심은 Consumer가 값을 소비한 후 **다음 CompletableFuture를 null로 완료**한다는 점이다. 이는 "작업이 완료되었지만 전달할 값이 없음"을 타입 안전하게 표현한다.

### 8.3 실행 주체 결정: thenApply()와 동일한 적응적 전략

thenAccept()는 thenApply()와 **완전히 동일한 Fast Path/Slow Path 메커니즘**을 사용한다. 값을 변환하는가, 부수 효과를 수행하는가의 차이만 있을 뿐, 스레드 할당 전략은 동일하다.

#### Fast Path(빠른 경로): 이미 완료된 경우

```java
CompletableFuture<Address> addressFuture = CompletableFuture
    .completedFuture(address);  // 이미 완료됨

addressFuture.thenAccept(addr -> {
    System.out.println("Thread: " + Thread.currentThread().getName());
    // 출력: "main" - 호출자 스레드가 직접 실행
    logger.info("Address: {}", addr);
});
```

원본 CompletableFuture가 이미 완료된 상태라면, thenAccept()를 호출한 스레드(주로 main)가 즉시 Consumer를 실행한다. 이는 불필요한 스레드 전환을 방지하는 최적화다.

#### Slow Path(느린 경로): 아직 완료되지 않은 경우

```java
CompletableFuture<Address> addressFuture = CompletableFuture
    .supplyAsync(() -> {
        Thread.sleep(1000);  // 워커 스레드에서 실행 중
        return fetchAddress();
    });

addressFuture.thenAccept(addr -> {
    System.out.println("Thread: " + Thread.currentThread().getName());
    // 출력: "ForkJoinPool.commonPool-worker-1" - 워커 스레드가 실행
    logger.info("Address: {}", addr);
});
```

원본 작업이 아직 실행 중이라면, UniAccept 노드만 completion stack에 등록되고 호출자 스레드는 즉시 반환된다. 나중에 워커 스레드가 원본 작업을 완료하면서 Consumer를 실행한다.

### 8.4 thenAccept vs thenAcceptAsync: 부수 효과의 스레드 격리

#### thenAcceptAsync의 명시적 비동기 실행

thenAccept()의 적응적 실행이 대부분의 경우 최적이지만, **부수 효과가 블로킹 I/O를 포함하거나 CPU 집약적일 때**는 명시적으로 다른 스레드로 분리해야 한다.

```java
// 안티패턴: 블로킹 I/O를 thenAccept로 처리
addressFuture.thenAccept(address -> {
    // 워커 스레드가 블로킹됨 → 풀의 다른 작업 지연
    saveToDatabase(address);  // 100ms 블로킹
});

// 올바른 패턴: 블로킹 I/O는 별도 스레드로 분리
ExecutorService dbExecutor = Executors.newFixedThreadPool(10);

addressFuture.thenAcceptAsync(address -> {
    saveToDatabase(address);  // DB 전용 스레드에서 실행
}, dbExecutor);
```

#### 부수 효과의 병렬 실행

하나의 결과를 여러 Consumer에게 독립적으로 전달할 때, thenAcceptAsync()를 사용하면 각 부수 효과가 병렬로 실행된다.

```java
CompletableFuture<ApiResponse> responseFuture = CompletableFuture
    .supplyAsync(() -> callExternalApi(), ioExecutor);

// 3개의 독립적인 부수 효과를 병렬 실행
CompletableFuture<Void> logging = responseFuture.thenAcceptAsync(
    response -> logger.info("Response: {}", response),
    loggingExecutor
);

CompletableFuture<Void> caching = responseFuture.thenAcceptAsync(
    response -> cache.put(key, response),
    cacheExecutor
);

CompletableFuture<Void> metrics = responseFuture.thenAcceptAsync(
    response -> metricsCollector.record(response),
    metricsExecutor
);

// 모든 부수 효과 완료 대기
CompletableFuture.allOf(logging, caching, metrics).join();
```

### 8.5 실무 적용: 부수 효과의 구조화된 관리

#### 로깅과 모니터링 파이프라인

```java
CompletableFuture
    .supplyAsync(() -> processTransaction(tx), txExecutor)
    .thenApply(result -> enrichWithMetadata(result))
    .thenAccept(enriched -> {
        // 성공한 트랜잭션 로깅
        auditLogger.log(enriched);
        metricsCollector.recordSuccess(enriched.getDuration());
    })
    .exceptionally(ex -> {
        // 실패한 트랜잭션 로깅
        errorLogger.log(tx, ex);
        metricsCollector.recordFailure();
        return null;
    });
```

#### 캐시 워밍과 사전 계산

```java
// 백그라운드에서 캐시 갱신
CompletableFuture
    .supplyAsync(() -> fetchLatestData(), ioExecutor)
    .thenApply(data -> preprocess(data))
    .thenAcceptAsync(processed -> {
        // 캐시 갱신은 메인 로직과 독립
        cache.refresh(processed);
        logger.info("Cache refreshed with {} items", processed.size());
    }, cacheExecutor);
```

#### 알림 전송과 이벤트 발행

```java
orderFuture
    .thenApply(order -> validateOrder(order))
    .thenApply(validated -> saveOrder(validated))
    .thenAcceptAsync(saved -> {
        // 주문 저장 후 비동기 알림
        emailService.sendConfirmation(saved.getCustomerEmail());
        smsService.sendNotification(saved.getCustomerPhone());
        eventBus.publish(new OrderCreatedEvent(saved));
    }, notificationExecutor);
```

### 8.6 아키텍처적 의의: 부수 효과의 명시적 분리

#### 순수 함수와 부수 효과의 계층 분리

thenAccept()의 존재는 CompletableFuture가 **함수형 아키텍처의 원칙을 비동기 영역으로 확장**한다는 것을 보여준다. 값 변환 로직(thenApply)과 부수 효과(thenAccept)를 타입 수준에서 분리함으로써, 다음을 달성한다:

- **테스트 가능성 향상**: 순수 변환 로직은 부수 효과 없이 단위 테스트 가능
- **관심사의 분리**: 비즈니스 로직과 인프라 로직(로깅, 캐싱)의 명확한 경계
- **체인 가독성**: 어떤 단계가 값을 생성하고, 어떤 단계가 소비만 하는지 명확

#### CQRS 패턴의 자연스러운 구현

Command와 Query를 분리하는 CQRS 패턴에서, thenAccept()는 Command의 부수 효과를 처리하는 자연스러운 지점이 된다.

```java
// Command: 상태 변경
CompletableFuture<OrderId> commandFuture = CompletableFuture
    .supplyAsync(() -> createOrder(request), commandExecutor)
    .thenApply(order -> order.getId());

// Side effects: 이벤트 발행, 로깅
commandFuture.thenAccept(orderId -> {
    eventStore.append(new OrderCreatedEvent(orderId));
    auditLog.record("Order created: " + orderId);
});

// Query: 조회 (독립적)
CompletableFuture<OrderView> queryFuture = commandFuture
    .thenCompose(orderId -> queryService.getOrderView(orderId));
```

### 8.7 성능 고려사항과 안티패턴

#### 안티패턴 1: 무거운 부수 효과를 thenAccept로 처리

```java
// 잘못된 예: CPU 집약적 작업
addressFuture.thenAccept(address -> {
    // 이미지 처리 같은 무거운 작업 → 워커 스레드 블로킹
    BufferedImage map = generateMap(address.getLatLon());  // 500ms
    saveMapToFile(map);
});

// 올바른 예: 별도 스레드 풀 사용
addressFuture.thenAcceptAsync(address -> {
    BufferedImage map = generateMap(address.getLatLon());
    saveMapToFile(map);
}, cpuExecutor);
```

#### 안티패턴 2: 동기 블로킹 I/O

```java
// 잘못된 예: 동기 DB 쓰기
resultFuture.thenAccept(result -> {
    jdbcTemplate.update("INSERT INTO ...", result);  // 블로킹
});

// 올바른 예: 비동기 DB 또는 별도 Executor
resultFuture.thenAcceptAsync(result -> {
    jdbcTemplate.update("INSERT INTO ...", result);
}, dbExecutor);
```

#### 최적 패턴: 빠른 부수 효과는 thenAccept 활용

```java
// 최적: 메모리 내 빠른 작업
resultFuture.thenAccept(result -> {
    cache.putIfAbsent(key, result);  // ~1μs
    metricsCollector.increment("success");  // ~1μs
    // Fast Path 최적화 활용 - 스레드 전환 비용 절약
});
```

### 8.8 설계적 책임과 선택 기준

개발자는 thenAccept() 사용 시 다음을 고려해야 한다:

**부수 효과의 무게 평가**: 작업이 1ms 이하로 빠르다면 thenAccept()로 Fast Path 최적화 활용. 10ms 이상이거나 블로킹을 포함한다면 thenAcceptAsync() 사용.

**실패 처리 전략**: 부수 효과가 실패해도 전체 체인이 실패하지 않도록 exceptionally()나 handle()로 보호.

**독립성 보장**: 여러 부수 효과가 서로 의존하지 않는다면, thenAcceptAsync()로 병렬 실행하여 처리량 향상.

**타입 안전성 활용**: CompletableFuture<Void>는 "값이 없음"을 명시적으로 표현하므로, 실수로 결과를 사용하려는 시도를 컴파일 타임에 방지.

---

## 9. 조합 메소드: 복잡한 의존성 그래프의 표현

### 9.1 thenCombine: 두 독립 작업의 결과 병합

`thenCombine()`은 **두 개의 독립적인 CompletableFuture가 모두 완료되면 그 결과를 병합**한다. 이는 Fork-Join 패턴의 Join 단계를 표현한다.

```java
CompletableFuture<Address> addressFuture = CompletableFuture.supplyAsync(() -> 
    getAddress(lat, lon), ioExecutor
);

CompletableFuture<List<Amenity>> amenityFuture = CompletableFuture.supplyAsync(() -> 
    getAmenities(lat, lon), ioExecutor
);

// 두 결과를 병합하여 새로운 값 생성
CompletableFuture<LocationAnalysis> analysisFuture = addressFuture
    .thenCombine(amenityFuture, (address, amenities) -> {
        return LocationAnalysis.builder()
            .address(address.getFullAddress())
            .convenienceScore(calculateScore(amenities))
            .build();
    });
```

`thenCombine()`의 핵심 가치는 **병렬 실행의 이점을 유지하면서도 결과를 안전하게 조합**할 수 있다는 점이다. 두 작업 중 느린 쪽이 완료될 때까지 기다리지만, 빠른 쪽의 결과는 이미 메모리에 저장되어 있어 즉시 병합 함수가 실행된다.

### 9.2 allOf: N개 작업의 완료 대기

`allOf()`는 **모든 CompletableFuture가 완료될 때까지 대기**한다. 반환 타입이 `CompletableFuture<Void>`인 이유는 각 Future의 타입이 다를 수 있기 때문이다.

```java
// 15개 카테고리별 검색
List<CompletableFuture<CategoryResult>> categoryFutures = categories.stream()
    .map(category -> CompletableFuture.supplyAsync(() -> 
        searchCategory(lat, lon, category), ioExecutor
    ))
    .collect(Collectors.toList());

// 모두 완료 대기
CompletableFuture<Void> allDone = CompletableFuture.allOf(
    categoryFutures.toArray(new CompletableFuture[0])
);

// 완료 후 결과 수집
CompletableFuture<Map<String, CategoryResult>> resultMap = allDone
    .thenApply(v -> categoryFutures.stream()
        .collect(Collectors.toMap(
            f -> f.join().getCategory(),  // 이미 완료되어 즉시 반환
            f -> f.join()
        ))
    );
```

`allOf()`가 AtomicInteger 카운터로 구현된 이유는 **lock-free 방식으로 동시 완료를 추적**하기 위함이다. 각 작업이 완료될 때마다 카운터를 감소시키고, 0이 되면 `allOf()`가 완료된다. 이는 CountDownLatch보다 가볍고 비블로킹이다.

### 9.3 anyOf: 경쟁을 통한 최적화

`anyOf()`는 **가장 먼저 완료되는 CompletableFuture의 결과를 반환**한다. 이는 여러 대안 중 가장 빠른 것을 선택하는 패턴에 유용하다.

```java
// 여러 지오코딩 서비스를 경쟁시킴
CompletableFuture<Address> kakaoFuture = CompletableFuture.supplyAsync(() -> 
    kakaoGeocode(lat, lon), ioExecutor
);

CompletableFuture<Address> naverFuture = CompletableFuture.supplyAsync(() -> 
    naverGeocode(lat, lon), ioExecutor
);

CompletableFuture<Address> googleFuture = CompletableFuture.supplyAsync(() -> 
    googleGeocode(lat, lon), ioExecutor
);

// 가장 빠른 응답 사용
CompletableFuture<Object> firstResponse = CompletableFuture.anyOf(
    kakaoFuture, naverFuture, googleFuture
);

Address fastest = (Address) firstResponse.join();
```

이 패턴은 **레이턴시 최적화**에 효과적이다. 특히 네트워크 상태가 불안정하거나 서비스별 응답 시간이 크게 다를 때, 사용자 경험을 개선할 수 있다.

---

## 10. 예외 처리 메소드: 실패의 우아한 관리

### 10.1 exceptionally: 예외를 폴백 값으로 변환

`exceptionally()`는 **예외가 발생했을 때만 실행되는 복구 함수**를 등록한다. 이는 try-catch의 catch 블록과 유사하지만, 비동기 체인에서 작동한다는 점이 다르다.

```java
CompletableFuture<Crime> crimeFuture = CompletableFuture
    .supplyAsync(() -> {
        // DB 조회 중 예외 가능
        return crimeRepository.findByGu(gu)
            .orElseThrow(() -> new DataNotFoundException("No crime data for " + gu));
    }, dbExecutor)
    .exceptionally(ex -> {
        logger.warn("Crime data fetch failed: {}", ex.getMessage());
        
        // 기본값 반환 (폴백)
        return Crime.builder()
            .gu(gu)
            .rate(0.5)  // 전국 평균
            .level("MEDIUM")
            .build();
    });
```

`exceptionally()`의 설계 철학은 **예외를 정상 값으로 변환하여 체인을 계속 진행**시키는 것이다. 이후 체인은 예외가 발생했는지 모른 채 정상적으로 진행된다. Wherehouse R-04에서는 일부 API 실패가 전체 서비스를 중단시키지 않도록 각 API 호출마다 폴백을 설정한다.

### 10.2 handle: 성공과 실패를 통합 처리

`handle()`은 **정상 결과와 예외를 모두 받아 새로운 값을 생성**한다. 이는 finally 블록과 catch 블록의 조합과 유사하다.

```java
CompletableFuture<ApiResponse> responseFuture = CompletableFuture
    .supplyAsync(() -> callExternalApi(request), ioExecutor)
    .handle((result, ex) -> {
        long duration = System.currentTimeMillis() - startTime;
        
        if (ex != null) {
            metricsCollector.recordFailure(apiName, duration, ex);
            return ApiResponse.failed(ex.getMessage());
        } else {
            metricsCollector.recordSuccess(apiName, duration);
            return ApiResponse.success(result);
        }
    });
```

`handle()`이 `exceptionally()`보다 강력한 이유는 **성공 경로와 실패 경로를 하나의 지점에서 통합 관리**할 수 있기 때문이다. 메트릭 수집, 로깅, 응답 래핑 등 양쪽 경로에서 공통으로 수행해야 할 작업이 있을 때 유용하다.

### 10.3 whenComplete: 부수 효과만 수행하는 완료 처리

`whenComplete()`는 **예외를 소비하지 않고 전파**한다. 이는 로깅이나 리소스 정리 같은 부수 효과를 수행하되, 체인의 결과는 변경하지 않을 때 사용한다.

```java
CompletableFuture<Connection> connectionFuture = CompletableFuture
    .supplyAsync(() -> dataSource.getConnection(), dbExecutor)
    .whenComplete((conn, ex) -> {
        if (ex != null) {
            logger.error("Connection acquisition failed", ex);
            alertService.sendAlert("DB connection pool exhausted");
        } else {
            logger.debug("Connection acquired: {}", conn.getMetaData());
            connectionMonitor.recordAcquisition();
        }
        // 예외는 그대로 전파됨
    });
```

`whenComplete()`의 핵심은 **관찰만 하고 개입하지 않는다**는 것이다. 체인의 성공/실패 상태를 변경하지 않으므로, 모니터링이나 감사(audit) 목적으로 적합하다.

---

## 11. 블로킹 메소드: 비동기를 동기로 변환

### 11.1 join vs get: 예외 처리 방식의 차이

`join()`과 `get()`은 모두 **CompletableFuture가 완료될 때까지 현재 스레드를 블로킹**한다. 차이는 예외 처리 방식에 있다.

```java
// join(): unchecked exception (CompletionException)
try {
    String result = future.join();  // CompletionException 가능
} catch (CompletionException e) {
    Throwable cause = e.getCause();  // 실제 예외 추출
}

// get(): checked exception (ExecutionException)
try {
    String result = future.get();  // ExecutionException, InterruptedException
} catch (ExecutionException e) {
    Throwable cause = e.getCause();
} catch (InterruptedException e) {
    Thread.currentThread().interrupt();  // 인터럽트 상태 복원
}
```

`join()`이 더 자주 사용되는 이유:
1. **람다 표현식에서 사용 가능** (checked exception이 없음)
2. **스트림 API와 호환** (`.map(CompletableFuture::join)` 가능)
3. **간결한 코드** (InterruptedException 처리 불필요)

`get()`을 사용해야 하는 경우:
1. **타임아웃 필요**: `get(timeout, unit)`
2. **인터럽트 처리 필요**: 스레드 풀 종료 시나리오
3. **레거시 코드 호환**: Future 인터페이스와의 일관성

### 11.2 get(timeout): 무한 대기 방지 및 cancel() 동작

`get(long timeout, TimeUnit unit)`은 **지정된 시간만큼만 대기**한다. 이는 외부 API 호출이나 네트워크 작업에서 필수적이다.

```java
CompletableFuture<Address> addressFuture = CompletableFuture
    .supplyAsync(() -> kakaoApi.getAddress(lat, lon), ioExecutor);

try {
    Address address = addressFuture.get(3, TimeUnit.SECONDS);
    return address;
} catch (TimeoutException e) {
    // 3초 내 응답 없음 → 폴백
    logger.warn("Kakao API timeout for ({}, {})", lat, lon);
    addressFuture.cancel(true);  // 작업 취소 시도
    return Address.unknown();
} catch (ExecutionException | InterruptedException e) {
    // 다른 예외 처리
}
```

`cancel(true)` 호출 시의 동작:
1. **result 필드를 CAS로 예외 상태로 변경**: 다른 스레드가 이미 완료했다면 실패
2. **interrupt() 전달 시도**: `mayInterruptIfRunning=true`면 워커 스레드에 인터럽트 신호 전송
3. **이미 실행 중인 작업은 중단되지 않을 수 있음**: 인터럽트를 처리하지 않는 블로킹 I/O나 계산 작업은 계속 실행

중요한 점은 **cancel()은 best-effort(최선의 노력) 메커니즘**이라는 것이다. 작업이 이미 시작되었다면 취소를 보장하지 않는다. 따라서 타임아웃 후에도 워커 스레드가 작업을 완료할 수 있으며, 이는 리소스 누수로 이어질 수 있다. 실무에서는 ExecutorService 자체를 종료하거나, 작업 내부에서 인터럽트를 명시적으로 확인하는 패턴을 사용해야 한다.

---

## 12. 결론: CompletableFuture의 실무적 가치와 아키텍처적 의의

CompletableFuture는 Java의 비동기 프로그래밍을 근본적으로 변화시켰다. Future의 블로킹 한계를 극복하고, 선언적으로 복잡한 비동기 워크플로우를 구성할 수 있게 만들었다. Wherehouse R-04의 성능 최적화는 이러한 메커니즘을 실전에 적용한 사례다.

**핵심 설계 원칙**:
- **Completion-driven execution**: 작업 완료가 다음 작업을 트리거하는 이벤트 기반 모델
- **Composability**: 비동기 작업을 레고처럼 조립 가능한 부품으로 만듦
- **Adaptive threading**: 상황에 따라 최적의 실행 주체를 선택하는 전략 (thenApply의 Fast/Slow Path)
- **Explicit control**: 필요 시 명시적 스레드 제어 가능 (thenApplyAsync)
- **Exception propagation**: 예외가 체인을 통해 자동으로 전파되는 안전성

**실무 적용 시 주의사항**:
- 작업 특성에 맞는 커스텀 Executor 사용 (I/O vs CPU)
- thenApply()와 thenApplyAsync()의 차이를 이해하고 적절히 선택
- 예외 처리를 체인 초기에 설정하여 전체 워크플로우 보호
- 타임아웃과 cancel()로 리소스 누수 방지
- Fast Path 최적화를 활용한 성능 개선

CompletableFuture는 단순한 유틸리티가 아니라, 현대적인 비동기 아키텍처를 구현하는 핵심 도구다. Completion-driven model의 도입으로 "누가 실행하는가"에서 "언제 실행되는가"로 관심사가 전환되었으며, 이는 마이크로서비스 아키텍처와 리액티브 시스템 설계의 기반이 되었다.
