# CompletableFuture 기술 백서: 비동기 작업 조합의 설계 원리

## 1. 서론: Future 패턴의 근본적 한계

### 1.1 완료 알림 메커니즘의 부재

Future 패턴은 비동기 작업의 결과를 나타내는 추상화지만, 작업 완료 시점을 **능동적으로 알려주는 메커니즘**이 없다. 호출자는 작업이 완료되었는지 지속적으로 확인하거나(폴링), 완료될 때까지 스레드를 블로킹해야 한다. 이는 비동기 프로그래밍의 핵심 가치인 "스레드 자원의 효율적 활용"을 근본적으로 제한한다. Main 스레드가 결과를 필요로 하는 순간, 불가피하게 블로킹 상태로 전환되며, 이는 Thread-per-Request 모델의 한계를 극복하지 못한다.

### 1.2 작업 조합의 불가능성

더 심각한 문제는 **여러 비동기 작업을 조합하는 선언적 방법이 존재하지 않는다**는 점이다. "A 작업이 완료되면 그 결과로 B 작업을 시작하고, B가 완료되면 C를 실행한다"는 단순한 의존성 체인조차 명령형 코드로 수동 구현해야 한다. 각 단계마다 `get()`을 호출해 Main 스레드를 블로킹하거나, 복잡한 콜백 지옥을 직접 구현해야 한다. 이는 비동기 로직의 복잡도를 기하급수적으로 증가시킨다.

Wherehouse R-04 최적화에서 "주소 변환 완료 → 범죄율 조회 시작"이라는 의존성과 "15개 카테고리 검색이 모두 완료되면 결과 수집"이라는 조합 로직을 Future로 표현하려면, 명시적인 블로킹과 복잡한 동기화 코드가 필요하다. 이는 비동기화의 장점을 상쇄한다.

#### Future로 작업 체이닝을 시도하면

```java
ExecutorService executor = Executors.newFixedThreadPool(10);

// 1단계: 주소 변환 제출 (비동기)
Future<String> addressFuture = executor.submit(() -> getAddress(lat, lon));

// 2단계: 결과를 받기 위해 블로킹
String address = addressFuture.get();  // ← Main 스레드 블로킹 (100ms)

// 3단계: 주소로 범죄율 조회 제출
Future<Crime> crimeFuture = executor.submit(() -> getCrime(address));

// 4단계: 또 블로킹
Crime crime = crimeFuture.get();  // ← 또 블로킹 (200ms)

// 총 300ms 동안 Main 스레드가 2번 블로킹됨
```

이 코드의 문제는 Worker 스레드가 백그라운드에서 작업하는 동안 Main 스레드가 `get()`에서 블로킹되어 아무 일도 하지 못한다는 점이다. "비동기"로 시작했지만 결과를 받는 순간 "동기"로 전환된다.

#### 왜 이렇게 설계했는가: 역사적 배경

Future 패턴이 도입된 2004년(Java 5)에는 람다식이 존재하지 않았다. 콜백을 표현하려면 익명 클래스를 중첩해야 했고, 이는 코드를 극도로 복잡하게 만들었다. 설계자들은 이 문제를 인지하고 있었지만, "복잡한 콜백 지옥"보다는 "단순한 블로킹 방식"이 대부분의 개발자에게 더 이해하기 쉽다고 판단했다.

```java
// 2004년에 콜백 기반 설계를 시도하면
executor.submit(task, new Callback() {
    public void onComplete(String address) {
        executor.submit(new Task(address), new Callback() {
            public void onComplete(Crime crime) {
                // 콜백 중첩... 가독성 최악
            }
        });
    }
});
```

Doug Lea(Executor Framework 설계자)는 이 한계를 명시적으로 인정했으며, "언어 수준의 개선(람다식)이 필요하다"고 언급했다. 실제로 10년 후 Java 8(2014)에서 람다식이 도입되자 즉시 CompletableFuture가 함께 도입되었다. 이는 "설계의 문제"가 아니라 "언어 도구의 부재" 때문이었다.

### 1.3 예외 전파의 복잡성

비동기 환경에서 예외는 작업을 실행한 Worker 스레드의 스택에 갇힌다. Future는 예외를 `ExecutionException`으로 래핑하여 `get()` 시점에 던지지만, 이는 **각 Future마다 개별적으로 예외 처리**를 강제한다. "이 체인 중 어디서든 오류가 발생하면 전체 작업을 취소하고 폴백 값을 반환"과 같은 패턴을 표현할 방법이 없다.

---

## 2. CompletableFuture의 설계 철학

### 2.1 Promise 패턴의 구현

CompletableFuture는 JavaScript의 Promise, Scala의 Future와 같은 **"완료 가능한 값"** 추상화를 Java에 도입한 것이다. 핵심 아이디어는 "미래에 완료될 값"을 나타내는 객체에 **완료 시 실행할 콜백을 등록**할 수 있다는 점이다. 이는 블로킹 대기를 콜백 기반 비블로킹 처리로 전환하는 패러다임 전환이다.

전통적 Future는 "작업을 시작하고 나중에 결과를 가져온다"는 pull 모델이다. CompletableFuture는 "작업을 시작하고 완료되면 나에게 알려달라"는 push 모델이다. Main 스레드는 결과를 기다리며 블로킹되는 대신, "완료되면 이 함수를 실행해달라"는 콜백을 등록하고 다른 작업을 계속한다. 작업이 완료되면 시스템이 자동으로 콜백을 실행한다.

### 2.2 비동기 작업의 조합 가능성

Future의 가장 치명적인 문제는 **여러 비동기 작업을 조립할 방법이 없다**는 점이다. "A가 끝나면 B를 시작하고, B와 C가 모두 끝나면 D를 실행"이라는 단순한 로직도 수동으로 구현해야 한다. 각 작업마다 `get()`을 호출하며 블로킹하거나, 복잡한 콜백과 동기화 코드를 직접 작성해야 한다.

CompletableFuture는 이 문제를 **비동기 작업을 조립 가능한 부품처럼 만들어** 해결한다. 각 CompletableFuture는 독립적으로 실행되는 작업이면서, 동시에 다른 작업과 연결될 수 있는 "연결 지점"을 제공한다. 이는 레고 블록처럼 비동기 작업을 자유롭게 조립할 수 있게 만든다.

#### 조합의 세 가지 기본 패턴

**1. 순차 실행 (A 완료 → B 시작)**: `thenCompose`를 사용한다. 첫 번째 작업의 결과를 받아 두 번째 작업을 시작한다. Wherehouse의 "주소 변환 완료 → 범죄율 조회"가 이 패턴이다.

**2. 병렬 실행 후 조합 (A와 B 동시 → 둘 다 완료되면 합침)**: `thenCombine`을 사용한다. 두 작업이 독립적으로 실행되고, 둘 다 완료되면 결과를 합친다.

**3. 다중 작업 대기 (여러 작업 모두 완료 대기)**: `allOf`를 사용한다. 15개 카테고리 검색처럼 독립적인 작업들을 모두 실행하고, 전부 완료될 때까지 대기한다.

#### 안전한 조합의 의미

이러한 조합 메커니즘은 단순히 "코드를 짧게 만드는 편의 기능"이 아니다. 각 단계가 명확히 분리되어 있고, 예외가 발생하면 체인 전체로 자동 전파되며, 중간 단계를 건너뛰고 예외 처리 로직으로 이동한다. 수동으로 try-catch를 중첩하거나 플래그 변수로 상태를 추적할 필요가 없다.

또한 각 단계는 독립적으로 테스트 가능하며, 새로운 단계를 추가하거나 순서를 변경할 때 다른 부분을 수정하지 않아도 된다. 이는 복잡한 비동기 로직을 안전하게 구성할 수 있는 아키텍처 수준의 개선이다.

### 2.3 ExecutorService와의 역할 분리

CompletableFuture와 ExecutorService는 **완전히 다른 책임**을 가진 별개의 컴포넌트다. 이 둘은 상속 관계가 아니라 **협력 관계**다.

#### 각자의 역할

**ExecutorService (ThreadPoolExecutor)의 역할:**
- Worker 스레드 생성 및 관리
- 작업 큐에서 작업을 꺼내 스레드에 배정
- 스레드 라이프사이클 제어 (생성, 재사용, 종료)

**CompletableFuture의 역할:**
- 비동기 작업의 결과를 담는 컨테이너
- "완료되면 실행할 콜백" 목록 관리
- 콜백 체인 자동 실행

#### 실제 협력 방식

CompletableFuture는 ExecutorService를 **도구로 사용**한다:

```java
// 1. 커스텀 Executor 생성 (스레드 풀)
ExecutorService ioExecutor = Executors.newFixedThreadPool(20);

// 2. CompletableFuture가 이 Executor를 사용
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    return getData();  // ← ioExecutor의 Worker 스레드가 실행
}, ioExecutor);

// 내부 동작:
// - CompletableFuture: "이 작업을 실행해줘" → ioExecutor에게 전달
// - ioExecutor: Worker 스레드에 작업 배정
// - Worker 스레드: 작업 실행 완료
// - CompletableFuture: 결과 받아서 저장 + 콜백 실행
```

**비유**: ExecutorService는 "배달 회사", CompletableFuture는 "주문서 + 알림 시스템"이다. 주문서가 배달 회사에게 "이거 배달해줘"라고 요청하고, 배달 완료되면 자동으로 알림을 실행한다.

#### 왜 커스텀 Executor가 필요한가

CompletableFuture는 기본적으로 `ForkJoinPool.commonPool()`을 사용한다. 이 풀은 `Runtime.getRuntime().availableProcessors() - 1`개의 스레드를 생성한다 (예: 8코어 CPU → 7개 스레드). Main 스레드를 제외한 나머지 코어를 활용하는 설계다. 이는 CPU-bound 작업(계산 위주)에는 적합하지만, I/O-bound 작업(네트워크 대기)에는 부족하다.

Wherehouse R-04는 최대 17개의 동시 API 호출이 필요하다 (주소 1 + 카테고리 15 + 범죄율 1). 그런데 commonPool이 7개 스레드만 제공하면, 나머지 10개 작업은 큐에서 대기하며 순차 실행된다. 이는 병렬도를 떨어뜨려 성능 개선 효과를 반감시킨다.

따라서 I/O 작업에서는 **충분한 수의 스레드를 가진 커스텀 Executor**를 명시적으로 지정해야 한다:

```java
// I/O 작업용: 20개 스레드
ExecutorService ioExecutor = Executors.newFixedThreadPool(20);

CompletableFuture.supplyAsync(() -> apiCall(), ioExecutor);
```

이렇게 하면 CompletableFuture의 "콜백 자동 실행 메커니즘"과 ThreadPoolExecutor의 "스레드 풀 관리"를 모두 활용할 수 있다.

---

## 3. CompletableFuture의 내부 구조와 동작 원리



---

## 4. 실행 모델의 이해

### 4.1 ForkJoinPool vs ThreadPoolExecutor

CompletableFuture는 기본적으로 ForkJoinPool.commonPool을 사용한다. 이는 work-stealing 알고리즘으로 CPU-bound 작업의 부하 분산에 최적화된 풀이다. `Runtime.getRuntime().availableProcessors() - 1`개의 스레드를 생성하며 (예: 8코어 → 7개 스레드), 각 스레드는 자신의 작업 큐를 가지고, 큐가 비면 다른 스레드의 큐에서 작업을 훔쳐온다.

하지만 Wherehouse R-04처럼 네트워크 I/O 대기가 주된 작업에서는, 스레드가 WAITING 상태로 대부분의 시간을 보내므로 work-stealing의 이점이 없다. 오히려 CPU 코어 수(예: 7개)보다 훨씬 많은 수(예: 20개)의 스레드가 필요하다. 

스레드 풀 크기는 동시에 처리해야 할 I/O 작업 수를 기준으로 결정된다. Wherehouse R-04는 최대 17개의 동시 API 호출(주소 1 + 카테고리 15 + 범죄율 1)이 발생할 수 있으므로, 최소 17개 이상의 스레드가 필요하다. 일반적으로 여유를 두어 20~30개 정도로 설정한다.

따라서 I/O-bound 작업에서는 `Executors.newFixedThreadPool(N)`으로 생성한 커스텀 ExecutorService를 `supplyAsync`의 두 번째 인자로 명시해야 한다. 이는 CompletableFuture가 제공하는 콜백 체인 메커니즘과 ThreadPoolExecutor가 제공하는 스레드 관리를 조합하는 방식이다.

### 4.2 동기 vs 비동기 메소드의 선택

`thenApply`와 `thenApplyAsync`의 차이는 **어느 스레드에서 실행되는가**다. `thenApply`는 원본 작업을 완료한 Worker 스레드에서 즉시 실행된다. 추가적인 스레드 전환(context switching)이 없으므로 오버헤드가 적지만, 해당 Worker는 `thenApply` 작업이 끝날 때까지 다른 작업을 처리할 수 없다.

`thenApplyAsync`는 새로운 스레드에 작업을 제출한다. Worker 스레드는 즉시 다음 작업을 처리할 수 있지만, 스레드 전환 비용이 발생한다.

**선택 기준:**
- **CPU-bound 작업** (필터링, 계산): `thenApply` 사용 - 스레드 전환 비용 절약
- **I/O-bound 작업** (API 호출, DB 조회): 이미 `supplyAsync`에서 별도 스레드 사용 중이므로 후속 처리는 `thenApply`로 충분
- **작업 분리가 필요한 경우**: `thenApplyAsync` 사용 - 작업 간 격리 필요 시

Wherehouse R-04에서는 API 호출은 `supplyAsync(..., ioExecutor)`, 결과 필터링이나 점수 계산 같은 CPU 작업은 `thenApply`를 사용하는 것이 적절하다. 이는 불필요한 스레드 전환을 줄이면서도 I/O 대기 시 스레드가 블로킹되지 않도록 보장한다.

### 4.3 예외 처리 전략

CompletableFuture의 예외 처리는 체인 전체에 걸쳐 자동으로 전파된다. 중간 단계에서 예외가 발생하면, 이후의 모든 `thenApply`, `thenCompose`는 건너뛰고 `exceptionally`나 `handle`로 제어가 이동한다.

`exceptionally`는 예외를 폴백 값으로 변환한다. "데이터베이스 조회 실패 → 캐시에서 가져오기"와 같은 복구 로직을 표현한다. `handle`은 정상 결과와 예외를 모두 받아 새로운 값을 반환하므로, "성공이면 A, 실패면 B"라는 분기 로직을 표현한다. `whenComplete`는 예외를 소비하지 않고 전파하므로, 로깅이나 리소스 정리 같은 부수 효과에 사용한다.

이러한 예외 처리는 동기 코드의 try-catch와 동일한 제어 흐름을 비동기 환경에서 제공한다. 15개 카테고리 중 일부가 실패해도 나머지는 계속 진행하고, 실패한 것만 기본값으로 대체하는 복잡한 로직을 선언적으로 표현할 수 있다.

---

## 5. Wherehouse R-04 적용 전략

### 5.1 의존성 그래프 분석

현재 Wherehouse R-04는 다음과 같은 의존성 구조를 가진다:

1. **주소 변환** (100ms) - 독립 작업, 즉시 시작 가능
2. **범죄율 조회** (200ms) - 주소 변환 완료 후에만 시작 가능
3. **15개 카테고리 검색** (각 150ms) - 독립 작업들, 병렬 실행 가능

Future로는 이를 "주소 변환 `get()` → 범죄율 제출 → 15개 제출 → 15개 `get()` 순회"로 구현해야 하며, 각 `get()` 시점에 Main이 블로킹된다. CompletableFuture로는 이를 비블로킹 체인으로 표현할 수 있다.

주소 변환을 `supplyAsync`로 시작하고, `thenCompose`로 범죄율 조회를 연결한다. 이는 주소 변환 완료 시 자동으로 범죄율 조회를 시작하며, Main 스레드는 개입하지 않는다. 15개 카테고리는 각각 `supplyAsync`로 시작하고, `allOf`로 모두 완료를 대기한다.

### 5.2 Thread Pool 크기 결정

I/O-bound 작업의 최적 스레드 수는 대략 "동시 I/O 요청 수 × 2" 정도다. Wherehouse R-04는 최대 17개 동시 요청(주소 1 + 카테고리 15 + 범죄율 1)이 발생할 수 있으므로, 20~30개 정도의 스레드가 적절하다.

너무 적으면 일부 작업이 큐에서 대기하며 병렬도가 떨어진다. 너무 많으면 context switching 비용과 메모리 사용량이 증가한다. JMeter로 부하 테스트를 하며 스레드 수를 조정하고, VisualVM으로 스레드 상태(WAITING 비율)를 모니터링하여 최적값을 찾아야 한다.

### 5.3 성능 개선 예상치

순차 실행 시간은 100(주소) + 150×15(카테고리) + 200(범죄율) = 2,550ms다. CompletableFuture로 병렬화하면 이론적으로 max(100, 150, 100+200) = 300ms까지 단축 가능하다. 실제로는 스레드 전환 비용, 네트워크 지터, 카카오 API Rate Limit 등으로 350~400ms 정도가 예상된다.

---

## 6. supplyAsync() 메서드의 내부 실행 메커니즘

### 6.1 AsyncSupply 객체의 생명주기

`supplyAsync()`는 단순히 "작업을 비동기로 실행한다"는 추상적 개념이 아니라, 정확한 3단계 실행 메커니즘을 가진다. 이 과정의 핵심은 **AsyncSupply라는 특수한 Runnable 구현체**다.

메서드 호출 시점에서 즉시 새로운 CompletableFuture 객체가 생성되며, 이와 동시에 AsyncSupply 객체가 생성되어 Executor의 작업 큐에 삽입된다. 중요한 점은 **메인 스레드가 이 시점에서 즉시 반환받는다**는 것이다. 실제 람다 실행은 워커 스레드가 큐에서 AsyncSupply를 꺼낼 때 비로소 시작된다.

AsyncSupply는 두 가지 핵심 참조를 보유한다: 실행할 Supplier 람다와 완료시킬 CompletableFuture. 워커 스레드가 `run()` 메서드를 실행하면, 람다를 호출하여 결과를 얻고, 이를 CompletableFuture의 result 필드에 CAS 연산으로 저장한 후, `postComplete()`를 호출하여 등록된 모든 콜백을 트리거한다.

이 설계가 Wherehouse R-04에 주는 시사점은 명확하다. 15개 카테고리 API 호출을 `supplyAsync()`로 제출하면, 15개의 AsyncSupply 객체가 즉시 생성되어 큐에 들어가고, 메인 스레드는 블로킹 없이 다음 로직을 진행할 수 있다. 각 워커 스레드는 독립적으로 API 호출을 수행하며, **람다 내부의 네트워크 I/O가 워커 스레드를 블로킹한다**는 사실이 커스텀 Executor가 필요한 근본 이유다.

### 6.2 CAS 기반 완료 메커니즘의 설계 근거

CompletableFuture의 `completeValue()` 메서드는 VarHandle을 통한 Compare-And-Swap 연산을 사용한다. 이는 단순한 동기화 기법이 아니라, **경쟁 상태에서도 정확히 한 번만 완료를 보장**하는 메커니즘이다.

```
RESULT.compareAndSet(this, null, value)
```

이 연산이 원자적으로 수행하는 작업:
1. result 필드가 null인지 확인
2. null이면 value로 교체
3. 성공 여부 반환

여러 스레드가 동시에 `complete()`를 호출해도, CAS의 원자성으로 인해 정확히 하나의 스레드만 성공한다. 실패한 스레드들은 false를 반환받고 조용히 종료된다. 이는 명시적 락이나 synchronized 블록 없이도 스레드 안전성을 보장하는 lock-free 알고리즘의 전형이다.

Wherehouse R-04에서 이는 특히 중요하다. 15개 카테고리 검색 중 일부가 타임아웃으로 인해 동시에 완료를 시도하거나, 예외 처리 로직과 정상 완료가 경쟁하는 상황에서도 데이터 일관성이 보장된다. 이러한 저수준 보장이 없다면, 개발자가 직접 복잡한 동기화 로직을 구현해야 했을 것이다.

### 6.3 volatile 필드의 메모리 가시성 보장

CompletableFuture의 `result`와 `stack` 필드가 volatile로 선언된 것은 **캐시 일관성 문제를 해결**하기 위함이다. 현대 CPU는 성능 최적화를 위해 각자의 캐시를 가지며, 한 코어에서 변경한 값이 다른 코어에 즉시 반영되지 않을 수 있다.

#### volatile 키워드의 동작 원리

**문서 내용**: volatile 키워드가 "CPU 캐시를 거치지 않고 메인 메모리에 직접 기록"하고 "CPU 캐시를 무시하고 메인 메모리에서 최신 값 읽기"를 보장한다고 설명한다.

**정정/보완**: 이는 volatile의 효과를 설명하기 위한 일반적인 비유이지만, 실제 하드웨어 동작과는 다소 차이가 있다:

- volatile은 캐시를 '우회(bypass)'하는 것이 아니라, **캐시 일관성(cache coherence)**을 보장한다
- 쓰기(Write): volatile 변수에 값을 쓸 때, JMM(Java Memory Model)은 '쓰기 배리어(Write Barrier)'를 삽입한다. 이는 해당 스레드의 CPU 캐시에 있는 volatile 변수 값을 메인 메모리로 플러시(flush)하고, 다른 CPU 코어들이 가진 해당 값의 캐시를 무효화(invalidate)하도록 보장한다
- 읽기(Read): volatile 변수를 읽을 때, JMM은 '읽기 배리어(Read Barrier)'를 삽입한다. 이는 자신의 CPU 캐시가 무효화된 상태라면, 메인 메모리(또는 다른 CPU의 캐시)로부터 최신 값을 다시 읽어오도록 강제한다

결론적으로 정상 최신 값을 본다는 점에서 "캐시 무시"라고 표현해도 동작하지만, "캐시 일관성 보장한다"가 더 정확한 표현이다.

#### happens-before 관계

volatile은 단순히 가시성만 보장하는 것이 아니라 순서도 보장한다:
- volatile 쓰기 이전의 모든 일반 변수 쓰기가 volatile 읽기 이후에 가시적
- 이를 통해 일반 변수들의 설정이 완료된 후 volatile 플래그를 설정하는 패턴 가능

워커 스레드 A가 카카오 API 응답을 받아 `result`에 저장하면, 이 값은 즉시 메인 메모리에 반영되고 다른 CPU 캐시가 무효화된다. 이후 메인 스레드가 `join()`을 호출할 때, 최신 값을 읽는다. 이는 x86 아키텍처의 MFENCE(Memory Fence) 명령어로 구현되며, 약 10-20 CPU 사이클의 비용이 발생하지만, 네트워크 I/O의 수백만 사이클에 비하면 무시할 수 있는 수준이다.

---

## 7. 메모리 구조와 객체 생명주기

### 7.1 CompletableFuture 객체의 메모리 레이아웃

CompletableFuture 객체 하나가 JVM 힙에서 차지하는 실제 메모리는 약 40바이트다. 이는 객체 헤더(16바이트) + result 참조(8바이트) + stack 참조(8바이트) + 패딩(8바이트)으로 구성된다. 여기에 AsyncSupply 객체(32바이트)와 람다 클로저(24바이트+캡처 변수)가 추가된다.

Wherehouse R-04가 15개 카테고리를 병렬 처리하면:
- CompletableFuture 객체 17개 × 40바이트 = 680바이트
- AsyncSupply 객체 17개 × 32바이트 = 544바이트
- 람다 객체 17개 × 24바이트 = 408바이트
- **총 힙 메모리 사용**: 약 1.6KB

이는 네트워크 응답 데이터(수십 KB)에 비해 미미한 수준이다. 더 중요한 것은 **스레드 스택 메모리**다. 각 워커 스레드는 기본 1MB의 스택을 할당받으므로, 20개 스레드는 20MB의 스택 메모리를 예약한다. 이것이 무제한 스레드 생성이 위험한 이유이며, 고정 크기 스레드 풀을 사용해야 하는 근거다.

### 7.2 가비지 컬렉션과 참조 관계

CompletableFuture가 완료되고 `join()`으로 결과를 추출한 후, 더 이상 참조하지 않으면 GC 대상이 된다. 하지만 **Completion Stack에 연결된 모든 객체가 함께 수거**되어야 하므로, 체인이 길수록 GC 압력이 증가한다.

특히 주의할 점은 람다가 외부 변수를 캡처할 때다. 람다가 large 객체를 참조하면, CompletableFuture가 살아있는 동안 해당 객체도 GC되지 않는다. Wherehouse R-04에서 각 API 응답을 파싱한 DTO들이 람다에 캡처되면, 모든 작업이 완료될 때까지 메모리에 유지된다.

이를 완화하려면:
- 필요한 데이터만 추출하여 작은 객체로 변환
- `thenApply()`에서 즉시 필터링하여 불필요한 데이터 제거
- 대용량 응답은 스트리밍 방식으로 처리

### 7.3 Thread-Local 메모리와 성능 영향

각 워커 스레드는 Thread-Local Storage를 가지며, 여기에는 난수 생성기, 날짜 포맷터, 커넥션 풀 등이 저장될 수 있다. CompletableFuture를 사용하면 작업이 여러 스레드에 분산되므로, **Thread-Local 초기화 비용이 스레드 수만큼 발생**한다.

예를 들어, Jackson ObjectMapper를 Thread-Local로 캐싱하면, 20개 스레드 각각에 ObjectMapper 인스턴스가 생성된다. 이는 메모리 사용량 증가와 초기화 지연을 유발한다. Wherehouse R-04에서는 ObjectMapper를 싱글톤으로 공유하되, thread-safe 설정을 확인해야 한다.

---

## 8. 실행 시점의 Thread 상태 추이

### 8.1 순차 실행 시 Thread 라이프사이클

순차 실행에서 메인 스레드의 상태 변화를 마이크로초 단위로 추적하면:

```
[0μs]      RUNNABLE - HTTP 요청 수신, 파라미터 파싱
[100μs]    RUNNABLE - 카카오 주소 API 호출 준비
[200μs]    WAITING  - 네트워크 소켓 대기 (100ms)
[100,200μs] RUNNABLE - 응답 수신, JSON 파싱
[100,300μs] WAITING  - 카테고리 API 대기 (2,250ms)
[2,350,300μs] RUNNABLE - 응답 처리
[2,350,400μs] WAITING  - 범죄율 DB 대기 (200ms)
[2,550,400μs] RUNNABLE - 최종 결과 생성
```

전체 2,550ms 중 2,549ms(99.96%)를 WAITING 상태로 소비한다. 이는 **스레드가 실제로 일하는 시간은 0.04%**에 불과함을 의미한다. Thread-per-Request 모델에서 동시 사용자 100명이면, 100개 스레드가 대부분 WAITING 상태로 메모리만 점유한다.

### 8.2 CompletableFuture 병렬 실행 시 Thread 오케스트레이션

병렬 실행에서는 여러 워커 스레드가 협업한다:

```
Main Thread:
[0μs]      RUNNABLE - supplyAsync 17개 제출
[100μs]    RUNNABLE - 다른 비즈니스 로직 처리 가능
[1,000μs]  RUNNABLE - allOf().join() 호출
[1,001μs]  WAITING  - 모든 작업 완료 대기
[300,000μs] RUNNABLE - 결과 수집

Worker-1: 주소 변환
[50μs]     RUNNABLE - 큐에서 작업 획득
[150μs]    WAITING  - 카카오 API 대기 (100ms)
[100,150μs] RUNNABLE - 응답 처리, completeValue() 호출

Worker-2~16: 카테고리 검색
[각 50μs]   RUNNABLE - 큐에서 작업 획득
[각 150μs]  WAITING  - API 대기 (150ms)
[각 150,150μs] RUNNABLE - 응답 처리

Worker-17: 범죄율 조회 (주소 완료 후)
[100,200μs] RUNNABLE - Completion 트리거로 시작
[100,300μs] WAITING  - DB 대기 (200ms)
[300,300μs] RUNNABLE - 완료
```

핵심은 **메인 스레드가 1ms만 블로킹**된다는 점이다. 나머지 299ms 동안 다른 요청을 처리하거나 비즈니스 로직을 수행할 수 있다. 이는 동일 하드웨어에서 처리 가능한 동시 요청 수를 극대화한다.

### 8.3 Context Switch 비용의 정량적 분석

스레드 상태가 RUNNABLE ↔ WAITING으로 전환될 때마다 Context Switch가 발생한다. Intel x86-64 아키텍처에서 이 비용은:
- 레지스터 저장/복원: 약 500 CPU 사이클
- TLB(Translation Lookaside Buffer) 플러시: 약 1,000 사이클
- 캐시 미스 페널티: 약 500 사이클
- **총 비용**: 약 2,000 사이클 ≈ 1μs (2GHz CPU 기준)

Wherehouse R-04에서 병렬 실행 시 약 50회의 Context Switch가 발생하므로, 총 오버헤드는 50μs다. 이는 전체 실행 시간 300ms의 0.016%로, 완전히 무시할 수 있는 수준이다. 반면 절약되는 시간은 2,250ms로, **Context Switch 비용 대비 45,000배의 이익**을 얻는다.

이러한 정량적 분석이 CompletableFuture 도입의 타당성을 뒷받침하며, "왜 Thread를 더 많이 사용해도 더 빠른가"라는 직관적 모순을 해결한다.

## 9. CompletableFuture 생성 메소드의 설계 의도

### 9.1 supplyAsync vs runAsync: 반환값의 유무가 만드는 차이

CompletableFuture는 두 가지 핵심 생성 메소드를 제공한다. `supplyAsync()`는 **값을 생산하는 작업**을, `runAsync()`는 **부수 효과만 있는 작업**을 표현한다. 이 구분은 단순한 편의가 아니라, 함수형 프로그래밍의 순수 함수와 부수 효과 함수를 명확히 분리하는 설계 철학의 반영이다.

```java
// 값을 생산하는 작업: Supplier<T> → CompletableFuture<T>
CompletableFuture<AddressDto> addressFuture = CompletableFuture.supplyAsync(() -> {
    return kakaoApiService.getAddress(lat, lon);  // 결과 반환
}, ioExecutor);

// 부수 효과만 있는 작업: Runnable → CompletableFuture<Void>
CompletableFuture<Void> loggingFuture = CompletableFuture.runAsync(() -> {
    performanceLogger.logApiCall("kakao", startTime);  // 로깅만 수행
}, loggingExecutor);
```

`supplyAsync()`가 `Supplier<T>`를 받는 이유는 **작업의 결과를 후속 체인에 전달**하기 위함이다. Wherehouse R-04에서 주소 변환 API의 결과는 범죄율 조회의 입력이 되므로, 반드시 값을 반환해야 한다. 반면 성능 로깅이나 캐시 갱신 같은 작업은 결과값이 필요 없으므로 `runAsync()`를 사용한다.

### 9.2 completedFuture: 이미 알고 있는 값의 비동기 체인 진입

때로는 이미 계산된 값을 CompletableFuture 체인에 주입해야 할 때가 있다. `completedFuture()`는 **즉시 완료된 상태의 CompletableFuture**를 생성한다.

```java
// 캐시에서 즉시 반환 가능한 경우
CompletableFuture<Crime> crimeFuture;
Crime cached = crimeCache.get(gu);

if (cached != null) {
    crimeFuture = CompletableFuture.completedFuture(cached);  // 즉시 완료
} else {
    crimeFuture = CompletableFuture.supplyAsync(() -> {
        return crimeRepository.findByGu(gu);  // DB 조회
    }, dbExecutor);
}

// 이후 체인은 캐시 히트/미스와 무관하게 동일
crimeFuture.thenApply(crime -> calculateSafetyScore(crime));
```

이 패턴의 핵심은 **동기와 비동기 경로를 통일된 인터페이스로 처리**하는 것이다. 호출자는 값이 캐시에서 왔는지 DB에서 왔는지 알 필요 없이, 동일한 CompletableFuture 체인으로 처리할 수 있다.

### 9.3 failedFuture: 예외 상태의 명시적 생성

Java 9에서 추가된 `failedFuture()`는 **이미 예외로 완료된 CompletableFuture**를 생성한다. 이는 검증 실패나 전제 조건 위반을 비동기 체인에서 우아하게 처리할 수 있게 한다.

```java
CompletableFuture<Location> validateAndConvert(double lat, double lon) {
    if (lat < -90 || lat > 90 || lon < -180 || lon > 180) {
        // 즉시 예외 상태로 완료
        return CompletableFuture.failedFuture(
            new IllegalArgumentException("Invalid coordinates")
        );
    }
    
    return CompletableFuture.supplyAsync(() -> {
        return new Location(lat, lon);
    });
}
```

이 접근법은 동기 코드의 예외 던지기와 달리, **예외도 값처럼 다룰 수 있게** 만든다. 후속 체인의 `exceptionally()`나 `handle()`이 자연스럽게 처리한다.

---

## 10. 변환 메소드: 함수형 파이프라인의 구축

### 10.1 thenApply vs thenApplyAsync: 스레드 전환의 트레이드오프

`thenApply()`는 **이전 작업을 완료한 스레드에서 즉시 실행**되고, `thenApplyAsync()`는 **새로운 스레드에 작업을 제출**한다. 이 차이는 단순한 동기/비동기의 구분이 아니라, 스레드 자원 활용의 전략적 선택이다.

```java
// thenApply: 같은 워커 스레드에서 연속 실행
CompletableFuture<Integer> scoreFuture = addressFuture
    .thenApply(address -> extractGu(address))        // Worker-1에서 실행
    .thenApply(gu -> calculateBaseScore(gu))         // 여전히 Worker-1
    .thenApply(score -> applyLocalModifier(score));  // 계속 Worker-1

// thenApplyAsync: 스레드 전환
CompletableFuture<Report> reportFuture = scoreFuture
    .thenApplyAsync(score -> {
        // CPU 집약적 PDF 생성 → 별도 스레드로 분리
        return generatePdfReport(score);
    }, cpuExecutor);
```

**선택 기준의 핵심 원칙:**

1. **가벼운 변환 작업** (필터링, 매핑, 간단한 계산): `thenApply()` 사용. Context switching 비용을 절약하고, CPU 캐시 지역성을 활용한다.

2. **무거운 작업이나 블로킹 I/O**: `thenApplyAsync()` 사용. 현재 워커 스레드를 즉시 해방시켜 다른 작업을 처리할 수 있게 한다.

3. **다른 Executor로 전환 필요**: `thenApplyAsync(fn, newExecutor)` 사용. I/O용 스레드 풀에서 CPU용 스레드 풀로 작업을 이관한다.

Wherehouse R-04에서는 API 응답 파싱과 점수 계산은 `thenApply()`로, 새로운 API 호출이나 DB 조회는 `thenApplyAsync()`로 처리한다.

### 10.2 thenAccept vs thenRun: 소비와 트리거의 차이

`thenAccept()`는 **이전 결과를 소비**하고, `thenRun()`은 **이전 작업 완료를 트리거로만 사용**한다.

```java
// thenAccept: 결과를 받아서 소비 (Consumer<T>)
addressFuture.thenAccept(address -> {
    // address를 사용하여 부수 효과 수행
    metricsCollector.recordApiResponse("address", address.getResponseTime());
    cacheManager.put(cacheKey, address);
});

// thenRun: 완료 신호만 필요 (Runnable)
allOf(futures).thenRun(() -> {
    // 모든 작업 완료 후 실행, 개별 결과는 불필요
    logger.info("All {} API calls completed", futures.length);
    performanceMonitor.recordBatchCompletion();
});
```

`thenAccept()`는 결과를 로깅하거나 캐시에 저장하는 등 **결과에 의존하는 부수 효과**에 사용된다. `thenRun()`은 단순히 "작업이 끝났다"는 사실만 중요할 때, 예를 들어 진행 표시기 업데이트나 완료 카운터 증가에 사용된다.

### 10.3 thenCompose: 중첩된 CompletableFuture의 평탄화

`thenCompose()`는 **CompletableFuture를 반환하는 함수**를 받아, 중첩을 평탄화한다. 이는 함수형 프로그래밍의 `flatMap`과 동일한 개념이다.

```java
// thenApply를 사용하면 중첩 발생
CompletableFuture<CompletableFuture<Crime>> nested = addressFuture
    .thenApply(address -> {
        String gu = extractGu(address);
        // 새로운 비동기 작업 시작 → CompletableFuture 반환
        return CompletableFuture.supplyAsync(() -> crimeService.getCrime(gu));
    });

// thenCompose를 사용하면 평탄화
CompletableFuture<Crime> flat = addressFuture
    .thenCompose(address -> {
        String gu = extractGu(address);
        return CompletableFuture.supplyAsync(() -> crimeService.getCrime(gu));
    });
```

`thenCompose()`의 존재 이유는 **연속적인 비동기 작업을 체인으로 연결**하기 위함이다. Wherehouse R-04에서 "주소 변환 → 구 추출 → 범죄율 조회"처럼 각 단계가 비동기 작업인 경우, `thenCompose()`로 자연스럽게 연결된다.

---

## 11. 조합 메소드: 복잡한 의존성 그래프의 표현

### 11.1 thenCombine: 두 독립 작업의 결과 병합

`thenCombine()`은 **두 개의 독립적인 CompletableFuture가 모두 완료되면 그 결과를 병합**한다. 이는 Fork-Join 패턴의 Join 단계를 표현한다.

```java
CompletableFuture<Address> addressFuture = CompletableFuture.supplyAsync(() -> 
    getAddress(lat, lon), ioExecutor
);

CompletableFuture<List<Amenity>> amenityFuture = CompletableFuture.supplyAsync(() -> 
    getAmenities(lat, lon), ioExecutor
);

// 두 결과를 병합하여 새로운 값 생성
CompletableFuture<LocationAnalysis> analysisFuture = addressFuture
    .thenCombine(amenityFuture, (address, amenities) -> {
        return LocationAnalysis.builder()
            .address(address.getFullAddress())
            .convenienceScore(calculateScore(amenities))
            .build();
    });
```

`thenCombine()`의 핵심 가치는 **병렬 실행의 이점을 유지하면서도 결과를 안전하게 조합**할 수 있다는 점이다. 두 작업 중 느린 쪽이 완료될 때까지 기다리지만, 빠른 쪽의 결과는 이미 메모리에 저장되어 있어 즉시 병합 함수가 실행된다.

### 11.2 allOf: N개 작업의 완료 대기

`allOf()`는 **모든 CompletableFuture가 완료될 때까지 대기**한다. 반환 타입이 `CompletableFuture<Void>`인 이유는 각 Future의 타입이 다를 수 있기 때문이다.

```java
// 15개 카테고리별 검색
List<CompletableFuture<CategoryResult>> categoryFutures = categories.stream()
    .map(category -> CompletableFuture.supplyAsync(() -> 
        searchCategory(lat, lon, category), ioExecutor
    ))
    .collect(Collectors.toList());

// 모두 완료 대기
CompletableFuture<Void> allDone = CompletableFuture.allOf(
    categoryFutures.toArray(new CompletableFuture[0])
);

// 완료 후 결과 수집
CompletableFuture<Map<String, CategoryResult>> resultMap = allDone
    .thenApply(v -> categoryFutures.stream()
        .collect(Collectors.toMap(
            f -> f.join().getCategory(),  // 이미 완료되어 즉시 반환
            f -> f.join()
        ))
    );
```

`allOf()`가 AtomicInteger 카운터로 구현된 이유는 **lock-free 방식으로 동시 완료를 추적**하기 위함이다. 각 작업이 완료될 때마다 카운터를 감소시키고, 0이 되면 `allOf()`가 완료된다. 이는 CountDownLatch보다 가볍고 비블로킹이다.

### 11.3 anyOf: 경쟁을 통한 최적화

`anyOf()`는 **가장 먼저 완료되는 CompletableFuture의 결과를 반환**한다. 이는 여러 대안 중 가장 빠른 것을 선택하는 패턴에 유용하다.

```java
// 여러 지오코딩 서비스를 경쟁시킴
CompletableFuture<Address> kakaoFuture = CompletableFuture.supplyAsync(() -> 
    kakaoGeocode(lat, lon), ioExecutor
);

CompletableFuture<Address> naverFuture = CompletableFuture.supplyAsync(() -> 
    naverGeocode(lat, lon), ioExecutor
);

CompletableFuture<Address> googleFuture = CompletableFuture.supplyAsync(() -> 
    googleGeocode(lat, lon), ioExecutor
);

// 가장 빠른 응답 사용
CompletableFuture<Object> firstResponse = CompletableFuture.anyOf(
    kakaoFuture, naverFuture, googleFuture
);

Address fastest = (Address) firstResponse.join();
```

이 패턴은 **레이턴시 최적화**에 효과적이다. 특히 네트워크 상태가 불안정하거나 서비스별 응답 시간이 크게 다를 때, 사용자 경험을 개선할 수 있다.

---

## 12. 예외 처리 메소드: 실패의 우아한 관리

### 12.1 exceptionally: 예외를 폴백 값으로 변환

`exceptionally()`는 **예외가 발생했을 때만 실행되는 복구 함수**를 등록한다. 이는 try-catch의 catch 블록과 유사하지만, 비동기 체인에서 작동한다는 점이 다르다.

```java
CompletableFuture<Crime> crimeFuture = CompletableFuture
    .supplyAsync(() -> {
        // DB 조회 중 예외 가능
        return crimeRepository.findByGu(gu)
            .orElseThrow(() -> new DataNotFoundException("No crime data for " + gu));
    }, dbExecutor)
    .exceptionally(ex -> {
        logger.warn("Crime data fetch failed: {}", ex.getMessage());
        
        // 기본값 반환 (폴백)
        return Crime.builder()
            .gu(gu)
            .rate(0.5)  // 전국 평균
            .level("MEDIUM")
            .build();
    });
```

`exceptionally()`의 설계 철학은 **예외를 정상 값으로 변환하여 체인을 계속 진행**시키는 것이다. 이후 체인은 예외가 발생했는지 모른 채 정상적으로 진행된다. Wherehouse R-04에서는 일부 API 실패가 전체 서비스를 중단시키지 않도록 각 API 호출마다 폴백을 설정한다.

### 12.2 handle: 성공과 실패를 통합 처리

`handle()`은 **정상 결과와 예외를 모두 받아 새로운 값을 생성**한다. 이는 finally 블록과 catch 블록의 조합과 유사하다.

```java
CompletableFuture<ApiResponse> responseFuture = CompletableFuture
    .supplyAsync(() -> callExternalApi(request), ioExecutor)
    .handle((result, ex) -> {
        long duration = System.currentTimeMillis() - startTime;
        
        if (ex != null) {
            metricsCollector.recordFailure(apiName, duration, ex);
            return ApiResponse.failed(ex.getMessage());
        } else {
            metricsCollector.recordSuccess(apiName, duration);
            return ApiResponse.success(result);
        }
    });
```

`handle()`이 `exceptionally()`보다 강력한 이유는 **성공 경로와 실패 경로를 하나의 지점에서 통합 관리**할 수 있기 때문이다. 메트릭 수집, 로깅, 응답 래핑 등 양쪽 경로에서 공통으로 수행해야 할 작업이 있을 때 유용하다.

### 12.3 whenComplete: 부수 효과만 수행하는 완료 처리

`whenComplete()`는 **예외를 소비하지 않고 전파**한다. 이는 로깅이나 리소스 정리 같은 부수 효과를 수행하되, 체인의 결과는 변경하지 않을 때 사용한다.

```java
CompletableFuture<Connection> connectionFuture = CompletableFuture
    .supplyAsync(() -> dataSource.getConnection(), dbExecutor)
    .whenComplete((conn, ex) -> {
        if (ex != null) {
            logger.error("Connection acquisition failed", ex);
            alertService.sendAlert("DB connection pool exhausted");
        } else {
            logger.debug("Connection acquired: {}", conn.getMetaData());
            connectionMonitor.recordAcquisition();
        }
        // 예외는 그대로 전파됨
    });
```

`whenComplete()`의 핵심은 **관찰만 하고 개입하지 않는다**는 것이다. 체인의 성공/실패 상태를 변경하지 않으므로, 모니터링이나 감사(audit) 목적으로 적합하다.

---

## 13. 블로킹 메소드: 동기 세계로의 다리

### 13.1 join vs get: 예외 처리 방식의 차이

`join()`과 `get()`은 모두 **CompletableFuture가 완료될 때까지 현재 스레드를 블로킹**한다. 차이는 예외 처리 방식에 있다.

```java
// join(): unchecked exception (CompletionException)
try {
    String result = future.join();  // CompletionException 가능
} catch (CompletionException e) {
    Throwable cause = e.getCause();  // 실제 예외 추출
}

// get(): checked exception (ExecutionException)
try {
    String result = future.get();  // ExecutionException, InterruptedException
} catch (ExecutionException e) {
    Throwable cause = e.getCause();
} catch (InterruptedException e) {
    Thread.currentThread().interrupt();  // 인터럽트 상태 복원
}
```

`join()`이 더 자주 사용되는 이유:
1. **람다 표현식에서 사용 가능** (checked exception이 없음)
2. **스트림 API와 호환** (`.map(CompletableFuture::join)` 가능)
3. **간결한 코드** (InterruptedException 처리 불필요)

`get()`을 사용해야 하는 경우:
1. **타임아웃 필요**: `get(timeout, unit)`
2. **인터럽트 처리 필요**: 스레드 풀 종료 시나리오
3. **레거시 코드 호환**: Future 인터페이스와의 일관성

### 13.2 get(timeout): 무한 대기 방지 및 cancel() 동작

`get(long timeout, TimeUnit unit)`은 **지정된 시간만큼만 대기**한다. 이는 외부 API 호출이나 네트워크 작업에서 필수적이다.

```java
CompletableFuture<Address> addressFuture = CompletableFuture
    .supplyAsync(() -> kakaoApi.getAddress(lat, lon), ioExecutor);

try {
    Address address = addressFuture.get(3, TimeUnit.SECONDS);
    return address;
} catch (TimeoutException e) {
    // 3초 내 응답 없음 → 폴백
    logger.warn("Kakao API timeout for ({}, {})", lat, lon);
    addressFuture.cancel(true);  // 작업 취소 시도
    return Address.unknown();
} catch (ExecutionException | InterruptedException e) {
    // 다른 예외 처리
}
```

#### cancel(true)의 동작 원리

**문서 내용**: `get(timeout)` 사용 예제에서 `TimeoutException` 발생 시 `addressFuture.cancel(true)`를 호출하여 작업을 취소 시도한다.

**정정/보완**: 이 코드는 올바르지만, `cancel(true)`의 한계를 명시하는 것이 중요하다:

- 이 코드는 올바르지만, `cancel(true)`의 한계를 명시하는 것이 좋다
- `cancel(true)`는 작업을 실행 중인 스레드에 `Thread.interrupt()` 시그널을 보낸다
- 문제는 `kakaoApi.getAddress()`와 같은 대부분의 I/O 작업(예: `Socket.read()`, `InputStream.read()`)이 `InterruptedException`에 민감하도록 설계되어 있지 않다는 점이다 (NIO의 `Channel`은 인터럽트 가능)
- 따라서 `cancel(true)`를 호출해도, `kakaoApi.getAddress`를 실행 중인 워커 스레드는 인터럽트 상태 플래그만 세팅될 뿐, 네트워크 응답이 올 때까지 API 콜라이언트의 자체 타임아웃까지 계속 블로킹 상태로 대기할 가능성이 높다
- 즉, `cancel(true)`로 인해 해당 워커 스레드의 작업을 즉시 중단시킨다고 보장할 수 없으며, 타입 아웃은 이후 "되던 노력을 일부 포기한다(best-effort)" 방식임

타임아웃 설정의 원칙:
1. **P99 레이턴시의 2-3배**: 정상 상황에서는 거의 발생하지 않도록
2. **캐스케이딩 실패 방지**: 상위 서비스의 타임아웃보다 짧게
3. **리트라이와 조합**: 짧은 타임아웃 + 여러 번 재시도
4. **API 클라이언트 자체 타임아웃 설정**: cancel()에만 의존하지 말고 HTTP 클라이언트 레벨에서도 타임아웃 설정

### 13.3 getNow: 논블로킹 조회

`getNow(T valueIfAbsent)`는 **완료되었으면 결과를, 아니면 기본값을 즉시 반환**한다. 이는 폴링이나 상태 확인에 유용하다.

```java
// 캐시 갱신 작업 (백그라운드)
CompletableFuture<Map<String, Crime>> cacheUpdateFuture = CompletableFuture
    .supplyAsync(() -> refreshCrimeCache(), cacheExecutor);

// 요청 처리 시점
Map<String, Crime> crimeData = cacheUpdateFuture.getNow(oldCache);
// 갱신 완료면 새 데이터, 진행 중이면 기존 캐시 사용
```

`getNow()`의 사용 사례:
1. **선택적 최적화**: 준비되면 사용, 아니면 대안
2. **진행 상태 확인**: UI 업데이트나 진행률 표시
3. **Best-effort 캐싱**: 최신이면 좋지만 필수는 아닌 경우

---

## 14. 실전 패턴: Wherehouse R-04 완전 구현

### 14.1 전체 의존성 그래프의 CompletableFuture 표현

Wherehouse R-04의 복잡한 의존성을 CompletableFuture로 완전히 구현하면:

```java
public CompletableFuture<SafetyAnalysis> analyzeLocation(double lat, double lon) {
    
    // 1. 독립적인 작업들 시작
    CompletableFuture<Address> addressFuture = CompletableFuture
        .supplyAsync(() -> kakaoApi.getAddress(lat, lon), ioExecutor)
        .orTimeout(3, TimeUnit.SECONDS)  // 3초 타임아웃 추가
        .exceptionally(ex -> {
            if (ex instanceof TimeoutException) {
                logger.warn("Address API timeout for ({}, {})", lat, lon);
            } else {
                logger.error("Address API failed for ({}, {})", lat, lon, ex);
            }
            return Address.unknown();
        });
    
    // 2. 15개 카테고리 병렬 검색
    List<CompletableFuture<CategoryResult>> categoryFutures = 
        Arrays.stream(Category.values())
            .map(cat -> CompletableFuture
                .supplyAsync(() -> kakaoApi.searchCategory(lat, lon, cat), ioExecutor)
                .orTimeout(2, TimeUnit.SECONDS)  // 카테고리당 2초 타임아웃
                .exceptionally(ex -> {
                    if (ex instanceof TimeoutException) {
                        logger.warn("Category {} search timeout", cat);
                    }
                    return CategoryResult.empty(cat);
                })
            )
            .collect(Collectors.toList());
    
    // 3. 주소 의존 작업 (주소 완료 후 시작)
    CompletableFuture<Crime> crimeFuture = addressFuture
        .thenCompose(addr -> CompletableFuture
            .supplyAsync(() -> {
                String gu = AddressParser.extractGu(addr);
                return crimeRepository.findByGu(gu)
                    .orElse(Crime.defaultForGu(gu));
            }, dbExecutor)
        );
    
    // 4. 모든 카테고리 검색 완료
    CompletableFuture<Map<Category, CategoryResult>> categoryMap = 
        CompletableFuture
            .allOf(categoryFutures.toArray(new CompletableFuture[0]))
            .thenApply(v -> categoryFutures.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.toMap(
                    CategoryResult::getCategory,
                    Function.identity()
                ))
            );
    
    // 5. 최종 조합
    return addressFuture
        .thenCombine(crimeFuture, (addr, crime) -> 
            Pair.of(addr, crime)
        )
        .thenCombine(categoryMap, (pair, categories) -> 
            SafetyAnalysis.builder()
                .address(pair.getLeft())
                .crimeRate(pair.getRight().getRate())
                .amenities(categories)
                .overallScore(calculateScore(pair.getRight(), categories))
                .build()
        );
}
```

### 14.2 성능 모니터링 통합

CompletableFuture 체인에 성능 측정을 통합하면:

```java
public class PerformanceAwareCompletableFuture {
    
    private static <T> CompletableFuture<T> withMetrics(
            String operation,
            Supplier<T> supplier,
            Executor executor) {
        
        long startTime = System.nanoTime();
        
        return CompletableFuture
            .supplyAsync(supplier, executor)
            .whenComplete((result, ex) -> {
                long duration = System.nanoTime() - startTime;
                
                if (ex != null) {
                    metricsCollector.recordFailure(operation, duration, ex);
                } else {
                    metricsCollector.recordSuccess(operation, duration);
                }
                
                // 특정 임계값 초과 시 경고
                if (duration > TimeUnit.SECONDS.toNanos(1)) {
                    logger.warn("{} took {}ms", operation, 
                        TimeUnit.NANOSECONDS.toMillis(duration));
                }
            });
    }
    
    // 사용 예
    CompletableFuture<Address> addressFuture = withMetrics(
        "kakao.geocode",
        () -> kakaoApi.getAddress(lat, lon),
        ioExecutor
    );
}
```

### 14.3 에러 복구 전략

계층적 폴백과 재시도를 구현하면:

```java
public class ResilientCompletableFuture {
    
    private static <T> CompletableFuture<T> withRetry(
            Supplier<CompletableFuture<T>> action,
            int maxRetries,
            Duration delay) {
        
        return action.get()
            .exceptionallyCompose(ex -> {
                if (maxRetries > 0) {
                    logger.debug("Retry after {} due to: {}", 
                        delay, ex.getMessage());
                    
                    // 지연 후 재시도 (비블로킹)
                    return Delayer.delay(delay)
                        .thenCompose(v -> withRetry(action, maxRetries - 1, delay));
                }
                return CompletableFuture.failedFuture(ex);
            });
    }
    
    // 계층적 폴백
    CompletableFuture<Address> robustAddress = 
        withRetry(() -> kakaoGeocode(lat, lon), 2, Duration.ofSeconds(1))
        .exceptionally(ex -> {
            logger.warn("Kakao failed, trying Naver");
            return naverGeocode(lat, lon);
        })
        .exceptionally(ex -> {
            logger.error("All geocoding failed");
            return Address.approximate(lat, lon);
        });
}
```

이러한 패턴들은 Wherehouse R-04를 **단순한 성능 개선을 넘어 장애 복원력 있는 시스템**으로 만든다. CompletableFuture의 메소드들은 각각 특정 문제를 해결하기 위해 설계되었으며, 이들을 적절히 조합하면 복잡한 비동기 로직도 선언적이고 유지보수 가능한 코드로 표현할 수 있다.

## 15. 검증 방법

Wherehouse R-04에 CompletableFuture를 적용한 후 다음을 측정하여 개선 효과를 정량적으로 증명한다:

**성능 지표:**
- 평균 응답 시간: 2,681ms → 350~400ms (목표)
- P95 응답 시간: 순차 대비 80% 이상 감소
- 처리량(TPS): 순차 대비 7~8배 증가

**Thread 상태 모니터링:**
- ThreadMXBean으로 스레드 상태 수집
- WAITING 상태 비율: 순차는 95% 이상, 병렬은 90% 이상 (I/O 대기)
- Active Thread: 순차는 1개, 병렬은 15~17개

**부하 테스트:**
- JMeter로 동시 사용자 50명, 5분간 부하
- CPU 사용률: 10% 미만 유지 (I/O-bound 특성)
- 메모리: Thread 증가에 따른 Stack 메모리 증가 확인

이를 통해 "CompletableFuture 적용으로 응답 시간을 X배 개선하고, 동일 하드웨어에서 처리 가능한 동시 사용자를 Y배 증가시켰다"는 구체적 수치를 포트폴리오에 기록할 수 있다.