# Future와 Callback: 비동기 완료 통지 메커니즘의 두 가지 방법

## 서론: Pull 모델과 Push 모델의 근본적 차이

### 비동기 작업 완료를 어떻게 알 것인가

비동기 프로그래밍에서 가장 핵심적인 질문은 "작업이 완료되었다는 사실을 어떻게 알 것인가"다. 이 질문에 대한 답은 크게 두 가지 방법으로 나뉜다. **Pull 모델(Future)**은 호출자가 능동적으로 완료 여부를 확인하고 결과를 가져간다. **Push 모델(Callback)**은 시스템이 완료 시점에 호출자에게 알려준다.

이 차이는 단순한 API 설계의 차이가 아니라, **스레드 자원 활용과 제어 흐름**에 대한 근본적으로 다른 철학을 반영한다. Future는 "결과가 필요한 시점"에 블로킹하여 동기적 코드처럼 보이게 만들지만, 그 대가로 해당 스레드(main 스레드)가 블록킹 된다. Callback은 호출자 스레드(main 스레드)에게 워커 스레드가 즉시 제어권을 반납하지만, 제어 흐름이 분산되어 코드 복잡도가 증가한다.

### 역사적 맥락: 왜 두 패턴이 공존하는가

Java 5(2004)에서 Future가 도입될 당시, 람다식이 존재하지 않았다. Callback을 구현하려면 익명 클래스를 중첩해야 했고, 이는 "Callback Hell"이라는 악명 높은 안티패턴을 만들었다. Doug Lea는 이 문제를 인지했지만, "복잡한 콜백보다는 단순한 블로킹"이 당시 Java 생태계에 더 적합하다고 판단했다.

JavaScript는 반대 경로를 택했다. 브라우저 환경에서는 단일 스레드만 사용 가능했기 때문에, 블로킹이 곧 UI 동결을 의미했다. 따라서 처음부터 Callback 기반 비동기 모델을 채택했고, 이후 Promise와 async/await로 진화했다.

이 문서는 두 패턴의 **내부 동작 메커니즘과 스레드 동기화 방식**을 분석하고, 각각의 장단점과 적용 시나리오를 제시한다.

---

## 1. Future 패턴: Pull 기반 결과 조회

### 1.1 아키텍처 구조와 동작 원리

Future 패턴은 **"미래에 완료될 작업의 핸들"**을 즉시 반환하는 설계다. 작업 제출과 결과 조회를 시간적으로 분리하되, 결과가 필요한 시점에 명시적으로 블로킹한다.

```java
public class FuturePatternAnalysis {
    
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        System.out.println("[T=0ms] Main Thread: 작업 제출 시작");
        
        // === Phase 1: 작업 제출 (논블로킹) ===
        Future<String> future = executor.submit(() -> {
            System.out.println("[T=1ms] Worker Thread: 작업 시작 (Thread ID: " + 
                Thread.currentThread().getId() + ")");
            
            try {
                // 네트워크 I/O 시뮬레이션
                Thread.sleep(2000);  // Worker Thread가 TIMED_WAITING 상태로 전환
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            System.out.println("[T=2001ms] Worker Thread: 작업 완료");
            return "카카오 API 응답 데이터";
        });
        
        // === Phase 2: Main Thread 다른 작업 수행 (병렬 실행) ===
        System.out.println("[T=2ms] Main Thread: Future 객체 즉시 반환받음");
        System.out.println("[T=3ms] Main Thread: 다른 작업 수행 중...");
        
        Thread.sleep(500);  // 다른 작업 시뮬레이션
        
        // === Phase 3: 결과 필요 시점 (블로킹 시작) ===
        System.out.println("[T=503ms] Main Thread: 이제 결과가 필요함");
        System.out.println("[T=504ms] Main Thread: future.get() 호출 → 블로킹 시작");
        
        long blockStart = System.currentTimeMillis();
        String result = future.get();  // Main Thread가 WAITING 상태로 전환
        long blockDuration = System.currentTimeMillis() - blockStart;
        
        System.out.println("[T=" + (504 + blockDuration) + "ms] Main Thread: 블로킹 해제됨");
        System.out.println("결과: " + result);
        System.out.println("블로킹 시간: " + blockDuration + "ms");
        
        executor.shutdown();
    }
}
```

### 1.2 내부 메커니즘: FutureTask의 동작

```java
// submit() 호출 시 내부 동작
public <T> Future<T> submit(Callable<T> task) {
    // 1. Callable을 FutureTask로 래핑
    RunnableFuture<T> ftask = new FutureTask<T>(task);
    
    // 2. 작업 큐에 삽입
    execute(ftask);  // workQueue.offer(ftask)
    
    // 3. 동일한 객체를 Future로 반환
    return ftask;
}
```

#### 스레드 상태 전이 다이어그램

```
시간    Main Thread           Worker Thread         FutureTask.state
────────────────────────────────────────────────────────────────────
T=0     RUNNABLE             (미생성)              NEW
        submit() 호출
        
T=1     RUNNABLE             RUNNABLE              NEW
        다른 작업 수행        callable.call() 시작
        
T=500   RUNNABLE             TIMED_WAITING         NEW
        다른 작업 중         Thread.sleep(2000)
        
T=504   future.get() 호출    TIMED_WAITING         NEW
        ↓
        WAITING              TIMED_WAITING         NEW
        (LockSupport.park)
        
T=2001  WAITING              RUNNABLE              COMPLETING
                            작업 완료
                            outcome = result
                            
T=2002  WAITING              RUNNABLE              NORMAL
                            finishCompletion()
                            LockSupport.unpark(main)
                            
T=2003  RUNNABLE             (작업 큐 확인)        NORMAL
        결과 반환받음
```

### 1.3 Future 패턴의 본질적 특성

#### 장점
1. **직관적인 제어 흐름**: 코드가 위에서 아래로 순차적으로 읽힌다
2. **명확한 에러 처리**: try-catch로 동기 코드처럼 예외 처리
3. **타임아웃 지원**: `get(timeout, unit)`으로 무한 대기 방지

#### 한계
1. **스레드 블로킹**: 결과를 기다리는 동안 스레드가 WAITING 상태
2. **조합의 어려움**: 여러 Future를 체이닝하려면 각 단계마다 블로킹
3. **리소스 낭비**: 블로킹된 스레드는 다른 작업을 처리할 수 없음

---

## 2. Callback 패턴: Push 기반 완료 통지

### 2.1 아키텍처 구조와 동작 원리

Callback 패턴은 **"완료되면 이 함수를 호출해달라"**는 계약을 미리 등록하는 설계다. 호출자는 콜백만 등록하고 즉시 다른 일을 계속하며, 작업 완료 시 Worker Thread가 콜백을 실행한다.

```java
// Callback 인터페이스 정의
interface AsyncCallback<T> {
    void onSuccess(T result);
    void onError(Throwable error);
}

// 비동기 작업 서비스
public class CallbackPatternAnalysis {
    
    private final ExecutorService executor = Executors.newFixedThreadPool(3);
    
    // 비동기 작업 실행 메서드
    public void executeAsync(String taskName, AsyncCallback<String> callback) {
        
        System.out.println("[Submit] " + taskName + " 작업 제출 (Thread: " + 
            Thread.currentThread().getName() + ")");
        
        executor.submit(() -> {
            Thread workerThread = Thread.currentThread();
            System.out.println("[Start] " + taskName + " 시작 (Thread: " + 
                workerThread.getName() + ")");
            
            try {
                // 작업 수행
                Thread.sleep(2000);
                String result = taskName + " 완료 데이터";
                
                // === 핵심: Worker Thread가 콜백 실행 ===
                System.out.println("[Callback] " + taskName + " 콜백 호출 (Thread: " + 
                    workerThread.getName() + ")");
                callback.onSuccess(result);
                
            } catch (Exception e) {
                callback.onError(e);
            }
        });
        
        System.out.println("[Return] " + taskName + " 제출 완료, 즉시 반환");
    }
    
    public static void main(String[] args) throws Exception {
        CallbackPatternAnalysis service = new CallbackPatternAnalysis();
        
        // === Phase 1: 콜백 정의 ===
        AsyncCallback<String> callback = new AsyncCallback<>() {
            @Override
            public void onSuccess(String result) {
                System.out.println("[Success] 결과 수신: " + result + 
                    " (Thread: " + Thread.currentThread().getName() + ")");
            }
            
            @Override
            public void onError(Throwable error) {
                System.err.println("[Error] 오류 발생: " + error.getMessage());
            }
        };
        
        // === Phase 2: 작업 제출 (논블로킹) ===
        System.out.println("[T=0ms] Main Thread 시작");
        service.executeAsync("카카오API호출", callback);
        
        // === Phase 3: Main Thread는 블로킹 없이 계속 진행 ===
        System.out.println("[T=1ms] Main Thread: 다른 작업 계속 수행");
        
        // 콜백 실행을 관찰하기 위해 대기
        Thread.sleep(3000);
        service.executor.shutdown();
    }
}
```

### 2.2 Callback Hell과 제어 흐름의 분산

#### 순차적 의존성이 있는 작업의 콜백 중첩

```java
public class CallbackHellExample {
    
    // 주소 변환 → 범죄율 조회 → 카테고리 검색의 순차 의존성
    public void analyzeLocationWithCallbacks(double lat, double lon) {
        
        // 1단계: 주소 변환
        geocodeService.getAddress(lat, lon, new AsyncCallback<Address>() {
            @Override
            public void onSuccess(Address address) {
                
                // 2단계: 범죄율 조회 (주소 필요)
                crimeService.getCrimeRate(address.getGu(), new AsyncCallback<Crime>() {
                    @Override
                    public void onSuccess(Crime crime) {
                        
                        // 3단계: 카테고리 검색 (15개 병렬)
                        AtomicInteger counter = new AtomicInteger(15);
                        List<CategoryResult> results = new CopyOnWriteArrayList<>();
                        
                        for (Category category : Category.values()) {
                            categoryService.search(lat, lon, category, 
                                new AsyncCallback<CategoryResult>() {
                                    @Override
                                    public void onSuccess(CategoryResult result) {
                                        results.add(result);
                                        
                                        // 모든 카테고리 완료 확인
                                        if (counter.decrementAndGet() == 0) {
                                            // 최종 결과 처리
                                            SafetyAnalysis analysis = SafetyAnalysis.builder()
                                                .address(address)
                                                .crimeRate(crime.getRate())
                                                .categories(results)
                                                .build();
                                            
                                            // 4단계: 최종 콜백
                                            finalCallback.onSuccess(analysis);
                                        }
                                    }
                                    
                                    @Override
                                    public void onError(Throwable error) {
                                        // 에러 처리도 중첩...
                                    }
                                });
                        }
                    }
                    
                    @Override
                    public void onError(Throwable error) {
                        finalCallback.onError(error);
                    }
                });
            }
            
            @Override
            public void onError(Throwable error) {
                finalCallback.onError(error);
            }
        });
    }
}
```

### 2.3 스레드 실행 컨텍스트 분석

```
Main Thread                 Worker-1                  Worker-2
───────────────────────────────────────────────────────────────
submit(task1, callback1)    
│                          
├─ 즉시 반환               task1 실행 시작
│                          │
├─ 다른 작업 수행          │ (2초 대기)
│                          │
submit(task2, callback2)   │                        task2 실행 시작  
│                          │                        │
├─ 또 즉시 반환            │                        │ (2초 대기)
│                          │                        │
├─ 계속 다른 작업          callback1.onSuccess()    │
│                          │                        │
│                          └─ (Worker-1에서 실행)  callback2.onSuccess()
│                                                   │
│                                                   └─ (Worker-2에서 실행)
```

**핵심 차이점**: 
- Future: Main Thread가 `get()`에서 블로킹되어 결과를 기다림
- Callback: Worker Thread가 작업 완료 후 콜백을 실행, Main은 블로킹 없음

---

## 3. 실무 적용 가이드라인

### 3.1 Future 패턴이 적합한 경우

```java
// 1. 단순한 요청-응답 패턴
public User getUser(Long id) {
    Future<User> future = executor.submit(() -> 
        userRepository.findById(id)
    );
    
    try {
        return future.get(5, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        // 명확한 타임아웃 처리
        throw new ServiceUnavailableException("User service timeout");
    }
}

// 2. 동기적 코드와의 통합이 필요한 경우
public Order processOrder(OrderRequest request) {
    // 기존 동기 코드
    validateRequest(request);
    
    // 비동기 작업을 동기적으로 대기
    Future<Payment> paymentFuture = processPaymentAsync(request);
    Payment payment = paymentFuture.get();
    
    // 다시 동기 코드
    return createOrder(payment);
}
```

### 3.2 Callback 패턴이 적합한 경우

```java
// 1. 이벤트 기반 시스템
public class EventDrivenSystem {
    
    public void handleUserAction(UserEvent event) {
        // 이벤트 발생 시 여러 비동기 작업 트리거
        
        analyticsService.track(event, new AsyncCallback<>() {
            public void onSuccess(Void v) {
                logger.info("Analytics tracked");
            }
        });
        
        notificationService.notify(event, new AsyncCallback<>() {
            public void onSuccess(Void v) {
                logger.info("Notification sent");
            }
        });
        
        // Main 흐름은 블로킹 없이 계속
    }
}

// 2. 고성능 I/O 처리
public class HighThroughputService {
    
    public void processBatch(List<Request> requests) {
        AtomicInteger completed = new AtomicInteger(0);
        
        for (Request req : requests) {
            // 수천 개의 요청을 블로킹 없이 처리
            processAsync(req, result -> {
                int count = completed.incrementAndGet();
                if (count % 100 == 0) {
                    logger.info("Processed: " + count);
                }
            });
        }
    }
}
```

## 결론: 선택의 기준

### 핵심 트레이드오프

| 측면 | Future 패턴 | Callback 패턴 |
|------|------------|---------------|
| **제어 흐름** | 순차적, 직관적 | 분산, 이벤트 기반 |
| **스레드 사용** | 블로킹으로 인한 점유 | 블로킹 없음, 효율적 |
| **에러 처리** | try-catch 집중 | 콜백마다 개별 처리 |
| **코드 복잡도** | 낮음 | 높음 (Callback Hell) |
| **성능** | 블로킹으로 인한 제한 | 높은 동시성 가능 |

**결론**: Future는 "학습 용이성과 단순성"을 제공하고, Callback은 "성능과 확장성"을 제공한다. 하지만 현대적 Java 애플리케이션에서는 CompletableFuture가 두 방법의 장점을 모두 제공하므로, 이를 채택하는 것이 아키텍처적으로 올바른 선택이다.