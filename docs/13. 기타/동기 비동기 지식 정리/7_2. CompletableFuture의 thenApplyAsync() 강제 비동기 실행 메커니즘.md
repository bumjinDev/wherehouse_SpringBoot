# CompletableFuture의 thenApplyAsync() 강제 비동기 실행 메커니즘
## thenApply()와의 차별점과 명시적 비동기 제어 전략

---

## 1. 서론: 왜 thenApplyAsync()라는 별도 메서드가 필요한가

### 1.1 적응적 실행의 한계와 예측 가능성의 필요성

CompletableFuture의 thenApply()는 Fast Path/Slow Path를 통한 적응적 실행 전략을 제공한다. 이는 대부분의 상황에서 최적의 성능을 보장하지만, **실행 주체의 비결정성(non-determinism)**이라는 근본적인 특성을 갖는다. 동일한 코드가 실행 시점의 타이밍에 따라 main 스레드에서 실행될 수도, 워커 스레드에서 실행될 수도 있다는 것이다.

이러한 비결정성은 특정 상황에서 심각한 문제를 야기한다. CPU 집약적 작업이 main 스레드에서 실행되어 전체 애플리케이션이 블로킹되거나, ThreadLocal을 사용하는 코드에서 예상치 못한 컨텍스트 오염이 발생할 수 있다. 더 중요한 것은, 개발자가 **명시적으로 작업을 다른 스레드로 분리하고자 할 때** 이를 보장할 방법이 없다는 점이다.

### 1.2 명시적 비동기 실행의 설계 요구사항

thenApplyAsync()는 이러한 한계를 극복하기 위해 설계되었다. 이 메서드의 핵심 보장사항은 **"호출자 스레드가 절대 변환 작업을 직접 실행하지 않는다"**는 것이다. 이는 단순히 성능 최적화의 포기가 아니라, 특정 아키텍처 패턴을 구현하기 위한 필수적인 도구다.

비동기 파이프라인에서 각 단계가 서로 다른 특성의 작업(I/O-bound vs CPU-bound)을 수행하거나, 서로 다른 자원 제약(데이터베이스 연결 풀 vs 계산 스레드 풀)을 가질 때, 명시적 스레드 분리는 시스템의 안정성과 처리량을 보장하는 핵심 메커니즘이 된다.

---

## 2. 본론: thenApplyAsync()의 내부 실행 메커니즘

### 2.1 AsyncApply 노드와 강제 비동기 실행 구조

thenApplyAsync()가 호출되면 CompletableFuture는 내부적으로 **AsyncApply** 노드를 생성한다. 이는 thenApply()의 UniApply와 유사하지만, 결정적인 차이점을 갖는다:

```java
// CompletableFuture 내부 구조 (간략화)
static final class AsyncApply<T,V> extends AsyncCompletion<T,V> {
    Function<? super T,? extends V> fn;
    
    void tryFire(int mode) {
        // mode와 무관하게 항상 비동기 실행
        if (mode == SYNC) {
            // SYNC 모드에서도 풀에 제출
            ForkJoinPool.commonPool().execute(this);
            return;
        }
        // ASYNC 모드에서 실제 작업 실행
        applyFunction();
    }
}
```

AsyncApply의 핵심은 **SYNC 모드에서도 직접 실행하지 않고 스레드 풀에 제출**한다는 점이다. 이는 UniApply가 SYNC 모드에서 직접 함수를 실행하는 것과 대조적이다.

### 2.2 스레드 할당 타이밍과 논블로킹 보장

#### 이전 작업이 완료되지 않은 경우

```java
CompletableFuture<Integer> future = CompletableFuture
    .supplyAsync(() -> {
        Thread.sleep(5000);  // 워커 스레드에서 실행 중
        return 42;
    })
    .thenApplyAsync(x -> x * 2);  // main 스레드가 호출
```

main 스레드가 thenApplyAsync()를 호출하는 시점에 다음이 발생한다:

1. **AsyncApply 노드 생성**: 변환 함수를 캡슐화한 completion 노드 생성
2. **Completion Stack 등록**: 원본 CompletableFuture의 stack에 추가
3. **즉시 반환**: main 스레드는 새 CompletableFuture를 받고 즉시 다음 작업 진행

이 시점에서 **어떤 새로운 스레드도 생성되거나 할당되지 않는다**. AsyncApply는 단지 "나중에 실행될 작업"으로 등록될 뿐이다.

5초 후 supplyAsync()가 완료되면:

```java
// 워커 스레드가 실행
completeValue(42);
postComplete() {
    // AsyncApply 발견
    ForkJoinPool.commonPool().execute(() -> {
        result = fn.apply(42);  // x * 2 실행
        nextCompletableFuture.complete(result);
    });
}
```

#### 이전 작업이 이미 완료된 경우

```java
CompletableFuture<Integer> future = CompletableFuture
    .completedFuture(42)  // 이미 완료된 상태
    .thenApplyAsync(x -> x * 2);  // main 스레드가 호출
```

이 경우에도 main 스레드는 직접 작업을 실행하지 않는다:

1. **즉시 풀 제출**: ForkJoinPool.commonPool().execute(asyncApplyTask)
2. **논블로킹 반환**: main은 제출만 하고 결과를 기다리지 않음
3. **비동기 실행**: 풀의 워커 스레드가 나중에 작업 수행

### 2.3 폴링 없는 이벤트 기반 실행 모델

CompletableFuture는 **폴링(polling)을 전혀 사용하지 않는다**. 이는 흔한 오해인데, 많은 개발자가 "어떤 스레드가 주기적으로 완료 상태를 확인한다"고 잘못 이해한다.

실제로는 **push 기반 이벤트 모델**을 사용한다:

```java
// 폴링이 아닌 콜백 체인
class CompletableFuture<T> {
    volatile Object result;
    volatile Completion stack;  // 콜백 체인
    
    boolean complete(T value) {
        this.result = value;
        postComplete();  // 즉시 모든 대기 중인 작업 실행
        return true;
    }
    
    void postComplete() {
        Completion h;
        while ((h = stack) != null) {
            h.tryFire(NESTED);  // 각 completion 실행
        }
    }
}
```

작업을 완료하는 스레드가 직접 다음 작업들을 트리거한다. 어떤 스레드도 "대기"하지 않으며, CPU 자원 낭비가 없다.

### 2.4 ForkJoinPool과 Work-Stealing 메커니즘

thenApplyAsync()가 기본적으로 사용하는 ForkJoinPool.commonPool()은 **work-stealing(작업 훔치기)** 알고리즘을 구현한다:

```java
// ForkJoinPool 내부 동작
class ForkJoinPool {
    WorkQueue[] queues;  // 워커별 큐
    
    void execute(Runnable task) {
        WorkQueue q = selectQueue();  // 적절한 큐 선택
        q.push(task);
        
        if (noIdleWorkers()) {
            tryAddWorker();  // 필요시 워커 추가 (제한 내에서)
        }
    }
}
```

각 워커 스레드는 자신의 작업 큐를 가지며, 큐가 비면 다른 워커의 큐에서 작업을 "훔쳐"온다. 이는 load balancing(부하 분산)을 자동으로 수행한다.

---

## 3. thenApplyAsync()가 필요한 아키텍처 패턴

### 3.1 I/O와 CPU 작업의 명시적 분리

```java
ExecutorService ioExecutor = Executors.newCachedThreadPool();
ExecutorService cpuExecutor = Executors.newFixedThreadPool(4);

CompletableFuture
    .supplyAsync(() -> fetchFromNetwork(), ioExecutor)  // I/O 스레드
    .thenApplyAsync(data -> parseJson(data), cpuExecutor)  // CPU 스레드
    .thenApplyAsync(json -> compress(json), cpuExecutor)   // CPU 스레드
    .thenApplyAsync(compressed -> saveToFile(compressed), ioExecutor); // I/O 스레드
```

각 작업 특성에 맞는 스레드 풀을 사용하여 자원 활용을 최적화한다. I/O 스레드는 대기 시간이 길어도 많은 수를 유지할 수 있지만, CPU 스레드는 코어 수에 맞춰 제한한다.

### 3.2 ThreadLocal 격리가 필요한 보안 컨텍스트

```java
ThreadLocal<SecurityContext> securityContext = new ThreadLocal<>();

CompletableFuture
    .supplyAsync(() -> authenticateUser(credentials))
    .thenApplyAsync(user -> {
        // 새로운 스레드에서 깨끗한 보안 컨텍스트
        securityContext.set(new SecurityContext(user));
        return authorizeAccess(user, resource);
    })
    .thenApplyAsync(authorized -> {
        // 이전 스레드의 컨텍스트와 완전히 격리
        return performSecureOperation(authorized);
    });
```

### 3.3 백프레셔(Back-pressure) 제어

```java
// 제한된 크기의 스레드 풀로 백프레셔 구현
ExecutorService bounded = new ThreadPoolExecutor(
    10, 10, 0L, TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue<>(100),  // 제한된 큐
    new ThreadPoolExecutor.CallerRunsPolicy()  // 큐 포화시 호출자가 실행
);

stream.map(item -> 
    CompletableFuture
        .supplyAsync(() -> fetchData(item))
        .thenApplyAsync(data -> process(data), bounded)  // 처리량 제한
);
```

---

## 4. 성능 특성과 트레이드오프

### 4.1 컨텍스트 스위칭 오버헤드

thenApplyAsync()는 **항상 컨텍스트 스위칭을 발생**시킨다:

```java
// 성능 비교
CompletableFuture<String> fast = CompletableFuture
    .completedFuture("data")
    .thenApply(String::toUpperCase);  // ~100ns (캐시 히트)

CompletableFuture<String> slow = CompletableFuture
    .completedFuture("data")
    .thenApplyAsync(String::toUpperCase);  // ~10,000ns (컨텍스트 스위칭)
```

간단한 변환에 thenApplyAsync()를 사용하면 100배 이상의 성능 저하가 발생할 수 있다.

### 4.2 스레드 풀 압력과 처리량

```java
// 안티패턴: 모든 변환에 Async 사용
CompletableFuture
    .supplyAsync(() -> getData())
    .thenApplyAsync(x -> x + 1)  // 불필요한 풀 압력
    .thenApplyAsync(x -> x * 2)  // 불필요한 풀 압력
    .thenApplyAsync(x -> x.toString());  // 불필요한 풀 압력

// 올바른 패턴: 필요한 곳에만 Async
CompletableFuture
    .supplyAsync(() -> getData())
    .thenApply(x -> x + 1)  // 빠른 변환은 동기
    .thenApply(x -> x * 2)
    .thenApplyAsync(x -> heavyComputation(x));  // 무거운 작업만 비동기
```

---

## 5. 결론: 명시적 제어와 자동 최적화의 균형

### 5.1 패러다임의 공존

CompletableFuture가 thenApply()와 thenApplyAsync()를 모두 제공하는 것은 **두 가지 설계 철학의 공존**을 보여준다:

- **thenApply()**: "시스템이 최적을 선택" - 신뢰 기반 자동화
- **thenApplyAsync()**: "개발자가 명시적 제어" - 예측 가능성 우선

이는 Java 생태계의 전형적인 접근법으로, 편의성과 제어권을 모두 제공하여 다양한 요구사항을 충족시킨다.

### 5.2 아키텍처적 의의

thenApplyAsync()의 존재는 CompletableFuture가 단순한 비동기 유틸리티가 아니라 **복잡한 비동기 아키텍처를 구현하는 도구**임을 보여준다. 마이크로서비스 간 비동기 통신, 리액티브 스트림 처리, CQRS 패턴 구현 등에서 명시적 스레드 제어는 필수적이다.

### 5.3 설계적 책임

개발자는 thenApplyAsync() 사용 시 다음을 고려해야 한다:

**정당한 사용 사례인지 검증**: CPU 집약적 작업, 스레드 격리 필요성, 특정 Executor 사용 등 명확한 이유가 있어야 한다.

**성능 영향 측정**: 컨텍스트 스위칭 오버헤드가 실제 작업보다 클 수 있음을 인지하고, 프로파일링을 통해 검증해야 한다.

**스레드 풀 관리**: 기본 commonPool() 대신 작업 특성에 맞는 커스텀 Executor 사용을 고려해야 한다.