# CompletableFuture의 thenCompose() 평탄화 메커니즘
## 타입 중첩 제거와 비동기 체이닝의 구조적 설계

---

# 개요: 평탄화 메커니즘

## 1. 왜 평탄화가 필요한가

### 1.1 비동기 체이닝에서 발생하는 타입 중첩 문제

비동기 작업을 연속적으로 체이닝할 때 근본적인 구조적 문제가 발생한다. 현대 마이크로서비스 아키텍처에서는 각 서비스 호출이 네트워크 I/O를 수반하므로 필연적으로 CompletableFuture를 반환한다. 문제는 이러한 비동기 작업의 결과를 받아서 또 다른 비동기 작업을 시작해야 할 때 발생한다.

예를 들어 전자상거래 시스템에서 주문을 처리하는 과정을 생각해보자. 먼저 인증 서비스에서 사용자를 검증하고, 그 결과인 사용자 ID로 재고 서비스를 조회하며, 다시 그 결과로 결제 서비스를 호출한다. 각 단계가 CompletableFuture를 반환하는 비동기 작업이다. 

thenApply()를 사용하면 이러한 체인이 만들어진다: 첫 번째 서비스가 `CompletableFuture<UserId>`를 반환하고, 이를 받아 재고 서비스를 호출하는 함수가 `CompletableFuture<Inventory>`를 반환한다면, thenApply()는 이를 그대로 새로운 CompletableFuture로 감싸서 `CompletableFuture<CompletableFuture<Inventory>>`를 만든다. 세 번째 단계를 거치면 `CompletableFuture<CompletableFuture<CompletableFuture<Payment>>>`라는 삼중 중첩이 발생한다.

### 1.2 타입 중첩이 야기하는 실제 문제

이러한 타입 중첩은 단순한 문법적 불편함이 아니다. 실제 Payment 객체에 접근하려면 세 번의 join()을 호출해야 한다. 각 중첩 레벨마다 별도의 예외 처리가 필요하며, 어느 레벨에서 발생한 예외인지 추적하기 어렵다. 

더 심각한 것은 비즈니스 로직의 의도가 왜곡된다는 점이다. "사용자를 인증하고, 재고를 확인한 후, 결제를 처리한다"는 선형적이고 명확한 흐름이 "결제 처리 작업을 조회하는 작업을 조회하는 작업"이라는 무의미한 중첩 구조로 변질된다. 코드를 읽는 사람은 실제 비즈니스 플로우를 파악하기 어려워지고, 유지보수성이 크게 저하된다.

---

## 2. thenCompose()의 평탄화 메커니즘

### 2.1 평탄화의 핵심 원리

thenCompose()의 핵심은 **함수가 반환하는 CompletableFuture를 새로운 CompletableFuture로 감싸지 않는다**는 것이다. 대신 내부에서 반환된 CompletableFuture의 결과를 외부 CompletableFuture로 직접 전달한다. 

이 과정을 단계별로 분해하면 다음과 같다. thenCompose()가 호출되면 즉시 새로운 CompletableFuture를 생성하여 호출자에게 반환한다. 이를 '외부 future'라고 하자. 중요한 점은 이 시점에서 사용자가 제공한 함수는 아직 실행되지 않았다는 것이다. 외부 future는 미완료 상태의 빈 껍데기로 반환되며, 호출자는 이 future에 대해 추가적인 체이닝을 즉시 수행할 수 있다.

### 2.2 이벤트 전파 체인의 동작

선행 작업이 완료되면 평탄화의 핵심 메커니즘이 작동한다:

**첫 번째 단계: 함수 실행과 내부 future 생성**
선행 CompletableFuture가 완료되면, 그 결과값을 추출하여 사용자가 제공한 함수에 전달한다. 이 함수는 새로운 CompletableFuture를 반환하는데, 이를 '내부 future'라고 하자. 예를 들어 사용자 ID를 받아 데이터베이스에서 사용자 정보를 조회하는 비동기 작업을 시작하고, 그 작업을 나타내는 CompletableFuture를 반환한다.

**두 번째 단계: 완료 콜백 등록**
내부 future에 특별한 콜백이 등록된다. 이 콜백의 역할은 명확하다: "내부 future가 완료되면, 그 결과를 가져와서 외부 future의 complete() 메서드를 호출하라." 이것이 평탄화의 핵심이다. 내부 future의 결과가 외부 future로 직접 복사되는 것이다.

**세 번째 단계: 결과 전파**
내부 future가 완료되면(예: 데이터베이스 조회가 끝나면) 등록된 콜백이 트리거된다. 이 콜백은 내부 future의 결과값을 읽어서 외부 future의 result 필드에 직접 설정한다. 이 시점에서 내부 future는 더 이상 필요 없으며, 가비지 컬렉션의 대상이 된다.

**최종 결과**
사용자는 외부 future만 보게 되며, 중첩 없이 단일 join()으로 최종 결과에 접근할 수 있다. 타입은 `CompletableFuture<T>`로 유지되며, 중간의 CompletableFuture는 평탄화 과정에서만 일시적으로 존재했을 뿐이다.

### 2.3 예외 전파의 투명성

평탄화 메커니즘은 정상 값뿐만 아니라 예외도 동일하게 처리한다. 내부 future에서 예외가 발생하면, 완료 콜백은 이를 감지하여 외부 future의 completeExceptionally() 메서드를 호출한다. 

이는 매우 중요한 특성이다. 중간 계층이 없으므로 예외가 직접 전파되며, 예외의 스택 트레이스가 원본 그대로 유지된다. 개발자는 어느 서비스 호출에서 예외가 발생했는지 명확히 파악할 수 있고, 전체 체인에 대해 단일 exceptionally 핸들러로 일관된 에러 처리를 수행할 수 있다.

---

## 3. thenApply()와의 구조적 차이

### 3.1 타입 제약을 통한 의도 명시

thenApply()는 함수의 반환값이 무엇이든 받아들인다. 함수가 String을 반환하면 `CompletableFuture<String>`을, Integer를 반환하면 `CompletableFuture<Integer>`를 만든다. 문제는 함수가 이미 CompletableFuture를 반환할 때다. thenApply()는 이것도 그대로 감싸서 `CompletableFuture<CompletableFuture<T>>`를 만든다.

반면 thenCompose()는 함수 시그니처에 명시적 제약을 둔다. 함수가 반드시 CompletionStage(실질적으로 CompletableFuture)를 반환하도록 요구한다. 이 제약은 두 가지 목적을 달성한다. 첫째, 개발자가 의도를 명확히 표현하도록 강제한다. 일반 객체를 반환하는 함수를 실수로 전달하면 컴파일 에러가 발생한다. 둘째, 컴파일러와 런타임이 평탄화가 필요한 상황임을 인지하고 적절한 처리를 수행할 수 있다.

### 3.2 UniCompose와 UniRelay의 역할

thenCompose() 내부에서는 UniCompose와 UniRelay라는 특별한 컴포넌트가 평탄화를 담당한다. UniCompose는 선행 작업이 완료되면 사용자 함수를 실행하여 내부 future를 생성하는 역할을 한다. UniRelay는 내부 future의 완료를 감지하여 그 결과를 외부 future로 전파하는 역할을 한다.

이들은 completion stack이라는 내부 메커니즘을 통해 연결된다. 선행 CompletableFuture가 완료되면 그 completion stack에 등록된 모든 노드가 순차적으로 트리거되는데, UniCompose도 그 중 하나다. UniCompose가 내부 future를 생성하면, 그 future의 completion stack에 UniRelay를 등록한다. 이러한 체인을 통해 결과가 최종적으로 외부 future까지 전달된다.

### 3.3 사용 시점의 명확한 구분

두 메서드의 사용 시점은 명확히 구분된다:

**thenApply()를 사용하는 경우:**
- 동기적 변환 작업: `user -> user.getName()`
- 즉시 계산 가능한 값: `price -> price * 1.1`
- I/O 작업이 없는 순수 함수: `list -> list.size()`

**thenCompose()를 사용하는 경우:**
- 데이터베이스 조회: `userId -> findUserById(userId)`
- 외부 API 호출: `order -> paymentService.process(order)`
- 또 다른 비동기 작업 시작: `file -> readFileAsync(file)`

이 구분을 지키지 않으면 타입 중첩이나 불필요한 오버헤드가 발생한다.

---

## 4. 결론

### 4.1 평탄화의 본질적 가치

thenCompose()의 평탄화는 단순한 편의 기능이 아니라, 비동기 프로그래밍의 복잡성을 관리하기 위한 필수적인 메커니즘이다. 핵심은 내부 CompletableFuture의 결과를 외부 CompletableFuture로 직접 전파하여, 타입 중첩 없이 선형적인 비동기 파이프라인을 구성하는 것이다.

이를 통해 타입 시스템이 비즈니스 로직의 의도를 정확히 표현할 수 있다. "A 후 B 후 C"라는 단순한 흐름이 복잡한 중첩 타입으로 왜곡되지 않고, 그대로 코드에 반영된다.

### 4.2 설계 원칙과 선택 기준

개발자는 명확한 기준을 가지고 두 메서드를 선택해야 한다. 함수가 일반 객체를 반환하면 thenApply()를, CompletableFuture를 반환하면 thenCompose()를 사용한다. 이는 선택사항이 아니라 필수 요구사항이다. 잘못된 선택은 타입 중첩이나 불필요한 오버헤드를 발생시킨다.

### 4.3 현대 비동기 프로그래밍에서의 위치

thenApply()와 thenCompose()의 분리는 CompletableFuture가 단순한 비동기 유틸리티가 아니라, 정교한 타입 시스템을 갖춘 비동기 프로그래밍 프레임워크임을 보여준다. 이는 Java 생태계의 표준이 되었으며, Reactive Streams, Kotlin Coroutines 등 다른 비동기 프레임워크들도 동일한 평탄화 개념을 채택했다.

평탄화 메커니즘을 이해하는 것은 현대적인 비동기 아키텍처를 설계하고 구현하는 데 필수적이다. 이는 비동기 프로그래밍이 직면한 보편적 문제에 대한 검증된 해법이며, 복잡한 비동기 워크플로우를 관리 가능한 수준으로 유지하는 핵심 도구다.

---

# 본문: 타입 중첩과 평탄화의 구조적 분석

## 1. thenApply()의 무제약 제네릭과 타입 중첩의 구조적 원인

### 1.1 제네릭 타입 시스템의 제약 부재

`thenApply()`의 메서드 시그니처는 Java의 제네릭 시스템이 제공하는 최대 유연성을 활용한다:

```java
public <U> CompletableFuture<U> thenApply(Function<T, U> fn)
```

제네릭 타입 파라미터 `U`에는 어떠한 상한(upper bound)이나 하한(lower bound) 제약도 존재하지 않는다. 이는 `U`가 Java의 모든 참조 타입(reference type)이 될 수 있음을 의미하며, 여기에는 `CompletableFuture<T>`, `Optional<T>`, `List<T>` 같은 제네릭 컨테이너 타입도 포함된다.

이러한 무제약 설계는 의도적인 것이다. `thenApply()`는 **블로킹 없이 즉시 계산 가능한 변환(non-blocking computation)**을 위해 설계되었으며, 변환 함수가 어떤 타입을 반환하든 그것을 CompletableFuture로 감싸는 것이 올바른 동작이다. 문제는 개발자가 이 메서드를 **비동기 작업을 반환하는 함수**에 적용할 때 발생한다.

### 1.2 타입 중첩의 메모리 구조와 접근 경로

구체적인 예시로 타입 중첩의 구조를 분석해보자:

```java
CompletableFuture<Integer> userIdFuture = CompletableFuture.completedFuture(12345);

Function<Integer, CompletableFuture<User>> fetchUser = 
    id -> CompletableFuture.supplyAsync(() -> new User(id, "John"));

// thenApply() 사용 - 타입 중첩 발생
CompletableFuture<CompletableFuture<User>> nested = userIdFuture.thenApply(fetchUser);
```

Java 컴파일러의 타입 추론 엔진은 다음과 같이 타입을 추론한다:
- `fetchUser`의 반환 타입: `CompletableFuture<User>`
- 이를 제네릭 파라미터 `U`에 바인딩: `U = CompletableFuture<User>`
- 최종 반환 타입: `CompletableFuture<U>` = `CompletableFuture<CompletableFuture<User>>`

**컴파일러는 이를 전혀 문제 삼지 않는다.** 타입 규칙을 완벽히 준수한 코드이기 때문이다.

이 시점에서 `nested` 객체의 내부 메모리 레이아웃은:

```
nested (CompletableFuture<CompletableFuture<User>> 인스턴스)
  ├─ result 필드 (Object 타입): CompletableFuture<User> 인스턴스의 참조
  │   └─ (내부 CompletableFuture의 필드들)
  │       ├─ result 필드: User 인스턴스의 참조
  │       │   └─ User { id: 12345, name: "John" }
  │       └─ stack 필드: completion chain 참조
  └─ stack 필드: completion chain 참조
```

실제 `User` 객체는 **이중 래핑**되어 있다. 접근하려면:

```java
CompletableFuture<User> innerFuture = nested.join();  // 첫 번째 언래핑
User user = innerFuture.join();  // 두 번째 언래핑
```

두 번의 `join()` 호출이 필요하며, 각 호출은 blocking 연산이므로 현재 스레드를 두 번 차단한다. 이는 **타입 시스템이 실제 데이터 접근 패턴을 정확히 표현하지 못한다**는 것을 의미한다.

### 1.3 타입 왜곡이 초래하는 설계 문제

더 심각한 것은 타입이 비즈니스 의도를 왜곡한다는 점이다. 개발자의 의도는 "사용자 ID로 사용자를 비동기 조회한다"는 것이지만, 타입 `CompletableFuture<CompletableFuture<User>>`는 "사용자 조회 작업을 조회하는 작업"이라는 불필요한 중첩 구조를 표현한다. 이는 비즈니스 로직의 의도를 타입 시스템이 정확히 반영하지 못하는 것이다.

이러한 타입 중첩은 체이닝이 길어질수록 기하급수적으로 악화된다:

```java
CompletableFuture<Integer> step1 = getSessionToken();

CompletableFuture<CompletableFuture<User>> step2 = 
    step1.thenApply(token -> getUserId(token));

CompletableFuture<CompletableFuture<CompletableFuture<Order>>> step3 = 
    step2.thenApply(userFuture -> 
        userFuture.thenApply(user -> getOrders(user))
    );

// 이 시점에서 타입이 3중 중첩되어 코드 자체가 거의 작성 불가능해진다
```

---

## 2. thenCompose()의 타입 제약과 평탄화 보장

### 2.1 CompletionStage 제약을 통한 의도 명시

`thenCompose()`는 함수 시그니처 레벨에서 명시적 제약을 도입한다:

```java
public <U> CompletableFuture<U> thenCompose(
    Function<? super T, ? extends CompletionStage<U>> fn
)
```

`thenCompose()`의 핵심은 함수가 **반드시 CompletableFuture(또는 CompletionStage)를 반환하도록 강제**한다는 것이다:

```java
CompletableFuture<Integer> userIdFuture = CompletableFuture.completedFuture(12345);

// ✅ 컴파일 성공: CompletableFuture 반환
Function<Integer, CompletableFuture<User>> asyncFunc = 
    id -> CompletableFuture.supplyAsync(() -> new User(id, "John"));

CompletableFuture<User> result = userIdFuture.thenCompose(asyncFunc);
```

```java
CompletableFuture<Integer> userIdFuture = CompletableFuture.completedFuture(12345);

// ❌ 컴파일 에러: 일반 User 객체 반환
Function<Integer, User> syncFunc = 
    id -> new User(id, "John");

CompletableFuture<User> error = userIdFuture.thenCompose(syncFunc);
/*
컴파일러 오류 메시지:
incompatible types: Function<Integer,User> cannot be converted to 
Function<? super Integer,? extends CompletionStage<User>>
*/
```

**이 제약 덕분에:**

1. **개발자 실수 방지**: 일반 객체 반환 함수를 잘못 사용하면 컴파일 타임에 에러 발생
2. **평탄화 보장**: 컴파일러가 "함수가 CompletableFuture를 반환한다"는 것을 알고 있으므로, 런타임에 적절한 평탄화 메커니즘 적용 가능
3. **의도 명시**: 코드만 봐도 "이 함수는 비동기 작업을 시작한다"는 것이 명확

### 2.2 평탄화의 기본 동작

올바른 사용 예시를 통해 평탄화 메커니즘을 확인하자:

```java
Function<Integer, CompletableFuture<User>> asyncFunc = 
    id -> CompletableFuture.supplyAsync(() -> {
        // 실제 비동기 작업 - 예: 데이터베이스 조회
        Thread.sleep(100); // 시뮬레이션
        return new User(id, "John");
    });

CompletableFuture<User> flat = userIdFuture.thenCompose(asyncFunc);
```

**핵심 사실**: 최종 타입이 `CompletableFuture<User>`이다. `CompletableFuture<CompletableFuture<User>>`가 아니다.

`thenCompose()`는 내부적으로 다음을 보장한다:
1. 함수가 반환하는 `CompletableFuture<User>` (내부 future)를 생성
2. 이 내부 future가 완료되면, 그 결과를 외부 future로 직접 복사
3. 최종적으로 사용자는 단일 계층의 CompletableFuture만 보게 됨

사용자는 단일 `join()` 호출로 결과에 접근한다:

```java
User user = flat.join();  // 한 번의 언래핑만 필요
System.out.println(user.getName()); // "John"
```

**메모리 구조의 차이**:

thenApply() 오용 시:
```
CompletableFuture<CompletableFuture<User>>
  └─ result → CompletableFuture<User>
      └─ result → User 객체
```

thenCompose() 사용 시:
```
CompletableFuture<User>
  └─ result → User 객체 (직접 참조)
```

내부 future는 평탄화 과정에서만 일시적으로 존재하며, 최종 메모리 구조에는 나타나지 않는다.

### 2.3 예외 전파의 투명성

평탄화 메커니즘은 정상 값뿐만 아니라 예외도 동일하게 처리한다:

```java
Function<Integer, CompletableFuture<User>> failingFunc = 
    id -> CompletableFuture.supplyAsync(() -> {
        if (id < 0) throw new IllegalArgumentException("Invalid user ID");
        return new User(id, "John");
    });

CompletableFuture<User> result = CompletableFuture
    .completedFuture(-1)
    .thenCompose(failingFunc);
```

**핵심 사실**: 내부 future에서 발생한 예외가 외부 future로 직접 전파된다.

```java
result.exceptionally(ex -> {
    ex.printStackTrace();
    /*
    java.util.concurrent.CompletionException: 
        java.lang.IllegalArgumentException: Invalid user ID
        at User.lambda$failingFunc$0(...)  ← 원본 예외 발생 지점 보존
        ...
    */
    return null;
});
```

**장점**:
- 예외의 스택 트레이스가 원본 그대로 유지됨
- 어느 단계에서 예외가 발생했는지 명확히 파악 가능
- 전체 체인에 대해 단일 `exceptionally()` 핸들러로 일관된 에러 처리

만약 thenApply()를 오용했다면 중첩된 CompletionException이 발생하여 디버깅이 훨씬 어려워진다.

---

## 3. UniCompose의 내부 동작과 Completion 전파 체계

### 3.1 Completion Stack 아키텍처

CompletableFuture의 내부 구조를 이해하는 것이 평탄화 메커니즘을 완전히 파악하는 열쇠다. 각 CompletableFuture 인스턴스는 `stack`이라는 필드를 갖는다:

```java
// CompletableFuture 내부 (단순화)
public class CompletableFuture<T> {
    volatile Object result;        // 완료 결과 저장
    volatile Completion stack;     // completion 체인의 head
}
```

`stack` 필드는 **연결 리스트(linked list)**의 head를 가리킨다. 이 리스트의 각 노드는 `Completion` 추상 클래스를 상속한 객체다:

```java
abstract class Completion extends ForkJoinTask<Void> {
    volatile Completion next;  // 다음 completion 노드
    abstract CompletableFuture<?> tryFire(int mode);
}
```

CompletableFuture가 완료되면, `stack`에 등록된 모든 Completion 노드들의 `tryFire()` 메서드가 순차적으로 호출된다. 이것이 **이벤트 전파의 기본 메커니즘**이다.

### 3.2 UniCompose의 내부 구조

`thenCompose()`를 호출하면 `UniCompose` 타입의 Completion 노드가 생성된다:

```java
// OpenJDK 내부 구현 (간략화 및 교육 목적으로 재구성)
static final class UniCompose<T,V> extends UniCompletion<T,V> {
    Function<? super T, ? extends CompletionStage<V>> fn;
    
    UniCompose(
        Executor executor,
        CompletableFuture<V> dep,  // 외부 future (thenCompose가 반환한 것)
        CompletableFuture<T> src,  // 선행 future
        Function<? super T, ? extends CompletionStage<V>> fn
    ) {
        super(executor, dep, src);
        this.fn = fn;
    }
    
    final CompletableFuture<V> tryFire(int mode) {
        CompletableFuture<V> d;   // dep (외부 future)
        CompletableFuture<T> a;   // src (선행 future)
        
        if ((d = dep) == null || (a = src) == null) 
            return null;
        
        // 선행 future의 결과 추출
        Object r = a.result;
        if (r == null) return null;  // 아직 완료 안 됨
        
        if (d.result == null) {  // 외부 future가 아직 완료 안 됨
            try {
                // 핵심: 사용자 함수 실행
                T t = (r instanceof AltResult) ? null : (T) r;
                CompletionStage<V> innerStage = fn.apply(t);
                CompletableFuture<V> inner = innerStage.toCompletableFuture();
                
                // 평탄화의 핵심: inner → outer 전파 설정
                if (inner.result == null) {
                    // inner가 미완료면 콜백 등록
                    inner.unipush(new UniRelay<>(inner, d));
                } else {
                    // inner가 이미 완료면 즉시 outer에 복사
                    d.completeRelay(inner.result);
                }
            } catch (Throwable ex) {
                d.completeExceptionally(ex);
            }
        }
        return d;
    }
}
```

### 3.3 평탄화의 핵심: UniRelay를 통한 결과 전파

UniRelay는 **내부 future의 완료를 감지하여 외부 future로 결과를 전달하는 경량 completion 노드**다:

```java
static final class UniRelay<U, T extends U> extends UniCompletion<T, U> {
    UniRelay(CompletableFuture<T> src, CompletableFuture<U> dep) {
        super(null, dep, src);
    }
    
    final CompletableFuture<U> tryFire(int mode) {
        CompletableFuture<U> d;
        CompletableFuture<T> a;
        Object r;
        
        if ((d = dep) == null || (a = src) == null || (r = a.result) == null)
            return null;
        
        // 핵심: src의 결과를 dep로 직접 복사
        if (d.result == null) {
            d.completeRelay(r);
        }
        
        return d;
    }
}
```

**completeRelay()의 역할**은 매우 명확하다:

```java
final boolean completeRelay(Object r) {
    return RESULT.compareAndSet(this, null, r);
}
```

이는 단순히 `this.result = r`을 CAS(Compare-And-Set) 연산으로 수행하는 것이다. **inner future의 result 필드 값이 outer future의 result 필드로 직접 복사**된다.

---

## 4. 비동기 체이닝 패턴과 실전 아키텍처

### 4.1 의존적 비동기 작업 체이닝

각 단계가 이전 단계의 결과에 의존하는 전형적인 패턴이다. 마이크로서비스 아키텍처에서 가장 흔하게 발생하는 시나리오다:

```java
public class OrderService {
    
    public CompletableFuture<OrderConfirmation> processOrder(String sessionToken) {
        return CompletableFuture
            .supplyAsync(() -> authService.validateSession(sessionToken))
            .thenCompose(session -> userService.getUser(session.getUserId()))
            .thenCompose(user -> inventoryService.checkAvailability(user, cartId))
            .thenCompose(availability -> {
                if (!availability.isAvailable()) {
                    return CompletableFuture.failedFuture(
                        new OutOfStockException()
                    );
                }
                return paymentService.processPayment(user, availability);
            })
            .thenCompose(payment -> orderRepository.createOrder(payment))
            .thenCompose(order -> notificationService.sendConfirmation(order))
            .exceptionally(ex -> {
                log.error("Order processing failed", ex);
                return OrderConfirmation.failed(ex.getMessage());
            });
    }
}
```

**구조적 특징**:
- 각 `thenCompose()`는 이전 단계의 결과를 받아 새로운 비동기 작업을 시작
- 타입은 전체 체인에서 `CompletableFuture<OrderConfirmation>`으로 평탄하게 유지
- 단일 `exceptionally()` 핸들러로 전체 체인의 에러를 일관되게 처리

만약 `thenApply()`를 잘못 사용했다면:

```java
// 안티패턴 - 컴파일조차 거의 불가능한 코드
CompletableFuture<CompletableFuture<CompletableFuture<CompletableFuture<...>>>> hell = 
    CompletableFuture.supplyAsync(() -> authService.validateSession(sessionToken))
        .thenApply(session -> userService.getUser(session.getUserId()))
        .thenApply(userFuture -> 
            userFuture.thenApply(user -> 
                inventoryService.checkAvailability(user, cartId)
            )
        )
        .thenApply(availabilityFuture ->
            availabilityFuture.thenApply(innerFuture ->
                innerFuture.thenApply(availability -> ...
```

코드 자체가 유지보수 불가능해진다.

### 4.2 조건부 분기와 thenCompose의 활용

비즈니스 로직에 조건부 분기가 필요한 경우, `thenCompose()`는 다른 비동기 경로를 선택하는 라우터 역할을 한다:

```java
public CompletableFuture<ShippingInfo> getShippingInfo(Order order) {
    return CompletableFuture
        .supplyAsync(() -> order.getDestinationCountry())
        .thenCompose(country -> {
            // 국가별로 다른 배송 서비스 호출
            if ("KR".equals(country)) {
                return domesticShippingService.calculate(order);
            } else if (isEUCountry(country)) {
                return euShippingService.calculate(order, country);
            } else {
                return internationalShippingService.calculate(order, country);
            }
        })
        .thenCompose(shippingCost -> {
            // 비용에 따라 다른 결제 처리
            if (shippingCost.isExpressAvailable()) {
                return offerExpressOption(order, shippingCost);
            } else {
                return confirmStandardShipping(order, shippingCost);
            }
        });
}
```

각 분기에서 반환되는 CompletableFuture가 평탄화되어, 최종 타입은 항상 `CompletableFuture<ShippingInfo>`로 유지된다.

### 4.3 병렬 작업과 순차 작업의 혼합

`thenCompose()` 내부에서 여러 비동기 작업을 병렬로 시작한 후, 그 결과들을 조합하는 복잡한 패턴:

```java
public CompletableFuture<ProductDetail> getEnrichedProduct(String productId) {
    return CompletableFuture
        .supplyAsync(() -> productRepository.findById(productId))
        .thenCompose(product -> {
            // 병렬로 여러 서비스 호출
            CompletableFuture<Category> categoryFuture = 
                categoryService.getCategory(product.getCategoryId());
            
            CompletableFuture<List<Review>> reviewsFuture = 
                reviewService.getReviews(productId);
            
            CompletableFuture<Inventory> inventoryFuture = 
                inventoryService.getStock(productId);
            
            CompletableFuture<Supplier> supplierFuture = 
                supplierService.getSupplier(product.getSupplierId());
            
            // 모든 결과를 조합
            return CompletableFuture
                .allOf(categoryFuture, reviewsFuture, inventoryFuture, supplierFuture)
                .thenApply(v -> new ProductDetail(
                    product,
                    categoryFuture.join(),
                    reviewsFuture.join(),
                    inventoryFuture.join(),
                    supplierFuture.join()
                ));
        });
}
```

**아키텍처 분석**:
1. `thenCompose()` 블록 내부에서 4개의 비동기 작업을 병렬로 시작
2. `allOf()`로 모든 작업의 완료를 대기
3. `thenApply()`로 결과들을 동기적으로 조합
4. 최종적으로 `CompletableFuture<CompletableFuture<ProductDetail>>`이 아닌 `CompletableFuture<ProductDetail>` 반환

이는 평탄화 메커니즘이 없다면 구현이 매우 복잡해지는 패턴이다.

---

## 5. 성능 특성과 올바른 사용 기준

### 5.1 불필요한 thenCompose() 사용의 오버헤드 분석

`thenCompose()`는 평탄화를 위해 추가적인 객체를 생성한다:
- UniCompose 노드 생성 및 completion stack 등록
- 내부 future 생성
- UniRelay 노드 생성 (내부 future가 미완료인 경우)

만약 단순 변환 작업에 `thenCompose()`를 사용하면 불필요한 오버헤드가 발생한다:

```java
// 안티패턴: 동기 변환에 thenCompose() 사용
CompletableFuture<String> inefficient = userFuture.thenCompose(user -> 
    CompletableFuture.completedFuture(user.getName().toUpperCase())
);

// 올바른 패턴: thenApply() 사용
CompletableFuture<String> efficient = userFuture.thenApply(user -> 
    user.getName().toUpperCase()
);
```

**inefficient 버전의 오버헤드**:
1. `CompletableFuture.completedFuture()` 호출 → 불필요한 CompletableFuture 인스턴스 생성 (약 56 바이트 메모리)
2. UniCompose 노드 생성 → 약 32 바이트
3. UniRelay 노드 생성 (내부 future가 이미 완료되어 있으면 생략될 수 있음)
4. completion 전파 로직 실행

**efficient 버전**:
1. UniApply 노드만 생성 → 약 32 바이트
2. 함수 즉시 실행 및 결과 설정

마이크로벤치마크에서는 약 2-3배의 성능 차이가 측정되지만, 실제 비즈니스 로직에서 I/O 비용(네트워크, 데이터베이스)이 지배적이므로 대부분의 경우 무시할 수 있는 수준이다.

### 5.2 thenApply() 오용의 복잡도 문제

반대로 `thenApply()`를 비동기 작업에 사용하면 **성능 문제보다 코드 복잡도와 유지보수성 문제**가 훨씬 심각하다:

```java
// thenApply() 오용 - 타입 중첩 발생
CompletableFuture<CompletableFuture<User>> nested = 
    idFuture.thenApply(id -> fetchUser(id));

// 사용 코드가 복잡해짐
nested.thenAccept(userFuture -> {
    userFuture.thenAccept(user -> {
        // 실제 User 객체 사용
        processUser(user);
    }).exceptionally(ex -> {
        // 내부 future의 예외 처리
        handleInnerError(ex);
        return null;
    });
}).exceptionally(ex -> {
    // 외부 future의 예외 처리
    handleOuterError(ex);
    return null;
});
```

**구조적 문제점**:
1. 중첩된 콜백 구조 (Callback Hell)
2. 예외 처리가 각 레벨에서 분리됨
3. 어느 레벨에서 예외가 발생했는지 파악 어려움
4. 코드 가독성 심각하게 저하

`thenCompose()`를 사용하면:

```java
// 올바른 패턴
CompletableFuture<User> flat = idFuture.thenCompose(id -> fetchUser(id));

// 깔끔한 선형 구조
flat.thenAccept(user -> processUser(user))
    .exceptionally(ex -> {
        handleError(ex);  // 전체 체인의 에러를 한 곳에서 처리
        return null;
    });
```

---

## 6. 결론: 평탄화의 설계적 의의

### 6.1 타입 시스템과 비즈니스 로직의 정렬

`thenCompose()`의 평탄화 메커니즘은 단순한 syntactic sugar가 아니라, **타입 시스템이 비즈니스 로직의 의도를 정확히 표현하도록 만드는 구조적 설계**다. 

"사용자 ID로 사용자를 조회하고, 그 사용자의 주문을 조회한다"는 비즈니스 의도는 타입 `CompletableFuture<Order>`로 직접 표현되어야 한다. `CompletableFuture<CompletableFuture<Order>>`라는 중첩 타입은 "주문을 조회하는 작업을 조회하는 작업"이라는 무의미한 의미론을 갖는다.

평탄화는 이러한 타입 왜곡을 방지하여, 코드가 비즈니스 도메인의 개념을 직접적으로 반영하도록 한다.

### 6.2 CompletableFuture의 설계 철학

`thenApply()`와 `thenCompose()`의 분리는 CompletableFuture가 단순한 비동기 유틸리티가 아니라, **타입 안전한 함수형 비동기 프로그래밍 프레임워크**임을 보여준다.

이 설계는 다음 원칙들을 반영한다:
1. **타입 안전성**: 컴파일 타임에 최대한 많은 에러를 잡는다
2. **의도 명시성**: 코드가 무엇을 하는지 타입으로 표현한다
3. **합성 가능성**: 작은 비동기 작업들을 조합하여 복잡한 워크플로우를 구성한다
4. **에러 처리의 일관성**: 전체 체인을 단일 exceptionally()로 처리한다

### 6.3 현대 비동기 프레임워크로의 영향

CompletableFuture의 평탄화 개념은 Java 생태계를 넘어 확산되었다:

- **Reactive Streams (Project Reactor)**: `Mono.flatMap()`, `Flux.flatMap()`
- **Kotlin Coroutines**: `Flow.flatMapConcat()`, `Flow.flatMapMerge()`
- **JavaScript Promises**: `.then(f)` (자동 평탄화)
- **C# Tasks**: `Task.ContinueWith()`와 `await` 키워드

이는 비동기 프로그래밍이 직면한 **보편적 문제**에 대한 **검증된 해법**이며, 언어와 플랫폼을 초월한 설계 패턴으로 자리 잡았다.

평탄화 메커니즘을 이해하는 것은 현대적인 비동기 아키텍처를 설계하고 구현하는 데 필수적이다. 이는 복잡한 비동기 워크플로우를 관리 가능한 수준으로 유지하는 핵심 도구이며, 타입 시스템을 통해 코드의 정확성을 보장하는 강력한 추상화다.
