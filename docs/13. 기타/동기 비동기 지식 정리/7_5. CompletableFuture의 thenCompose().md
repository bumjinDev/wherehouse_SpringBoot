# CompletableFuture의 thenCompose() 중첩 제거 메커니즘
## 타입 중첩 제거와 비동기 체이닝의 구조적 설계

---

# 개요: 중첩 제거 메커니즘

## 1. 왜 중첩 제거가 필요한가

### 1.1 비동기 체이닝에서 발생하는 타입 중첩 문제

비동기 작업을 연속적으로 체이닝할 때 근본적인 구조적 문제가 발생한다. 현대 마이크로서비스 아키텍처에서는 각 서비스 호출이 네트워크 I/O를 수반하므로 필연적으로 CompletableFuture를 반환한다. 문제는 이러한 비동기 작업의 결과를 받아서 또 다른 비동기 작업을 시작해야 할 때 발생한다.

예를 들어 전자상거래 시스템에서 주문을 처리하는 과정을 생각해보자. 먼저 인증 서비스에서 사용자를 검증하고, 그 결과인 사용자 ID로 재고 서비스를 조회하며, 다시 그 결과로 결제 서비스를 호출한다. 각 단계가 CompletableFuture를 반환하는 비동기 작업이다. 

thenApply()를 사용하면 이러한 체인이 만들어진다: 첫 번째 서비스가 `CompletableFuture<UserId>`를 반환하고, 이를 받아 재고 서비스를 호출하는 함수가 `CompletableFuture<Inventory>`를 반환한다면, thenApply()는 이를 그대로 새로운 CompletableFuture로 감싸서 `CompletableFuture<CompletableFuture<Inventory>>`를 만든다. 세 번째 단계를 거치면 `CompletableFuture<CompletableFuture<CompletableFuture<Payment>>>`라는 삼중 중첩이 발생한다.

### 1.2 타입 중첩이 야기하는 실제 문제

이러한 타입 중첩은 단순한 문법적 불편함이 아니다. 실제 Payment 객체에 접근하려면 세 번의 join()을 호출해야 한다. 각 중첩 레벨마다 별도의 예외 처리가 필요하며, 어느 레벨에서 발생한 예외인지 추적하기 어렵다. 

더 심각한 것은 비즈니스 로직의 의도가 왜곡된다는 점이다. "사용자를 인증하고, 재고를 확인한 후, 결제를 처리한다"는 선형적이고 명확한 흐름이 "결제 처리 작업을 조회하는 작업을 조회하는 작업"이라는 무의미한 중첩 구조로 변질된다. 코드를 읽는 사람은 실제 비즈니스 플로우를 파악하기 어려워지고, 유지보수성이 크게 저하된다.

### 1.3 연쇄 체이닝에서의 타입 전파 실패

타입 중첩의 가장 치명적인 문제는 후속 비동기 작업을 자연스럽게 체이닝할 수 없다는 것이다. 이것이 단순한 타입 불편함을 넘어 치명적인 이유는, 비동기 체인의 자동 실행 메커니즘 자체가 붕괴되기 때문이다.

**체인 자동 실행의 정상 동작:**

체인의 각 단계는 이전 CompletableFuture가 완료되면 자동으로 트리거된다. 이때 각 단계가 받는 입력은 "이전 CompletableFuture가 담고 있는 값", 즉 실제 비즈니스 데이터다. 인증 → 장바구니 조회 → 재고 확인 체인에서, 재고 확인 단계는 Cart 객체를 받아야 한다.

**thenApply() 오용 시 발생하는 타입 전파 실패:**

1단계: supplyAsync()가 인증 토큰을 생성한다. CompletableFuture<String>이 반환된다.

2단계: thenApply()에 장바구니 조회 함수를 전달한다. 이 함수는 CompletableFuture<Cart>를 반환한다(네트워크 I/O이므로 비동기 작업). thenApply()는 이 CompletableFuture 객체 자체를 래핑하여 CompletableFuture<CompletableFuture<Cart>>를 생성한다.

**여기서 체인이 붕괴한다.**

3단계: 재고 확인 함수가 트리거되어야 하는데, 이 함수가 받는 입력이 문제다.
- **개발자의 기대**: Cart 객체를 받아 `cart.getItems()`를 호출
- **실제로 받는 것**: CompletableFuture<Cart> 객체

3단계 함수는 Cart의 메서드를 호출하려고 시도하지만, 받은 것은 CompletableFuture이므로 컴파일 에러가 발생한다. CompletableFuture에는 getItems() 메서드가 없기 때문이다.

**강제 해결 시도의 문제:**

개발자가 이 문제를 인지하고 `cart.join()`을 호출하여 실제 Cart를 추출하려고 시도할 수 있다. 하지만 join()은 블로킹 호출이다. 3단계를 실행하는 스레드가 CompletableFuture<Cart>가 완료될 때까지 대기하게 되며, 이것은 전체 비동기 파이프라인을 동기 방식으로 전락시킨다.

더 나쁜 것은 4단계, 5단계가 추가되면 각 단계마다 이러한 중첩 해소를 수동으로 수행해야 하며, 중첩 깊이가 늘어날수록 코드는 기하급수적으로 복잡해져 사실상 작성 불가능해진다. 이것이 바로 thenApply()를 CompletableFuture 반환 함수에 사용할 수 없는 구조적 이유다.

---

## 2. thenCompose()의 중첩 제거 메커니즘

### 2.1 중첩 제거의 핵심 원리

thenCompose()의 핵심은 **함수가 반환하는 CompletableFuture를 새로운 CompletableFuture로 감싸지 않는다**는 것이다. 대신 함수가 반환한 CompletableFuture의 결과를 thenCompose()가 반환하는 CompletableFuture로 직접 전달한다. 

이 과정을 단계별로 분해하면 다음과 같다. thenCompose()가 호출되면 즉시 새로운 CompletableFuture를 생성하여 호출자에게 반환한다. 이 CompletableFuture를 "결과 컨테이너"라고 하자. 중요한 점은 이 시점에서 사용자가 제공한 함수는 아직 실행되지 않았다는 것이다. 결과 컨테이너는 미완료 상태의 빈 껍데기로 반환되며, 호출자는 이 future에 대해 추가적인 체이닝을 즉시 수행할 수 있다.

### 2.2 이벤트 전파 체인의 동작

선행 작업이 완료되면 중첩 제거의 핵심 메커니즘이 작동한다.

선행 CompletableFuture가 완료되면 그 결과값을 추출하여 사용자가 제공한 함수에 전달한다. 이 함수는 새로운 CompletableFuture를 반환하는데, 이것을 "중간 작업"이라고 하자. 예를 들어 사용자 ID를 받아 데이터베이스에서 사용자 정보를 조회하는 비동기 작업을 시작하고, 그 작업을 나타내는 CompletableFuture를 반환한다.

이 중간 작업에 특별한 콜백이 등록된다. 이 콜백의 역할은 명확하다: "중간 작업이 완료되면 그 결과를 가져와서 결과 컨테이너의 complete() 메서드를 호출하라." 이것이 중첩 제거의 핵심이다. 중간 작업의 결과가 결과 컨테이너로 직접 복사되는 것이다.

중간 작업이 완료되면(예: 데이터베이스 조회가 끝나면) 등록된 콜백이 트리거된다. 이 콜백은 중간 작업의 결과값을 읽어서 결과 컨테이너의 result 필드에 직접 설정한다. 이 시점에서 중간 작업은 더 이상 필요 없으며 가비지 컬렉션의 대상이 된다.

사용자는 결과 컨테이너만 보게 되며, 중첩 없이 단일 join()으로 최종 결과에 접근할 수 있다. 타입은 `CompletableFuture<T>`로 유지되며, 중간의 CompletableFuture는 중첩 제거 과정에서만 일시적으로 존재했을 뿐이다.

### 2.3 예외 전파의 투명성

중첩 제거 메커니즘은 정상 값뿐만 아니라 예외도 동일하게 처리한다. 중간 작업에서 예외가 발생하면 완료 콜백은 이를 감지하여 결과 컨테이너의 completeExceptionally() 메서드를 호출한다. 

이는 매우 중요한 특성이다. 중간 계층이 없으므로 예외가 직접 전파되며, 예외의 스택 트레이스가 원본 그대로 유지된다. 개발자는 어느 서비스 호출에서 예외가 발생했는지 명확히 파악할 수 있고, 전체 체인에 대해 단일 exceptionally 핸들러로 일관된 에러 처리를 수행할 수 있다.

---

## 3. thenApply()와 thenCompose()의 구조적 차이와 역할

### 3.1 메서드의 근본적 역할 구분

thenApply()와 thenCompose()는 CompletableFuture의 인스턴스 메서드이며, 둘 다 이미 존재하는 CompletableFuture에 대한 변환 연산을 수행한다. 하지만 이들이 처리하는 변환의 성격이 근본적으로 다르다.

thenApply()는 동기적 변환을 위해 설계되었다. 제공된 함수가 즉시 계산 가능한 값을 반환하는 경우, 즉 블로킹 없이 결과를 생성할 수 있는 순수 함수에 적합하다. 문자열 변환, 숫자 계산, 객체 필드 접근 같은 작업이 여기에 해당한다. 함수가 반환하는 값이 무엇이든 thenApply()는 이를 새로운 CompletableFuture로 래핑하여 반환한다.

thenCompose()는 비동기적 변환을 위해 설계되었다. 제공된 함수가 또 다른 비동기 작업을 시작하여 CompletableFuture를 반환하는 경우에 사용된다. 데이터베이스 조회, 외부 API 호출, 파일 I/O 같은 작업이 여기에 해당한다. 함수가 반환하는 CompletableFuture를 추가로 래핑하지 않고, 그 완료 이벤트를 외부로 직접 전파한다.

### 3.2 타입 제약을 통한 의도 명시

thenApply()의 메서드 시그니처는 `public <U> CompletableFuture<U> thenApply(Function<T, U> fn)`이다. 제네릭 타입 파라미터 U에는 어떠한 제약도 없다. 함수가 String을 반환하면 `CompletableFuture<String>`을, Integer를 반환하면 `CompletableFuture<Integer>`를 만든다. 문제는 함수가 이미 CompletableFuture를 반환할 때다. thenApply()는 이것도 그대로 감싸서 `CompletableFuture<CompletableFuture<T>>`를 만든다.

반면 thenCompose()의 시그니처는 `public <U> CompletableFuture<U> thenCompose(Function<T, CompletionStage<U>> fn)`이다. 함수가 반드시 CompletionStage(실질적으로 CompletableFuture)를 반환하도록 요구한다. 이 제약은 두 가지 목적을 달성한다. 첫째, 개발자가 의도를 명확히 표현하도록 강제한다. 일반 객체를 반환하는 함수를 실수로 전달하면 컴파일 에러가 발생한다. 둘째, 컴파일러와 런타임이 중첩 제거가 필요한 상황임을 인지하고 적절한 처리를 수행할 수 있다.

### 3.3 선택 기준: 함수의 반환 타입

두 메서드의 선택은 오직 하나의 기준에 의해 결정된다: 제공하는 함수가 무엇을 반환하는가?

함수가 일반 객체(String, Integer, User 등)를 반환하면 thenApply()를 사용한다. 함수가 CompletableFuture를 반환하면 thenCompose()를 사용한다. 이것은 권장사항이 아니라 필수 요구사항이다. 잘못된 선택은 타입 중첩이나 컴파일 에러를 발생시킨다.

이 선택은 함수가 어느 스레드에서 실행되는지, 동기인지 비동기인지와는 무관하다. 순전히 반환 타입의 문제다. 함수가 비즈니스 데이터를 직접 반환하면 thenApply()를, 비동기 작업을 나타내는 CompletableFuture를 반환하면 thenCompose()를 사용한다.

### 3.4 thenApply()의 체이닝 범용성과 인스턴스 독립성

thenApply()는 CompletableFuture 타입의 인스턴스 메서드이며, 그 인스턴스가 어떤 방식으로 생성되었는지와 무관하게 호출 가능하다. 이는 메서드 체이닝 설계의 핵심 원칙이다.

thenApply()의 호출 전제 조건은 호출 대상이 CompletableFuture 타입의 인스턴스여야 한다는 것뿐이다. supplyAsync()는 이 인스턴스를 생성하는 여러 방법 중 하나에 불과하다. completedFuture()로 생성된 이미 완료된 Future에도, thenCompose()의 반환값에도, 외부에서 파라미터로 받은 CompletableFuture에도 thenApply()를 적용할 수 있다.

각 thenApply() 호출은 새로운 CompletableFuture를 반환하며, 이 반환된 인스턴스에 다시 thenApply()를 적용할 수 있다. 이것은 Stream API에서 map()이나 filter()를 연속으로 체이닝하는 것과 동일한 합성 가능성 설계 패턴이다.

만약 thenApply()가 supplyAsync() 직후에만 사용 가능하다면 중간에 다른 변환 연산을 거친 Future에는 적용할 수 없게 되어 체이닝의 유연성이 심각하게 제한된다. 현재의 설계는 각 변환 메서드가 입력 타입과 출력 타입만 올바르면 어떤 순서로든 조합 가능하도록 보장한다.

### 3.5 사용 시점의 명확한 구분

두 메서드의 사용 시점은 명확히 구분된다.

thenApply()를 사용하는 경우는 동기적 변환 작업(`user -> user.getName()`), 즉시 계산 가능한 값(`price -> price * 1.1`), I/O 작업이 없는 순수 함수(`list -> list.size()`)다.

thenCompose()를 사용하는 경우는 데이터베이스 조회(`userId -> findUserById(userId)`), 외부 API 호출(`order -> paymentService.process(order)`), 또 다른 비동기 작업 시작(`file -> readFileAsync(file)`)이다.

이 구분을 지키지 않으면 타입 중첩이나 불필요한 오버헤드가 발생한다.

---

## 4. 핵심 정리

### 4.1 중첩 제거의 본질적 가치

thenCompose()의 중첩 제거는 단순한 편의 기능이 아니라 비동기 프로그래밍의 복잡성을 관리하기 위한 필수적인 메커니즘이다. 핵심은 함수가 반환한 CompletableFuture의 결과를 thenCompose()가 반환하는 CompletableFuture로 직접 전파하여, 타입 중첩 없이 선형적인 비동기 파이프라인을 구성하는 것이다.

이를 통해 타입 시스템이 비즈니스 로직의 의도를 정확히 표현할 수 있다. "A 후 B 후 C"라는 단순한 흐름이 복잡한 중첩 타입으로 왜곡되지 않고, 그대로 코드에 반영된다.

### 4.2 설계 원칙과 선택 기준

개발자는 명확한 기준을 가지고 두 메서드를 선택해야 한다. 함수가 일반 객체를 반환하면 thenApply()를, CompletableFuture를 반환하면 thenCompose()를 사용한다. 이는 선택사항이 아니라 필수 요구사항이다. 잘못된 선택은 타입 중첩이나 불필요한 오버헤드를 발생시킨다.

### 4.3 현대 비동기 프로그래밍에서의 위치

thenApply()와 thenCompose()의 분리는 CompletableFuture가 단순한 비동기 유틸리티가 아니라, 정교한 타입 시스템을 갖춘 비동기 프로그래밍 프레임워크임을 보여준다. 이는 Java 생태계의 표준이 되었으며, Reactive Streams, Kotlin Coroutines 등 다른 비동기 프레임워크들도 동일한 중첩 제거 개념을 채택했다.

중첩 제거 메커니즘을 이해하는 것은 현대적인 비동기 아키텍처를 설계하고 구현하는 데 필수적이다. 이는 비동기 프로그래밍이 직면한 보편적 문제에 대한 검증된 해법이며, 복잡한 비동기 워크플로우를 관리 가능한 수준으로 유지하는 핵심 도구다.

---

# 본문: 타입 중첩과 중첩 제거의 구조적 분석

## 1. thenApply()의 무제약 제네릭과 타입 중첩의 구조적 원인

### 1.1 제네릭 타입 시스템의 제약 부재

`thenApply()`의 메서드 시그니처는 Java의 제네릭 시스템이 제공하는 최대 유연성을 활용한다:

```java
public <U> CompletableFuture<U> thenApply(Function<T, U> fn)
```

제네릭 타입 파라미터 `U`에는 어떠한 상한(upper bound)이나 하한(lower bound) 제약도 존재하지 않는다. 이는 `U`가 Java의 모든 참조 타입(reference type)이 될 수 있음을 의미하며, 여기에는 `CompletableFuture<T>`, `Optional<T>`, `List<T>` 같은 제네릭 컨테이너 타입도 포함된다.

이러한 무제약 설계는 의도적인 것이다. `thenApply()`는 **블로킹 없이 즉시 계산 가능한 변환(non-blocking computation)**을 위해 설계되었으며, 변환 함수가 어떤 타입을 반환하든 그것을 CompletableFuture로 감싸는 것이 올바른 동작이다. 문제는 개발자가 이 메서드를 **비동기 작업을 반환하는 함수**에 적용할 때 발생한다.

### 1.2 타입 중첩의 메모리 구조와 접근 경로

구체적인 예시로 타입 중첩의 구조를 분석해보자:

```java
CompletableFuture<Integer> userIdFuture = CompletableFuture.completedFuture(12345);

Function<Integer, CompletableFuture<User>> fetchUser = 
    id -> CompletableFuture.supplyAsync(() -> new User(id, "John"));

// thenApply() 사용 - 타입 중첩 발생
CompletableFuture<CompletableFuture<User>> nested = userIdFuture.thenApply(fetchUser);
```

Java 컴파일러의 타입 추론 엔진은 다음과 같이 타입을 추론한다:
- `fetchUser`의 반환 타입: `CompletableFuture<User>`
- 이를 제네릭 파라미터 `U`에 바인딩: `U = CompletableFuture<User>`
- 최종 반환 타입: `CompletableFuture<U>` = `CompletableFuture<CompletableFuture<User>>`

**컴파일러는 이를 전혀 문제 삼지 않는다.** 타입 규칙을 완벽히 준수한 코드이기 때문이다.


### 1.3 타입 왜곡이 초래하는 설계 문제

더 심각한 것은 타입이 비즈니스 의도를 왜곡한다는 점이다. 개발자의 의도는 "사용자 ID로 사용자를 비동기 조회한다"는 것이지만, 타입 `CompletableFuture<CompletableFuture<User>>`는 "사용자 조회 작업을 조회하는 작업"이라는 불필요한 중첩 구조를 표현한다. 이는 비즈니스 로직의 의도를 타입 시스템이 정확히 반영하지 못하는 것이다.

이러한 타입 중첩은 체이닝이 길어질수록 기하급수적으로 악화된다:

```java
CompletableFuture<Integer> step1 = getSessionToken();

CompletableFuture<CompletableFuture<User>> step2 = 
    step1.thenApply(token -> getUserId(token));

CompletableFuture<CompletableFuture<CompletableFuture<Order>>> step3 = 
    step2.thenApply(userFuture -> 
        userFuture.thenApply(user -> getOrders(user))
    );

// 이 시점에서 타입이 3중 중첩되어 코드 자체가 거의 작성 불가능해진다
```

---

## 2. 체이닝 실행 흐름과 타입 전파 메커니즘

### 2.1 이벤트 기반 체이닝의 자동 실행 구조

CompletableFuture 체인은 각 단계가 이전 단계의 완료에 반응하여 자동으로 실행되는 이벤트 기반 아키텍처를 따른다. 체인이 생성되는 시점에는 각 단계의 함수가 즉시 실행되지 않으며, 대신 이전 CompletableFuture에 콜백으로 등록된다. 해당 CompletableFuture가 완료될 때 콜백이 트리거되고, 완료된 CompletableFuture의 result 필드에서 값을 읽어 등록된 함수에 전달한다. 함수의 반환값은 다음 CompletableFuture를 완료시키는 데 사용된다.

이 자동 실행 메커니즘의 핵심은 각 단계가 "이전 CompletableFuture에 저장된 값"을 입력으로 받아 처리한다는 것이다. 이 메커니즘은 thenApply()와 thenCompose() 모두 동일하게 작동하지만, 함수의 반환값을 처리하는 방식에서 결정적 차이가 발생한다. 함수가 일반 객체를 반환하면 문제가 없지만, CompletableFuture를 반환하는 경우 thenApply()는 타입 중첩을 야기하여 후속 단계의 타입 전파를 파괴한다.

### 2.2 thenApply() 오용 시의 타입 전파 실패 메커니즘

마이크로서비스 환경에서 인증 토큰으로 사용자를 조회하고, 장바구니를 가져온 뒤, 재고를 확인하는 체인을 구현한 경우를 분석한다.

```java
public class OrderService {
    
    // 각 서비스 호출은 네트워크 I/O이므로 CompletableFuture 반환
    private CompletableFuture<User> fetchUser(String authToken) {
        return CompletableFuture.supplyAsync(() -> {
            // 인증 서비스 API 호출 시뮬레이션
            System.out.println("[fetchUser] 인증 토큰 검증 중: " + authToken);
            return new User(12345L, "John Doe");
        });
    }
    
    private CompletableFuture<Cart> fetchCart(Long userId) {
        return CompletableFuture.supplyAsync(() -> {
            // 장바구니 서비스 API 호출 시뮬레이션
            System.out.println("[fetchCart] 사용자 ID로 장바구니 조회 중: " + userId);
            return new Cart(userId, List.of("Item1", "Item2"));
        });
    }
    
    private CompletableFuture<InventoryStatus> checkInventory(Cart cart) {
        return CompletableFuture.supplyAsync(() -> {
            // 재고 서비스 API 호출 시뮬레이션
            System.out.println("[checkInventory] 장바구니 품목 재고 확인 중: " + cart.getItems());
            return new InventoryStatus(true, cart.getItems().size());
        });
    }
    
    // ❌ 잘못된 구현 - thenApply() 오용으로 타입 중첩 발생
    public CompletableFuture<?> processOrderWrong(String authToken) {
        // 1단계: 사용자 조회
        CompletableFuture<User> step1 = fetchUser(authToken);
        
        // 2단계: 장바구니 조회 - 여기서 타입 중첩 발생
        CompletableFuture<CompletableFuture<Cart>> step2 = 
            step1.thenApply(user -> fetchCart(user.getId()));
        
        // step2의 타입: CompletableFuture<CompletableFuture<Cart>>
        // step2.result는 Cart 객체가 아니라 CompletableFuture<Cart> 객체를 가리킴
        
        // 3단계: 재고 확인을 시도하지만 타입 불일치로 체이닝 불가능
        // ❌ 컴파일 에러 발생:
        // step2.thenApply(cart -> checkInventory(cart));
        // → cart의 타입이 CompletableFuture<Cart>이므로
        // → cart.getItems() 호출 불가 (CompletableFuture에는 getItems() 메서드 없음)
        
        // 수동으로 중첩 해소 시도 시 타입 중첩 심화
        CompletableFuture<CompletableFuture<CompletableFuture<InventoryStatus>>> step3 =
            step2.thenApply(cartFuture -> 
                cartFuture.thenApply(cart -> 
                    checkInventory(cart)  // 또 다시 CompletableFuture 반환
                )
            );
        
        // 3중 중첩 타입으로 인해 코드 작성 불가능
        return step3;
    }
}
```

**타입 전파 실패의 단계별 분석:**

1. step1이 완료되면 User 객체가 step1.result에 저장된다.
2. step2의 콜백이 트리거되어 User 객체를 받아 `fetchCart(user.getId())`를 실행한다.
3. `fetchCart()` 메서드는 CompletableFuture<Cart>를 반환한다.
4. **핵심 문제**: thenApply()는 이 CompletableFuture<Cart> 객체 자체를 step2의 result 필드에 저장한다.
5. step2는 즉시 완료 상태가 되며, step2.result는 Cart 객체가 아니라 CompletableFuture<Cart> 객체를 가리킨다.
6. step3의 콜백이 트리거되면 step2.result에서 CompletableFuture<Cart>를 읽어 함수에 전달한다.
7. 함수의 인자 타입이 Cart가 아니라 CompletableFuture<Cart>가 되므로 `cart.getItems()` 호출 시 컴파일 에러가 발생한다.

### 2.3 thenCompose()의 평탄한 타입 전파 구현

동일한 시나리오를 thenCompose()로 구현하면 타입이 평탄하게 유지되며 체이닝이 자연스럽게 작동한다.

```java
public class OrderService {
    
    // ✅ 올바른 구현 - thenCompose() 사용으로 타입 중첩 제거
    public CompletableFuture<OrderResult> processOrderCorrect(String authToken) {
        return fetchUser(authToken)
            .thenCompose(user -> {
                System.out.println("[Chain] User 획득: " + user.getName());
                // fetchCart()가 CompletableFuture<Cart> 반환
                // thenCompose()가 중첩 제거 수행
                return fetchCart(user.getId());
            })
            .thenCompose(cart -> {
                System.out.println("[Chain] Cart 획득, 품목 수: " + cart.getItems().size());
                // checkInventory()가 CompletableFuture<InventoryStatus> 반환
                // thenCompose()가 중첩 제거 수행
                return checkInventory(cart);
            })
            .thenApply(inventory -> {
                System.out.println("[Chain] 재고 확인 완료: " + inventory.isAvailable());
                // 마지막 단계: 즉시 계산 가능한 변환 → thenApply 사용
                return new OrderResult(inventory.isAvailable(), inventory.getQuantity());
            })
            .exceptionally(ex -> {
                // 전체 체인에 대한 통합 예외 처리
                System.err.println("[Chain] 주문 처리 실패: " + ex.getMessage());
                return OrderResult.failed(ex.getMessage());
            });
    }
}
```

**평탄한 타입 전파의 단계별 메커니즘:**

1. step1(fetchUser)이 완료되면 User 객체가 step1.result에 저장된다.
2. step2의 콜백이 트리거되어 User 객체를 받아 `fetchCart(user.getId())`를 실행한다.
3. `fetchCart()` 메서드는 CompletableFuture<Cart>를 반환한다. 이것을 CF_cart라고 명명한다.
4. **핵심 차이**: thenCompose()는 CF_cart를 step2의 result에 직접 저장하지 않는다.
5. 대신 CF_cart에 특별한 완료 콜백을 등록한다: "CF_cart가 완료되면 그 결과를 step2.result에 복사하라."
6. step2는 CF_cart가 완료될 때까지 미완료 상태로 대기한다.
7. CF_cart가 완료되어 Cart 객체가 CF_cart.result에 저장되면, 등록된 콜백이 트리거된다.
8. 이 콜백은 Cart 객체를 step2.result에 직접 복사한다.
9. step2가 완료 상태가 되며, step2.result는 Cart 객체를 가리킨다. CompletableFuture<Cart>가 아니다.
10. step3의 콜백이 트리거되면 step2.result에서 Cart 객체를 읽어 함수에 전달한다.
11. 함수는 정확히 기대한 타입인 Cart를 받으므로 `cart.getItems()` 호출이 자연스럽게 작동한다.

### 2.4 실행 가능한 완전한 예시 코드

타입 전파 메커니즘을 직접 실행하여 확인할 수 있는 완전한 구현 예시다.

```java
import java.util.List;
import java.util.concurrent.CompletableFuture;

// 도메인 모델
class User {
    private final Long id;
    private final String name;
    
    public User(Long id, String name) {
        this.id = id;
        this.name = name;
    }
    
    public Long getId() { return id; }
    public String getName() { return name; }
}

class Cart {
    private final Long userId;
    private final List<String> items;
    
    public Cart(Long userId, List<String> items) {
        this.userId = userId;
        this.items = items;
    }
    
    public Long getUserId() { return userId; }
    public List<String> getItems() { return items; }
}

class InventoryStatus {
    private final boolean available;
    private final int quantity;
    
    public InventoryStatus(boolean available, int quantity) {
        this.available = available;
        this.quantity = quantity;
    }
    
    public boolean isAvailable() { return available; }
    public int getQuantity() { return quantity; }
}

class OrderResult {
    private final boolean success;
    private final int itemCount;
    private final String message;
    
    public OrderResult(boolean success, int itemCount) {
        this.success = success;
        this.itemCount = itemCount;
        this.message = success ? "주문 처리 성공" : "주문 처리 실패";
    }
    
    private OrderResult(String message) {
        this.success = false;
        this.itemCount = 0;
        this.message = message;
    }
    
    public static OrderResult failed(String reason) {
        return new OrderResult("실패: " + reason);
    }
    
    @Override
    public String toString() {
        return String.format("OrderResult{success=%s, itemCount=%d, message='%s'}", 
                           success, itemCount, message);
    }
}

// 체이닝 메커니즘 구현
public class TypePropagationDemo {
    
    private CompletableFuture<User> fetchUser(String authToken) {
        return CompletableFuture.supplyAsync(() -> {
            System.out.println("[T1] fetchUser 실행 - 스레드: " + Thread.currentThread().getName());
            simulateDelay(100);
            User user = new User(12345L, "John Doe");
            System.out.println("[T1] fetchUser 완료 - User ID: " + user.getId());
            return user;
        });
    }
    
    private CompletableFuture<Cart> fetchCart(Long userId) {
        return CompletableFuture.supplyAsync(() -> {
            System.out.println("[T2] fetchCart 실행 - 스레드: " + Thread.currentThread().getName());
            simulateDelay(100);
            Cart cart = new Cart(userId, List.of("Item1", "Item2", "Item3"));
            System.out.println("[T2] fetchCart 완료 - Cart 품목 수: " + cart.getItems().size());
            return cart;
        });
    }
    
    private CompletableFuture<InventoryStatus> checkInventory(Cart cart) {
        return CompletableFuture.supplyAsync(() -> {
            System.out.println("[T3] checkInventory 실행 - 스레드: " + Thread.currentThread().getName());
            simulateDelay(100);
            InventoryStatus status = new InventoryStatus(true, cart.getItems().size());
            System.out.println("[T3] checkInventory 완료 - 재고 있음: " + status.isAvailable());
            return status;
        });
    }
    
    private void simulateDelay(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    // thenCompose() 사용 - 평탄한 타입 전파
    public CompletableFuture<OrderResult> processOrderWithCompose(String authToken) {
        System.out.println("\n=== thenCompose() 사용 - 타입 평탄화 ===");
        
        return fetchUser(authToken)
            .thenCompose(user -> {
                System.out.println("[Chain] step1 완료 - User 획득");
                System.out.println("[Chain] 타입: CompletableFuture<User> → User 전달");
                return fetchCart(user.getId());
            })
            .thenCompose(cart -> {
                System.out.println("[Chain] step2 완료 - Cart 획득");
                System.out.println("[Chain] 타입: CompletableFuture<Cart> → Cart 전달");
                return checkInventory(cart);
            })
            .thenApply(inventory -> {
                System.out.println("[Chain] step3 완료 - InventoryStatus 획득");
                System.out.println("[Chain] 타입: CompletableFuture<InventoryStatus> → InventoryStatus 전달");
                return new OrderResult(inventory.isAvailable(), inventory.getQuantity());
            })
            .whenComplete((result, ex) -> {
                if (ex == null) {
                    System.out.println("[Chain] 최종 완료: " + result);
                } else {
                    System.err.println("[Chain] 실패: " + ex.getMessage());
                }
            });
    }
    
    // 실행 메서드
    public static void main(String[] args) {
        TypePropagationDemo demo = new TypePropagationDemo();
        
        // thenCompose() 실행
        CompletableFuture<OrderResult> composeFuture = 
            demo.processOrderWithCompose("auth-token-12345");
        
        // 결과 대기
        try {
            OrderResult result = composeFuture.join();
            System.out.println("\n최종 결과: " + result);
        } catch (Exception e) {
            System.err.println("오류 발생: " + e.getMessage());
        }
    }
}
```

**실행 결과:**

```
=== thenCompose() 사용 - 타입 평탄화 ===
[T1] fetchUser 실행 - 스레드: ForkJoinPool.commonPool-worker-1
[T1] fetchUser 완료 - User ID: 12345
[Chain] step1 완료 - User 획득
[Chain] 타입: CompletableFuture<User> → User 전달
[T2] fetchCart 실행 - 스레드: ForkJoinPool.commonPool-worker-2
[T2] fetchCart 완료 - Cart 품목 수: 3
[Chain] step2 완료 - Cart 획득
[Chain] 타입: CompletableFuture<Cart> → Cart 전달
[T3] checkInventory 실행 - 스레드: ForkJoinPool.commonPool-worker-1
[T3] checkInventory 완료 - 재고 있음: true
[Chain] step3 완료 - InventoryStatus 획득
[Chain] 타입: CompletableFuture<InventoryStatus> → InventoryStatus 전달
[Chain] 최종 완료: OrderResult{success=true, itemCount=3, message='주문 처리 성공'}

최종 결과: OrderResult{success=true, itemCount=3, message='주문 처리 성공'}
```

이 예시는 thenCompose()가 각 단계에서 CompletableFuture를 평탄화하여, 후속 단계가 항상 실제 비즈니스 객체(User, Cart, InventoryStatus)를 입력으로 받는 것을 보여준다. 타입은 전체 체인에서 `CompletableFuture<T>` 형태를 유지하며, 중첩 해소를 위한 추가 작업이 필요 없다. 이것이 비동기 파이프라인의 합성 가능성을 보장하는 핵심 메커니즘이다.

---

## 3. thenCompose()의 타입 제약과 중첩 제거 보장

### 2.1 CompletionStage 제약을 통한 의도 명시

`thenCompose()`는 함수 시그니처 레벨에서 명시적 제약을 도입한다:

```java
public <U> CompletableFuture<U> thenCompose(
    Function<? super T, ? extends CompletionStage<U>> fn
)
```

`thenCompose()`의 핵심은 함수가 **반드시 CompletableFuture(또는 CompletionStage)를 반환하도록 강제**한다는 것이다:

```java
CompletableFuture<Integer> userIdFuture = CompletableFuture.completedFuture(12345);

// ✅ 컴파일 성공: CompletableFuture 반환
Function<Integer, CompletableFuture<User>> asyncFunc = 
    id -> CompletableFuture.supplyAsync(() -> new User(id, "John"));

CompletableFuture<User> result = userIdFuture.thenCompose(asyncFunc);
```

```java
CompletableFuture<Integer> userIdFuture = CompletableFuture.completedFuture(12345);

// ❌ 컴파일 에러: 일반 User 객체 반환
Function<Integer, User> syncFunc = 
    id -> new User(id, "John");

CompletableFuture<User> error = userIdFuture.thenCompose(syncFunc);
/*
컴파일러 오류 메시지:
incompatible types: Function<Integer,User> cannot be converted to 
Function<? super Integer,? extends CompletionStage<User>>
*/
```

**이 제약 덕분에:**

1. **개발자 실수 방지**: 일반 객체 반환 함수를 잘못 사용하면 컴파일 타임에 에러 발생
2. **중첩 제거 보장**: 컴파일러가 "함수가 CompletableFuture를 반환한다"는 것을 알고 있으므로, 런타임에 적절한 중첩 제거 메커니즘 적용 가능
3. **의도 명시**: 코드만 봐도 "이 함수는 비동기 작업을 시작한다"는 것이 명확

### 2.2 중첩 제거의 기본 동작

올바른 사용 예시를 통해 중첩 제거 메커니즘을 확인하자:

```java
Function<Integer, CompletableFuture<User>> asyncFunc = 
    id -> CompletableFuture.supplyAsync(() -> {
        // 실제 비동기 작업 - 예: 데이터베이스 조회
        Thread.sleep(100); // 시뮬레이션
        return new User(id, "John");
    });

CompletableFuture<User> flat = userIdFuture.thenCompose(asyncFunc);
```

**핵심 사실**: 최종 타입이 `CompletableFuture<User>`이다. `CompletableFuture<CompletableFuture<User>>`가 아니다.

`thenCompose()`는 내부적으로 다음을 보장한다:
1. 함수가 반환하는 `CompletableFuture<User>` (중간 작업)를 생성
2. 이 중간 작업이 완료되면 그 결과를 thenCompose()가 반환한 CompletableFuture로 직접 복사
3. 최종적으로 사용자는 단일 계층의 CompletableFuture만 보게 됨

사용자는 단일 `join()` 호출로 결과에 접근한다:

```java
User user = flat.join();  // 한 번의 언래핑만 필요
System.out.println(user.getName()); // "John"
```

**메모리 구조의 차이**:

thenApply() 오용 시:
```
CompletableFuture<CompletableFuture<User>>
  └─ result → CompletableFuture<User>
      └─ result → User 객체
```

thenCompose() 사용 시:
```
CompletableFuture<User>
  └─ result → User 객체 (직접 참조)
```

중간 작업은 중첩 제거 과정에서만 일시적으로 존재하며, 최종 메모리 구조에는 나타나지 않는다.

### 2.3 예외 전파의 투명성

중첩 제거 메커니즘은 정상 값뿐만 아니라 예외도 동일하게 처리한다:

```java
Function<Integer, CompletableFuture<User>> failingFunc = 
    id -> CompletableFuture.supplyAsync(() -> {
        if (id < 0) throw new IllegalArgumentException("Invalid user ID");
        return new User(id, "John");
    });

CompletableFuture<User> result = CompletableFuture
    .completedFuture(-1)
    .thenCompose(failingFunc);
```

**핵심 사실**: 중간 작업에서 발생한 예외가 thenCompose()가 반환한 CompletableFuture로 직접 전파된다.

```java
result.exceptionally(ex -> {
    ex.printStackTrace();
    /*
    java.util.concurrent.CompletionException: 
        java.lang.IllegalArgumentException: Invalid user ID
        at User.lambda$failingFunc$0(...)  ← 원본 예외 발생 지점 보존
        ...
    */
    return null;
});
```

**장점**:
- 예외의 스택 트레이스가 원본 그대로 유지됨
- 어느 단계에서 예외가 발생했는지 명확히 파악 가능
- 전체 체인에 대해 단일 `exceptionally()` 핸들러로 일관된 에러 처리

만약 thenApply()를 오용했다면 중첩된 CompletionException이 발생하여 디버깅이 훨씬 어려워진다.

---