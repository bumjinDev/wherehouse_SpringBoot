# CompletableFuture의 thenCompose() 중첩 제거 메커니즘
## 타입 중첩 제거와 비동기 체이닝의 구조적 설계

---

# 개요: 중첩 제거 메커니즘

## 1. 왜 중첩 제거가 필요한가

### 1.1 비동기 체이닝에서 발생하는 타입 중첩 문제

비동기 작업을 연속적으로 체이닝할 때 근본적인 구조적 문제가 발생한다. 현대 마이크로서비스 아키텍처에서는 각 서비스 호출이 네트워크 I/O를 수반하므로 필연적으로 CompletableFuture를 반환한다. 문제는 이러한 비동기 작업의 결과를 받아서 또 다른 비동기 작업을 시작해야 할 때 발생한다.

예를 들어 전자상거래 시스템에서 주문을 처리하는 과정을 생각해보자. 먼저 인증 서비스에서 사용자를 검증하고, 그 결과인 사용자 ID로 재고 서비스를 조회하며, 다시 그 결과로 결제 서비스를 호출한다. 각 단계가 CompletableFuture를 반환하는 비동기 작업이다. 

thenApply()를 사용하면 이러한 체인이 만들어진다: 첫 번째 서비스가 `CompletableFuture<UserId>`를 반환하고, 이를 받아 재고 서비스를 호출하는 함수가 `CompletableFuture<Inventory>`를 반환한다면, thenApply()는 이를 그대로 새로운 CompletableFuture로 감싸서 `CompletableFuture<CompletableFuture<Inventory>>`를 만든다. 세 번째 단계를 거치면 `CompletableFuture<CompletableFuture<CompletableFuture<Payment>>>`라는 삼중 중첩이 발생한다.

### 1.2 타입 중첩이 야기하는 실제 문제

이러한 타입 중첩은 단순한 문법적 불편함이 아니다. 실제 Payment 객체에 접근하려면 세 번의 join()을 호출해야 한다. 각 중첩 레벨마다 별도의 예외 처리가 필요하며, 어느 레벨에서 발생한 예외인지 추적하기 어렵다. 

더 심각한 것은 비즈니스 로직의 의도가 왜곡된다는 점이다. "사용자를 인증하고, 재고를 확인한 후, 결제를 처리한다"는 선형적이고 명확한 흐름이 "결제 처리 작업을 조회하는 작업을 조회하는 작업"이라는 무의미한 중첩 구조로 변질된다. 코드를 읽는 사람은 실제 비즈니스 플로우를 파악하기 어려워지고, 유지보수성이 크게 저하된다.

---

## 2. thenCompose()의 중첩 제거 메커니즘

### 2.1 중첩 제거의 핵심 원리

thenCompose()의 핵심은 **함수가 반환하는 CompletableFuture를 새로운 CompletableFuture로 감싸지 않는다**는 것이다. 대신 내부에서 반환된 CompletableFuture의 결과를 외부 CompletableFuture로 직접 전달한다. 

이 과정을 단계별로 분해하면 다음과 같다. thenCompose()가 호출되면 즉시 새로운 CompletableFuture를 생성하여 호출자에게 반환한다. 이를 '외부 future'라고 하자. 중요한 점은 이 시점에서 사용자가 제공한 함수는 아직 실행되지 않았다는 것이다. 외부 future는 미완료 상태의 빈 껍데기로 반환되며, 호출자는 이 future에 대해 추가적인 체이닝을 즉시 수행할 수 있다.

### 2.2 이벤트 전파 체인의 동작

선행 작업이 완료되면 중첩 제거의 핵심 메커니즘이 작동한다:

**첫 번째 단계: 함수 실행과 내부 future 생성**
선행 CompletableFuture가 완료되면, 그 결과값을 추출하여 사용자가 제공한 함수에 전달한다. 이 함수는 새로운 CompletableFuture를 반환하는데, 이를 '내부 future'라고 하자. 예를 들어 사용자 ID를 받아 데이터베이스에서 사용자 정보를 조회하는 비동기 작업을 시작하고, 그 작업을 나타내는 CompletableFuture를 반환한다.

**두 번째 단계: 완료 콜백 등록**
내부 future에 특별한 콜백이 등록된다. 이 콜백의 역할은 명확하다: "내부 future가 완료되면, 그 결과를 가져와서 외부 future의 complete() 메서드를 호출하라." 이것이 중첩 제거의 핵심이다. 내부 future의 결과가 외부 future로 직접 복사되는 것이다.

**세 번째 단계: 결과 전파**
내부 future가 완료되면(예: 데이터베이스 조회가 끝나면) 등록된 콜백이 트리거된다. 이 콜백은 내부 future의 결과값을 읽어서 외부 future의 result 필드에 직접 설정한다. 이 시점에서 내부 future는 더 이상 필요 없으며, 가비지 컬렉션의 대상이 된다.

**최종 결과**
사용자는 외부 future만 보게 되며, 중첩 없이 단일 join()으로 최종 결과에 접근할 수 있다. 타입은 `CompletableFuture<T>`로 유지되며, 중간의 CompletableFuture는 중첩 제거 과정에서만 일시적으로 존재했을 뿐이다.

### 2.3 예외 전파의 투명성

중첩 제거 메커니즘은 정상 값뿐만 아니라 예외도 동일하게 처리한다. 내부 future에서 예외가 발생하면, 완료 콜백은 이를 감지하여 외부 future의 completeExceptionally() 메서드를 호출한다. 

이는 매우 중요한 특성이다. 중간 계층이 없으므로 예외가 직접 전파되며, 예외의 스택 트레이스가 원본 그대로 유지된다. 개발자는 어느 서비스 호출에서 예외가 발생했는지 명확히 파악할 수 있고, 전체 체인에 대해 단일 exceptionally 핸들러로 일관된 에러 처리를 수행할 수 있다.

---

## 3. thenApply()와의 구조적 차이

### 3.1 타입 제약을 통한 의도 명시

thenApply()는 함수의 반환값이 무엇이든 받아들인다. 함수가 String을 반환하면 `CompletableFuture<String>`을, Integer를 반환하면 `CompletableFuture<Integer>`를 만든다. 문제는 함수가 이미 CompletableFuture를 반환할 때다. thenApply()는 이것도 그대로 감싸서 `CompletableFuture<CompletableFuture<T>>`를 만든다.

반면 thenCompose()는 함수 시그니처에 명시적 제약을 둔다. 함수가 반드시 CompletionStage(실질적으로 CompletableFuture)를 반환하도록 요구한다. 이 제약은 두 가지 목적을 달성한다. 첫째, 개발자가 의도를 명확히 표현하도록 강제한다. 일반 객체를 반환하는 함수를 실수로 전달하면 컴파일 에러가 발생한다. 둘째, 컴파일러와 런타임이 중첩 제거가 필요한 상황임을 인지하고 적절한 처리를 수행할 수 있다.

### 3.2 사용 시점의 명확한 구분

두 메서드의 사용 시점은 명확히 구분된다:

**thenApply()를 사용하는 경우:**
- 동기적 변환 작업: `user -> user.getName()`
- 즉시 계산 가능한 값: `price -> price * 1.1`
- I/O 작업이 없는 순수 함수: `list -> list.size()`

**thenCompose()를 사용하는 경우:**
- 데이터베이스 조회: `userId -> findUserById(userId)`
- 외부 API 호출: `order -> paymentService.process(order)`
- 또 다른 비동기 작업 시작: `file -> readFileAsync(file)`

이 구분을 지키지 않으면 타입 중첩이나 불필요한 오버헤드가 발생한다.

---

## 4. 핵심 정리

### 4.1 중첩 제거의 본질적 가치

thenCompose()의 중첩 제거는 단순한 편의 기능이 아니라, 비동기 프로그래밍의 복잡성을 관리하기 위한 필수적인 메커니즘이다. 핵심은 내부 CompletableFuture의 결과를 외부 CompletableFuture로 직접 전파하여, 타입 중첩 없이 선형적인 비동기 파이프라인을 구성하는 것이다.

이를 통해 타입 시스템이 비즈니스 로직의 의도를 정확히 표현할 수 있다. "A 후 B 후 C"라는 단순한 흐름이 복잡한 중첩 타입으로 왜곡되지 않고, 그대로 코드에 반영된다.

### 4.2 설계 원칙과 선택 기준

개발자는 명확한 기준을 가지고 두 메서드를 선택해야 한다. 함수가 일반 객체를 반환하면 thenApply()를, CompletableFuture를 반환하면 thenCompose()를 사용한다. 이는 선택사항이 아니라 필수 요구사항이다. 잘못된 선택은 타입 중첩이나 불필요한 오버헤드를 발생시킨다.

### 4.3 현대 비동기 프로그래밍에서의 위치

thenApply()와 thenCompose()의 분리는 CompletableFuture가 단순한 비동기 유틸리티가 아니라, 정교한 타입 시스템을 갖춘 비동기 프로그래밍 프레임워크임을 보여준다. 이는 Java 생태계의 표준이 되었으며, Reactive Streams, Kotlin Coroutines 등 다른 비동기 프레임워크들도 동일한 중첩 제거 개념을 채택했다.

중첩 제거 메커니즘을 이해하는 것은 현대적인 비동기 아키텍처를 설계하고 구현하는 데 필수적이다. 이는 비동기 프로그래밍이 직면한 보편적 문제에 대한 검증된 해법이며, 복잡한 비동기 워크플로우를 관리 가능한 수준으로 유지하는 핵심 도구다.

---

# 본문: 타입 중첩과 중첩 제거의 구조적 분석

## 1. thenApply()의 무제약 제네릭과 타입 중첩의 구조적 원인

### 1.1 제네릭 타입 시스템의 제약 부재

`thenApply()`의 메서드 시그니처는 Java의 제네릭 시스템이 제공하는 최대 유연성을 활용한다:

```java
public <U> CompletableFuture<U> thenApply(Function<T, U> fn)
```

제네릭 타입 파라미터 `U`에는 어떠한 상한(upper bound)이나 하한(lower bound) 제약도 존재하지 않는다. 이는 `U`가 Java의 모든 참조 타입(reference type)이 될 수 있음을 의미하며, 여기에는 `CompletableFuture<T>`, `Optional<T>`, `List<T>` 같은 제네릭 컨테이너 타입도 포함된다.

이러한 무제약 설계는 의도적인 것이다. `thenApply()`는 **블로킹 없이 즉시 계산 가능한 변환(non-blocking computation)**을 위해 설계되었으며, 변환 함수가 어떤 타입을 반환하든 그것을 CompletableFuture로 감싸는 것이 올바른 동작이다. 문제는 개발자가 이 메서드를 **비동기 작업을 반환하는 함수**에 적용할 때 발생한다.

### 1.2 타입 중첩의 메모리 구조와 접근 경로

구체적인 예시로 타입 중첩의 구조를 분석해보자:

```java
CompletableFuture<Integer> userIdFuture = CompletableFuture.completedFuture(12345);

Function<Integer, CompletableFuture<User>> fetchUser = 
    id -> CompletableFuture.supplyAsync(() -> new User(id, "John"));

// thenApply() 사용 - 타입 중첩 발생
CompletableFuture<CompletableFuture<User>> nested = userIdFuture.thenApply(fetchUser);
```

Java 컴파일러의 타입 추론 엔진은 다음과 같이 타입을 추론한다:
- `fetchUser`의 반환 타입: `CompletableFuture<User>`
- 이를 제네릭 파라미터 `U`에 바인딩: `U = CompletableFuture<User>`
- 최종 반환 타입: `CompletableFuture<U>` = `CompletableFuture<CompletableFuture<User>>`

**컴파일러는 이를 전혀 문제 삼지 않는다.** 타입 규칙을 완벽히 준수한 코드이기 때문이다.


### 1.3 타입 왜곡이 초래하는 설계 문제

더 심각한 것은 타입이 비즈니스 의도를 왜곡한다는 점이다. 개발자의 의도는 "사용자 ID로 사용자를 비동기 조회한다"는 것이지만, 타입 `CompletableFuture<CompletableFuture<User>>`는 "사용자 조회 작업을 조회하는 작업"이라는 불필요한 중첩 구조를 표현한다. 이는 비즈니스 로직의 의도를 타입 시스템이 정확히 반영하지 못하는 것이다.

이러한 타입 중첩은 체이닝이 길어질수록 기하급수적으로 악화된다:

```java
CompletableFuture<Integer> step1 = getSessionToken();

CompletableFuture<CompletableFuture<User>> step2 = 
    step1.thenApply(token -> getUserId(token));

CompletableFuture<CompletableFuture<CompletableFuture<Order>>> step3 = 
    step2.thenApply(userFuture -> 
        userFuture.thenApply(user -> getOrders(user))
    );

// 이 시점에서 타입이 3중 중첩되어 코드 자체가 거의 작성 불가능해진다
```

---

## 2. thenCompose()의 타입 제약과 중첩 제거 보장

### 2.1 CompletionStage 제약을 통한 의도 명시

`thenCompose()`는 함수 시그니처 레벨에서 명시적 제약을 도입한다:

```java
public <U> CompletableFuture<U> thenCompose(
    Function<? super T, ? extends CompletionStage<U>> fn
)
```

`thenCompose()`의 핵심은 함수가 **반드시 CompletableFuture(또는 CompletionStage)를 반환하도록 강제**한다는 것이다:

```java
CompletableFuture<Integer> userIdFuture = CompletableFuture.completedFuture(12345);

// ✅ 컴파일 성공: CompletableFuture 반환
Function<Integer, CompletableFuture<User>> asyncFunc = 
    id -> CompletableFuture.supplyAsync(() -> new User(id, "John"));

CompletableFuture<User> result = userIdFuture.thenCompose(asyncFunc);
```

```java
CompletableFuture<Integer> userIdFuture = CompletableFuture.completedFuture(12345);

// ❌ 컴파일 에러: 일반 User 객체 반환
Function<Integer, User> syncFunc = 
    id -> new User(id, "John");

CompletableFuture<User> error = userIdFuture.thenCompose(syncFunc);
/*
컴파일러 오류 메시지:
incompatible types: Function<Integer,User> cannot be converted to 
Function<? super Integer,? extends CompletionStage<User>>
*/
```

**이 제약 덕분에:**

1. **개발자 실수 방지**: 일반 객체 반환 함수를 잘못 사용하면 컴파일 타임에 에러 발생
2. **중첩 제거 보장**: 컴파일러가 "함수가 CompletableFuture를 반환한다"는 것을 알고 있으므로, 런타임에 적절한 중첩 제거 메커니즘 적용 가능
3. **의도 명시**: 코드만 봐도 "이 함수는 비동기 작업을 시작한다"는 것이 명확

### 2.2 중첩 제거의 기본 동작

올바른 사용 예시를 통해 중첩 제거 메커니즘을 확인하자:

```java
Function<Integer, CompletableFuture<User>> asyncFunc = 
    id -> CompletableFuture.supplyAsync(() -> {
        // 실제 비동기 작업 - 예: 데이터베이스 조회
        Thread.sleep(100); // 시뮬레이션
        return new User(id, "John");
    });

CompletableFuture<User> flat = userIdFuture.thenCompose(asyncFunc);
```

**핵심 사실**: 최종 타입이 `CompletableFuture<User>`이다. `CompletableFuture<CompletableFuture<User>>`가 아니다.

`thenCompose()`는 내부적으로 다음을 보장한다:
1. 함수가 반환하는 `CompletableFuture<User>` (내부 future)를 생성
2. 이 내부 future가 완료되면, 그 결과를 외부 future로 직접 복사
3. 최종적으로 사용자는 단일 계층의 CompletableFuture만 보게 됨

사용자는 단일 `join()` 호출로 결과에 접근한다:

```java
User user = flat.join();  // 한 번의 언래핑만 필요
System.out.println(user.getName()); // "John"
```

**메모리 구조의 차이**:

thenApply() 오용 시:
```
CompletableFuture<CompletableFuture<User>>
  └─ result → CompletableFuture<User>
      └─ result → User 객체
```

thenCompose() 사용 시:
```
CompletableFuture<User>
  └─ result → User 객체 (직접 참조)
```

내부 future는 중첩 제거 과정에서만 일시적으로 존재하며, 최종 메모리 구조에는 나타나지 않는다.

### 2.3 예외 전파의 투명성

중첩 제거 메커니즘은 정상 값뿐만 아니라 예외도 동일하게 처리한다:

```java
Function<Integer, CompletableFuture<User>> failingFunc = 
    id -> CompletableFuture.supplyAsync(() -> {
        if (id < 0) throw new IllegalArgumentException("Invalid user ID");
        return new User(id, "John");
    });

CompletableFuture<User> result = CompletableFuture
    .completedFuture(-1)
    .thenCompose(failingFunc);
```

**핵심 사실**: 내부 future에서 발생한 예외가 외부 future로 직접 전파된다.

```java
result.exceptionally(ex -> {
    ex.printStackTrace();
    /*
    java.util.concurrent.CompletionException: 
        java.lang.IllegalArgumentException: Invalid user ID
        at User.lambda$failingFunc$0(...)  ← 원본 예외 발생 지점 보존
        ...
    */
    return null;
});
```

**장점**:
- 예외의 스택 트레이스가 원본 그대로 유지됨
- 어느 단계에서 예외가 발생했는지 명확히 파악 가능
- 전체 체인에 대해 단일 `exceptionally()` 핸들러로 일관된 에러 처리

만약 thenApply()를 오용했다면 중첩된 CompletionException이 발생하여 디버깅이 훨씬 어려워진다.

---

## 3. 비동기 체이닝 패턴과 실전 아키텍처

### 3.1 의존적 비동기 작업 체이닝

각 단계가 이전 단계의 결과에 의존하는 전형적인 패턴이다. 마이크로서비스 아키텍처에서 가장 흔하게 발생하는 시나리오다:

```java
public class OrderService {
    
    public CompletableFuture<OrderConfirmation> processOrder(String sessionToken) {
        return CompletableFuture
            .supplyAsync(() -> authService.validateSession(sessionToken))
            .thenCompose(session -> userService.getUser(session.getUserId()))
            .thenCompose(user -> inventoryService.checkAvailability(user, cartId))
            .thenCompose(availability -> {
                if (!availability.isAvailable()) {
                    return CompletableFuture.failedFuture(
                        new OutOfStockException()
                    );
                }
                return paymentService.processPayment(user, availability);
            })
            .thenCompose(payment -> orderRepository.createOrder(payment))
            .thenCompose(order -> notificationService.sendConfirmation(order))
            .exceptionally(ex -> {
                log.error("Order processing failed", ex);
                return OrderConfirmation.failed(ex.getMessage());
            });
    }
}
```

**구조적 특징**:
- 각 `thenCompose()`는 이전 단계의 결과를 받아 새로운 비동기 작업을 시작
- 타입은 전체 체인에서 `CompletableFuture<OrderConfirmation>`으로 평탄하게 유지
- 단일 `exceptionally()` 핸들러로 전체 체인의 에러를 일관되게 처리

만약 `thenApply()`를 잘못 사용했다면:

```java
// 안티패턴 - 컴파일조차 거의 불가능한 코드
CompletableFuture<CompletableFuture<CompletableFuture<CompletableFuture<...>>>> hell = 
    CompletableFuture.supplyAsync(() -> authService.validateSession(sessionToken))
        .thenApply(session -> userService.getUser(session.getUserId()))
        .thenApply(userFuture -> 
            userFuture.thenApply(user -> 
                inventoryService.checkAvailability(user, cartId)
            )
        )
        .thenApply(availabilityFuture ->
            availabilityFuture.thenApply(innerFuture ->
                innerFuture.thenApply(availability -> ...
```

코드 자체가 유지보수 불가능해진다.

### 3.2 조건부 분기와 thenCompose의 활용

비즈니스 로직에 조건부 분기가 필요한 경우, `thenCompose()`는 다른 비동기 경로를 선택하는 라우터 역할을 한다:

```java
public CompletableFuture<ShippingInfo> getShippingInfo(Order order) {
    return CompletableFuture
        .supplyAsync(() -> order.getDestinationCountry())
        .thenCompose(country -> {
            // 국가별로 다른 배송 서비스 호출
            if ("KR".equals(country)) {
                return domesticShippingService.calculate(order);
            } else if (isEUCountry(country)) {
                return euShippingService.calculate(order, country);
            } else {
                return internationalShippingService.calculate(order, country);
            }
        })
        .thenCompose(shippingCost -> {
            // 비용에 따라 다른 결제 처리
            if (shippingCost.isExpressAvailable()) {
                return offerExpressOption(order, shippingCost);
            } else {
                return confirmStandardShipping(order, shippingCost);
            }
        });
}
```

각 분기에서 반환되는 CompletableFuture가 중첩 제거되어, 최종 타입은 항상 `CompletableFuture<ShippingInfo>`로 유지된다.

### 3.3 병렬 작업과 순차 작업의 혼합

`thenCompose()` 내부에서 여러 비동기 작업을 병렬로 시작한 후, 그 결과들을 조합하는 복잡한 패턴:

```java
public CompletableFuture<ProductDetail> getEnrichedProduct(String productId) {
    return CompletableFuture
        .supplyAsync(() -> productRepository.findById(productId))
        .thenCompose(product -> {
            // 병렬로 여러 서비스 호출
            CompletableFuture<Category> categoryFuture = 
                categoryService.getCategory(product.getCategoryId());
            
            CompletableFuture<List<Review>> reviewsFuture = 
                reviewService.getReviews(productId);
            
            CompletableFuture<Inventory> inventoryFuture = 
                inventoryService.getStock(productId);
            
            CompletableFuture<Supplier> supplierFuture = 
                supplierService.getSupplier(product.getSupplierId());
            
            // 모든 결과를 조합
            return CompletableFuture
                .allOf(categoryFuture, reviewsFuture, inventoryFuture, supplierFuture)
                .thenApply(v -> new ProductDetail(
                    product,
                    categoryFuture.join(),
                    reviewsFuture.join(),
                    inventoryFuture.join(),
                    supplierFuture.join()
                ));
        });
}
```

**아키텍처 분석**:
1. `thenCompose()` 블록 내부에서 4개의 비동기 작업을 병렬로 시작
2. `allOf()`로 모든 작업의 완료를 대기
3. `thenApply()`로 결과들을 동기적으로 조합
4. 최종적으로 `CompletableFuture<CompletableFuture<ProductDetail>>`이 아닌 `CompletableFuture<ProductDetail>` 반환

이는 중첩 제거 메커니즘이 없다면 구현이 매우 복잡해지는 패턴이다.

---
