# 동기/비동기 및 블로킹/논블로킹: 완전 기술 백서

## 서론: 개념 혼동의 구조적 문제

### 널리 퍼진 오해의 현실

소프트웨어 개발 커뮤니티에서 "동기는 블로킹이고, 비동기는 논블로킹이다"라는 잘못된 등식이 널리 퍼져 있다. 이 오해는 단순한 용어 혼동을 넘어, 시스템 설계의 잘못된 선택으로 이어진다. 개발자가 "비동기"라고 믿고 구현한 시스템이 실제로는 블로킹되어 성능 병목이 발생하는 사례가 빈번하다.

### 문제 1: 개념의 혼재

많은 기술 문서와 블로그가 동기/비동기와 블로킹/논블로킹을 구분 없이 사용한다. Node.js를 "비동기 논블로킹"이라고 소개하는 문서가 있는가 하면, 같은 Node.js를 "논블로킹 I/O"라고만 설명하는 문서도 있다. 이런 혼재는 학습자에게 두 개념이 동일하다는 잘못된 인상을 준다.

### 문제 2: 실무적 혼란

개발자가 CompletableFuture를 사용하면서 "이제 우리 시스템은 완전 비동기"라고 착각한다. 하지만 실제로는 워커 스레드가 블로킹 I/O를 수행하고 있어, 스레드 풀이 고갈되는 문제가 발생한다. "비동기인데 왜 느리지?"라는 질문이 나오는 이유다.

### 문제 3: 잘못된 아키텍처 결정

"비동기가 항상 빠르다"는 오해로 인해, CPU 집약적 작업에 불필요하게 비동기 패턴을 적용하여 오히려 성능이 저하되는 경우가 있다. 반대로, I/O 집약적 작업에 동기-블로킹만 고집하다가 시스템 확장성이 한계에 부딪히는 경우도 흔하다.

**이 문서는 블로킹/논블로킹과 동기/비동기가 완전히 독립적인 두 개의 축임을 증명하고, 각 개념의 정확한 정의와 구현 메커니즘을 제시한다.**

---

## 0. 컴퓨터 아키텍처의 근본 제약과 프로그래밍 모델의 진화

### 0.1 하드웨어의 역사적 제약: "CPU는 한 번에 한 가지 일만 한다"

초기 컴퓨터의 CPU(중앙 처리 장치)는 코어가 하나였고, 이는 물리적으로 한 순간에 단 하나의 명령어만 처리할 수 있음을 의미한다. 이는 폰 노이만 아키텍처의 핵심 제약이며, 제어권이 "레지스터의 순차적인 나열"이라는 동작 원리에 기반한다.

아리한 하드웨어 위에서 프로그래밍이 동작하는 방식을 상상해보자:

- **프로그램은 명령어들의 순차적인 나열이다**: CPU는 **Instruction Pointer**(명령어 포인터)라는 것을 가지고 있으며, 이는 다음에 실행할 명령어의 메모리 주소를 가리킨다.
- **명령어를 하나 실행하면, 명령어 포인터는 자동으로 다음 주소로 이동한다**: 이것이 순차 실행의 본질이다.
- **명령어를 하나 실행하면, 명령어 포인터는 자동으로 다음 주소로 넘어간다**: 이렇게 코드는 위에서 아래로 흐른다.

여기서 한계(서브루틴 호출, 즉 "함수 호출")가 생긴다. 함수를 호출하면 현재 실행 중인 코드를 멈추고, 다른 코드로 점프해야 한다. 그리고 그 함수가 끝나면 다시 원래 위치로 돌아와야 한다.

### 0.2 콜 스택(Call Stack): 동기-블록킹이 "기본값"인 이유

프로그래밍은 복잡한 문제를 논리적 절차로 나누어 해결하는 과정이며, 이때 가장 중요한 것은 **"코드는 위에서 아래로 흐른다"**는 과정이다. 이 때 가장 중요한 것은 예측 가능성이다. 코드는 위에서 아래로 흐른다는 것, 그냥 보면 이해할 수 있다.

#### 0.2.1 콜 스택의 동작 방식

```java
int a = 1;
int b = 2;
int sum = add(a, b);  // "재어감"이 add 함수로 넘어간다
System.out.println(sum);  // add 함수 완료 후 여기로 돌아온다
```

만약 `add(a, b)`를 호출했을 때 제어권이 넘어가지 않고, `add`의 함수와 `System.out.println(sum)`이 동시에 실행된다고 가정해보자. 그럼 `sum`이라는 변수는 언제 어떤 값이 들어있을까? 알 수 없다. 이처럼 "제어권"을 넘겨주고 작업이 완료될 때까지 기다리는 동기-블로킹은 동작이 간결하고 가장에게 이해하기 쉬운 모델이다.

이 LIFO(Last-In, First-Out) 구조인 "콜 스택(Call Stack)"이 하드웨어 수준에서 지원된다:

1. 함수를 호출하면, 해당 함수로의 스택 프레임이 생성된다
2. 함수가 끝나면 그 공간은 자동으로 해제되고 이전 위치로 돌아간다
3. 코드를 이해하기가 쉽고, 자원 관리가 간단하며, 디버깅하기가 편리하다

결론: 제어흐름 모델은 **"콜 스택(Call Stack)"**이라는 하드웨어가 자연스럽게 지원하는 메커니즘을 사용하며, 그 대가로 동기-블록킹이 "기본값"이 된다.

### 0.3 제어 흐름의 진화: "기본" vs "고급"

#### 0.3.1 기본(Default) 제어 흐름: 동기-블록킹

하나의 함수가 완료될 때까지 기다리고 다음으로 진행하는 방식이다. 하드웨어(CPU, 콜 스택)가 자연스럽게 지원하는 모델이며, 코드는 위에서 아래로 순차적으로 흐른다. 각 함수 호출마다 완료를 기다린다. 이것이 모든 프로그래밍 언어의 기본 동작이다.

#### 0.3.2 고급(Advanced) 제어 흐름: 비동기-논블록킹

기본 모델의 한계(I/O 작업에서의 대기 시간)를 극복하기 위해 등장했다. 작업을 다른 실행 주체(Thread, Process)에 위임하고 즉시 반환한다. Main Thread는 다른 작업을 계속할 수 있다. 

하지만 이는 복잡성을 수반한다:
- OS 수준의 Thread/Process 관리가 필요하다
- Thread 간 통신이 복잡하다
- Race Condition 등 동시성 버그가 발생할 수 있다
- 디버깅이 어렵고 예측하기 힘들다

따라서 "제어권"이라는 개념이 흐트러지고, 두뇌가 처리해야 할 복잡도가 기하급수적으로 증가한다. 오히려 플러그램의 복잡성은 늘어나지만, 성능과 처리량이 개선되는 트레이드오프가 있다.

### 0.4 프로그래밍 모델의 진화 계층

복잡성을 감수하고 성능을 개선하려면, 새로운 추상화가 필요하다:

1. **하드웨어 수준**: 멍령어 포인터를 직접 조작, 순차 실행만 가능
2. **기본 추상화**: 함수 호출과 콜 스택, 동기-블록킹이 기본
3. **멀티스레드**: Thread를 생성하여 병렬 실행, 하지만 동기화 복잡
4. **비동기 추상화**: CompletableFuture, Promise 등으로 비동기 작업 관리
5. **반응형 스트림**: Event Loop와 Non-blocking I/O로 더 높은 효율성

### 0.5 현재 프로젝트의 맥락에서의 의미

카카오 API 15개를 순차 호출하는 현재 구조는 "기본" 제어 흐름(동기-블록킹)을 사용한다. 각 API 호출마다 Thread가 응답을 기다리며 WAITING 상태로 전환되어, 총 2,681ms의 시간이 소요된다.

CompletableFuture를 통한 "고급" 제어 흐름으로 전환하면:
- 15개 Thread가 동시에 각자의 API를 호출한다
- 대부분의 시간을 WAITING 상태로 보내므로 Context Switching 오버헤드는 미미하다
- 병렬 처리로 전체 시간이 대폭 단축된다

이는 단순히 "빠르게 만드는 기법"이 아니라, 하드웨어의 근본적 제약(CPU는 한 번에 한 가지)을 프로그래밍 모델의 진화(여러 Thread가 각자 일함)로 극복하는 아키텍처적 전환이다.


---

## 1. 근본적 정의: 두 개의 독립적 질문

### 1.1 블로킹/논블로킹이 답하는 질문

블로킹과 논블로킹은 **"함수가 호출되었을 때, 그 함수가 언제 제어권을 반환하는가?"**라는 질문에 답한다.

이 질문은 순전히 함수 호출 메커니즘에 관한 것이다. 함수 f()를 호출했을 때, f()가 즉시 반환되는가, 아니면 어떤 조건이 만족될 때까지 반환을 지연하는가? 이것이 블로킹/논블로킹이 구분하는 유일한 기준이다.

**블로킹 함수의 정의**: 함수가 자신이 수행해야 할 작업을 완료할 때까지 호출자에게 제어권을 반환하지 않는다.

```java
// 블로킹 함수의 전형적 예
String data = inputStream.read();  // 데이터를 읽을 때까지 반환 안 함
System.out.println(data);          // 위 줄이 끝나야 실행됨
```

이 코드에서 `read()` 메서드는 실제로 데이터를 읽어올 때까지 반환하지 않는다. 네트워크에서 데이터가 도착하지 않았다면, 이 메서드는 데이터가 도착할 때까지 호출자 스레드를 붙잡고 있다. 호출자 관점에서는 `read()` 호출 이후의 코드를 실행할 수 없다.

**논블로킹 함수의 정의**: 함수가 즉시 제어권을 반환하며, 작업 완료 여부와 무관하게 호출자가 다음 코드를 실행할 수 있게 한다.

```java
// 논블로킹 함수의 전형적 예
int bytesRead = channel.read(buffer);  // 즉시 반환
if (bytesRead > 0) {
    processData(buffer);
} else {
    doOtherWork();  // 데이터 없어도 다른 일 가능
}
```

이 코드에서 `read()` 메서드는 데이터 유무와 관계없이 즉시 반환한다. 데이터가 있으면 읽은 바이트 수를 반환하고, 없으면 0이나 -1을 반환한다. 호출자는 반환값을 확인하여 다음 행동을 결정할 수 있다.

### 1.2 동기/비동기가 답하는 질문

동기와 비동기는 **"작업이 완료되었다는 사실을 누가, 어떻게 확인하는가?"**라는 질문에 답한다.

이 질문은 완료 통지 메커니즘에 관한 것이다. 어떤 작업을 요청했을 때, 그 작업이 끝났다는 것을 호출자가 능동적으로 확인하는가, 아니면 시스템이 수동적으로 알려주는가? 이것이 동기/비동기가 구분하는 유일한 기준이다.

**동기적 완료 확인의 정의**: 호출자가 작업 완료 여부를 직접 확인한다. 확인 방법은 반환값, 상태 조회, 명시적 대기 등 다양하다.

```java
// 동기적 완료 확인의 예 1: 반환값
String result = httpClient.get(url);  // 반환값 자체가 완료 증명

// 동기적 완료 확인의 예 2: 상태 조회
Future<String> future = executor.submit(task);
while (!future.isDone()) {  // 호출자가 능동적으로 확인
    Thread.sleep(100);
}
String result = future.get();
```

두 경우 모두 호출자가 완료 여부를 확인하는 주체다. 첫 번째는 반환값으로, 두 번째는 `isDone()` 호출로 확인한다.

**비동기적 완료 통지의 정의**: 시스템(또는 호출된 함수)이 작업 완료를 호출자에게 알린다. 통지 방법은 콜백, 이벤트, 메시지 등 다양하다.

```java
// 비동기적 완료 통지의 예: 콜백
httpClient.getAsync(url, new Callback() {
    @Override
    public void onComplete(String result) {
        // 시스템이 완료 시 이 메서드를 호출
        System.out.println("완료: " + result);
    }
});
// 호출자는 완료를 기다리지 않고 다음 코드 실행
doOtherWork();
```

이 경우 호출자는 콜백만 등록하고 즉시 다른 일을 한다. 작업이 완료되면 시스템이 콜백을 호출하여 완료를 알린다.

### 1.3 두 축의 독립성

블로킹/논블로킹과 동기/비동기가 독립적이라는 것은, 이 두 속성의 4가지 조합이 모두 가능하다는 의미다.

```
             제어권 반환 시점
             블로킹    논블로킹
완료   동기   동기-블로킹  동기-논블로킹
확인   비동기  비동기-블로킹 비동기-논블로킹
방식
```

이 매트릭스의 4개 칸이 모두 실제로 존재한다는 것을 보이면, 두 축이 독립적임이 증명된다.

---

## 2. 네 가지 조합의 실제 구현과 내부 메커니즘

### 2.1 동기-블로킹 (Synchronous-Blocking)

#### 기술 정의와 시스템 동작 원리

**동기(Synchronous)의 본질**

동기 방식은 **호출자가 작업의 완료 여부를 직접 확인하고 제어하는 프로그래밍 모델**이다. 함수를 호출하면, 그 함수의 반환값으로 작업 완료를 알 수 있다. 이는 0.2절에서 설명한 콜 스택(Call Stack) 모델과 직접적으로 연결된다.

```java
int result = calculateSum(a, b);  // 반환 시점 = 작업 완료 시점
System.out.println(result);       // result는 항상 계산 완료된 값
```

이 코드에서 `calculateSum()`이 반환되는 순간, 우리는 작업이 완료되었음을 **반환값 자체로 확인**한다. 별도의 상태 확인이나 콜백 등록이 필요 없다. 반환값 = 완료 증거. 이것이 동기의 핵심이다.

**동기 방식의 제어 흐름 특성:**

1. **순차적 실행 보장**: `calculateSum()`이 완료되기 전까지 `println()`은 실행되지 않는다
2. **콜 스택 유지**: 호출한 함수의 스택 프레임이 계속 스택에 남아있다
3. **결과 즉시 사용 가능**: 반환 후 바로 다음 줄에서 결과를 사용할 수 있다

이는 **CPU가 명령어를 순차적으로 실행하는 하드웨어 모델과 완벽하게 일치**한다. 0.1절에서 설명했듯, CPU는 Instruction Pointer를 따라 명령어를 하나씩 실행한다. 동기 모델은 이 하드웨어 특성을 가장 직관적으로 반영한다.

**블로킹(Blocking)의 본질: 제어권의 관점**

블로킹의 정의는 단순하고 명확하다: **호출된 함수가 작업을 완료할 때까지 제어권을 호출자에게 돌려주지 않는 것**이다.

```java
public void caller() {
    System.out.println("1. 작업 시작");
    
    String result = blockingFunction();  // 제어권이 이 함수로 넘어감
                                         // 이 함수가 끝날 때까지 제어권을 돌려받지 못함
                                         // 호출자는 아무것도 할 수 없음
    
    System.out.println("2. 결과: " + result);  // 제어권을 돌려받아야 실행 가능
}
```

**제어권(Control)이란 무엇인가?**

제어권은 **"지금 CPU에서 코드를 실행할 수 있는 권한"**이다. 0.1절에서 설명한 Instruction Pointer가 어느 코드를 가리키고 있느냐의 문제다.

- 제어권이 `blockingFunction()` 안에 있을 때: 호출자의 다음 줄(`println("2. 결과...")`)은 실행될 수 없다
- 제어권이 호출자에게 돌아왔을 때: 비로소 다음 줄을 실행할 수 있다

**블로킹 vs 논블로킹의 핵심 차이**

```java
// 블로킹: 제어권을 끝까지 안 돌려줌
String data = blockingRead();      // 읽기가 완료될 때까지 여기 머물러 있음
System.out.println("완료");        // 데이터를 받아야 실행됨

// 논블로킹: 제어권을 즉시 돌려줌
Future<String> future = nonBlockingRead();  // 즉시 반환
System.out.println("다른 작업 수행");         // 바로 실행 가능
String data = future.get();                 // 나중에 필요할 때 결과 확인
```

블로킹 함수는 **"내가 끝날 때까지 너는 기다려"**라고 말하는 것이다. 논블로킹 함수는 **"나는 일단 돌아갈게, 너는 다른 일 해"**라고 말하는 것이다.

**제어권 미반환이 시스템 수준에서 구현되는 방법**

그렇다면 호출자는 왜 "제어권을 돌려받지 못한" 상태에서 아무것도 못하는가? 이는 OS 수준에서 다음과 같이 구현된다:

```
실행 흐름:
caller() 실행 중
    ↓
blockingRead() 호출
    ↓
[제어권이 blockingRead()로 이동]
    ↓
read 시스템 콜 호출 → 커널로 진입
    ↓
소켓 버퍼 확인: 데이터 없음
    ↓
OS가 스레드를 blocked 상태로 전환
    ↓
[스레드는 데이터가 올 때까지 대기]
    ↓
네트워크로부터 데이터 도착
    ↓
OS가 스레드를 깨움
    ↓
blockingRead() 반환
    ↓
[제어권이 caller()로 복귀]
    ↓
println("완료") 실행
```

**핵심: 제어권을 돌려받지 못한 동안, 스레드는 blocked 상태로 대기한다.** 이것이 "제어권 미반환"이 시스템 수준에서 구현되는 메커니즘이다.

**스레드 상태 전이로 본 블로킹**

```
Thread 상태:
실행 중 (caller 실행)
    ↓
blockingRead() 호출
    ↓
blocked 상태로 전환 (I/O 대기)
    ↓
데이터 도착
    ↓
실행 가능 상태로 전환
    ↓
다시 실행 (caller 계속 실행)
```

이 상태 전이는 **"제어권을 돌려주지 않는다"는 블로킹의 본질이 OS 수준에서 어떻게 구체화되는가**를 보여준다. 스레드는 blocked 상태에서 대기하고, 작업이 완료되면 다시 실행되어 제어권을 복귀받는다.

**왜 제어권을 돌려주지 않는 설계를 선택하는가?**

블로킹 설계는 **코드의 순차적 흐름을 보장**한다:

```java
Connection conn = getConnection();    // 1. 연결 획득 (블로킹)
ResultSet rs = executeQuery(conn);    // 2. 쿼리 실행 (블로킹)
User user = parseResult(rs);          // 3. 결과 파싱
```

각 단계는 이전 단계의 완료를 **보장받는다**. `executeQuery()`가 실행되는 시점에, `conn`은 반드시 유효한 연결이다. 왜냐하면 `getConnection()`이 제어권을 돌려주지 않았기 때문이다.

만약 논블로킹이었다면:

```java
Future<Connection> connFuture = getConnectionAsync();
Future<ResultSet> rsFuture = executeQueryAsync(???);  // conn이 준비 안 됐는데?
```

제어권을 즉시 돌려받으면, 다음 작업을 시작할 수 있지만 **의존성 관리가 복잡**해진다.

**동기-블로킹 조합: 제어권과 완료 통지의 결합**

동기와 블로킹이 결합되면, 다음과 같은 완전한 실행 모델이 만들어진다:

```java
public void processData() {
    System.out.println("호출 전");
    
    String data = readFromSocket();  // 블로킹: 제어권을 돌려주지 않음
                                     // 동기: 반환 = 완료 통지
    
    System.out.println("호출 후");   // 제어권 복귀 후에만 실행 가능
    process(data);                   // data는 이미 완료된 결과
}
```

**제어권과 완료의 관계:**

- **블로킹**: `readFromSocket()`이 제어권을 가지고 있는 동안, 호출자는 아무것도 할 수 없다
- **동기**: `readFromSocket()`이 제어권을 돌려주는 시점 = 작업 완료 시점
- **결과**: 제어권을 돌려받는 순간, 완료된 결과(`data`)를 사용할 수 있다

**단계별 제어권 이동과 시스템 동작:**

**단계 1: 제어권 이전 및 블로킹 진입**
```
[제어권: caller의 processData()]
    ↓
readFromSocket() 호출
    ↓
[제어권: readFromSocket() 내부]
    ↓
read() 시스템 콜 호출
    ↓
[제어권: 커널]
    ↓
소켓 버퍼 확인: 데이터 없음
    ↓
OS가 스레드를 blocked 상태로 전환
    ↓
[스레드는 데이터가 올 때까지 대기]
```

**핵심:** 호출자는 제어권을 `readFromSocket()`에 넘겼고, `readFromSocket()`은 다시 커널에 넘겼다. 데이터가 없으므로 커널은 이 스레드를 blocked 상태로 만들어 대기시킨다.

**단계 2: 대기 중**
- 스레드는 blocked 상태에서 데이터 도착을 기다림
- 다른 스레드들이 실행됨
- 네트워크 하드웨어가 데이터를 수신하면 인터럽트 발생

**단계 3: 제어권 복구**
```
네트워크 데이터 도착
    ↓
커널이 인터럽트 처리
    ↓
소켓 버퍼에 데이터 복사
    ↓
스레드를 실행 가능 상태로 전환
    ↓
readFromSocket() 복귀
    ↓
[제어권: caller의 processData()]
```

**단계 4: 동기 완료 통지**
```java
String data = readFromSocket();  // 이 시점에서 반환
                                 // 반환 = 제어권 복귀 = 작업 완료
```

**제어권이 돌아온 순간 = 작업이 완료된 순간**이다. 이것이 동기의 의미다. 호출자는 별도로 완료 여부를 확인할 필요 없이, **제어권을 돌려받았다는 사실 자체가 완료 증거**다.

**동기-블로킹이 "기본값"인 이유**

이 조합이 가장 널리 사용되는 이유는 **제어권 흐름이 인간의 사고 방식과 일치**하기 때문이다:

```java
try {
    Connection conn = getConnection();      // 1단계: 제어권 넘김 → 대기 → 제어권 복귀
    ResultSet rs = executeQuery(conn, sql); // 2단계: 제어권 넘김 → 대기 → 제어권 복귀
    User user = parseResult(rs);            // 3단계: 제어권 유지 (블로킹 없음)
    return user;
} catch (SQLException e) {
    // 모든 단계의 에러를 여기서 처리
}
```

**제어권 관점에서 본 장점:**

1. **순차적 제어권 이동**: 제어권이 위에서 아래로 한 줄씩 이동한다
   - 2단계는 1단계가 제어권을 돌려준 후에만 시작된다
   - 제어권을 돌려받았다 = 이전 작업이 완료되었다

2. **인과관계 자동 보장**: 제어권을 가진 순간, 이전 단계 결과를 사용할 수 있다
   - `executeQuery(conn, ...)`가 실행되는 순간, `conn`은 반드시 유효하다
   - 왜? `getConnection()`이 제어권을 돌려주지 않았기 때문에

3. **에러 처리 단순화**: 제어권이 try 블록 내에서만 이동한다
   - 어느 단계에서 실패하든, 제어권은 catch 블록으로 이동
   - 별도의 에러 콜백 등록 불필요

4. **디버깅 용이성**: 제어권 = 콜 스택의 위치
   - 콜 스택을 보면 현재 제어권 위치를 정확히 알 수 있음

**제어권을 즉시 돌려받는 경우와 비교:**

```java
// 논블로킹: 제어권을 즉시 돌려받음
Future<Connection> connFuture = getConnectionAsync();  // 즉시 제어권 복귀
Future<ResultSet> rsFuture = executeQueryAsync(...);   // 근데 conn이 준비 안 됐는데?

// 의존성 관리가 복잡해짐
connFuture.thenCompose(conn -> 
    executeQueryAsync(conn, sql)
).thenApply(rs -> 
    parseResult(rs)
);
```

논블로킹은 제어권을 즉시 받지만, **"이전 작업이 완료되었는가?"를 직접 관리**해야 한다. 동기-블로킹은 이것을 제어권 반환 시점으로 자동 해결한다.

**트랜잭션 일관성과의 관계**

데이터베이스 트랜잭션은 ACID 속성을 보장해야 하는데, 동기-블로킹 모델은 이와 자연스럽게 맞아떨어진다:

```java
@Transactional
public void transferMoney(Account from, Account to, int amount) {
    debit(from, amount);   // 출금 (블로킹, 동기)
    credit(to, amount);    // 입금 (블로킹, 동기)
    // 두 작업 모두 완료되어야 커밋
}
```

만약 이것이 비동기였다면, `debit()`이 완료되기 전에 메서드가 반환되어 트랜잭션 경계를 관리하기 어려워진다. 동기-블로킹은 **메서드 반환 시점 = 모든 작업 완료 시점**이므로, 트랜잭션 범위와 메서드 범위를 일치시킬 수 있다.

**성능 특성과 한계**

**장점:**
1. **구현 단순성**: 복잡한 콜백이나 상태 관리 불필요
2. **예측 가능성**: 실행 순서가 코드 순서와 일치
3. **메모리 효율**: 추가적인 Future 객체나 콜백 저장 불필요

**한계:**
1. **동시성 제약**: 하나의 스레드는 한 번에 하나의 블로킹 작업만 수행
   
2. **스레드 고갈**: 많은 동시 요청 시 스레드 풀이 고갈될 수 있음
   
3. **컨텍스트 스위칭 비용**: 블로킹 시마다 스레드 전환 발생

```java
// 100개의 동시 요청 처리
for (int i = 0; i < 100; i++) {
    threadPool.submit(() -> {
        String data = blockingRead();  // 각 스레드가 블로킹
        process(data);
    });
}
// 스레드 풀 크기가 10이면, 90개는 대기
```

**실무에서의 적용 지침**

동기-블로킹은 다음 상황에서 최적의 선택이다:

1. **작업이 빠르게 완료되는 경우**: 블로킹 시간이 짧으면 스레드 낭비가 적음
2. **순차 의존성이 강한 경우**: 각 단계가 이전 단계 결과에 의존
3. **트랜잭션이 필요한 경우**: ACID 속성 보장이 중요
4. **동시 요청 수가 적은 경우**: 스레드 풀 고갈 위험이 낮음

예시로 데이터베이스 쿼리는 빠르게 완료되고, 순차 의존성이 있으며, 트랜잭션이 필수적이고, 일반적으로 동시 요청 수를 커넥션 풀 크기로 제한할 수 있다. 따라서 JDBC는 동기-블로킹을 채택한 것이 합리적이다.

### 2.2 동기-논블로킹 (Synchronous-Non-Blocking)

#### 기술 정의와 시스템 동작 원리

**동기(Synchronous)의 본질 (재확인)**

2.1에서 정의했듯, 동기는 **호출자가 작업의 완료 여부를 직접 확인하고 제어하는 모델**이다. 반환값이나 상태 확인을 통해 "작업이 끝났는가?"를 호출자가 스스로 판단한다.

**논블로킹(Non-Blocking)의 본질: 제어권의 즉시 반환**

논블로킹의 정의는 블로킹의 정반대다: **호출된 함수가 작업 완료 여부와 무관하게 제어권을 즉시 호출자에게 돌려주는 것**이다.

```java
public void caller() {
    System.out.println("1. 작업 시작");
    
    Status status = nonBlockingRead();   // 제어권 즉시 복귀 (데이터 준비 안 됐어도)
    
    System.out.println("2. 바로 실행됨");  // 기다리지 않고 즉시 실행
}
```

**제어권 반환 타이밍의 차이:**

- **블로킹**: 제어권 반환 시점 = 작업 완료 시점
  ```java
  String data = blockingRead();  // 데이터 받을 때까지 제어권 안 줌
  // 이 시점에서 data는 항상 유효한 값
  ```

- **논블로킹**: 제어권 반환 시점 ≠ 작업 완료 시점
  ```java
  Result result = nonBlockingRead();  // 즉시 제어권 복귀
  // 이 시점에서 result.data는 null일 수 있음
  ```

**제어권 즉시 반환의 의미:**

논블로킹 함수는 호출되자마자 **"나는 요청만 받았고, 완료는 나중에 될 거야. 너는 다른 일 해"**라고 말하며 제어권을 돌려준다.

```java
// 블로킹: 제어권을 작업이 끝날 때까지 붙잡음
public String blockingRead() {
    // 네트워크 데이터 도착까지 여기 머물러 있음
    return data;  // 데이터 받고 나서야 제어권 반환
}

// 논블로킹: 제어권을 즉시 반환
public Result nonBlockingRead() {
    startReadOperation();  // 읽기 시작만 함
    return new Result(Status.PENDING);  // 즉시 반환 (데이터 없어도)
}
```

**제어권 즉시 반환이 시스템 수준에서 구현되는 방법**

논블로킹 함수가 제어권을 즉시 반환한다는 것은, **스레드가 blocked 상태로 전환되지 않는다**는 의미다.

```
caller() 실행 중
    ↓
nonBlockingRead() 호출
    ↓
read 시스템 콜 호출 (O_NONBLOCK 플래그)
    ↓
커널: 소켓 버퍼 확인
    ↓
데이터 없음 → 하지만 EAGAIN 에러 반환 (스레드를 재우지 않음)
    ↓
nonBlockingRead() 즉시 반환 (Status.NOT_READY)
    ↓
[스레드는 계속 실행]
    ↓
println("2. 바로 실행됨") 실행
```

**핵심: 논블로킹에서는 데이터가 없어도 스레드가 blocked 상태로 전환되지 않는다.** 커널이 "데이터 없어요"라고 즉시 알려주고, 스레드는 계속 실행되며 다음 코드로 넘어간다.

**블로킹 vs 논블로킹의 차이**

```
블로킹:
blockingRead() 호출 → 스레드 blocked 상태로 대기 → 데이터 도착 → 실행 재개

논블로킹:
nonBlockingRead() 호출 → 즉시 반환 → 다음 코드 실행
```

블로킹은 제어권을 돌려주지 않고 대기한다. 논블로킹은 제어권을 즉시 돌려준다.

**동기-논블로킹 조합: 폴링(Polling) 패턴**

동기와 논블로킹이 결합되면 **폴링(Polling)** 패턴이 만들어진다:

```java
public void processData() {
    // 논블로킹: 즉시 제어권 복귀
    Status status = startNonBlockingRead();
    
    // 동기: 완료 여부를 호출자가 직접 확인
    while (!status.isComplete()) {
        System.out.println("대기 중...");
        Thread.sleep(100);  // CPU 낭비 방지
        status.checkCompletion();  // 완료 여부 확인 (폴링)
    }
    
    String data = status.getData();
    process(data);
}
```

**제어권과 완료 확인의 관계:**

- **논블로킹**: 제어권을 즉시 받음
- **동기**: 하지만 완료는 호출자가 직접 확인해야 함
- **결과**: 제어권은 있지만, 완료 여부를 반복적으로 물어봐야 함 (폴링)

**단계별 제어권 이동과 시스템 동작:**

**단계 1: 논블로킹 요청**
```
[제어권: caller]
    ↓
startNonBlockingRead() 호출
    ↓
[제어권: startNonBlockingRead()]
    ↓
read(fd, buffer, O_NONBLOCK)
    ↓
커널: 데이터 없음 → EAGAIN 반환
    ↓
startNonBlockingRead() 즉시 반환 (Status.PENDING)
    ↓
[제어권: caller로 복귀]
[스레드는 계속 실행]
```

**단계 2: 폴링 루프**
```
[제어권: caller - while 루프]
    ↓
status.isComplete() 호출
    ↓
false → 루프 계속
    ↓
Thread.sleep(100) 호출
    ↓
[잠시 대기]
    ↓
100ms 후 깨어남
    ↓
다시 status.isComplete() 호출
    ↓
반복...
```

**단계 3: 완료 감지**
```
[백그라운드에서 네트워크 데이터 도착]
    ↓
커널이 소켓 버퍼에 데이터 복사
    ↓
[제어권: caller - 폴링 루프 진행 중]
    ↓
status.isComplete() 호출
    ↓
true → 루프 탈출
    ↓
status.getData() 호출
    ↓
완료된 데이터 반환
```

**핵심: 논블로킹에서는 데이터 도착 시 OS가 스레드를 깨우지 않는다.** 호출자가 스스로 반복적으로 확인해야 한다. 제어권은 계속 호출자에게 있다.

**타임아웃: 동기-논블로킹의 실용적 구현**

순수 폴링은 비효율적이므로, 실무에서는 **타임아웃**을 설정한다:

```java
public String readWithTimeout(int timeoutMs) {
    long startTime = System.currentTimeMillis();
    
    // 논블로킹 요청
    Status status = startNonBlockingRead();
    
    // 타임아웃까지 폴링
    while (!status.isComplete()) {
        if (System.currentTimeMillis() - startTime > timeoutMs) {
            throw new TimeoutException();  // 동기: 예외로 완료 통지
        }
        Thread.sleep(10);  // 짧은 간격으로 폴링
    }
    
    return status.getData();
}
```

이것이 RestTemplate의 타임아웃 설정이 하는 일이다:

```java
// 내부적으로 동기-논블로킹 폴링 패턴
factory.setReadTimeout(5000);  // 5초 동안 폴링, 안 오면 예외
```

**타임아웃 시 제어권 흐름:**

```
[제어권: caller]
    ↓
restTemplate.getForEntity() 호출
    ↓
내부적으로 논블로킹 소켓 생성
    ↓
반복 폴링 (소켓 버퍼 확인)
    ↓
5초 경과, 데이터 없음
    ↓
TimeoutException 발생
    ↓
[제어권: caller의 catch 블록]
```

제어권은 계속 caller에게 있고, 타임아웃도 caller가 판단한다. 이것이 동기의 특성이다.

**동기-논블로킹이 사용되는 이유**

이 조합은 언뜻 비효율적으로 보이지만, 다음 상황에서 유용하다:

**1. 제한된 대기 시간**
```java
// 5초만 기다리고, 안 오면 포기
Result result = readWithTimeout(5000);
```

블로킹을 사용하면 영원히 기다릴 수 있다. 논블로킹 + 폴링으로 명확한 타임아웃을 구현할 수 있다.

**2. 여러 리소스 동시 확인**
```java
while (true) {
    if (socket1.hasData()) return socket1.read();
    if (socket2.hasData()) return socket2.read();
    if (socket3.hasData()) return socket3.read();
    Thread.sleep(10);
}
```

블로킹하면 socket1에서 막히지만, 논블로킹이면 여러 소켓을 순회하며 확인할 수 있다.

**3. UI 스레드의 응답성**
```java
// UI 스레드에서 블로킹하면 화면이 멈춤
while (!data.isReady()) {
    updateProgressBar();  // UI 업데이트 가능
    Thread.sleep(100);
}
```

**제어권 관점에서 본 장점과 한계**

**장점:**

1. **제어권 유지**: 호출자가 항상 제어권을 가지고 있음
   - 타임아웃, 취소 등을 직접 제어 가능
   
2. **스레드 대기 없음**: 블로킹되지 않음
   
3. **예측 가능성**: 여전히 동기 모델
   - 코드 흐름이 위에서 아래로

**한계:**

1. **CPU 낭비 (Busy-Waiting)**: 계속 확인하느라 CPU 사용
   ```java
   while (!isReady()) {
       // CPU를 계속 사용하며 폴링
   }
   ```
   
2. **폴링 간격의 딜레마**: 
   - 짧게: CPU 낭비 증가
   - 길게: 응답 지연 증가
   
3. **복잡도 증가**: 완료 확인 로직을 직접 구현
   ```java
   // 블로킹은 간단
   data = read();
   
   // 논블로킹은 복잡
   while (!status.isComplete()) {
       sleep(10);
   }
   data = status.getData();
   ```

**스레드 상태로 본 동기-논블로킹**

```
Thread 상태 (폴링 루프):
실행 중 (폴링 확인)
    ↓
sleep(100) 호출
    ↓
대기 (잠시 sleep)
    ↓
100ms 후 깨어남
    ↓
다시 실행 (폴링 확인)
    ↓
반복...
```

블로킹과 달리, 논블로킹은 **의도적으로 sleep을 하지 않으면 계속 실행 상태를 유지**한다. 이것이 CPU를 낭비할 수 있는 이유다.

**실무에서의 적용 지침**

동기-논블로킹은 다음 상황에서 적절하다:

1. **명확한 타임아웃이 필요한 경우**: 
   - "5초 안에 응답 없으면 포기"
   
2. **여러 리소스를 동시 모니터링**:
   - select(), poll() 시스템 콜 (다중 소켓 폴링)
   
3. **블로킹이 불가능한 환경**:
   - UI 메인 스레드
   - 실시간 시스템

하지만 대부분의 경우, 이 조합은 **비효율적**이다. 블로킹(2.1)이나 비동기-논블로킹(2.3)이 더 나은 선택인 경우가 많다.

다음 섹션에서 보게 될 RestTemplate 타임아웃 예제는 이 패턴의 실제 구현이다. HTTP 요청을 논블로킹 소켓으로 보내고, 내부적으로 폴링하며, 타임아웃 시 예외를 발생시킨다.
### 2.3 비동기-논블로킹 (Asynchronous-Non-Blocking)

#### 기술 정의와 시스템 동작 원리

**비동기(Asynchronous)의 본질: 완료 통지의 위임**

비동기는 동기의 정반대다. 동기는 호출자가 완료 여부를 직접 확인했지만, 비동기는 **시스템이 완료를 통지 하거나 호출된 워커 스레드 자체가 콜백 함수를 사용하여 호출자(main 스레드 등)에게 통지**한다.

```java
// 동기: 호출자가 완료 확인
Result result = syncFunction();  // 반환 = 완료
System.out.println(result);      // 완료를 확인했으므로 사용

// 비동기: 시스템이 완료 통지
asyncFunction(result -> {        // 콜백 등록
    System.out.println(result);  // 완료되면 시스템이 이 코드를 호출
});
// 여기서는 완료 여부를 모름
```

**완료 확인의 주체:**

- **동기**: 호출자가 확인
  - "내가 반환값을 받았으니, 완료된 것이다"
  - "내가 상태를 확인하니, 완료되었구나"

- **비동기**: 시스템이 통지
  - "완료되면 내가 너한테 알려줄게"
  - "콜백을 등록해두면, 내가 완료 시 호출해줄게"

**논블로킹(Non-Blocking)의 본질 (재확인)**

2.2에서 정의했듯, 논블로킹은 **제어권을 즉시 반환**하는 것이다. 작업 완료 여부와 무관하게 호출자에게 제어권을 돌려준다.

**비동기-논블로킹 조합: 이벤트 기반 프로그래밍의 핵심**

비동기와 논블로킹이 결합되면, 가장 강력한 동시성 모델이 만들어진다:

```java
public void processData() {
    System.out.println("1. 요청 시작");
    
    // 논블로킹: 즉시 제어권 복귀
    // 비동기: 완료는 콜백으로 통지
    asyncNonBlockingRead(data -> {
        System.out.println("3. 완료됨: " + data);
        process(data);
    });
    
    System.out.println("2. 다른 작업 수행");  // 바로 실행
    performOtherTasks();
}
```

**출력 순서:**
```
1. 요청 시작
2. 다른 작업 수행
(다른 작업들 계속 수행)
3. 완료됨: [데이터]
```

**제어권과 완료 통지의 완전한 분리:**

- **논블로킹**: 제어권은 즉시 호출자에게 (2번 줄 바로 실행)
- **비동기**: 완료 통지는 나중에 시스템이 (3번 줄은 나중에 실행)
- **결과**: 호출자는 기다리지 않고, 시스템이 알아서 완료를 처리

이것이 Node.js, Netty, Reactor의 핵심 모델이다.

**제어권 흐름: 호출자와 이벤트 루프의 분리**

비동기-논블로킹의 가장 큰 특징은 **제어권이 두 개의 독립적인 흐름**으로 나뉜다는 것이다:

```
[제어권 흐름 1: 호출자]
processData() 시작
    ↓
asyncNonBlockingRead() 호출 (콜백 등록만 함)
    ↓
즉시 반환 (제어권 복귀)
    ↓
println("2. 다른 작업 수행")
    ↓
performOtherTasks()
    ↓
메서드 종료

[제어권 흐름 2: 이벤트 루프] (독립적으로 실행)
논블로킹 I/O 수행 (백그라운드)
    ↓
데이터 도착 감지 (epoll, kqueue 등)
    ↓
등록된 콜백 호출
    ↓
println("3. 완료됨")
    ↓
process(data)
```

**핵심: 두 제어권 흐름이 서로 다른 스레드에서 독립적으로 실행된다.** 호출자는 블로킹되지도 않고, 폴링하지도 않는다. 완전히 분리된다.

**시스템 수준에서의 구현: EventLoop와 epoll**

비동기-논블로킹이 어떻게 "기다리지 않으면서" 완료를 감지하는가? 이는 **EventLoop + 커널의 논블로킹 I/O 알림 메커니즘**으로 구현된다.

**단계 1: 논블로킹 요청 및 콜백 등록**
```
[제어권: caller]
    ↓
asyncNonBlockingRead(callback) 호출
    ↓
내부적으로:
1. 논블로킹 소켓 생성 (O_NONBLOCK)
2. EventLoop에 (소켓, callback) 등록
3. epoll/kqueue에 소켓 등록
    ↓
asyncNonBlockingRead() 즉시 반환
    ↓
[제어권: caller로 복귀]
[호출자는 다른 작업 수행]
```

**단계 2: 백그라운드 I/O 처리 (EventLoop)**
```
[EventLoop 실행 중]
    ↓
while (true) {
    // epoll_wait() - 논블로킹 대기
    events = epoll_wait(epollFd, ...);
    
    for (event : events) {
        callback = findCallback(event.fd);
        callback.onComplete(event.data);
    }
}
```

**핵심: EventLoop는 하나의 스레드로 수천 개의 I/O를 처리한다.** epoll_wait()가 커널에게 "이 소켓들 중 준비된 게 있으면 알려줘"라고 말하면, 커널이 준비된 소켓 목록을 반환한다.

**단계 3: 완료 통지 (콜백 실행)**
```
네트워크 데이터 도착
    ↓
커널이 epoll에 통지
    ↓
epoll_wait() 반환 (해당 소켓 fd 포함)
    ↓
EventLoop가 등록된 콜백 찾음
    ↓
[제어권: EventLoop 스레드에서 콜백 실행]
    ↓
callback.onComplete(data)
    ↓
println("3. 완료됨")
    ↓
process(data)
```

**caller와 콜백의 실행 주체 차이:**

```java
asyncNonBlockingRead(data -> {
    process(data);  // 이 코드는 누가 실행하는가?
});
performOtherTasks();  // 이 코드는 누가 실행하는가?
```

- `performOtherTasks()`: 호출한 스레드가 실행
- `process(data)`: EventLoop 스레드가 실행

**서로 다른 스레드**다. 이것이 비동기의 핵심이다.

**스레드 상태: 효율적인 리소스 사용**

비동기-논블로킹의 최대 장점은 **최소한의 스레드로 많은 I/O를 처리**한다는 것이다:

```
[시스템 전체 상태]

호출한 스레드:
    다른 비즈니스 로직 수행

EventLoop 스레드:
    대기 중 (epoll_wait)
    하지만 1000개의 소켓을 동시에 감시 중

소켓 1~1000:
    커널이 관리, 데이터 도착 시 epoll에 통지
```

**비교: 동기-블로킹이었다면?**

```
스레드 1: BLOCKED (소켓 1 대기)
스레드 2: BLOCKED (소켓 2 대기)
스레드 3: BLOCKED (소켓 3 대기)
...
스레드 1000: BLOCKED (소켓 1000 대기)
```

1000개의 스레드가 모두 BLOCKED 상태로 메모리만 차지한다. 비동기-논블로킹은 **1개의 EventLoop 스레드**로 동일한 일을 한다.

**콜백의 실행: 스레드 풀 vs EventLoop**

비동기-논블로킹에는 두 가지 구현 방식이 있다:

**방식 1: EventLoop 직접 실행 (Node.js 스타일)**
```javascript
// Node.js
fs.readFile('file.txt', (err, data) => {
    // 이 콜백은 EventLoop 스레드에서 실행
    console.log(data);
});
```

장점: 컨텍스트 스위칭 없음
단점: 콜백이 오래 걸리면 EventLoop 블로킹

**방식 2: 워커 스레드 풀로 dispatch (Netty, Reactor 스타일)**
```java
// Reactor
Mono.fromCallable(() -> blockingOperation())
    .subscribeOn(Schedulers.boundedElastic())  // 워커 스레드 풀
    .subscribe(result -> process(result));
```

```
EventLoop 스레드:
    epoll_wait()로 I/O 감지
    ↓
    콜백을 워커 스레드 풀에 제출
    ↓
    즉시 다시 epoll_wait()로 돌아감

워커 스레드 1:
    콜백 실행 (process(data))

워커 스레드 2~N:
    다른 콜백 실행
```

이 방식은 콜백이 CPU 집약적이거나 블로킹 작업을 해도 EventLoop를 막지 않는다.

**비동기-논블로킹의 핵심 메커니즘 정리**

1. **제어권 즉시 반환**: 호출자는 기다리지 않음 (논블로킹)
2. **완료 통지 위임**: 시스템이 콜백 호출 (비동기)
3. **EventLoop**: 한 스레드로 다중 I/O 감시
4. **커널 알림**: epoll/kqueue로 효율적인 I/O 감지
5. **독립적인 제어권 흐름**: 호출자와 콜백이 다른 스레드

**동기-논블로킹 (폴링)과의 비교**

```
동기-논블로킹 (2.2):
    while (!isComplete()) {
        sleep(10);  // 주기적으로 확인 (낭비)
    }

비동기-논블로킹 (2.3):
    epoll_wait(...);  // 준비될 때까지 대기, 준비되면 즉시 반환
```

폴링은 "혹시 준비됐나?"를 반복적으로 물어본다. epoll은 "준비되면 알려줘"라고 말하고 기다린다. 후자가 훨씬 효율적이다.

**WebClient의 내부 구조**

Spring WebClient는 이 모든 메커니즘을 구현한다:

```java
Mono<User> userMono = webClient.get()
    .uri("/users/{id}", userId)
    .retrieve()
    .bodyToMono(User.class);  // 여기까지는 실행 안 됨 (지연 평가)

userMono.subscribe(user -> {
    // 비동기: 이 콜백은 EventLoop 스레드가 실행
    System.out.println(user);
});
// 논블로킹: 여기 즉시 도달
```

**내부 동작:**

1. `subscribe()` 호출 시 Reactor Netty EventLoop 시작
2. EventLoop가 논블로킹 HTTP 요청 전송
3. EventLoop는 epoll로 소켓 감시
4. 응답 도착 시 콜백 실행
5. 호출한 스레드는 전혀 블로킹되지 않음

**성능 특성과 장점**

**장점:**

1. **최소 스레드로 최대 동시성**
   - 1개 EventLoop로 수천 개 I/O 처리
   - 스레드 생성/관리 비용 최소화

2. **스레드 전환 최소화**
   - 스레드가 blocked되지 않으므로 전환 불필요

3. **메모리 효율**
   - 스레드마다 스택 메모리(1MB+) 불필요
   - 1000 커넥션 = 1000MB (블로킹) vs ~10MB (논블로킹)

4. **확장성**
   - C10K 문제 해결 (1만 개 동시 연결)
   - EventLoop만으로 충분

**한계:**

1. **복잡한 제어 흐름**
   ```java
   // 동기-블로킹: 직관적
   User user = getUser(id);
   Order order = getOrder(user.getId());
   return process(order);

   // 비동기-논블로킹: 복잡
   getUserAsync(id)
       .thenCompose(user -> getOrderAsync(user.getId()))
       .thenApply(order -> process(order));
   ```

2. **디버깅 어려움**
   - 콜백이 다른 스레드에서 실행
   - 스택 트레이스가 단절됨

3. **에러 처리 복잡**
   ```java
   asyncOperation()
       .onErrorResume(error -> fallback())  // 에러도 비동기로
       .subscribe(result -> process(result));
   ```

4. **러닝 커브**
   - Reactive 프로그래밍 패러다임 학습 필요
   - 콜백 지옥 또는 Reactive 체인

**스레드 상태로 본 비동기-논블로킹**

```
[호출한 스레드]
실행 중 (요청 시작)
    ↓
실행 중 (콜백 등록)
    ↓
실행 중 (다른 작업 계속)
    ↓
(콜백과 무관하게 계속 실행)

[EventLoop 스레드]
대기 (epoll_wait - 하지만 1000개 소켓 감시)
    ↓
I/O 준비됨
    ↓
실행 중 (콜백 실행)
    ↓
대기 (다시 epoll_wait)
```

호출한 스레드는 단 한 번도 blocked되지 않는다. 이것이 논블로킹이다.
EventLoop는 대기하지만, 하나의 epoll_wait로 수천 개를 감시한다. 이것이 비동기의 효율성이다.

**실무에서의 적용 지침**

비동기-논블로킹은 다음 상황에서 최적이다:

1. **I/O 집약적 워크로드**
   - 많은 네트워크 요청
   - 많은 데이터베이스 쿼리
   - 파일 I/O

2. **높은 동시성 요구**
   - 수천~수만 개의 동시 연결
   - 마이크로서비스 간 통신

3. **낮은 레이턴시 요구**
   - 실시간 시스템
   - 게임 서버
   - 채팅 서버

하지만 다음 경우는 피해야 한다:

1. **CPU 집약적 작업**: 비동기의 이점 없음
2. **단순한 CRUD**: 동기-블로킹이 더 간단
3. **팀의 러닝 커브**: Reactive 경험 필요

다음 섹션에서 보게 될 WebClient 예제는 이 모든 원리를 실제 코드로 구현한다. Reactor Netty EventLoop가 논블로킹 I/O를 수행하고, 응답이 오면 등록된 콜백을 호출하여 비동기 처리를 완성한다.

### 2.4 비동기-블로킹 (Asynchronous-Blocking)

#### 기술 정의와 시스템 동작 원리

**비동기(Asynchronous)의 본질 (재확인)**

2.3에서 정의했듯, 비동기는 **완료 통지를 시스템에 위임**하는 것이다. 호출자는 완료를 직접 확인하지 않고, 콜백이나 Future를 통해 통지받는다.

**블로킹(Blocking)의 본질 (재확인)**

2.1에서 정의했듯, 블로킹은 **제어권을 즉시 돌려주지 않는 것**이다. 작업이 완료될 때까지 스레드가 blocked 상태로 대기한다.

**비동기-블로킹 조합: 모순적이고 비효율적인 패턴**

비동기와 블로킹의 조합은 **이론적으로는 가능하지만, 실무에서는 대부분 의도하지 않은 안티패턴**이다:

```java
public CompletableFuture<User> getUserAsync(Long id) {
    CompletableFuture<User> future = new CompletableFuture<>();
    
    executor.submit(() -> {
        try {
            // 블로킹: 이 스레드가 BLOCKED됨
            Connection conn = dataSource.getConnection();  // 블로킹!
            ResultSet rs = executeQuery(conn, id);         // 블로킹!
            User user = parseResult(rs);
            
            // 비동기: Future를 통해 완료 통지
            future.complete(user);
        } catch (Exception e) {
            future.completeExceptionally(e);
        }
    });
    
    return future;  // 즉시 반환 (논블로킹처럼 보임)
}
```

**제어권과 완료 통지의 비대칭:**

- **호출자 관점**: 제어권을 즉시 받음 (논블로킹처럼 보임)
  ```java
  CompletableFuture<User> future = getUserAsync(id);  // 즉시 반환
  System.out.println("다른 작업 수행");  // 바로 실행
  ```

- **실행 스레드 관점**: 제어권을 돌려주지 않음 (블로킹)
  ```java
  Connection conn = dataSource.getConnection();  // 워커 스레드가 BLOCKED
  ```

- **완료 통지**: 비동기 (Future/콜백)
  ```java
  future.thenAccept(user -> process(user));  // 완료 시 시스템이 호출
  ```

**왜 이것이 문제인가?**

겉으로는 비동기로 보이지만(Future 반환), 내부적으로는 워커 스레드가 블로킹되어 있다. 이는 비동기의 이점(적은 스레드로 많은 요청 처리)을 전혀 살리지 못한다.

**제어권 흐름: 숨겨진 블로킹**

```
[제어권 흐름 1: 호출자]
getUserAsync(id) 호출
    ↓
Future 객체 생성 및 즉시 반환
    ↓
[제어권: 즉시 호출자에게 복귀]
    ↓
println("다른 작업 수행")  // 호출자는 논블로킹

[제어권 흐름 2: 워커 스레드]
executor.submit()의 람다 실행
    ↓
dataSource.getConnection() 호출
    ↓
[워커 스레드: blocked 상태]
[커넥션 대기]
    ↓
커넥션 획득
    ↓
[워커 스레드: 실행 재개]
    ↓
executeQuery() 호출
    ↓
[워커 스레드: blocked 상태]
[DB 응답 대기]
    ↓
DB 응답 도착
    ↓
[워커 스레드: 실행 재개]
    ↓
future.complete(user)  // 비동기 완료 통지
```

**핵심 문제: 워커 스레드가 블로킹되는 동안 그 스레드는 아무 일도 못한다.** 호출자는 논블로킹이지만, 시스템 전체로 보면 스레드 리소스를 낭비한다.

**시스템 리소스 관점: 비효율의 증명**

**시나리오: 100개의 동시 요청**

**동기-블로킹 (2.1):**
```
스레드 풀 크기: 10
    ↓
10개 요청: 동시 처리 (각 스레드 BLOCKED 상태)
90개 요청: 큐에서 대기
    ↓
평균 응답 시간: 높음
하지만 스레드 사용은 정직함 (10개만 사용)
```

**비동기-블로킹 (2.4 - 잘못된 패턴):**
```
워커 스레드 풀 크기: 50
    ↓
50개 요청: 동시 제출
각 워커 스레드: BLOCKED (커넥션/DB 대기)
    ↓
50개 스레드가 모두 BLOCKED
나머지 50개 요청: 큐에서 대기
    ↓
평균 응답 시간: 여전히 높음
스레드는 5배 사용 (50개)
메모리 낭비: 50MB (스레드 스택)
```

**비동기-논블로킹 (2.3 - 올바른 패턴):**
```
EventLoop 스레드: 1~2개
    ↓
100개 요청: 모두 동시 처리
각 요청: 논블로킹 I/O (스레드 BLOCKED 안 됨)
    ↓
100개 요청 모두 진행 중
스레드는 2개만 사용
메모리: 2MB
    ↓
평균 응답 시간: 낮음 (진짜 동시 처리)
```

**비동기-블로킹은 최악이다**: 비동기의 복잡도 + 블로킹의 비효율성

**스레드 사용 패턴 비교**

**동기-블로킹:**
```
스레드 A: 실행 → blocked (I/O 대기)
스레드 B: 실행 → blocked (I/O 대기)
스레드 C: 실행 (CPU 작업)
    ↓
명확함: 블로킹을 예상하고 설계
스레드 풀 크기를 적절히 제한
```

**비동기-블로킹:**
```
워커 1: 실행 → blocked (숨겨진 블로킹!)
워커 2: 실행 → blocked (숨겨진 블로킹!)
워커 3: 실행 → blocked (숨겨진 블로킹!)
...
워커 50: 실행 → blocked
    ↓
혼란스러움: 겉으로는 비동기인데 내부는 블로킹
스레드 풀을 크게 만들어도 여전히 블로킹됨
```

**비동기-논블로킹:**
```
EventLoop: 실행 (epoll_wait)
워커 1: 실행 (실제 연산 작업)
워커 2: 실행 (실제 연산 작업)
    ↓
효율적: I/O는 논블로킹, CPU 작업만 스레드 사용
최소 스레드로 최대 동시성
```

**실제 사례: CompletableFuture + JDBC의 함정**

많은 개발자가 다음과 같이 작성한다:

```java
@Service
public class UserService {
    private final ExecutorService executor = Executors.newFixedThreadPool(50);
    private final DataSource dataSource;  // HikariCP
    
    public CompletableFuture<User> getUserAsync(Long id) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // 이 부분이 블로킹!
                Connection conn = dataSource.getConnection();
                PreparedStatement ps = conn.prepareStatement("SELECT * FROM users WHERE id = ?");
                ps.setLong(1, id);
                ResultSet rs = ps.executeQuery();
                
                if (rs.next()) {
                    return new User(rs.getLong("id"), rs.getString("name"));
                }
                return null;
            } catch (SQLException e) {
                throw new RuntimeException(e);
            }
        }, executor);
    }
}
```

**이 코드의 문제:**

1. **겉으로는 비동기**: `CompletableFuture` 반환, 호출자는 논블로킹
2. **실제로는 블로킹**: 워커 스레드가 JDBC로 블로킹
3. **스레드 풀 고갈**: 50개 스레드 모두 DB 대기로 BLOCKED
4. **메모리 낭비**: 50개 스레드 × 1MB = 50MB
5. **컨텍스트 스위칭**: BLOCKED → RUNNING 반복

**Wherehouse 프로젝트의 함정**

Wherehouse 프로젝트가 바로 이 패턴에 해당한다:

```java
// 현재 Wherehouse 구현 (비동기-블로킹)
public CompletableFuture<List<PlaceInfo>> getPlacesAsync(String category) {
    return CompletableFuture.supplyAsync(() -> {
        // RestTemplate은 블로킹 I/O!
        ResponseEntity<KakaoApiResponse> response = 
            restTemplate.getForEntity(url, KakaoApiResponse.class);
        return parseResponse(response);
    }, executor);
}
```

**무엇이 블로킹인가?**

- `restTemplate.getForEntity()`: 내부적으로 블로킹 소켓 사용
- 워커 스레드가 HTTP 응답을 받을 때까지 BLOCKED 상태
- 16개 API 호출 = 16개 워커 스레드가 동시에 BLOCKED

**스레드 상태:**

```
[15개 워커 스레드가 모두 blocked]
워커 1: 대기 (카카오 API 응답 대기)
워커 2: 대기 (카카오 API 응답 대기)
워커 3: 대기 (카카오 API 응답 대기)
...
워커 15: 대기 (카카오 API 응답 대기)

[이 시간 동안 이 스레드들은 아무것도 못함]
```

**올바른 해결책: WebClient (진짜 비동기-논블로킹)**

```java
// 올바른 구현 (비동기-논블로킹)
public Mono<List<PlaceInfo>> getPlacesAsync(String category) {
    return webClient.get()
        .uri(uriBuilder -> uriBuilder
            .path("/v2/local/search/category")
            .queryParam("category_group_code", category)
            .build())
        .retrieve()
        .bodyToMono(KakaoApiResponse.class)
        .map(this::parseResponse);
}
```

**차이점:**

- RestTemplate: 워커 스레드가 블로킹 소켓에서 BLOCKED
- WebClient: EventLoop가 epoll로 논블로킹 감시, 스레드 BLOCKED 안 됨

**성능 비교:**

```
RestTemplate (비동기-블로킹):
    15개 API 호출
    15개 워커 스레드 필요
    각 스레드 BLOCKED
    메모리: 15MB (스레드 스택)
    응답 시간: 400ms

WebClient (비동기-논블로킹):
    15개 API 호출
    1개 EventLoop 스레드
    스레드 BLOCKED 안 됨
    메모리: 1MB
    응답 시간: 400ms (동일)
    
하지만 동시 요청이 100개라면?
RestTemplate: 1500개 워커 스레드 필요 (불가능, 스레드 풀 고갈)
WebClient: 여전히 1개 EventLoop (수천 개 동시 처리 가능)
```

**비동기-블로킹이 발생하는 다른 사례**

**사례 1: 블로킹 라이브러리를 비동기로 감싼 경우**
```java
CompletableFuture.supplyAsync(() -> {
    return blockingHttpClient.get(url);  // Apache HttpClient (블로킹)
}, executor);
```

**사례 2: CompletableFuture 체인에 블로킹 작업**
```java
CompletableFuture.supplyAsync(() -> fetchUser())
    .thenApply(user -> {
        // 이 부분이 블로킹!
        Thread.sleep(1000);  // 워커 스레드 BLOCKED
        return processUser(user);
    });
```

**사례 3: Reactive 스트림에 블로킹 작업**
```java
Mono.fromCallable(() -> {
    // JDBC는 블로킹!
    return jdbcTemplate.queryForObject(sql, User.class);
});  // subscribeOn() 없으면 호출한 스레드에서 블로킹!
```

**스레드 상태로 본 비동기-블로킹**

```
[호출자]
실행 중 (getUserAsync 호출)
    ↓
실행 중 (Future 반환 받음, 논블로킹처럼 보임)
    ↓
실행 중 (다른 작업 계속)

[워커 스레드 1]
실행 중 (작업 시작)
    ↓
blocked (dataSource.getConnection())
    ↓
커넥션 획득
    ↓
실행 재개
    ↓
blocked (executeQuery())
    ↓
DB 응답
    ↓
실행 재개
    ↓
future.complete()

[워커 스레드 2~N]
동일한 블로킹 패턴 반복
```

**호출자는 논블로킹이지만, 워커 스레드들은 계속 blocked된다.** 이것이 비동기-블로킹의 본질이다.

**성능 특성과 문제점**

**장점:**
거의 없음. 억지로 찾자면:
1. **호출자 논블로킹**: 호출하는 쪽 코드는 간단
2. **기존 블로킹 라이브러리 재사용**: JDBC 등을 그대로 사용

**치명적인 단점:**

1. **스레드 낭비**: 
   - 워커 스레드가 BLOCKED되어 아무것도 안 함
   - 동시 요청 수만큼 스레드 필요

2. **메모리 낭비**:
   - 각 스레드마다 스택 메모리 (1MB+)
   - 1000개 요청 = 1GB 메모리

3. **스레드 전환 오버헤드**:
   - blocked → 실행 전환 반복
   - 레지스터 저장/복원 비용

4. **비동기의 복잡도**:
   - CompletableFuture 체이닝
   - 에러 처리 복잡
   - 하지만 성능 이점은 없음!

5. **스레드 풀 크기 딜레마**:
   - 작게: 동시 요청 처리 불가
   - 크게: 메모리 낭비, 컨텍스트 스위칭 폭발

---

## 결론: 개념의 명확한 이해와 올바른 적용

### 핵심 정리

1. **블로킹/논블로킹은 제어권 반환 시점**을 다룬다. 함수가 즉시 반환하는가, 작업 완료 후 반환하는가의 문제다.

2. **동기/비동기는 완료 확인 방식**을 다룬다. 호출자가 확인하는가, 시스템이 알려주는가의 문제다.

3. **두 개념은 완전히 독립적**이다. 4가지 조합이 모두 실재하며, 각각 다른 사용 사례를 가진다.

4. **CompletableFuture는 이중 구조**를 가진다. 사용자에게는 비동기-논블로킹으로 보이지만, 워커 스레드는 동기-블로킹으로 동작한다.

5. **진정한 논블로킹은 작업과 스레드의 분리**를 의미한다. 작업 상태를 객체로 관리하고, 스레드는 단순히 실행 자원이 된다.

### 실무 적용 지침

- **CPU 집약적**: 동기-블로킹 유지, 병렬 처리로 개선
- **I/O 집약적**: 비동기-논블로킹으로 전환 고려
- **레거시 통합**: CompletableFuture로 점진적 개선
- **고성능 요구**: 완전 논블로킹 (Reactive) 도입

### 최종 통찰

블로킹과 논블로킹의 차이는 단순한 API 차이가 아니라, **시스템 아키텍처의 근본적 차이**다. 스레드를 작업 단위로 보느냐, 실행 자원으로 보느냐의 패러다임 전환이다. 이 차이를 정확히 이해할 때, 시스템의 확장성과 효율성을 극대화할 수 있다.

---

## 참고 자료

### 기술 명세
- Java Language Specification, Chapter 17: Threads and Locks
- Intel 64 and IA-32 Architectures Software Developer's Manual

### 구현 소스 코드
- OpenJDK Source: java.util.concurrent
- Netty Framework: io.netty.channel

### 실무 가이드
- "Java Concurrency in Practice" - Brian Goetz
- "Reactive Programming with RxJava" - Tomasz Nurkiewicz
- "High Performance Browser Networking" - Ilya Grigorik