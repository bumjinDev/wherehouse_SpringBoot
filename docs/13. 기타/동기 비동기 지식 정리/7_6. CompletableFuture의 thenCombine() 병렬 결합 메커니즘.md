# CompletableFuture의 thenCombine() 병렬 결합 메커니즘
## 독립적 비동기 작업의 병렬 실행과 결과 통합 아키텍처

---

# 개요: 병렬 결합 메커니즘

## 1. 왜 병렬 결합이 필요한가

### 1.1 순차 의존성 vs 병렬 독립성의 구조적 차이

비동기 작업 체이닝에는 근본적으로 두 가지 패턴이 존재한다. 첫 번째는 **순차적 의존성(Sequential Dependency)**으로, A 작업의 결과가 B 작업의 입력이 되는 경우다. 사용자 인증 후 그 사용자의 프로필을 조회하는 것이 전형적인 예다. 이 경우 B는 A 없이는 시작조차 할 수 없으며, 이를 위해 `thenCompose()`가 설계되었다.

두 번째는 **병렬 독립성(Parallel Independence)**이다. 두 작업이 서로의 결과를 필요로 하지 않으며, 동시에 실행될 수 있는 경우다. 전자상거래 시스템에서 상품 상세 페이지를 구성할 때를 생각해보자. 상품의 기본 정보(상품명, 가격, 설명)와 재고 상태는 서로 다른 데이터베이스 테이블이나 서비스에서 조회된다. 이 두 조회 작업은 완전히 독립적이며, 하나가 다른 하나의 결과를 필요로 하지 않는다.

만약 이를 `thenCompose()`로 구현하면 구조적으로 잘못된 설계가 된다:

```java
// ❌ 구조적으로 잘못된 순차 실행
getProductInfo(productId)
    .thenCompose(info -> getInventoryStatus(productId)
        .thenApply(inventory -> new ProductPage(info, inventory))
    );
```

이 코드는 상품 정보 조회(예: 500ms)가 완료된 후에야 재고 조회(예: 300ms)를 시작한다. 총 실행 시간은 800ms가 되며, 두 작업이 독립적임에도 불구하고 순차적으로 실행되어 성능이 낭비된다. 더 중요한 문제는 **코드가 비즈니스 로직의 의도를 왜곡한다**는 것이다. 상품 정보와 재고는 의존 관계가 없는데, 코드는 마치 재고 조회가 상품 정보에 의존하는 것처럼 표현한다.

### 1.2 병렬 실행의 아키텍처적 필요성

현대 마이크로서비스 아키텍처에서는 독립적인 서비스 호출이 빈번히 발생한다. 사용자 대시보드를 구성하는 상황을 생각해보자:
- 사용자 프로필 서비스에서 기본 정보 조회
- 알림 서비스에서 읽지 않은 알림 개수 조회
- 추천 서비스에서 맞춤 콘텐츠 목록 조회
- 활동 서비스에서 최근 활동 이력 조회

이 네 개의 서비스 호출은 완전히 독립적이다. 순차적으로 실행하면 각 호출이 평균 200ms 걸린다고 가정할 때 총 800ms가 소요된다. 하지만 병렬로 실행하면 이론적으로 200ms(가장 느린 호출의 시간)에 완료할 수 있다. 이는 단순한 성능 최적화가 아니라 **사용자 경험의 질적 차이**를 만든다.

더 중요한 것은 장애 격리(Fault Isolation)다. 병렬 실행 구조에서는 한 서비스의 지연이나 실패가 다른 서비스 호출을 블로킹하지 않는다. 알림 서비스가 느려지더라도 프로필과 추천 콘텐츠는 정상적으로 표시될 수 있다. 이는 부분 실패(Partial Failure)를 우아하게 처리하는 회복력 있는 시스템 설계의 핵심이다.

### 1.3 결과 통합의 타입 설계 문제

병렬로 실행된 두 작업의 결과를 결합해야 하는데, 이때 타입 시스템이 해결해야 할 문제가 있다. `CompletableFuture<T>`와 `CompletableFuture<U>`라는 서로 다른 타입의 비동기 작업이 있을 때, 이 둘의 결과를 받아 `V` 타입을 생성하는 로직을 어떻게 표현할 것인가?

단순히 각각을 `join()`으로 블로킹하여 결과를 얻는 것은 비동기성을 포기하는 것이다:

```java
// ❌ 비동기성 포기 - 블로킹 방식
CompletableFuture<ProductInfo> infoFuture = getProductInfo(id);
CompletableFuture<Inventory> inventoryFuture = getInventoryStatus(id);

ProductInfo info = infoFuture.join();      // 블로킹 1
Inventory inventory = inventoryFuture.join(); // 블로킹 2
ProductPage page = new ProductPage(info, inventory);
```

이 코드는 두 작업을 병렬로 시작하지만, 결과를 기다리는 시점에서 메인 스레드를 블로킹한다. 더 나쁜 것은 타입 시스템이 "이것은 비동기 작업이다"라는 정보를 완전히 잃어버린다는 것이다. `ProductPage`는 그냥 일반 객체가 되어, 이후 비동기 체인에 통합할 수 없게 된다.

필요한 것은 **"두 비동기 작업이 모두 완료되면, 그 결과들로 새로운 값을 계산하고, 이 계산 결과를 담은 새로운 CompletableFuture를 반환하는" 메커니즘**이다. 이것이 `thenCombine()`의 존재 이유다.

---

## 2. thenCombine()의 병렬 결합 메커니즘

### 2.1 BiFunction을 통한 타입 결합 구조

`thenCombine()`의 메서드 시그니처는 병렬 결합의 본질을 명확히 드러낸다:

```java
public <U, V> CompletableFuture<V> thenCombine(
    CompletionStage<? extends U> other,
    BiFunction<? super T, ? super U, ? extends V> fn
)
```

이 시그니처는 세 가지 핵심 요소를 정의한다:

**첫째, 두 독립적인 타입의 결합:**
- 현재 CompletableFuture가 담고 있는 타입 `T`
- `other` 파라미터로 전달된 또 다른 CompletableFuture가 담고 있는 타입 `U`
- 이 둘은 완전히 다른 타입이며, 어떠한 상속 관계도 없을 수 있다

**둘째, BiFunction의 타입 변환 능력:**
```java
BiFunction<T, U, V>
```
이 함수는 `T`와 `U`를 입력으로 받아 새로운 타입 `V`를 생성한다. 단순히 두 값을 조합하는 것부터 완전히 새로운 비즈니스 객체를 생성하는 것까지 모든 변환이 가능하다.

**셋째, 비동기성의 보존:**
반환 타입이 `CompletableFuture<V>`이므로, 결합된 결과도 여전히 비동기 컨텍스트 내에 존재한다. 이는 추가적인 체이닝이 가능함을 의미한다.

### 2.2 병렬 실행과 동기화 메커니즘

`thenCombine()`이 호출되는 순간 무슨 일이 발생하는지 단계별로 분해해보자.

**호출 즉시 발생하는 일:**

```java
CompletableFuture<ProductInfo> future1 = getProductInfo(productId);  // 이미 실행 중
CompletableFuture<Inventory> future2 = getInventoryStatus(productId); // 이미 실행 중

CompletableFuture<ProductPage> combined = future1.thenCombine(future2, 
    (info, inventory) -> new ProductPage(info, inventory)
);
```

`thenCombine()`이 호출되면 즉시 새로운 `CompletableFuture<ProductPage>` 객체가 생성되어 반환된다. 이 객체를 "결과 컨테이너"라고 하자. 중요한 점은 **이 시점에서 `future1`과 `future2`는 이미 실행 중이며**, `thenCombine()`은 이들의 실행을 방해하지 않는다는 것이다.

**동기화 지점 설정:**

내부적으로 `thenCombine()`은 두 Future에 각각 콜백을 등록한다:
- `future1`에 등록된 콜백: "내가 완료되면 `future2`의 상태를 확인하라"
- `future2`에 등록된 콜백: "내가 완료되면 `future1`의 상태를 확인하라"

이는 **상호 참조 동기화(Cross-Reference Synchronization)** 패턴이다. 각 Future는 자신이 완료되면 상대방의 완료 여부를 체크한다.

**BiFunction 실행 조건:**

두 Future 모두 완료되었을 때만 BiFunction이 실행된다. 먼저 완료된 쪽의 콜백이 실행되면 상대방이 아직 미완료 상태이므로 대기한다. 나중에 완료된 쪽의 콜백이 실행되면 이미 상대방이 완료되었음을 확인하고, 이 시점에서 BiFunction을 트리거한다.

**결과 전파:**

```
T1 스레드: getProductInfo() 실행 → 500ms 후 완료
T2 스레드: getInventoryStatus() 실행 → 300ms 후 완료

300ms 시점: future2 완료 → future1 확인 → 아직 미완료 → 대기
500ms 시점: future1 완료 → future2 확인 → 이미 완료됨 → BiFunction 실행
```

BiFunction이 실행되면 `ProductPage` 객체가 생성되고, 이 값이 결과 컨테이너의 `complete(value)` 메서드를 통해 설정된다. 이제 `combined.join()`을 호출하는 모든 코드가 이 결과를 받을 수 있다.

### 2.3 예외 처리의 병렬 전파

병렬 실행에서 예외 처리는 복잡한 문제를 야기한다. 두 작업 중 하나 또는 둘 다 실패할 수 있으며, 실패 시점도 다를 수 있다.

**단일 실패 시나리오:**

```java
CompletableFuture<ProductInfo> future1 = getProductInfo(productId);
CompletableFuture<Inventory> future2 = CompletableFuture.supplyAsync(() -> {
    throw new RuntimeException("재고 서비스 장애");
});

CompletableFuture<ProductPage> combined = future1.thenCombine(future2,
    (info, inventory) -> new ProductPage(info, inventory)
);
```

`future2`가 먼저 실패하면, `combined`는 즉시 예외 상태로 전환된다. **BiFunction은 실행되지 않는다.** 이는 중요한 설계 결정이다: 두 입력 중 하나라도 실패하면 결합 자체가 무의미하기 때문이다.

`future1`이 나중에 완료되더라도 이미 `combined`는 실패 상태이므로, 그 결과는 무시된다. 이는 **빠른 실패(Fail-Fast)** 원칙을 따른다.

**동시 실패 시나리오:**

두 작업이 모두 실패하면 **먼저 발생한 예외**가 `combined`에 전파된다. 나중 예외는 `getSuppressed()`를 통해 접근 가능한 억제된 예외로 기록될 수 있다.

```java
combined.exceptionally(ex -> {
    System.err.println("주 예외: " + ex.getMessage());
    for (Throwable suppressed : ex.getSuppressed()) {
        System.err.println("억제된 예외: " + suppressed.getMessage());
    }
    return null;
});
```

이는 디버깅 시 매우 유용하다. 두 서비스가 동시에 장애를 겪었는지, 하나의 장애가 연쇄 반응을 일으켰는지 파악할 수 있다.

---

## 3. thenCombine() vs 다른 결합 메서드들의 역할 구분

### 3.1 thenCombine() vs thenCompose(): 의존성 패턴의 차이

`thenCompose()`와 `thenCombine()`은 근본적으로 다른 의존성 패턴을 처리한다.

**thenCompose() - 순차적 의존성:**
```java
getUserId(sessionToken)
    .thenCompose(userId -> getUserProfile(userId))
    .thenCompose(profile -> getUserOrders(profile.getId()))
```

각 단계는 이전 단계의 결과에 **의존**한다:
- `getUserProfile()`은 `userId` 없이는 시작할 수 없음
- `getUserOrders()`는 `profile.getId()` 없이는 시작할 수 없음

이는 **데이터 흐름 의존성(Data Flow Dependency)**이며, 실행 순서가 강제된다.

**thenCombine() - 병렬 독립성:**
```java
CompletableFuture<ProductInfo> info = getProductInfo(productId);
CompletableFuture<Inventory> inventory = getInventoryStatus(productId);

info.thenCombine(inventory, (i, inv) -> new ProductPage(i, inv));
```

두 작업은 **독립적**이며:
- `getProductInfo()`는 `getInventoryStatus()`의 결과를 필요로 하지 않음
- `getInventoryStatus()`는 `getProductInfo()`의 결과를 필요로 하지 않음

이는 **실행 독립성(Execution Independence)**이며, 동시 실행이 가능하다.

**선택 기준:**
- 이전 결과가 다음 작업의 입력인가? → `thenCompose()`
- 두 작업이 동시에 시작 가능한가? → `thenCombine()`

### 3.2 thenCombine() vs allOf(): 결과 타입 보존의 차이

`CompletableFuture.allOf()`도 여러 작업을 병렬로 실행하지만, 근본적인 차이가 있다.

**allOf()의 타입 손실:**
```java
CompletableFuture<Void> all = CompletableFuture.allOf(future1, future2, future3);
```

`allOf()`의 반환 타입은 항상 `CompletableFuture<Void>`다. 이는 "모든 작업이 완료되었다"는 신호만 제공하며, **개별 결과에 대한 타입 정보가 소실된다.**

결과를 얻으려면 각 Future를 명시적으로 `join()`해야 한다:
```java
all.thenRun(() -> {
    ProductInfo info = future1.join();
    Inventory inv = future2.join();
    Review review = future3.join();
    // 수동 결합
});
```

**thenCombine()의 타입 보존:**
```java
CompletableFuture<ProductPage> result = future1.thenCombine(future2,
    (info, inv) -> new ProductPage(info, inv)
);
```

결과 타입이 명확히 `CompletableFuture<ProductPage>`로 보존된다. 타입 시스템이 "이것은 ProductPage를 생성하는 비동기 작업이다"라는 의미를 정확히 표현한다.

**선택 기준:**
- N개의 작업을 실행하되 개별 결과 타입이 중요하지 않은 경우 → `allOf()`
- 2개의 작업을 실행하고 타입 안전하게 결과를 결합하려는 경우 → `thenCombine()`
- 3개 이상의 작업을 타입 안전하게 결합하려는 경우 → `thenCombine()` 체이닝

---

## 4. 핵심 정리

### 4.1 병렬 결합의 본질적 가치

`thenCombine()`은 독립적인 비동기 작업을 병렬로 실행하고, 두 결과를 타입 안전하게 결합하는 메커니즘을 제공한다. 핵심은 **실행 독립성과 타입 보존**이다. 

두 작업이 서로의 결과를 필요로 하지 않는다면, 순차 실행은 불필요한 대기 시간을 발생시킨다. `thenCombine()`은 이러한 작업을 동시에 시작하고, 둘 다 완료되면 자동으로 결합 함수를 실행한다. 이 과정에서 타입 시스템은 각 단계의 의미를 정확히 표현하며, 컴파일 타임에 타입 안정성을 보장한다.

### 4.2 설계 선택의 명확한 기준

개발자는 작업 간 의존성 패턴에 따라 메서드를 선택해야 한다:
- **순차적 의존성** (B가 A의 결과를 입력으로 필요) → `thenCompose()`
- **병렬 독립성** (A와 B가 동시 실행 가능, 결과 결합 필요) → `thenCombine()`
- **단순 완료 대기** (N개 작업의 완료만 확인, 결과 타입 불필요) → `allOf()`

이 선택은 성능 최적화의 문제이기도 하지만, 더 근본적으로는 **코드가 비즈니스 로직의 의도를 정확히 표현하는가**의 문제다.

### 4.3 현대 분산 시스템에서의 위치

마이크로서비스 아키텍처에서 독립적인 서비스 호출은 매우 흔한 패턴이다. 사용자 인터페이스를 구성하는 각 컴포넌트가 서로 다른 서비스에서 데이터를 가져오며, 이들은 병렬로 실행될 수 있고 실행되어야 한다.

`thenCombine()`은 이러한 병렬 호출을 코드로 명확히 표현하고, 타입 안전성을 유지하며, 예외를 일관되게 처리하는 표준 메커니즘을 제공한다. 이는 단순한 편의 기능이 아니라, 분산 시스템의 복잡성을 관리하기 위한 필수 도구다.

---

# 본문: 병렬 실행과 결과 결합의 구조적 분석

## 1. 병렬 실행의 동기화 메커니즘과 메모리 가시성

### 1.1 스레드 풀과 실행 컨텍스트

**비동기 작업의 스레드 할당:**

```java
CompletableFuture<ProductInfo> future1 = 
    CompletableFuture.supplyAsync(() -> getProductInfo(id));

CompletableFuture<Inventory> future2 = 
    CompletableFuture.supplyAsync(() -> getInventory(id));

CompletableFuture<ProductPage> combined = future1.thenCombine(future2,
    (info, inv) -> new ProductPage(info, inv)
);
```

실행 흐름:
- `future1`과 `future2`는 `ForkJoinPool.commonPool()`의 서로 다른 워커 스레드에서 실행된다.
- 두 작업은 **진정한 병렬 실행**이다. CPU 코어가 충분하면 물리적으로 동시에 실행된다.
- 먼저 완료된 작업의 스레드가 대기 상태로 전환된다.
- 나중에 완료된 작업의 스레드가 BiFunction을 실행한다.

**BiFunction 실행 스레드:**

기본적으로 BiFunction은 **두 번째로 완료된 작업의 스레드**에서 실행된다. 이는 중요한 설계 결정이다:

```
시간축:
0ms   : future1 시작 (Thread-1), future2 시작 (Thread-2)
300ms : future2 완료 (Thread-2) → future1 확인 → 미완료 → 대기
500ms : future1 완료 (Thread-1) → future2 확인 → 이미 완료 → BiFunction 실행 (Thread-1에서)
```

이는 **추가 스레드 할당을 피해 오버헤드를 최소화**하는 최적화다.

---

## 2. 실제 사용 시나리오와 성능 분석

### 2.1 마이크로서비스 아키텍처의 전형적 패턴

**상품 상세 페이지 구성:**

전자상거래 시스템에서 상품 상세 페이지는 여러 독립적인 마이크로서비스에서 데이터를 가져온다:

```java
public class ProductPageService {
    private final ProductService productService;
    private final InventoryService inventoryService;
    private final ReviewService reviewService;
    private final RecommendationService recommendationService;
    
    public CompletableFuture<ProductDetailPage> getProductPage(String productId) {
        // 4개의 독립적인 서비스 호출을 동시에 시작
        CompletableFuture<Product> productFuture = 
            productService.getProduct(productId);
        
        CompletableFuture<Inventory> inventoryFuture = 
            inventoryService.getInventory(productId);
        
        CompletableFuture<List<Review>> reviewsFuture = 
            reviewService.getReviews(productId);
        
        CompletableFuture<List<Product>> recommendationsFuture = 
            recommendationService.getRecommendations(productId);
        
        // 2개씩 결합
        CompletableFuture<ProductWithInventory> basicInfoFuture = 
            productFuture.thenCombine(inventoryFuture,
                (product, inventory) -> new ProductWithInventory(product, inventory)
            );
        
        CompletableFuture<SocialProof> socialProofFuture = 
            reviewsFuture.thenCombine(recommendationsFuture,
                (reviews, recommendations) -> 
                    new SocialProof(reviews, recommendations)
            );
        
        // 최종 결합
        return basicInfoFuture.thenCombine(socialProofFuture,
            (basicInfo, socialProof) -> 
                new ProductDetailPage(basicInfo, socialProof)
        );
    }
}
```

**실행 흐름 분석:**

```
시간 0ms:
  ├─ productService.getProduct()         → Thread-1 시작
  ├─ inventoryService.getInventory()     → Thread-2 시작
  ├─ reviewService.getReviews()          → Thread-3 시작
  └─ recommendationService.get...()      → Thread-4 시작

시간 150ms: inventoryService 완료 (가장 빠름)
  └─ productFuture 대기 중 → 아직 결합 안 함

시간 200ms: productService 완료
  └─ inventoryFuture 이미 완료 → basicInfoFuture 완료

시간 300ms: reviewService 완료
  └─ recommendationsFuture 대기 중 → 아직 결합 안 함

시간 400ms: recommendationService 완료 (가장 느림)
  └─ reviewsFuture 이미 완료 → socialProofFuture 완료
  └─ basicInfoFuture도 완료 → ProductDetailPage 생성

총 실행 시간: 400ms (가장 느린 서비스의 응답 시간)
```

**순차 실행과의 비교:**

만약 `thenCompose()`로 순차 실행했다면:
```
productService (200ms) 
  → inventoryService (150ms) 
  → reviewService (300ms) 
  → recommendationService (400ms)

총 실행 시간: 1050ms
```

**성능 향상: 62% 감소** (400ms vs 1050ms)

---

## 3. thenCombineAsync()와 실행 스레드 제어

### 3.1 Async 변형의 존재 이유

`thenCombine()`에는 비동기 변형인 `thenCombineAsync()`가 존재한다:

```java
public <U, V> CompletableFuture<V> thenCombineAsync(
    CompletionStage<? extends U> other,
    BiFunction<? super T, ? super U, ? extends V> fn
)

public <U, V> CompletableFuture<V> thenCombineAsync(
    CompletionStage<? extends U> other,
    BiFunction<? super T, ? super U, ? extends V> fn,
    Executor executor
)
```

**thenCombine() vs thenCombineAsync()의 차이:**

`thenCombine()`:
- BiFunction을 **두 번째로 완료된 Future의 스레드**에서 실행
- 추가 스레드 할당 없음 → 오버헤드 최소

`thenCombineAsync()`:
- BiFunction을 **별도의 스레드**(기본: commonPool)에서 실행
- 두 Future가 모두 완료되면 새로운 작업을 스레드 풀에 제출

**사용 시나리오:**

BiFunction이 **무거운 계산**을 수행하는 경우 Async 사용:

```java
future1.thenCombineAsync(future2, (data1, data2) -> {
    // CPU 집약적 계산 (예: 이미지 처리, 암호화)
    return heavyComputation(data1, data2);  // 10초 소요
});
```

이렇게 하면 future1이나 future2를 완료한 워커 스레드가 블로킹되지 않고 다른 작업을 처리할 수 있다.

BiFunction이 **경량 연산**이면 일반 `thenCombine()` 사용:

```java
future1.thenCombine(future2, (data1, data2) -> {
    // 간단한 객체 생성
    return new Result(data1, data2);  // 1ms 미만
});
```

추가 스레드 할당 오버헤드(컨텍스트 스위칭 등)를 피할 수 있다.

### 3.2 커스텀 Executor를 통한 스레드 풀 분리

실무에서는 작업 종류에 따라 스레드 풀을 분리하는 것이 일반적이다:

```java
public class ThreadPoolConfiguration {
    // CPU 바운드 작업용 (코어 수만큼)
    private static final Executor CPU_POOL = 
        Executors.newFixedThreadPool(
            Runtime.getRuntime().availableProcessors()
        );
    
    // I/O 바운드 작업용 (더 많은 스레드)
    private static final Executor IO_POOL = 
        Executors.newFixedThreadPool(100);
    
    // 긴급/중요 작업용 (별도 우선순위)
    private static final Executor PRIORITY_POOL = 
        new ThreadPoolExecutor(
            2, 10,
            60L, TimeUnit.SECONDS,
            new PriorityBlockingQueue<>()
        );
}
```

**사용 예시:**

```java
// 데이터베이스 조회 (I/O)
CompletableFuture<User> userFuture = 
    CompletableFuture.supplyAsync(() -> db.getUser(id), IO_POOL);

// API 호출 (I/O)
CompletableFuture<Orders> ordersFuture = 
    CompletableFuture.supplyAsync(() -> api.getOrders(id), IO_POOL);

// 두 결과 결합 후 데이터 분석 (CPU)
userFuture.thenCombineAsync(ordersFuture,
    (user, orders) -> analyzeUserBehavior(user, orders),
    CPU_POOL  // CPU 집약적 작업은 CPU 전용 풀에서
);
```

**장점:**
- I/O 대기 중인 스레드가 CPU 작업을 블로킹하지 않음
- CPU 작업이 I/O 스레드 풀을 고갈시키지 않음
- 작업 우선순위 관리 가능

### 3.3 데드락 방지와 스레드 풀 크기 설정

병렬 실행에서 주의해야 할 함정은 **스레드 풀 고갈로 인한 데드락**이다.

**문제 상황:**

```java
ExecutorService pool = Executors.newFixedThreadPool(2);  // 스레드 2개만

CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {
    // 이 작업이 f2를 기다림
    CompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> {
        return "inner";
    }, pool);  // 같은 풀 사용
    
    return f2.join();  // 블로킹 대기
}, pool);

f1.join();  // 데드락!
```

**데드락 발생 과정:**
1. 풀의 스레드 2개가 모두 외부 작업(f1) 실행 중
2. 외부 작업이 내부 작업(f2)를 같은 풀에 제출하고 대기
3. 내부 작업은 스레드를 할당받을 수 없음 (풀이 고갈됨)
4. 외부 작업은 내부 작업이 완료될 때까지 스레드를 점유
5. **순환 대기 발생 → 데드락**

**해결책:**

1. **충분한 스레드 풀 크기**: 최대 동시 작업 수 + 여유분

```java
int maxConcurrent = 10;  // 최대 10개 작업 동시 실행 예상
int poolSize = maxConcurrent * 2;  // 여유 있게 2배
ExecutorService pool = Executors.newFixedThreadPool(poolSize);
```

2. **중첩 작업은 다른 풀 사용**:

```java
ExecutorService outerPool = Executors.newFixedThreadPool(10);
ExecutorService innerPool = Executors.newFixedThreadPool(20);

CompletableFuture.supplyAsync(() -> {
    CompletableFuture<String> inner = 
        CompletableFuture.supplyAsync(() -> "inner", innerPool);
    return inner.join();
}, outerPool);
```

3. **`join()` 대신 비동기 체이닝 사용**:

```java
CompletableFuture.supplyAsync(() -> "outer", pool)
    .thenCompose(outer -> 
        CompletableFuture.supplyAsync(() -> outer + " inner", pool)
    );  // 블로킹 없이 체이닝
```

---

## 4. 복잡한 결합 패턴과 체이닝 전략

### 4.1 3개 이상의 Future 결합

`thenCombine()`은 2개의 Future만 결합하므로, 3개 이상을 결합하려면 체이닝이 필요하다.

**방법 1: 순차적 체이닝**

```java
CompletableFuture<A> fa = getA();
CompletableFuture<B> fb = getB();
CompletableFuture<C> fc = getC();

CompletableFuture<Result> result = fa
    .thenCombine(fb, (a, b) -> new Pair<>(a, b))
    .thenCombine(fc, (pair, c) -> new Result(pair.a, pair.b, c));
```

**실행 흐름:**
```
시작: fa, fb, fc 모두 병렬 실행
완료 시점: fa와 fb 모두 완료되면 Pair 생성
최종 완료: Pair와 fc 모두 완료되면 Result 생성
```

**주의:** 이 방식은 fa와 fb가 모두 완료되어야 fc와 결합을 시작한다. fc가 먼저 완료되어도 대기해야 하므로 최적은 아니다.

**방법 2: allOf() 와 결합**

```java
CompletableFuture<Void> all = CompletableFuture.allOf(fa, fb, fc);

CompletableFuture<Result> result = all.thenApply(v -> 
    new Result(fa.join(), fb.join(), fc.join())
);
```

**장점:** 셋 중 가장 느린 작업이 완료되는 즉시 Result 생성
**단점:** 타입 안전성 손실, `join()` 호출 필요

**방법 3: 헬퍼 메서드 작성**

```java
public static <A, B, C, R> CompletableFuture<R> combine3(
    CompletableFuture<A> fa,
    CompletableFuture<B> fb,
    CompletableFuture<C> fc,
    TriFunction<A, B, C, R> fn
) {
    return CompletableFuture.allOf(fa, fb, fc)
        .thenApply(v -> fn.apply(fa.join(), fb.join(), fc.join()));
}

// 사용
CompletableFuture<Result> result = combine3(fa, fb, fc,
    (a, b, c) -> new Result(a, b, c)
);
```

### 4.2 조건부 결합과 동적 워크플로우

때로는 한 Future의 결과에 따라 다른 Future를 결합할지 결정해야 한다.

```java
CompletableFuture<User> userFuture = getUser(userId);

CompletableFuture<Dashboard> dashboardFuture = userFuture.thenCompose(user -> {
    if (user.isPremium()) {
        // 프리미엄 사용자: 상세 통계 + 추천 + 알림
        CompletableFuture<Statistics> statsFuture = getDetailedStats(user.getId());
        CompletableFuture<List<Recommendation>> recoFuture = getRecommendations(user.getId());
        CompletableFuture<List<Notification>> notifFuture = getNotifications(user.getId());
        
        return statsFuture
            .thenCombine(recoFuture, PremiumData::new)
            .thenCombine(notifFuture, (premium, notifs) -> 
                new PremiumDashboard(user, premium, notifs)
            );
    } else {
        // 일반 사용자: 기본 통계만
        return getBasicStats(user.getId())
            .thenApply(stats -> new BasicDashboard(user, stats));
    }
});
```

이는 사용자 타입에 따라 **다른 수의 병렬 호출**을 동적으로 실행한다.

### 4.3 재시도와 폴백 체인

실패 시 재시도하고, 최종적으로 폴백 값을 제공하는 회복력 있는 패턴:

```java
public CompletableFuture<Product> getProductWithRetry(String id, int maxRetries) {
    CompletableFuture<Product> attempt = productService.getProduct(id);
    
    for (int i = 0; i < maxRetries; i++) {
        final int retryCount = i + 1;
        attempt = attempt.exceptionally(ex -> {
            log.warn("상품 조회 실패, 재시도 {}/{}", retryCount, maxRetries);
            throw new CompletionException(ex);  // 다음 체인으로 전파
        }).thenCompose(product -> 
            CompletableFuture.completedFuture(product)
        ).exceptionallyCompose(ex -> {
            if (retryCount < maxRetries) {
                return productService.getProduct(id);  // 재시도
            } else {
                return CompletableFuture.completedFuture(
                    Product.empty(id)  // 최종 폴백
                );
            }
        });
    }
    
    return attempt;
}

// 병렬 결합에 통합
CompletableFuture<ProductPage> page = 
    getProductWithRetry(id, 3)
        .thenCombine(
            inventoryService.getInventory(id)
                .exceptionally(ex -> Inventory.unavailable()),
            ProductPage::new
        );
```

이 패턴은 **각 독립적인 서비스 호출에 회복력**을 부여하면서도 병렬 실행의 이점을 유지한다.

---

## 5. 핵심 원칙과 설계 가이드라인

### 5.1 병렬 vs 순차 결정 기준

작업 간 관계에 따라 명확한 선택 기준을 적용해야 한다:

**병렬 실행 (thenCombine):**
- 두 작업이 **입력 데이터를 공유하지 않음**
- 한 작업의 결과가 다른 작업의 시작 조건이 **아님**
- **독립적으로 실행 가능**하며 순서가 무관함
- 성능 향상이 실질적으로 의미 있음 (각 작업이 충분히 오래 걸림)

**순차 실행 (thenCompose):**
- 한 작업의 **결과가 다른 작업의 입력**
- 논리적 **의존 관계**가 명확함
- 작업 순서가 **비즈니스 규칙**을 반영함

**잘못된 병렬화의 예:**

```java
// 잘못된 병렬화 - userId가 필요한데 병렬 실행
CompletableFuture<Integer> userIdFuture = authenticate(token);
CompletableFuture<Profile> profileFuture = getProfile(???);  // userId가 없음!
```

이는 컴파일 에러를 발생시키거나, 잘못된 데이터를 조회하게 된다.

---

## 6. 최종 정리: thenCombine의 설계 철학

### 6.1 독립성과 병렬성의 타입 표현

`thenCombine()`은 "두 작업이 독립적이며 병렬 실행 가능하다"는 의도를 타입 시스템에 명시적으로 표현하는 메커니즘이다. 이는 단순한 성능 최적화를 넘어, **코드가 비즈니스 로직의 구조를 정확히 반영**하도록 한다.

순차적 의존성이 없는 작업을 `thenCompose()`로 순차 실행하는 것은 기술적으로는 작동하지만, 설계 의도를 왜곡한다. 코드를 읽는 사람은 "왜 이 작업들이 순차적으로 실행되는가?"라는 의문을 가지게 되며, 실제로는 병렬화가 가능한 구조임을 파악하기 어렵다.