---
# 공유 ThreadPoolExecutor의 결과 격리 로직 이해

## 문서 개정 이력

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|-----------|
| 1.0 | 2025-01-05 | 정범진 | 초안 작성 |
| 1.1 | 2025-01-05 | 정범진 | 사실 오류 수정 및 가독성 개선 |

---

## 목차

1. [개요](#1-개요)
2. [배경 및 목적](#2-배경-및-목적)
   - 2.1 현재 시스템 구조
   - 2.2 비동기 처리 전환의 필요성
   - 2.3 분석 대상 문제
3. [ExecutorService 아키텍처 분석](#3-executorservice-아키텍처-분석)
   - 3.1 전통적 생산자-소비자 패턴과의 차이
   - 3.2 작업 제출 계층과 결과 반환 계층의 분리
4. [작업-결과 격리 메커니즘](#4-작업-결과-격리-메커니즘)
   - 4.1 작업 캡슐화와 클로저 메커니즘
   - 4.2 FutureTask의 결과 저장 구조
   - 4.3 참조 기반 소유권 모델
5. [메모리 레이아웃과 실행 흐름](#5-메모리-레이아웃과-실행-흐름)
   - 5.1 공유 영역과 격리 영역의 구분
   - 5.2 스택 프레임의 독립성
   - 5.3 Heap 객체의 참조 관계
6. [결론](#6-결론)
7. [참고자료](#7-참고자료)

---

## 1. 개요

본 문서는 Spring Boot 기반 위치 분석 서비스 Wherehouse의 LocationAnalysisServiceImpl에서 공유 ExecutorService를 사용할 때 발생할 수 있는 작업 결과 혼재 가능성에 대한 기술적 분석을 제공한다. 멀티스레드 환경에서 단일 ThreadPoolExecutor 인스턴스를 모든 요청 스레드가 공유할 경우, BlockingQueue를 통해 제출된 비동기 작업들의 결과가 사용자 간 뒤섞일 수 있는지에 대한 구조적 검증을 수행한다.

분석 결과, ExecutorService의 설계는 작업 스케줄링과 결과 반환 경로를 완전히 분리하여 Future 객체의 참조 기반 소유권 모델을 통해 결과 격리를 보장함을 확인하였다. BlockingQueue는 작업 실행 순서만을 관리하며, 각 작업의 결과는 독립적인 FutureTask 객체의 내부 필드에 저장되어 제출자의 로컬 참조를 통해서만 접근 가능하다.

---

## 2. 배경 및 목적

### 2.1 현재 시스템 구조

Wherehouse 위치 분석 서비스의 LocationAnalysisServiceImpl 클래스는 사용자가 선택한 좌표를 기반으로 주변 안전 인프라와 편의시설을 분석한다. 현재 구현에서 R-04 단계는 외부 API 호출을 담당하며, 다음과 같은 작업을 순차적으로 수행한다.

```java
// LocationAnalysisServiceImpl.java:78
ExecutorService executorService = Executors.newFixedThreadPool(10);

// LocationAnalysisServiceImpl.java:832
AddressDto addressDto = kakaoApiService.getAddress(latitude, longitude);

// LocationAnalysisServiceImpl.java:907
amenityData = kakaoApiService.searchAllAmenities(latitude, longitude, radius);
```

KakaoApiService의 searchAllAmenities() 메소드는 15개 카테고리를 순차 조회한다.

```java
// KakaoApiService.java:200-214
public Map<String, List<Map<String, Object>>> searchAllAmenities(
        double latitude, double longitude, int radius) {
    
    String[] categories = {"SW8", "CS2", "FD6", "CE7", "MT1", "BK9", "PO3",
            "CT1", "HP8", "PM9", "PK6", "OL7", "SC4", "AC5", "AT4"};
    
    Map<String, List<Map<String, Object>>> results = new HashMap<>();
    
    for (String category : categories) {
        List<Map<String, Object>> places = searchPlacesByCategory(
            latitude, longitude, category, radius);
        results.put(category, places);
    }
    
    return results;
}
```

카테고리는 SW8(지하철역), CS2(편의점), FD6(음식점), CE7(카페), MT1(대형마트), BK9(은행), PO3(공공기관), CT1(문화시설), HP8(병원), PM9(약국), PK6(주차장), OL7(주유소), SC4(학교), AC5(학원), AT4(관광명소)로 구성된다.

### 2.2 비동기 처리 전환의 필요성

R-04 단계는 총 16개의 외부 API 호출을 수행한다. 주소 변환 API 1회와 편의시설 카테고리 검색 API 15회로 구성되며, 순차 실행 방식에서는 이들이 직렬로 처리되어 총 응답 시간이 약 2,681ms에 달한다. 

각 API 호출이 독립적이며 상호 의존성이 없으므로, CompletableFuture를 활용한 병렬 처리로 응답 시간을 400ms 이하로 단축할 수 있다. 78번째 줄에 이미 선언된 ExecutorService 인스턴스를 활용하면 추가적인 리소스 생성 없이 병렬화가 가능하다.

### 2.3 분석 대상 문제

LocationAnalysisServiceImpl 내에 하나의 ThreadPoolExecutor 객체를 공통 필드로 선언하면, 모든 HTTP 요청 스레드가 동일한 BlockingQueue를 공유하게 된다. 사용자 1번과 사용자 2번이 동시에 analyzeLocation() 메소드를 호출할 때, 각 사용자당 16개의 작업이 동일한 큐에 적재된다.

이 상황에서 다음과 같은 우려가 제기된다. 스레드 1과 스레드 2가 각각 자신의 16개 API 호출 결과를 올바르게 받는 것이 아니라, 공유 큐로 인해 결과값이 뒤섞여서 반환될 가능성이 있는가? 예를 들어 사용자 1이 서울 강남구의 편의점 목록을 요청했는데, 사용자 2가 요청한 부산 해운대구의 편의점 목록을 받게 되는 상황이 발생할 수 있는가?

본 문서는 이 우려의 타당성을 ExecutorService의 내부 구조를 통해 검증한다.

---

## 3. ExecutorService 아키텍처 분석

### 3.1 전통적 생산자-소비자 패턴과의 차이

BlockingQueue를 공용 저장소로 이해하면 결과 혼재에 대한 우려가 논리적으로 타당해진다. 전통적인 생산자-소비자 패턴에서 큐는 작업 명령과 실행 결과를 모두 운반하는 통신 채널로 기능한다. 

생산자가 `queue.put(task)`로 작업을 넣으면, 소비자가 `queue.take()`로 작업을 꺼내 실행한 뒤 결과를 다시 큐에 넣거나 별도 채널로 전달한다. 이러한 구조에서는 작업-결과 간 매핑이 큐 외부의 추가적인 식별 메커니즘에 의존하게 된다. 작업 ID나 상관관계 토큰을 사용하여 "이 결과가 어느 작업의 산출물인가"를 판별해야 하며, 이 과정에서 매핑 오류가 발생하면 결과 혼재가 나타난다.

### 3.2 작업 제출 계층과 결과 반환 계층의 분리

ExecutorService의 ThreadPoolExecutor는 근본적으로 다른 접근을 취한다. BlockingQueue는 작업의 실행 순서만을 관리하는 스케줄링 자료구조로 제한되며, 결과의 저장이나 반환 경로와는 완전히 분리된다. 

작업 제출 시점에 반환되는 Future 객체가 작업-결과 매핑의 전체 책임을 떠맡는다. Future 객체는 제출자의 스택 프레임에 저장되어 다른 호출자의 접근 범위 밖에 존재한다. 각 Future는 특정 작업에 대한 배타적 참조를 제공하며, 이 참조를 보유한 스레드만이 해당 작업의 결과를 회수할 수 있다. BlockingQueue는 이 매핑 과정에 전혀 관여하지 않으며, 단지 어느 작업을 다음에 실행할지 순서만을 결정한다.

---

## 4. 작업-결과 격리 메커니즘

### 4.1 작업 캡슐화와 클로저 메커니즘

`CompletableFuture.supplyAsync(() -> kakaoApiService.getAddress(latitude, longitude), executorService)` 호출 시 내부적으로 새로운 FutureTask 객체가 생성된다. 이 객체는 실행할 작업과 그 작업이 필요로 하는 모든 데이터를 자신의 필드에 복사하여 저장한다.

Java의 클로저 메커니즘에 의해, 람다 표현식이 참조하는 외부 변수 latitude와 longitude는 FutureTask 생성 시점에 해당 객체 내부로 값 복사된다. 이는 작업이 나중에 어느 워커 스레드에서 실행되든 제출 시점의 컨텍스트를 정확히 재현할 수 있게 하는 캡슐화 메커니즘이다.

사용자 1이 latitude=37.5665, longitude=126.9780으로 작업을 제출하면, 이 값들은 FutureTask1 객체의 내부 필드에 영구 저장된다. 사용자 2가 latitude=35.1796, longitude=129.0756으로 작업을 제출하면, 별도의 FutureTask2 객체에 이 값들이 저장된다. 두 FutureTask는 완전히 독립적인 Heap 객체로 존재하며 서로의 데이터를 침범할 수 없다.

### 4.2 FutureTask의 결과 저장 구조

생성된 FutureTask 객체는 ExecutorService의 BlockingQueue에 추가된다. 큐에 들어가는 것은 "주소를 조회하라"는 작업 명세서이지 조회 결과가 아니다. 큐는 "다음에 어떤 작업을 실행할 것인가"라는 스케줄링 정보만을 담는다.

워커 스레드가 BlockingQueue에서 FutureTask를 꺼내 실행할 때, 결과는 해당 FutureTask 객체의 outcome 필드에 저장된다. 이것이 결정적인 설계 결정이다. 결과가 BlockingQueue로 돌아가지 않고 작업 객체 자체에 저장된다.

FutureTask1.outcome과 FutureTask2.outcome은 완전히 다른 메모리 주소의 필드다. Thread-1이 FutureTask1의 결과를 outcome 필드에 쓰더라도, Thread-2가 접근하는 FutureTask2의 outcome 필드에는 영향을 줄 수 없다. FutureTask는 자신의 상태를 COMPLETING에서 NORMAL로 변경하고, 결과를 기다리고 있던 스레드들을 깨운다.

### 4.3 참조 기반 소유권 모델

supplyAsync()는 즉시 반환되며, 반환값은 방금 생성한 FutureTask에 대한 참조다. 이 참조는 호출자의 로컬 변수에 저장된다. 사용자 1이 이 메소드를 호출하면 사용자 1의 스택에 저장되고, 사용자 2가 호출하면 사용자 2의 스택에 저장된다.

스택은 스레드별로 격리되어 있으므로, 사용자 1이 받은 Future 참조와 사용자 2가 받은 Future 참조는 메모리상 완전히 다른 위치에 존재하며 서로 간섭할 수 없다.

호출자가 `future.get()`을 실행하면, 이 메소드는 future 참조가 가리키는 FutureTask 객체에 접근하여 그 객체의 outcome 필드를 읽어온다. 사용자 1이 자신의 future 변수로 get()을 호출하면 사용자 1의 FutureTask.outcome을 읽고, 사용자 2가 자신의 future 변수로 get()을 호출하면 사용자 2의 FutureTask.outcome을 읽는다. BlockingQueue는 이 과정에 전혀 개입하지 않는다.

이 설계의 본질은 참조 기반 소유권 모델이다. Future 객체의 참조를 가진 자만이 그 작업의 결과에 접근할 수 있으며, 이 참조는 작업 제출 시점에 제출자에게만 전달된다.

---

## 5. 메모리 레이아웃과 실행 흐름

### 5.1 공유 영역과 격리 영역의 구분

LocationAnalysisServiceImpl의 실행 코드 바이너리는 모든 HTTP 요청 스레드가 공유한다. 클래스 바이트코드는 Method Area(메타스페이스)에 한 번만 로드되어 모든 스레드가 동일한 기계어 명령을 실행한다. 

78번째 줄의 ThreadPoolExecutor 객체는 Heap에 단 하나만 존재하며, 모든 요청 스레드가 이 동일한 객체의 submit() 메소드를 호출한다. ThreadPoolExecutor 객체 내부 필드인 BlockingQueue 인스턴스도 단일 큐로 존재하며, 모든 제출된 FutureTask들이 이 큐에 저장된다. 이것이 공유 영역이다.

반면 각 요청 스레드의 스택 프레임은 격리된다. 사용자 1이 performExternalApiCalls()를 호출하면 사용자 1 스레드의 스택에 프레임이 생성되고, 사용자 2가 호출하면 사용자 2 스레드의 스택에 별도 프레임이 생성된다. 이 두 프레임은 물리적으로 다른 메모리 영역이다.

스택 프레임 내 로컬 변수들인 addressFuture, amenityFutures는 각 스레드의 스택 프레임에 독립적으로 존재한다. 변수명은 같지만 저장 위치가 다르다. Heap에 생성된 FutureTask 객체들은 각 작업마다 별도의 인스턴스가 생성되며, 이 객체들은 BlockingQueue에 섞여 있지만 각자의 outcome 필드를 독립적으로 가진다.

### 5.2 스택 프레임의 독립성

사용자 1 스레드의 스택에는 performExternalApiCalls() 프레임이 존재하며, 이 프레임 내부에는 latitude=37.5665, longitude=126.9780과 같은 로컬 변수가 있다. addressFuture라는 로컬 변수는 메모리 주소 0x1001을 가리키는 참조를 저장하고, amenityFutures 리스트는 0x1002, 0x1003 등의 주소를 가리키는 참조들을 담는다.

사용자 2 스레드의 스택에도 performExternalApiCalls() 프레임이 별도로 존재하며, latitude=35.1796, longitude=129.0756과 같은 로컬 변수를 가진다. addressFuture 로컬 변수는 메모리 주소 0x2001을 가리키고, amenityFutures 리스트는 0x2002, 0x2003 등의 주소를 가리킨다. 변수명은 사용자 1 스레드와 동일하지만 포인팅하는 대상 객체가 완전히 다르다.

### 5.3 Heap 객체의 참조 관계

Heap 영역에는 ThreadPoolExecutor 객체가 공유 자원으로 존재한다. 이 객체 내부의 workQueue인 BlockingQueue 역시 공유되며, 다음과 같은 FutureTask 객체들이 섞여 있다.

- FutureTask@0x1001: 사용자 1의 주소변환 작업
  - callable 필드: `() -> getAddress(37.5665, 126.9780)`
  - outcome 필드: 실행 전 null → 실행 후 AddressDto("서울특별시...")
  
- FutureTask@0x1002: 사용자 1의 지하철역(SW8) 검색 작업
  - callable 필드: `() -> searchPlacesByCategory(37.5665, 126.9780, "SW8", 500)`
  - outcome 필드: 실행 전 null → 실행 후 List<Map>

- FutureTask@0x2001: 사용자 2의 주소변환 작업
  - callable 필드: `() -> getAddress(35.1796, 129.0756)`
  - outcome 필드: 실행 전 null → 실행 후 AddressDto("부산광역시...")

BlockingQueue는 [0x1001, 0x1002, ..., 0x2001, 0x2002, ...] 같은 참조 목록을 관리한다. 사용자 1의 addressFuture 로컬 변수는 0x1001을 가리키고, 사용자 2의 addressFuture 로컬 변수는 0x2001을 가리킨다. 

워커 스레드가 workQueue.take()로 FutureTask를 꺼내 실행하면, 그 결과는 해당 FutureTask의 outcome 필드에만 저장된다. 사용자 1이 `addressFuture.get()`을 호출하면, 사용자 1 스택의 addressFuture 변수가 가리키는 0x1001 주소로 가서 FutureTask@0x1001의 outcome 필드를 읽는다. 사용자 2가 `addressFuture.get()`을 호출하면, 사용자 2 스택의 addressFuture 변수가 가리키는 0x2001 주소로 가서 FutureTask@0x2001의 outcome 필드를 읽는다. 두 스레드는 서로의 FutureTask에 접근할 방법이 없다.

ThreadPoolExecutor 객체를 공유하더라도 그 안에 대기열로 쌓인 FutureTask는 각 요청자 스레드 내 참조 변수별로 포인팅되어 있다. BlockingQueue는 공유되지만, 각 요청 스레드는 자신이 제출한 FutureTask의 참조만 가지고 있어서 자신의 결과만 회수할 수 있다. 다른 스레드의 Future 참조는 그 스레드의 스택에만 있으므로 접근 불가능하다.

---

## 6. 결론

LocationAnalysisServiceImpl의 78번째 줄 `ExecutorService executorService = Executors.newFixedThreadPool(10)`을 모든 사용자가 공유해도 안전하다. 각 사용자의 16개 API 호출은 각자의 Future 객체를 통해 완벽히 격리되며, BlockingQueue는 단지 이 작업들이 실행될 순서만을 결정할 뿐이다.

ExecutorService의 아키텍처는 Future 객체가 작업-결과 간 1대1 매핑을 캡슐화하고, 이 객체의 참조가 제출자의 로컬 스코프에만 존재하도록 강제함으로써, 공유 가변 상태 없이도 비동기 작업의 결과를 안전하게 회수할 수 있게 한다. BlockingQueue는 작업 실행 순서만을 조율할 뿐 결과의 소유권 관리에는 관여하지 않는다.

결과가 실제로 혼재될 수 있는 유일한 경우는 프로그래머가 명시적으로 공유 가변 상태를 도입할 때다. 서비스 클래스의 인스턴스 필드로 `Map<String, AddressDto> resultCache`를 선언하고 여러 스레드가 동시에 이 맵에 결과를 쓰고 읽는다면, 동기화 없이는 데이터 혼재가 발생한다. 그러나 이는 ExecutorService 설계의 문제가 아니라 프로그래머가 스레드 안전하지 않은 공유 상태를 사용한 것이다.

이것이 ExecutorService가 멀티유저 환경에서 안전한 이유이며, 서버 애플리케이션에서 ExecutorService를 싱글톤으로 사용할 수 있는 구조적 근거다. Wherehouse 프로젝트는 R-04 단계의 16개 API 호출을 CompletableFuture로 병렬화할 때 공유 ExecutorService를 안전하게 사용할 수 있다.

---

## 7. 참고자료

### 프로젝트 파일
- LocationAnalysisServiceImpl.java (2,692 lines)
- KakaoApiService.java (215 lines)

### Java Concurrency 관련 클래스
- `java.util.concurrent.ExecutorService`
- `java.util.concurrent.ThreadPoolExecutor`
- `java.util.concurrent.FutureTask`
- `java.util.concurrent.CompletableFuture`
- `java.util.concurrent.BlockingQueue`

### 핵심 개념
- 클로저 (Closure)와 변수 캡처 메커니즘
- 스레드별 스택 프레임 격리
- Heap 객체의 참조 기반 소유권
- Future 패턴의 작업-결과 매핑

---

**문서 끝**