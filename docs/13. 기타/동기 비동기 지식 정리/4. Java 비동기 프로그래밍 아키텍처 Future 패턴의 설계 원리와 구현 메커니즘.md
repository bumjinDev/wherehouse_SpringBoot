# Java 비동기 프로그래밍 아키텍처: Future 패턴의 설계 원리와 구현 메커니즘

## 1. 서론: 멀티스레드 환경에서의 결과 반환 문제

### 1.1 문제 정의

멀티스레드 프로그래밍 환경에서 호출자 스레드(Main Thread)가 작업자 스레드(Worker Thread)에게 작업을 위임할 때, 다음과 같은 근본적인 문제가 발생한다:

1. **호출 스택의 물리적 독립성**: 각 스레드는 독립적인 호출 스택(Call Stack)을 가지며, 스택 프레임(Stack Frame)이 물리적으로 분리되어 있다.
2. **예외 전파의 불가능성**: 작업자 스레드에서 발생한 예외는 해당 스레드의 스택에서만 처리되며, 호출자 스레드로 자동 전파되지 않는다.
3. **반환값 전달 메커니즘의 부재**: 작업자 스레드의 실행 결과를 호출자 스레드로 전달할 표준화된 방법이 없다.

### 1.2 기술적 요구사항

비동기 작업 처리를 위해서는 다음 요구사항을 충족해야 한다:

- 작업자 스레드의 실행 결과를 호출자 스레드가 조회할 수 있어야 함
- 작업자 스레드에서 발생한 예외를 호출자 스레드가 처리할 수 있어야 함
- 작업 완료 여부를 비동기적으로 확인할 수 있어야 함
- 작업 취소 메커니즘을 제공해야 함

---

## 2. 배경: Runnable 인터페이스의 구조적 한계

### 2.1 Runnable 인터페이스 명세

```java
@FunctionalInterface
public interface Runnable {
    void run();
}
```

Runnable 인터페이스는 Java 1.0부터 제공된 스레드 실행 단위이며, 다음과 같은 특징을 가진다:

- **반환 타입**: `void` - 어떠한 값도 반환하지 않음
- **예외 선언**: 메소드 시그니처에 `throws` 절이 없음 - Checked Exception 선언 불가

### 2.2 구조적 한계 분석

#### 2.2.1 반환값 부재의 한계

```java
class DatabaseTask implements Runnable {
    private String result;  // 결과를 저장할 필드 필요
    
    @Override
    public void run() {
        // DB 조회 수행
        this.result = queryDatabase();
        // 반환할 방법이 없음
    }
    
    public String getResult() {  // 별도 메소드로 결과 조회
        return result;
    }
}
```

문제점:
- 결과를 저장하기 위한 추가 필드 선언 필요
- 스레드 안전성을 보장하기 위한 동기화 메커니즘 필요
- 작업 완료 시점을 알 수 없어 폴링(Polling) 필요

#### 2.2.2 예외 처리의 한계

```java
class RiskyTask implements Runnable {
    @Override
    public void run() {
        try {
            // Checked Exception을 던지는 작업
            riskyOperation();
        } catch (CheckedException e) {
            // 여기서 처리하거나
            // 호출자에게 전달할 방법이 없음
        }
    }
}
```

근본 원인:
- `run()` 메소드는 `throws` 절이 없어 Checked Exception 선언 불가
- 작업자 스레드의 예외는 해당 스레드의 `UncaughtExceptionHandler`로만 전달됨
- 호출자 스레드는 작업자 스레드의 예외를 감지할 메커니즘이 없음

### 2.3 호출 스택 독립성의 원리

```
Main Thread Stack              Worker Thread Stack
┌──────────────────┐          ┌──────────────────┐
│ main()           │          │ run()            │
│  └─ submit()     │          │  └─ task logic   │
│     └─ ...       │          └──────────────────┘
└──────────────────┘
     ↕ (독립적)
물리적으로 분리된 메모리 영역
예외가 자동으로 전파되지 않음
```

**결론**: Runnable은 독립적인 작업 실행에는 적합하나, 결과 반환 및 예외 전파가 필요한 경우 구조적으로 부적합하다.

---

## 3. 해결 방안 1: Callable 인터페이스의 도입

### 3.1 Callable 인터페이스 명세

```java
@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
}
```

Java 5에서 도입된 Callable은 Runnable의 한계를 해결하기 위해 설계되었으며, 다음과 같은 특징을 가진다:

- **제네릭 반환 타입**: `V` - 임의의 타입 반환 가능
- **예외 선언**: `throws Exception` - 모든 Checked Exception 선언 가능
- **함수형 인터페이스**: 람다식 사용 가능

### 3.2 Callable의 의미론적 차이

```
Runnable: "작업을 실행하라" (명령)
Callable: "값을 계산하여 반환하라" (함수)
```

Callable은 단순 실행이 아닌 **값의 계산과 반환**에 초점을 둔 설계이다.

### 3.3 Callable 사용의 제약사항

**핵심 문제**: ThreadPoolExecutor는 Callable을 직접 실행할 수 없다.

```java
public class ThreadPoolExecutor extends AbstractExecutorService {
    // execute() 메소드는 Runnable만 받음
    public void execute(Runnable command) {
        // ...
    }
    
    // Callable을 받는 메소드가 없음
}
```

이유:
- Worker 스레드의 실행 루프는 `Runnable.run()` 호출을 전제로 설계됨
- Callable은 반환값과 예외를 처리할 추가 메커니즘이 필요함

**따라서 Callable을 Runnable로 변환하는 어댑터가 필요하다.**

---

## 4. 해결 방안 2: Future 패턴의 설계

### 4.1 Future 패턴의 개념적 모델

Future 패턴은 **비동기 작업의 결과를 나타내는 대리자(Proxy)** 패턴이다.

```
개념적 모델:
┌─────────────────────────────────────────┐
│ Future = "미래에 완료될 작업의 영수증"  │
└─────────────────────────────────────────┘
         ↓
┌─────────────────────────────────────────┐
│ 1. 작업을 제출하면 즉시 Future 반환     │
│ 2. 작업은 별도 스레드에서 비동기 실행   │
│ 3. 필요할 때 Future.get()으로 결과 조회 │
└─────────────────────────────────────────┘
```

### 4.2 Future 인터페이스 명세

```java
public interface Future<V> {
    /**
     * 작업 취소 시도
     * @param mayInterruptIfRunning 실행 중인 작업 인터럽트 여부
     * @return 취소 성공 여부
     */
    boolean cancel(boolean mayInterruptIfRunning);
    
    /**
     * 작업이 취소되었는지 확인
     */
    boolean isCancelled();
    
    /**
     * 작업이 완료되었는지 확인
     * (정상 완료, 예외 발생, 취소 모두 완료로 간주)
     */
    boolean isDone();
    
    /**
     * 작업 완료까지 블로킹하여 결과 반환
     * @throws InterruptedException 대기 중 인터럽트 발생
     * @throws ExecutionException 작업 실행 중 예외 발생
     */
    V get() throws InterruptedException, ExecutionException;
    
    /**
     * 타임아웃을 지정하여 결과 반환
     * @throws TimeoutException 지정 시간 내 완료되지 않음
     */
    V get(long timeout, TimeUnit unit) 
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

### 4.3 Future의 상태 모델

```
상태 전이 다이어그램:

    NEW (초기)
      ↓
   RUNNING (실행 중)
      ↓
   COMPLETING (완료 처리 중)
      ↓
   ┌────┴────┬─────────┐
   ↓         ↓         ↓
NORMAL   EXCEPTIONAL  CANCELLED
(정상)    (예외)      (취소)
```

각 상태의 의미:
- **NEW**: 작업이 아직 시작되지 않음
- **RUNNING**: 작업이 실행 중
- **COMPLETING**: 결과 저장 및 대기 스레드 깨우기 진행 중
- **NORMAL**: 정상 완료
- **EXCEPTIONAL**: 예외 발생으로 완료
- **CANCELLED**: 취소됨

### 4.4 Future 인터페이스의 한계

**Future는 인터페이스일 뿐, 구현체가 필요하다.**

구현체가 제공해야 하는 기능:
1. Callable 실행 결과 저장
2. 예외 저장 및 재전파
3. 스레드 동기화 (대기/깨우기)
4. 상태 관리
5. Runnable 인터페이스 구현 (ThreadPoolExecutor에서 실행 가능하도록)

---

## 5. 핵심 구현: FutureTask 클래스

### 5.1 FutureTask의 설계 목표

FutureTask는 다음 문제를 모두 해결하는 통합 솔루션이다:

1. **Callable을 Runnable로 변환** - Worker 스레드가 실행 가능
2. **결과 저장소 제공** - 실행 결과를 저장할 메모리 공간
3. **스레드 동기화** - 호출자와 작업자 간 협업
4. **Future 인터페이스 구현** - 표준 API 제공

### 5.2 FutureTask 클래스 구조

```java
public class FutureTask<V> implements RunnableFuture<V> {
    // === 핵심 필드 ===
    
    /** 실행할 작업 (Callable 래핑) */
    private Callable<V> callable;
    
    /** 실행 결과 또는 예외를 저장하는 공간 */
    private Object outcome;
    
    /** 작업 상태 (NEW, COMPLETING, NORMAL, EXCEPTIONAL, CANCELLED 등) */
    private volatile int state;
    
    /** 현재 작업을 실행 중인 스레드 */
    private volatile Thread runner;
    
    /** get() 메소드로 대기 중인 스레드들의 연결 리스트 */
    private volatile WaitNode waiters;
    
    // === 상태 상수 ===
    private static final int NEW          = 0;  // 초기 상태
    private static final int COMPLETING   = 1;  // 완료 처리 중
    private static final int NORMAL       = 2;  // 정상 완료
    private static final int EXCEPTIONAL  = 3;  // 예외 발생
    private static final int CANCELLED    = 4;  // 취소됨
    private static final int INTERRUPTING = 5;  // 인터럽트 중
    private static final int INTERRUPTED  = 6;  // 인터럽트 완료
    
    // === 생성자 ===
    
    public FutureTask(Callable<V> callable) {
        if (callable == null)
            throw new NullPointerException();
        this.callable = callable;
        this.state = NEW;  // 초기 상태 설정
    }
    
    // Runnable을 Callable로 변환하는 생성자
    public FutureTask(Runnable runnable, V result) {
        this.callable = Executors.callable(runnable, result);
        this.state = NEW;
    }
}
```

### 5.3 핵심 메커니즘 1: Runnable.run() 구현

```java
/**
 * Worker 스레드가 호출하는 메소드
 * Callable.call()을 실행하고 결과를 저장
 */
public void run() {
    // 상태가 NEW가 아니거나 runner 설정 실패 시 중단
    if (state != NEW ||
        !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread()))
        return;
    
    try {
        Callable<V> c = callable;
        if (c != null && state == NEW) {
            V result;
            boolean ran;
            try {
                // === 핵심: Callable.call() 실행 ===
                result = c.call();
                ran = true;
            } catch (Throwable ex) {
                result = null;
                ran = false;
                setException(ex);  // 예외 저장
            }
            if (ran)
                set(result);  // 정상 결과 저장
        }
    } finally {
        runner = null;
        int s = state;
        if (s >= INTERRUPTING)
            handlePossibleCancellationInterrupt(s);
    }
}
```

**실행 흐름 분석:**

```
Worker 스레드의 호출 스택:

┌─────────────────────────────────┐
│ FutureTask.run()                │  ← ThreadPoolExecutor가 호출
│   ├─ runner = currentThread()   │  ← Worker 스레드 기록
│   ├─ callable.call()            │  ← 실제 작업 실행 (2초 소요)
│   └─ set(result)                │  ← 결과 저장 및 대기자 깨우기
└─────────────────────────────────┘
```

### 5.4 핵심 메커니즘 2: 결과 저장 (set 메소드)

```java
/**
 * 정상 실행 결과를 저장하고 대기 중인 스레드들을 깨움
 */
protected void set(V v) {
    // state를 NEW → COMPLETING으로 원자적 변경
    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
        outcome = v;  // 결과 저장
        
        // state를 COMPLETING → NORMAL로 변경
        UNSAFE.putOrderedInt(this, stateOffset, NORMAL);
        
        finishCompletion();  // 대기 중인 스레드들 깨우기
    }
}

/**
 * 예외를 저장하고 대기 중인 스레드들을 깨움
 */
protected void setException(Throwable t) {
    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
        outcome = t;  // 예외 저장
        UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL);
        finishCompletion();
    }
}
```

**메모리 가시성 보장:**

- `volatile int state`: 상태 변경이 모든 스레드에 즉시 가시화
- `UNSAFE.putOrderedInt()`: 저장 순서 보장 (결과 저장 후 상태 변경)
- `volatile Object outcome`: 결과 읽기 시 최신 값 보장

### 5.5 핵심 메커니즘 3: 대기 스레드 관리

```java
/**
 * get() 호출로 대기 중인 스레드들을 관리하는 노드
 */
static final class WaitNode {
    volatile Thread thread;  // 대기 중인 스레드
    volatile WaitNode next;  // 다음 대기 노드
    
    WaitNode() { thread = Thread.currentThread(); }
}

/**
 * 작업 완료 시 대기 중인 모든 스레드를 깨움
 */
private void finishCompletion() {
    // waiters 연결 리스트를 순회하며 모든 대기 스레드 깨우기
    for (WaitNode q; (q = waiters) != null;) {
        // waiters를 null로 원자적 변경
        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {
            for (;;) {
                Thread t = q.thread;
                if (t != null) {
                    q.thread = null;
                    LockSupport.unpark(t);  // 스레드 깨우기
                }
                WaitNode next = q.next;
                if (next == null)
                    break;
                q.next = null;  // GC 지원
                q = next;
            }
            break;
        }
    }
    
    done();  // 서브클래스에서 오버라이드 가능한 훅
    callable = null;  // GC 지원
}
```

### 5.6 핵심 메커니즘 4: Future.get() 구현

```java
/**
 * 블로킹 방식으로 작업 완료를 대기하고 결과 반환
 */
public V get() throws InterruptedException, ExecutionException {
    int s = state;
    
    // 작업이 아직 완료되지 않았으면 대기
    if (s <= COMPLETING)
        s = awaitDone(false, 0L);
    
    // 완료된 작업의 결과 반환 (예외 처리 포함)
    return report(s);
}

/**
 * 작업 완료까지 대기 (블로킹)
 */
private int awaitDone(boolean timed, long nanos)
        throws InterruptedException {
    
    final long deadline = timed ? System.nanoTime() + nanos : 0L;
    WaitNode q = null;
    boolean queued = false;
    
    for (;;) {
        // 인터럽트 확인
        if (Thread.interrupted()) {
            removeWaiter(q);
            throw new InterruptedException();
        }
        
        int s = state;
        
        // 작업 완료됨 → 반환
        if (s > COMPLETING) {
            if (q != null)
                q.thread = null;
            return s;
        }
        
        // 완료 처리 중 → 양보
        else if (s == COMPLETING)
            Thread.yield();
        
        // 대기 노드 생성
        else if (q == null)
            q = new WaitNode();
        
        // 대기 리스트에 추가
        else if (!queued)
            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,
                                                 q.next = waiters, q);
        
        // 타임아웃 대기
        else if (timed) {
            nanos = deadline - System.nanoTime();
            if (nanos <= 0L) {
                removeWaiter(q);
                return state;
            }
            LockSupport.parkNanos(this, nanos);
        }
        
        // 무한 대기 (핵심: 여기서 블로킹)
        else
            LockSupport.park(this);
    }
}

/**
 * 상태에 따라 결과 반환 또는 예외 던지기
 */
private V report(int s) throws ExecutionException {
    Object x = outcome;
    
    // 정상 완료
    if (s == NORMAL)
        return (V)x;
    
    // 취소됨
    if (s >= CANCELLED)
        throw new CancellationException();
    
    // 예외 발생 → ExecutionException으로 래핑하여 던짐
    throw new ExecutionException((Throwable)x);
}
```

**블로킹 메커니즘:**

```
Main 스레드의 get() 호출:

1. state 확인
   └─ state > COMPLETING → 즉시 결과 반환
   └─ state <= COMPLETING → awaitDone() 진입

2. awaitDone() 무한 루프
   └─ WaitNode 생성 (현재 스레드 저장)
   └─ waiters 리스트에 추가
   └─ LockSupport.park(this) ← 여기서 블로킹

3. Worker 스레드가 finishCompletion() 호출
   └─ LockSupport.unpark(Main) ← Main 깨움

4. Main 스레드 재개
   └─ 루프 재진입 → state > COMPLETING 확인 → 반환
```

---

## 6. ExecutorService와의 통합

### 6.1 ThreadPoolExecutor의 Worker 스레드 메커니즘

```java
public class ThreadPoolExecutor extends AbstractExecutorService {
    
    /** 작업 대기 큐 */
    private final BlockingQueue<Runnable> workQueue;
    
    /** Worker 스레드 집합 */
    private final HashSet<Worker> workers = new HashSet<Worker>();
    
    /**
     * Worker 스레드를 나타내는 내부 클래스
     */
    private final class Worker extends AbstractQueuedSynchronizer
            implements Runnable {
        
        /** 이 Worker가 실행하는 실제 스레드 */
        final Thread thread;
        
        /** 첫 번째 작업 (생성 시 지정) */
        Runnable firstTask;
        
        Worker(Runnable firstTask) {
            setState(-1);  // AQS 초기화
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }
        
        /**
         * Worker 스레드의 메인 루프
         */
        public void run() {
            runWorker(this);
        }
    }
    
    /**
     * Worker 스레드가 실제로 하는 일
     */
    final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock();  // 인터럽트 허용
        boolean completedAbruptly = true;
        
        try {
            // 무한 루프: 작업을 계속 가져와서 실행
            while (task != null || (task = getTask()) != null) {
                w.lock();
                
                // 스레드 풀 상태 확인 로직 ...
                
                try {
                    beforeExecute(wt, task);  // 훅
                    Throwable thrown = null;
                    try {
                        // === 핵심: task.run() 호출 ===
                        // task가 FutureTask이면 FutureTask.run() 실행
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);  // 훅
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
    
    /**
     * 큐에서 작업을 가져옴 (블로킹 가능)
     */
    private Runnable getTask() {
        boolean timedOut = false;
        
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);
            
            // 스레드 풀 종료 확인 ...
            
            int wc = workerCountOf(c);
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
            
            // 타임아웃 또는 워커 수 조정 ...
            
            try {
                // === 핵심: 큐에서 작업 꺼내기 ===
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();  // 블로킹
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
}
```

### 6.2 submit() 메소드의 구현

```java
public abstract class AbstractExecutorService implements ExecutorService {
    
    /**
     * Callable을 제출하고 Future 반환
     */
    public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        
        // === 1단계: FutureTask 생성 ===
        RunnableFuture<T> ftask = newTaskFor(task);
        
        // === 2단계: 작업 큐에 추가 ===
        execute(ftask);
        
        // === 3단계: 즉시 반환 ===
        return ftask;
    }
    
    /**
     * Runnable을 제출하고 Future 반환
     */
    public Future<?> submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<Void> ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }
    
    /**
     * Runnable + 결과값을 제출하고 Future 반환
     */
    public <T> Future<T> submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }
    
    /**
     * FutureTask 생성 팩토리 메소드
     */
    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
        return new FutureTask<T>(callable);
    }
    
    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
        return new FutureTask<T>(runnable, value);
    }
}
```

---

## 7. 전체 실행 흐름: 타임라인 분석

### 7.1 시나리오 설정

```java
ExecutorService executor = Executors.newFixedThreadPool(1);

Future<String> future = executor.submit(() -> {
    Thread.sleep(2000);
    return "홍길동";
});

System.out.println("다른 작업 수행 중...");
String result = future.get();
System.out.println("결과: " + result);
```

### 7.2 타임라인별 실행 흐름

#### T=0ms: ExecutorService 생성 (Main 스레드)

```
Main 스레드:
  └─ Executors.newFixedThreadPool(1) 호출
      └─ ThreadPoolExecutor 생성
          └─ Worker 생성 및 스레드 시작
              └─ Worker.run() → runWorker() 진입
                  └─ getTask() 블로킹 (큐 대기)

JVM 스레드 상태:
- main (Main 스레드): RUNNABLE
- pool-1-thread-1 (Worker 스레드): WAITING (큐 대기)
```

#### T=1ms: submit() 호출 (Main 스레드)

```
Main 스레드 호출 스택:
┌─────────────────────────────────────┐
│ main()                              │
│  └─ executor.submit(callable)       │
│      └─ AbstractExecutorService.    │
│          submit(callable)           │
│          ├─ ftask = new FutureTask()│  ← Callable 래핑
│          ├─ execute(ftask)          │  ← 큐에 추가
│          └─ return ftask            │  ← 즉시 반환
└─────────────────────────────────────┘

메모리 상태:
FutureTask@1a2b 생성:
{
    callable = 람다식
    outcome = null
    state = NEW (0)
    runner = null
    waiters = null
}

workQueue: [FutureTask@1a2b]
```

#### T=2ms: Worker 깨어남 (Worker 스레드)

```
Worker 스레드 (pool-1-thread-1):
  └─ getTask() 반환 (FutureTask@1a2b)
      └─ task.run() 호출
          └─ FutureTask.run() 진입

FutureTask.run() 호출 스택:
┌─────────────────────────────────────┐
│ FutureTask.run()                    │
│  ├─ runner = currentThread()        │  ← pool-1-thread-1 기록
│  ├─ result = callable.call()        │  ← 람다식 실행 시작
│  │   └─ Thread.sleep(2000)          │  ← 2초 대기 시작
│  │       ...                         │
└─────────────────────────────────────┘

메모리 상태:
FutureTask@1a2b:
{
    callable = 람다식
    outcome = null
    state = NEW (0)
    runner = pool-1-thread-1  ← Worker 기록
    waiters = null
}

JVM 스레드 상태:
- main: RUNNABLE (다음 줄 실행 중)
- pool-1-thread-1: TIMED_WAITING (sleep 중)
```

#### T=3ms: Main 다른 작업 수행

```
Main 스레드:
  └─ System.out.println("다른 작업 수행 중...");
      출력: "다른 작업 수행 중..."

JVM 스레드 상태:
- main: RUNNABLE
- pool-1-thread-1: TIMED_WAITING (아직 sleep 중)
```

#### T=2002ms: Worker 작업 완료

```
Worker 스레드 (pool-1-thread-1):
  └─ callable.call() 반환 ("홍길동")
      └─ set(result) 호출

FutureTask.set() 호출 스택:
┌─────────────────────────────────────┐
│ set("홍길동")                        │
│  ├─ CAS(state: NEW → COMPLETING)   │  ← 원자적 상태 변경
│  ├─ outcome = "홍길동"               │  ← 결과 저장
│  ├─ state = NORMAL (2)              │  ← 최종 상태 설정
│  └─ finishCompletion()              │  ← 대기자 깨우기
│      └─ (waiters가 null이므로 생략) │
└─────────────────────────────────────┘

메모리 상태:
FutureTask@1a2b:
{
    callable = 람다식
    outcome = "홍길동"  ← 결과 저장됨
    state = NORMAL (2)  ← 완료 상태
    runner = pool-1-thread-1
    waiters = null
}

JVM 스레드 상태:
- main: RUNNABLE
- pool-1-thread-1: RUNNABLE (runWorker 루프로 복귀, getTask() 재진입)
```

#### T=2003ms: Main에서 get() 호출

```
Main 스레드 호출 스택:
┌─────────────────────────────────────┐
│ main()                              │
│  └─ future.get()                    │
│      └─ FutureTask.get()            │
│          ├─ s = state (NORMAL)      │  ← 이미 완료됨
│          ├─ s > COMPLETING? YES     │  ← 대기 불필요
│          └─ return report(s)        │
│              └─ return outcome      │  ← "홍길동" 반환
└─────────────────────────────────────┘

JVM 스레드 상태:
- main: RUNNABLE (블로킹 없이 즉시 반환)
- pool-1-thread-1: WAITING (getTask 블로킹)

Main 스레드 계속:
  └─ System.out.println("결과: " + result);
      출력: "결과: 홍길동"
```

### 7.3 시나리오 2: get()이 먼저 호출되는 경우

#### T=3ms: Main에서 get() 먼저 호출

```
Main 스레드 호출 스택:
┌─────────────────────────────────────┐
│ future.get()                        │
│  └─ FutureTask.get()                │
│      ├─ s = state (NEW)             │  ← 아직 완료 안됨
│      ├─ s <= COMPLETING? YES        │
│      └─ awaitDone() 진입            │
└─────────────────────────────────────┘

awaitDone() 호출 스택:
┌─────────────────────────────────────┐
│ awaitDone(false, 0)                 │
│  └─ for(;;) 무한 루프                │
│      ├─ q = new WaitNode()          │  ← 대기 노드 생성
│      │   q.thread = main            │
│      ├─ CAS(waiters: null → q)      │  ← waiters에 추가
│      └─ LockSupport.park(this)      │  ← Main 블로킹
└─────────────────────────────────────┘

메모리 상태:
FutureTask@1a2b:
{
    callable = 람다식
    outcome = null
    state = NEW (0)
    runner = pool-1-thread-1
    waiters = WaitNode {
        thread = main  ← Main 스레드 대기 중
        next = null
    }
}

JVM 스레드 상태:
- main: WAITING (LockSupport.park)
- pool-1-thread-1: TIMED_WAITING (sleep 중)
```

#### T=2002ms: Worker 작업 완료 및 Main 깨우기

```
Worker 스레드:
  └─ set("홍길동")
      └─ finishCompletion()

finishCompletion() 호출 스택:
┌─────────────────────────────────────┐
│ finishCompletion()                  │
│  └─ for (WaitNode q = waiters; ...) │
│      ├─ q.thread = main             │
│      └─ LockSupport.unpark(main)    │  ← Main 깨우기
└─────────────────────────────────────┘

JVM 스레드 상태:
- main: RUNNABLE (깨어남, awaitDone 루프 재진입)
- pool-1-thread-1: RUNNABLE
```

#### T=2003ms: Main 재개 및 결과 반환

```
Main 스레드 (awaitDone 루프 재개):
┌─────────────────────────────────────┐
│ awaitDone(false, 0)                 │
│  └─ for(;;) 루프 재진입              │
│      ├─ s = state (NORMAL)          │  ← 완료 상태 확인
│      ├─ s > COMPLETING? YES         │
│      └─ return NORMAL               │  ← 루프 탈출
└─────────────────────────────────────┘

Main 스레드 (get() 계속):
┌─────────────────────────────────────┐
│ get()                               │
│  └─ return report(NORMAL)           │
│      └─ return outcome              │  ← "홍길동" 반환
└─────────────────────────────────────┘
```

---

## 8. 스레드 동기화 메커니즘: LockSupport

### 8.1 LockSupport의 동작 원리

```java
public class LockSupport {
    /**
     * 현재 스레드를 블로킹 (대기 상태로 만듦)
     * permit이 있으면 즉시 반환, 없으면 대기
     */
    public static void park(Object blocker) {
        Thread t = Thread.currentThread();
        setBlocker(t, blocker);
        UNSAFE.park(false, 0L);
        setBlocker(t, null);
    }
    
    /**
     * 지정된 스레드를 깨움
     * permit을 제공하여 park()에서 반환하게 함
     */
    public static void unpark(Thread thread) {
        if (thread != null)
            UNSAFE.unpark(thread);
    }
}
```

**Permit 메커니즘:**

```
각 스레드는 0 또는 1의 permit을 가짐:

park() 호출:
  permit == 1 → permit = 0, 즉시 반환
  permit == 0 → 블로킹 (unpark 대기)

unpark() 호출:
  permit = 1
  대기 중인 스레드가 있으면 깨움
```

### 8.2 FutureTask에서의 사용

```
시나리오: Main이 get() 호출, Worker가 작업 완료

Main 스레드:                  Worker 스레드:
   │                             │
   ├─ get() 호출                 │
   ├─ awaitDone() 진입           │
   ├─ WaitNode 생성              │
   ├─ waiters에 추가             │
   ├─ park(this) ───────┐        │
   │ (블로킹)            │        │
   │                    │        ├─ callable.call()
   │                    │        ├─ set(result)
   │                    │        ├─ finishCompletion()
   │                    └────────┼─ unpark(main)
   ├─ (깨어남)                   │
   ├─ 루프 재진입                │
   ├─ state 확인 (NORMAL)        │
   └─ return result              │
```

---

## 9. 예외 처리 메커니즘

### 9.1 Callable에서 예외 발생

```java
Callable<String> riskyTask = () -> {
    if (Math.random() > 0.5)
        throw new SQLException("DB 연결 실패");
    return "데이터";
};

Future<String> future = executor.submit(riskyTask);
```

### 9.2 FutureTask의 예외 처리

```java
// FutureTask.run() 내부
public void run() {
    try {
        V result = callable.call();  // SQLException 발생 가능
        set(result);
    } catch (Throwable ex) {
        setException(ex);  // 예외 저장
    }
}

// 예외 저장
protected void setException(Throwable t) {
    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
        outcome = t;  // Throwable을 outcome에 저장
        UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL);
        finishCompletion();
    }
}
```

### 9.3 Main 스레드에서 예외 받기

```java
try {
    String data = future.get();
} catch (ExecutionException e) {
    Throwable cause = e.getCause();  // SQLException
    // 원본 예외 처리
}
```

**ExecutionException 생성:**

```java
// FutureTask.report()
private V report(int s) throws ExecutionException {
    Object x = outcome;
    
    if (s == NORMAL)
        return (V)x;
    
    if (s >= CANCELLED)
        throw new CancellationException();
    
    // 예외를 ExecutionException으로 래핑
    throw new ExecutionException((Throwable)x);
}
```

**예외 전파 흐름:**

```
Worker 스레드:                Main 스레드:
   │                            │
   ├─ callable.call()           │
   │  └─ SQLException 발생      │
   ├─ catch (Throwable ex)      │
   ├─ setException(ex)          │
   │  └─ outcome = SQLException │
   │  └─ state = EXCEPTIONAL    │
   │                            ├─ get() 호출
   │                            ├─ report(EXCEPTIONAL)
   │                            └─ throw ExecutionException
   │                               └─ cause = SQLException
```

---

## 10. 결론: 설계 원리의 종합

### 10.1 문제 해결 요약

**문제 1: Runnable의 반환값 부재**
- 해결: Callable 인터페이스 도입 (`V call() throws Exception`)

**문제 2: Callable을 직접 실행할 수 없음**
- 해결: FutureTask가 Runnable 구현, 내부에서 Callable 호출

**문제 3: 결과를 저장할 공간 부재**
- 해결: FutureTask의 `outcome` 필드

**문제 4: 호출 스택 독립성으로 인한 결과 전달 불가**
- 해결: FutureTask가 공유 메모리(outcome)로 동작, volatile로 가시성 보장

**문제 5: 작업 완료 시점 통지 메커니즘 부재**
- 해결: LockSupport를 이용한 park/unpark 메커니즘

**문제 6: 예외 전파 불가**
- 해결: 예외를 outcome에 저장, get()에서 ExecutionException으로 래핑하여 재전파

### 10.2 핵심 설계 패턴

**1. Adapter 패턴**
```
Callable (call() 반환값 있음)
    ↓ FutureTask가 변환
Runnable (run() 반환값 없음)
```

**2. Promise/Future 패턴**
```
submit() → 즉시 Future 반환 (Promise)
           ↓
        비동기 실행
           ↓
get() → 결과 조회 (Future의 이행)
```

**3. Producer-Consumer 패턴**
```
Main (Consumer):          Worker (Producer):
- submit() 로 작업 제출   - 큐에서 작업 꺼냄
- get() 로 결과 소비      - 작업 실행 후 결과 생산
```

### 10.3 성능 특성

**시간 복잡도:**
- `submit()`: O(1) - 큐에 추가만
- `get()`: O(1) - 완료된 경우, 대기 시 O(n) (n = 완료까지 시간)

**공간 복잡도:**
- FutureTask 인스턴스 하나당 고정 크기 메모리
- WaitNode는 대기 스레드 수에 비례

**동기화 비용:**
- CAS 연산: 낮은 오버헤드
- park/unpark: 시스템 콜, 중간 오버헤드
- synchronized 블록 없음: lock-free 설계

### 10.4 Wherehouse 프로젝트 적용 시나리오

**현재 구조 (순차):**
```java
String address = kakaoAddressApi.convert(lat, lon);  // 100ms
List<Place> places = new ArrayList<>();
for (String category : 15개 카테고리) {
    places.addAll(kakaoLocalApi.search(category));  // 각 150ms
}
Crime crime = policeCrimeApi.get(address);  // 200ms

// 총 시간: 100 + (150 × 15) + 200 = 2,550ms
```

**Future 패턴 적용 (병렬):**
```java
ExecutorService executor = Executors.newFixedThreadPool(17);

// 모든 API 호출을 동시 제출
Future<String> addressFuture = executor.submit(() -> 
    kakaoAddressApi.convert(lat, lon));

List<Future<List<Place>>> placeFutures = new ArrayList<>();
for (String category : 15개 카테고리) {
    placeFutures.add(executor.submit(() -> 
        kakaoLocalApi.search(category)));
}

Future<Crime> crimeFuture = executor.submit(() -> 
    policeCrimeApi.get(addressFuture.get()));  // 의존성

// 결과 수집 (블로킹)
String address = addressFuture.get();
List<Place> allPlaces = new ArrayList<>();
for (Future<List<Place>> f : placeFutures) {
    allPlaces.addAll(f.get());
}
Crime crime = crimeFuture.get();

// 총 시간: max(100, 150 × 병렬, 100+200) = 300ms
// 개선: 2,550ms → 300ms (8.5배 향상)
```

---

## 11. 참고: CompletableFuture와의 비교

Future 패턴의 한계를 해결한 Java 8의 CompletableFuture:

```java
// Future: 수동 조합
Future<String> f1 = executor.submit(task1);
Future<String> f2 = executor.submit(task2);
String result = process(f1.get(), f2.get());

// CompletableFuture: 선언적 조합
CompletableFuture<String> result = 
    CompletableFuture.supplyAsync(task1)
        .thenCombine(CompletableFuture.supplyAsync(task2), 
            (r1, r2) -> process(r1, r2));
```

그러나 **FutureTask의 기본 메커니즘은 CompletableFuture에서도 동일하게 사용**된다.

---

**본 백서는 Java 비동기 프로그래밍의 핵심인 Future 패턴의 설계 원리와 구현 메커니즘을 OS 레벨의 스레드 동기화까지 포함하여 분석하였다. Wherehouse 프로젝트의 R-04 최적화 단계에서 이러한 원리를 적용하면 API 호출 병렬화를 통해 약 8.5배의 성능 향상을 달성할 수 있을 것으로 예상된다.**