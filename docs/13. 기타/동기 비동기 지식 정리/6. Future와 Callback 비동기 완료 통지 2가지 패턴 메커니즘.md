# Future와 Callback: 비동기 완료 통지 메커니즘의 두 가지 패러다임

## 서론: Pull 모델과 Push 모델의 근본적 차이

### 비동기 작업 완료를 어떻게 알 것인가

비동기 프로그래밍에서 가장 핵심적인 질문은 "작업이 완료되었다는 사실을 어떻게 알 것인가"다. 이 질문에 대한 답은 크게 두 가지 패러다임으로 나뉜다. **Pull 모델(Future)**은 호출자가 능동적으로 완료 여부를 확인하고 결과를 가져간다. **Push 모델(Callback)**은 시스템이 완료 시점에 호출자에게 알려준다.

이 차이는 단순한 API 설계의 차이가 아니라, **스레드 자원 활용과 제어 흐름**에 대한 근본적으로 다른 철학을 반영한다. Future는 "결과가 필요한 시점"에 블로킹하여 동기적 코드처럼 보이게 만들지만, 그 대가로 스레드를 점유한다. Callback은 스레드를 즉시 해방시키지만, 제어 흐름이 분산되어 코드 복잡도가 증가한다.

### 역사적 맥락: 왜 두 패턴이 공존하는가

Java 5(2004)에서 Future가 도입될 당시, 람다식이 존재하지 않았다. Callback을 구현하려면 익명 클래스를 중첩해야 했고, 이는 "Callback Hell"이라는 악명 높은 안티패턴을 만들었다. Doug Lea는 이 문제를 인지했지만, "복잡한 콜백보다는 단순한 블로킹"이 당시 Java 생태계에 더 적합하다고 판단했다.

JavaScript는 반대 경로를 택했다. 브라우저 환경에서는 단일 스레드만 사용 가능했기 때문에, 블로킹이 곧 UI 동결을 의미했다. 따라서 처음부터 Callback 기반 비동기 모델을 채택했고, 이후 Promise와 async/await로 진화했다.

이 문서는 두 패턴의 **내부 동작 메커니즘과 스레드 동기화 방식**을 분석하고, 각각의 장단점과 적용 시나리오를 제시한다.

---

## 1. Future 패턴: Pull 기반 결과 조회

### 1.1 아키텍처 구조와 동작 원리

Future 패턴은 **"미래에 완료될 작업의 핸들"**을 즉시 반환하는 설계다. 작업 제출과 결과 조회를 시간적으로 분리하되, 결과가 필요한 시점에 명시적으로 블로킹한다.

```java
public class FuturePatternAnalysis {
    
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        System.out.println("[T=0ms] Main Thread: 작업 제출 시작");
        
        // === Phase 1: 작업 제출 (논블로킹) ===
        Future<String> future = executor.submit(() -> {
            System.out.println("[T=1ms] Worker Thread: 작업 시작 (Thread ID: " + 
                Thread.currentThread().getId() + ")");
            
            try {
                // 네트워크 I/O 시뮬레이션
                Thread.sleep(2000);  // Worker Thread가 TIMED_WAITING 상태로 전환
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            System.out.println("[T=2001ms] Worker Thread: 작업 완료");
            return "카카오 API 응답 데이터";
        });
        
        // === Phase 2: Main Thread 다른 작업 수행 (병렬 실행) ===
        System.out.println("[T=2ms] Main Thread: Future 객체 즉시 반환받음");
        System.out.println("[T=3ms] Main Thread: 다른 작업 수행 중...");
        
        Thread.sleep(500);  // 다른 작업 시뮬레이션
        
        // === Phase 3: 결과 필요 시점 (블로킹 시작) ===
        System.out.println("[T=503ms] Main Thread: 이제 결과가 필요함");
        System.out.println("[T=504ms] Main Thread: future.get() 호출 → 블로킹 시작");
        
        long blockStart = System.currentTimeMillis();
        String result = future.get();  // Main Thread가 WAITING 상태로 전환
        long blockDuration = System.currentTimeMillis() - blockStart;
        
        System.out.println("[T=" + (504 + blockDuration) + "ms] Main Thread: 블로킹 해제됨");
        System.out.println("결과: " + result);
        System.out.println("블로킹 시간: " + blockDuration + "ms");
        
        executor.shutdown();
    }
}
```

### 1.2 내부 메커니즘: FutureTask의 동작

```java
// submit() 호출 시 내부 동작
public <T> Future<T> submit(Callable<T> task) {
    // 1. Callable을 FutureTask로 래핑
    RunnableFuture<T> ftask = new FutureTask<T>(task);
    
    // 2. 작업 큐에 삽입
    execute(ftask);  // workQueue.offer(ftask)
    
    // 3. 동일한 객체를 Future로 반환
    return ftask;
}
```

#### 스레드 상태 전이 다이어그램

```
시간    Main Thread           Worker Thread         FutureTask.state
────────────────────────────────────────────────────────────────────
T=0     RUNNABLE             (미생성)              NEW
        submit() 호출
        
T=1     RUNNABLE             RUNNABLE              NEW
        다른 작업 수행        callable.call() 시작
        
T=500   RUNNABLE             TIMED_WAITING         NEW
        다른 작업 중         Thread.sleep(2000)
        
T=504   future.get() 호출    TIMED_WAITING         NEW
        ↓
        WAITING              TIMED_WAITING         NEW
        (LockSupport.park)
        
T=2001  WAITING              RUNNABLE              COMPLETING
                            작업 완료
                            outcome = result
                            
T=2002  WAITING              RUNNABLE              NORMAL
                            finishCompletion()
                            LockSupport.unpark(main)
                            
T=2003  RUNNABLE             (작업 큐 확인)        NORMAL
        결과 반환받음
```

### 1.3 Future 패턴의 본질적 특성

#### 장점
1. **직관적인 제어 흐름**: 코드가 위에서 아래로 순차적으로 읽힌다
2. **명확한 에러 처리**: try-catch로 동기 코드처럼 예외 처리
3. **타임아웃 지원**: `get(timeout, unit)`으로 무한 대기 방지

#### 한계
1. **스레드 블로킹**: 결과를 기다리는 동안 스레드가 WAITING 상태
2. **조합의 어려움**: 여러 Future를 체이닝하려면 각 단계마다 블로킹
3. **리소스 낭비**: 블로킹된 스레드는 다른 작업을 처리할 수 없음

---

## 2. Callback 패턴: Push 기반 완료 통지

### 2.1 아키텍처 구조와 동작 원리

Callback 패턴은 **"완료되면 이 함수를 호출해달라"**는 계약을 미리 등록하는 설계다. 호출자는 콜백만 등록하고 즉시 다른 일을 계속하며, 작업 완료 시 Worker Thread가 콜백을 실행한다.

```java
// Callback 인터페이스 정의
interface AsyncCallback<T> {
    void onSuccess(T result);
    void onError(Throwable error);
}

// 비동기 작업 서비스
public class CallbackPatternAnalysis {
    
    private final ExecutorService executor = Executors.newFixedThreadPool(3);
    
    // 비동기 작업 실행 메서드
    public void executeAsync(String taskName, AsyncCallback<String> callback) {
        
        System.out.println("[Submit] " + taskName + " 작업 제출 (Thread: " + 
            Thread.currentThread().getName() + ")");
        
        executor.submit(() -> {
            Thread workerThread = Thread.currentThread();
            System.out.println("[Start] " + taskName + " 시작 (Thread: " + 
                workerThread.getName() + ")");
            
            try {
                // 작업 수행
                Thread.sleep(2000);
                String result = taskName + " 완료 데이터";
                
                // === 핵심: Worker Thread가 콜백 실행 ===
                System.out.println("[Callback] " + taskName + " 콜백 호출 (Thread: " + 
                    workerThread.getName() + ")");
                callback.onSuccess(result);
                
            } catch (Exception e) {
                callback.onError(e);
            }
        });
        
        System.out.println("[Return] " + taskName + " 제출 완료, 즉시 반환");
    }
    
    public static void main(String[] args) throws Exception {
        CallbackPatternAnalysis service = new CallbackPatternAnalysis();
        
        // === Phase 1: 콜백 정의 ===
        AsyncCallback<String> callback = new AsyncCallback<>() {
            @Override
            public void onSuccess(String result) {
                System.out.println("[Success] 결과 수신: " + result + 
                    " (Thread: " + Thread.currentThread().getName() + ")");
            }
            
            @Override
            public void onError(Throwable error) {
                System.err.println("[Error] 오류 발생: " + error.getMessage());
            }
        };
        
        // === Phase 2: 작업 제출 (논블로킹) ===
        System.out.println("[T=0ms] Main Thread 시작");
        service.executeAsync("카카오API호출", callback);
        
        // === Phase 3: Main Thread는 블로킹 없이 계속 진행 ===
        System.out.println("[T=1ms] Main Thread: 다른 작업 계속 수행");
        
        // 콜백 실행을 관찰하기 위해 대기
        Thread.sleep(3000);
        service.executor.shutdown();
    }
}
```

### 2.2 Callback Hell과 제어 흐름의 분산

#### 순차적 의존성이 있는 작업의 콜백 중첩

```java
public class CallbackHellExample {
    
    // 주소 변환 → 범죄율 조회 → 카테고리 검색의 순차 의존성
    public void analyzeLocationWithCallbacks(double lat, double lon) {
        
        // 1단계: 주소 변환
        geocodeService.getAddress(lat, lon, new AsyncCallback<Address>() {
            @Override
            public void onSuccess(Address address) {
                
                // 2단계: 범죄율 조회 (주소 필요)
                crimeService.getCrimeRate(address.getGu(), new AsyncCallback<Crime>() {
                    @Override
                    public void onSuccess(Crime crime) {
                        
                        // 3단계: 카테고리 검색 (15개 병렬)
                        AtomicInteger counter = new AtomicInteger(15);
                        List<CategoryResult> results = new CopyOnWriteArrayList<>();
                        
                        for (Category category : Category.values()) {
                            categoryService.search(lat, lon, category, 
                                new AsyncCallback<CategoryResult>() {
                                    @Override
                                    public void onSuccess(CategoryResult result) {
                                        results.add(result);
                                        
                                        // 모든 카테고리 완료 확인
                                        if (counter.decrementAndGet() == 0) {
                                            // 최종 결과 처리
                                            SafetyAnalysis analysis = SafetyAnalysis.builder()
                                                .address(address)
                                                .crimeRate(crime.getRate())
                                                .categories(results)
                                                .build();
                                            
                                            // 4단계: 최종 콜백
                                            finalCallback.onSuccess(analysis);
                                        }
                                    }
                                    
                                    @Override
                                    public void onError(Throwable error) {
                                        // 에러 처리도 중첩...
                                    }
                                });
                        }
                    }
                    
                    @Override
                    public void onError(Throwable error) {
                        finalCallback.onError(error);
                    }
                });
            }
            
            @Override
            public void onError(Throwable error) {
                finalCallback.onError(error);
            }
        });
    }
}
```

### 2.3 스레드 실행 컨텍스트 분석

```
Main Thread                 Worker-1                  Worker-2
───────────────────────────────────────────────────────────────
submit(task1, callback1)    
│                          
├─ 즉시 반환               task1 실행 시작
│                          │
├─ 다른 작업 수행          │ (2초 대기)
│                          │
submit(task2, callback2)   │                        task2 실행 시작  
│                          │                        │
├─ 또 즉시 반환            │                        │ (2초 대기)
│                          │                        │
├─ 계속 다른 작업          callback1.onSuccess()    │
│                          │                        │
│                          └─ (Worker-1에서 실행)  callback2.onSuccess()
│                                                   │
│                                                   └─ (Worker-2에서 실행)
```

**핵심 차이점**: 
- Future: Main Thread가 `get()`에서 블로킹되어 결과를 기다림
- Callback: Worker Thread가 작업 완료 후 콜백을 실행, Main은 블로킹 없음

---

## 3. 메모리 모델과 동기화 메커니즘

### 3.1 Future의 동기화: Wait/Notify 메커니즘

```java
public class FutureSynchronization {
    
    // FutureTask 내부의 대기 메커니즘 (단순화)
    class SimpleFuture<V> {
        private volatile V outcome;
        private volatile Thread waiter;  // 대기 중인 스레드
        
        public V get() throws InterruptedException {
            if (outcome == null) {
                waiter = Thread.currentThread();
                
                // 스레드를 WAITING 상태로 전환
                while (outcome == null) {
                    LockSupport.park(this);  // OS 레벨 블로킹
                }
            }
            return outcome;
        }
        
        protected void set(V value) {
            this.outcome = value;
            
            // 대기 중인 스레드 깨우기
            Thread t = waiter;
            if (t != null) {
                LockSupport.unpark(t);  // 스레드 상태를 RUNNABLE로 전환
            }
        }
    }
}
```

### 3.2 Callback의 동기화: 함수 포인터 전달

```java
public class CallbackSynchronization {
    
    // Callback은 함수 참조를 전달하는 방식
    class SimpleAsyncExecutor {
        private final Queue<Runnable> taskQueue = new LinkedBlockingQueue<>();
        
        public void submitWithCallback(Runnable task, Runnable callback) {
            taskQueue.offer(() -> {
                try {
                    task.run();        // 작업 실행
                    callback.run();    // 완료 후 콜백 실행
                } catch (Exception e) {
                    // 에러 처리
                }
            });
        }
    }
}
```

---

## 4. 성능 특성과 리소스 사용량 비교

### 4.1 스레드 사용 패턴 분석

```java
public class ResourceComparisonTest {
    
    @Test
    public void testFutureThreadUsage() {
        // Future 패턴: N개 작업에 N개 블로킹
        ExecutorService executor = Executors.newFixedThreadPool(10);
        List<Future<String>> futures = new ArrayList<>();
        
        for (int i = 0; i < 100; i++) {
            futures.add(executor.submit(() -> apiCall()));
        }
        
        // 각 get()마다 Main Thread 블로킹
        for (Future<String> future : futures) {
            future.get();  // 블로킹 × 100회
        }
        
        // 총 블로킹 시간 = Σ(각 작업의 대기 시간)
    }
    
    @Test
    public void testCallbackThreadUsage() {
        // Callback 패턴: 블로킹 없음
        AtomicInteger counter = new AtomicInteger(100);
        CountDownLatch latch = new CountDownLatch(100);
        
        for (int i = 0; i < 100; i++) {
            service.executeAsync(task, result -> {
                counter.decrementAndGet();
                latch.countDown();
                // Main Thread는 블로킹되지 않음
            });
        }
        
        // Main Thread는 다른 작업 수행 가능
        doOtherWork();
        
        latch.await();  // 모든 작업 완료까지 대기 (선택적)
    }
}
```

### 4.2 메모리 사용량 비교

```
Future 패턴:
- FutureTask 객체: ~100 bytes × N개
- WaitNode (대기 스레드 정보): ~40 bytes × 대기 스레드 수
- 블로킹된 스레드의 스택: 1MB × 블로킹 스레드 수

Callback 패턴:
- Callback 객체: ~80 bytes × N개
- 람다 캡처 변수: 가변적
- 블로킹 스레드 없음 (스택 메모리 절약)
```

---

## 5. 실무 적용 가이드라인

### 5.1 Future 패턴이 적합한 경우

```java
// 1. 단순한 요청-응답 패턴
public User getUser(Long id) {
    Future<User> future = executor.submit(() -> 
        userRepository.findById(id)
    );
    
    try {
        return future.get(5, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        // 명확한 타임아웃 처리
        throw new ServiceUnavailableException("User service timeout");
    }
}

// 2. 동기적 코드와의 통합이 필요한 경우
public Order processOrder(OrderRequest request) {
    // 기존 동기 코드
    validateRequest(request);
    
    // 비동기 작업을 동기적으로 대기
    Future<Payment> paymentFuture = processPaymentAsync(request);
    Payment payment = paymentFuture.get();
    
    // 다시 동기 코드
    return createOrder(payment);
}
```

### 5.2 Callback 패턴이 적합한 경우

```java
// 1. 이벤트 기반 시스템
public class EventDrivenSystem {
    
    public void handleUserAction(UserEvent event) {
        // 이벤트 발생 시 여러 비동기 작업 트리거
        
        analyticsService.track(event, new AsyncCallback<>() {
            public void onSuccess(Void v) {
                logger.info("Analytics tracked");
            }
        });
        
        notificationService.notify(event, new AsyncCallback<>() {
            public void onSuccess(Void v) {
                logger.info("Notification sent");
            }
        });
        
        // Main 흐름은 블로킹 없이 계속
    }
}

// 2. 고성능 I/O 처리
public class HighThroughputService {
    
    public void processBatch(List<Request> requests) {
        AtomicInteger completed = new AtomicInteger(0);
        
        for (Request req : requests) {
            // 수천 개의 요청을 블로킹 없이 처리
            processAsync(req, result -> {
                int count = completed.incrementAndGet();
                if (count % 100 == 0) {
                    logger.info("Processed: " + count);
                }
            });
        }
    }
}
```

---

## 6. Wherehouse R-04 적용 시나리오

### 6.1 Future 패턴 적용

```java
public class WherehouseFutureImplementation {
    
    public SafetyAnalysis analyzeWithFuture(double lat, double lon) {
        ExecutorService executor = Executors.newFixedThreadPool(17);
        
        try {
            // 모든 작업을 Future로 제출
            Future<Address> addressFuture = executor.submit(() -> 
                kakaoApi.getAddress(lat, lon));
            
            List<Future<CategoryResult>> categoryFutures = new ArrayList<>();
            for (Category cat : Category.values()) {
                categoryFutures.add(executor.submit(() -> 
                    kakaoApi.searchCategory(lat, lon, cat)));
            }
            
            // 주소를 먼저 가져와야 범죄율 조회 가능
            Address address = addressFuture.get();  // 블로킹 1
            
            Future<Crime> crimeFuture = executor.submit(() -> 
                crimeApi.getCrime(address.getGu()));
            
            // 모든 카테고리 결과 수집
            List<CategoryResult> categories = new ArrayList<>();
            for (Future<CategoryResult> f : categoryFutures) {
                categories.add(f.get());  // 블로킹 15회
            }
            
            Crime crime = crimeFuture.get();  // 블로킹 1
            
            return SafetyAnalysis.of(address, crime, categories);
            
        } finally {
            executor.shutdown();
        }
    }
    
    // 문제점: 총 17번의 get() 호출로 인한 블로킹
    // 개선 필요: CompletableFuture로 전환
}
```

### 6.2 Callback 패턴 적용 (권장하지 않음)

```java
public class WherehouseCallbackImplementation {
    
    public void analyzeWithCallback(double lat, double lon, 
                                   AsyncCallback<SafetyAnalysis> finalCallback) {
        
        // Callback Hell의 전형적 예시
        geocodeService.getAddress(lat, lon, new AsyncCallback<Address>() {
            @Override
            public void onSuccess(Address address) {
                
                AtomicInteger categoryCounter = new AtomicInteger(15);
                List<CategoryResult> categoryResults = new CopyOnWriteArrayList<>();
                Crime[] crimeHolder = new Crime[1];  // 범죄율 저장용
                
                // 범죄율 조회
                crimeService.getCrime(address.getGu(), new AsyncCallback<Crime>() {
                    @Override
                    public void onSuccess(Crime crime) {
                        crimeHolder[0] = crime;
                        checkCompletion();
                    }
                });
                
                // 15개 카테고리 병렬 조회
                for (Category cat : Category.values()) {
                    categoryService.search(lat, lon, cat, new AsyncCallback<CategoryResult>() {
                        @Override
                        public void onSuccess(CategoryResult result) {
                            categoryResults.add(result);
                            if (categoryCounter.decrementAndGet() == 0) {
                                checkCompletion();
                            }
                        }
                    });
                }
                
                void checkCompletion() {
                    if (crimeHolder[0] != null && categoryCounter.get() == 0) {
                        SafetyAnalysis analysis = SafetyAnalysis.of(
                            address, crimeHolder[0], categoryResults
                        );
                        finalCallback.onSuccess(analysis);
                    }
                }
            }
        });
    }
    
    // 문제점: 
    // 1. 콜백 중첩으로 인한 가독성 저하
    // 2. 에러 처리 로직의 분산
    // 3. 동기화 로직의 복잡성 (counter, holder)
}
```

---

## 결론: 패러다임 선택의 기준

### 핵심 트레이드오프

| 측면 | Future 패턴 | Callback 패턴 |
|------|------------|---------------|
| **제어 흐름** | 순차적, 직관적 | 분산, 이벤트 기반 |
| **스레드 사용** | 블로킹으로 인한 점유 | 블로킹 없음, 효율적 |
| **에러 처리** | try-catch 집중 | 콜백마다 개별 처리 |
| **코드 복잡도** | 낮음 | 높음 (Callback Hell) |
| **성능** | 블로킹으로 인한 제한 | 높은 동시성 가능 |

### Wherehouse R-04를 위한 최종 권장사항

Future와 Callback 모두 한계가 명확하다. Future는 블로킹으로 인한 스레드 낭비, Callback은 복잡한 제어 흐름이 문제다. 따라서 **CompletableFuture**를 사용하는 것이 최선이다:

```java
// CompletableFuture: Future와 Callback의 장점 결합
CompletableFuture<Address> addressFuture = 
    CompletableFuture.supplyAsync(() -> kakaoApi.getAddress(lat, lon));

CompletableFuture<Crime> crimeFuture = addressFuture
    .thenCompose(addr -> CompletableFuture.supplyAsync(() -> 
        crimeApi.getCrime(addr.getGu())));  // 블로킹 없는 체이닝

// Callback처럼 논블로킹, Future처럼 조합 가능
```

**결론**: Future는 "학습 용이성과 단순성"을 제공하고, Callback은 "성능과 확장성"을 제공한다. 하지만 현대적 Java 애플리케이션에서는 CompletableFuture가 두 패러다임의 장점을 모두 제공하므로, 이를 채택하는 것이 아키텍처적으로 올바른 선택이다.