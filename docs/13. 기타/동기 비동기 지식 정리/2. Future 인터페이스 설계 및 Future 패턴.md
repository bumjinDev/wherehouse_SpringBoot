# Future 인터페이스 설계 및 Future 패턴

## 서론: 작업 제출과 결과 수신의 시간적 분리

Thread를 직접 생성하는 방식에서는 워커 Thread가 계산한 결과를 메인 Thread로 전달할 표준화된 방법이 없었다. 이유는 호출자인 메인 Thread 와 실제 워커 Thread 는 각자의 호출 스택이 물리적으로 별도로 구현되어 있기 때문이다. 개발자는 공유 변수를 선언하고 synchronized 블록으로 동기화하거나, BlockingQueue를 사용해 결과 전달 채널을 수동으로 구현해야 했다. 이는 모든 개발자가 동일한 문제를 반복적으로 해결하며, 각 구현마다 미묘한 동기화 버그를 양산하는 구조적 비효율을 초래했다.

ExecutorService는 작업 제출과 실행의 분리를 구현했지만, "제출한 작업의 결과를 나중에 어떻게 조회할 것인가"에 대한 추상화가 필요했다. Future는 이 시간적 분리를 해결하기 위해 도입된 인터페이스다. 작업 제출 시점에 "미래의 결과를 참조할 수 있는 핸들"을 반환함으로써, 작업 실행과 결과 수신을 독립적인 시간 축에서 제어할 수 있게 되었다.

---

## 본론: Future의 설계 구조와 내부 메커니즘

### Future 인터페이스: 결과 참조의 계약

Future는 비동기 작업의 결과를 참조하기 위한 표준 인터페이스다. 이 인터페이스는 작업이 어떻게 실행되는지에 대해서는 아무것도 정의하지 않으며, 오직 "이미 제출된 작업의 결과를 어떻게 조회하고 제어할 것인가"만을 명세한다.

```java
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit) 
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

**get() 메서드**는 작업이 완료될 때까지 호출 Thread를 블로킹하며 결과를 반환한다. 작업이 정상 완료되면 결과 값을 반환하고, 예외로 완료되면 ExecutionException으로 래핑하여 던지며, 대기 중 인터럽트가 발생하면 InterruptedException을 던진다. 이 메서드의 설계적 의의는 "아직 존재하지 않는 값을 필요한 시점까지 대기하며 수신"하는 블로킹 동기화를 표준화했다는 점이다.

**타임아웃 버전의 get() 메서드**는 지정된 시간 내에 작업이 완료되지 않으면 TimeoutException을 던진다. 이것은 무한 대기를 방지하기 위한 안전장치로, 네트워크 타임아웃이나 외부 시스템 지연으로 인한 영구 블로킹을 차단한다. 타임아웃이 발생해도 작업 자체는 취소되지 않으며, 백그라운드에서 계속 실행된다.

**isDone() 메서드**는 작업의 완료 여부를 논블로킹 방식으로 조회한다. 정상 완료, 예외 완료, 취소 모두 완료로 간주되어 true를 반환한다. 이 메서드는 폴링 기반 대기 구현을 가능하게 하지만, 반복 호출 시 CPU를 소비하는 busy-waiting이 발생할 수 있어 권장되지 않는다.

**cancel() 메서드**는 작업 취소를 시도한다. mayInterruptIfRunning 플래그가 true면 실행 중인 Thread에 인터럽트를 시도하고, false면 아직 시작되지 않은 작업만 취소한다. 하지만 이것은 "강제 중단"이 아니라 "협력적 취소"다. 작업 내부에서 인터럽트를 확인하고 스스로 중단해야 실제 취소가 이루어진다. 이미 완료된 작업은 취소할 수 없으며 false를 반환한다.

**isCancelled() 메서드**는 작업이 취소되었는지 조회한다. 이것은 완료 상태를 세분화하여, 정상 완료와 취소에 의한 완료를 구분할 수 있게 한다.

### Runnable과 Callable: 작업 표현의 두 인터페이스

ExecutorService의 작업 큐가 저장하는 것은 Runnable 인터페이스를 구현한 객체다. Runnable은 Java 1.0부터 존재한 Thread 작업의 표준 인터페이스로, 단일 메서드만을 정의한다.

```java
public interface Runnable {
    void run();
}
```

Runnable의 근본적 한계는 **반환값이 없고 체크 예외를 던질 수 없다**는 점이다. run() 메서드는 void를 반환하므로, 작업의 결과를 호출자에게 전달할 방법이 없다. 또한 throws 절이 없으므로, 체크 예외가 발생하면 run() 내부에서 처리하거나 언체크 예외로 래핑해야 한다.

Java 5는 이 한계를 극복하기 위해 Callable 인터페이스를 도입했다.

```java
public interface Callable<V> {
    V call() throws Exception;
}
```

Callable은 제네릭 타입 V를 반환하며, throws Exception 절로 모든 체크 예외를 던질 수 있다. 이것은 **값을 생성하는 작업**을 표현하기 위한 인터페이스다.

하지만 ExecutorService의 작업 큐는 `BlockingQueue<Runnable>` 타입이다. Callable을 직접 큐에 넣을 수 없다. 따라서 Callable을 Runnable로 변환하면서 동시에 반환값을 어딘가에 저장하는 어댑터가 필요하다. **FutureTask가 바로 이 어댑터 역할을 수행한다.**

### FutureTask: 실행 가능한 Future 구현체

FutureTask는 Runnable과 Future 두 인터페이스를 동시에 구현하는 클래스다. 더 정확히는 RunnableFuture 인터페이스를 구현한다.

```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    void run();
}

public class FutureTask<V> implements RunnableFuture<V> {
    // 구현
}
```

FutureTask의 설계 의도를 이해하려면 다음 문제를 생각해야 한다. Callable은 값을 반환하지만 Runnable이 아니므로 작업 큐에 넣을 수 없다. Callable을 Runnable로 래핑하려면, Runnable의 run() 메서드 내부에서 Callable의 call()을 호출하고, 그 반환값을 어딘가에 저장해야 한다. 그리고 나중에 그 저장된 값을 조회할 방법도 필요하다.

**FutureTask는 이 모든 것을 단일 객체로 통합한다.** FFutureTask는 Runnable이므로 작업 큐에 넣을 수 있고, 내부에 Callable을 담고 있으며, run() 메서드 내부에서 Callable.call()을 실행하고 그 결과와 작업 상태를 자신의 필드에 저장한다. 동시에 Future이므로 get() 메서드로 저장된 결과를 조회할 수 있다.

즉, FutureTask는 "실행 가능한 작업"이면서 동시에 "그 작업의 결과를 참조하는 핸들"이라는 이중 정체성을 갖는다. 제출 시점의 핸들과 실행 시점의 작업이 동일한 객체이므로, 별도의 결과 전달 채널이 불필요하다.

### ExecutorService.submit(): FutureTask 생성과 반환

개발자가 `executor.submit(() -> "결과")`를 호출하면 ExecutorService 내부에서 다음 과정이 실행된다.

ExecutorService의 submit() 메서드 실제 구현은 AbstractExecutorService 클래스에 있다.

```java
public <T> Future<T> submit(Callable<T> task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture<T> ftask = newTaskFor(task);
    execute(ftask);
    return ftask;
}

protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
    return new FutureTask<T>(callable);
}
```

**첫 번째 단계는 Callable을 FutureTask로 래핑하는 것이다.** newTaskFor() 메서드가 새 FutureTask 객체를 생성한다. 이때 FutureTask 생성자가 호출된다.

```java
public FutureTask(Callable<V> callable) {
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;
}
```

생성자는 전달받은 Callable을 callable 필드에 저장하고 state를 NEW로 초기화한다. 이 시점에서 outcome은 null, runner는 null, waiters는 null이다.

**두 번째 단계는 execute(ftask)를 호출하는 것이다.** execute()는 Runnable을 작업 큐에 삽입하는 메서드다. ThreadPoolExecutor의 execute() 구현을 보면, 워커 Thread 수와 큐 상태에 따라 분기하지만, 최종적으로는 workQueue.offer(ftask)를 호출하여 FutureTask를 큐에 넣는다.

FutureTask는 Runnable이므로 `BlockingQueue<Runnable>` 타입의 workQueue에 직접 삽입될 수 있다. 큐에 들어간 FutureTask는 워커 Thread가 꺼내기를 대기한다.

**세 번째 단계는 동일한 FutureTask 객체를 호출자에게 반환하는 것이다.** submit() 메서드는 ftask를 반환하며, 이것은 방금 큐에 넣은 바로 그 객체다. 이 시점에서 submit() 메서드는 즉시 반환되고, 개발자는 FutureTask 참조를 받아 다음 코드로 진행한다.

이 설계의 핵심은 **제출한 객체와 반환받은 객체가 동일하다**는 점이다. 개발자가 받은 Future는 작업 큐 안에 있는 Runnable과 같은 메모리 주소를 가리킨다. 워커 Thread가 이 객체를 실행하면, 실행 결과가 같은 객체 내부에 저장되고, 개발자는 같은 객체의 get()을 호출하여 결과를 조회한다.

람다를 Callable로 변환하는 과정도 간단하다. `executor.submit(() -> "결과")`에서 람다 표현식은 컴파일러에 의해 자동으로 Callable 인터페이스의 익명 구현체로 변환된다. 람다의 반환 타입이 String이면 `Callable<String>`이 되고, void를 반환하면 `Runnable`이 된다.

### FutureTask의 내부 필드: 상태 관리 구조

FutureTask는 작업의 생명주기를 관리하기 위해 다섯 개의 핵심 필드를 갖는다.

```java
public class FutureTask<V> implements RunnableFuture<V> {
    private volatile int state;
    private Callable<V> callable;
    private Object outcome;
    private volatile Thread runner;
    private volatile WaitNode waiters;
}
```

**state 필드**는 작업의 현재 상태를 나타내는 정수다. 상태는 7개의 상수로 정의된다.

```java
private static final int NEW          = 0;
private static final int COMPLETING   = 1;
private static final int NORMAL       = 2;
private static final int EXCEPTIONAL  = 3;
private static final int CANCELLED    = 4;
private static final int INTERRUPTING = 5;
private static final int INTERRUPTED  = 6;
```

NEW는 생성 직후 상태로 아직 실행되지 않았음을 의미한다. COMPLETING은 작업이 완료되어 결과를 설정 중인 과도 상태다. NORMAL은 정상 완료, EXCEPTIONAL은 예외로 인한 완료, CANCELLED는 취소를 나타낸다. INTERRUPTING과 INTERRUPTED는 인터럽트 진행 중과 완료 상태다.

state 필드는 volatile로 선언되어, 한 Thread가 이 값을 변경하면 다른 모든 Thread가 CPU 캐시를 거치지 않고 메인 메모리에서 최신 값을 읽는다. 멀티 Thread 환경에서 상태 변경의 즉각적 가시성은 정확한 완료 감지를 위한 필수 조건이다.

**callable 필드**는 실행할 작업을 담는다. submit()에서 전달받은 Callable이 여기 저장된다. 작업이 완료되면 이 필드는 null로 설정되어 메모리 누수를 방지한다.

**outcome 필드**는 타입이 Object인데, 정상 결과(V 타입)와 예외(Throwable)를 모두 담아야 하기 때문이다. 작업이 성공하면 실제 결과 객체가 이 필드에 저장되고, 실패하면 예외 객체(Throwable)가 직접 저장된다. 정상 완료와 예외 완료는 state 필드(NORMAL vs EXCEPTIONAL)로 구분한다.

**runner 필드**는 현재 이 작업을 실행 중인 워커 Thread의 참조다. 작업 실행 전에는 null이며, run() 메서드 진입 시 현재 Thread로 설정되고, 완료 후 다시 null로 초기화된다. 이 필드도 volatile로 선언되어 가시성이 보장된다.

**waiters 필드**는 결과를 기다리며 블로킹된 Thread들의 단일 연결 리스트다. 각 노드는 WaitNode 객체로, Thread 참조와 다음 노드 포인터를 담는다.

```java
static final class WaitNode {
    volatile Thread thread;
    volatile WaitNode next;
    WaitNode() { thread = Thread.currentThread(); }
}

```

---

#### waiters 리스트의 필요성: 다중 조회자 시나리오

여러 Thread가 동일한 Future 객체에 대해 get()을 호출하는 상황을 생각해보자.

```java
Future<Integer> future = executor.submit(() -> slowComputation());

// Thread-1, Thread-2, Thread-3가 동시에 get() 호출
Thread t1 = new Thread(() -> {
    Integer result = future.get();  // 블로킹
});
Thread t2 = new Thread(() -> {
    Integer result = future.get();  // 블로킹
});
Thread t3 = new Thread(() -> {
    Integer result = future.get();  // 블로킹
});

t1.start();
t2.start();
t3.start();
```

작업이 아직 완료되지 않았다면, 세 Thread 모두 블로킹되어야 한다. 작업이 완료되면 세 Thread 모두 동시에 깨어나 동일한 결과를 받아야 한다. 문제는 **"워커 Thread가 작업을 완료했을 때, 대기 중인 Thread가 누구인지 어떻게 아는가"**다. LockSupport.unpark(thread)를 호출하려면 대기자의 Thread 참조가 필요하다. 이를 추적하는 것이 waiters 리스트다.

#### waiters 리스트의 구조와 동작

waiters는 FutureTask의 인스턴스 필드로, 리스트의 head를 가리킨다.

```java
private volatile WaitNode waiters;  // 대기자 리스트의 head
```

작업 생성 직후에는 waiters가 null이다. 아무도 get()을 호출하지 않았기 때문이다. 첫 번째 Thread가 get()을 호출하여 블로킹되면, 이 Thread를 담은 WaitNode가 생성되고 waiters가 이 노드를 가리킨다. 두 번째 Thread가 블로킹되면, 새 WaitNode가 생성되어 리스트의 head에 추가되며, 기존 head는 새 노드의 next가 된다. 리스트는 스택(LIFO) 구조로 동작한다.

```
초기 상태:
waiters = null

Thread-1이 get() 호출하여 블로킹:
waiters → [WaitNode: thread=Thread-1, next=null]

Thread-2가 get() 호출하여 블로킹:
waiters → [WaitNode: thread=Thread-2, next=→]
            ↓
          [WaitNode: thread=Thread-1, next=null]

Thread-3이 get() 호출하여 블로킹:
waiters → [WaitNode: thread=Thread-3, next=→]
            ↓
          [WaitNode: thread=Thread-2, next=→]
            ↓
          [WaitNode: thread=Thread-1, next=null]
```

#### 리스트에 추가되는 과정: awaitDone()

Thread가 future.get()을 호출했는데 작업이 아직 완료되지 않았다면, get() 내부에서 awaitDone() 메서드가 호출된다.

```java
public V get() throws InterruptedException, ExecutionException {
    int s = state;
    if (s <= COMPLETING)
        s = awaitDone(false, 0L);  // 완료될 때까지 대기
    return report(s);
}
```

awaitDone()은 현재 Thread를 waiters 리스트에 추가하고 블로킹한다.

```java
private int awaitDone(boolean timed, long nanos) {
    WaitNode q = new WaitNode();  // (1) 현재 Thread를 담은 노드 생성
    boolean queued = false;
    for (;;) {
        if (Thread.interrupted()) {
            removeWaiter(q);
            throw new InterruptedException();
        }
        
        int s = state;
        if (s > COMPLETING) {
            if (q != null)
                q.thread = null;
            return s;
        }
        else if (s == COMPLETING)
            Thread.yield();
        else if (!queued)
            queued = WAITERS.weakCompareAndSet(this, q.next = waiters, q);  // (2) 리스트에 추가
        else
            LockSupport.park(this);  // (3) 블로킹
    }
}
```

**(1) WaitNode 생성**

`new WaitNode()`가 호출되면 생성자 내부에서 `thread = Thread.currentThread()`가 실행된다. 새 WaitNode 객체가 힙에 생성되며, thread 필드에는 현재 Thread(예: Thread-2)의 참조가 저장된다. next 필드는 아직 null이다.

**(2) 리스트에 추가 (CAS)**

`q.next = waiters`는 현재 리스트의 head를 새 노드의 next로 연결한다. 만약 waiters가 Thread-1을 담은 노드를 가리키고 있다면, q.next는 그 노드를 가리킨다. `WAITERS.weakCompareAndSet(this, q.next, q)`는 원자적 조건부 쓰기를 수행한다. "waiters의 현재 값이 q.next와 같으면 q로 변경하고 true 반환, 다르면 변경하지 않고 false 반환"을 CPU의 단일 명령어로 실행한다.

성공하면 queued가 true가 되고, waiters는 이제 q를 가리킨다. 새 노드가 head가 되고 기존 head는 두 번째 노드가 된다. 실패하면 다른 Thread가 먼저 노드를 추가했다는 의미다. 루프를 반복하여 최신 head를 다시 읽고(`q.next = waiters`) CAS를 재시도한다.

**(3) 블로킹**

리스트 추가에 성공하면 `LockSupport.park(this)`가 호출된다. 이 메서드는 현재 Thread를 OS 레벨에서 WAITING 상태로 전환한다. Thread는 CPU 스케줄링 큐에서 제거되어 CPU를 전혀 소비하지 않는다. 내부적으로 Linux에서는 futex 시스템 콜을 사용하여 커널에 "이 Thread를 재우고 누군가 unpark()를 호출할 때까지 깨우지 마"라고 요청한다.

park() 이후의 코드는 실행되지 않는다. Thread는 깨어날 때까지 이 지점에 멈춰 있다.

#### 대기자를 깨우는 과정: finishCompletion()

워커 Thread가 작업을 완료하면 set() 메서드를 호출한다. set()의 마지막 단계는 finishCompletion()이다.

```java
protected void set(V v) {
    if (STATE.compareAndSet(this, NEW, COMPLETING)) {
        outcome = v;
        STATE.setRelease(this, NORMAL);
        finishCompletion();  // 모든 대기자 깨우기
    }
}
```

finishCompletion()은 waiters 리스트를 순회하며 모든 Thread를 깨운다.

```java
private void finishCompletion() {
    for (WaitNode q; (q = waiters) != null;) {
        if (WAITERS.weakCompareAndSet(this, q, null)) {  // (1) 리스트 소유권 획득
            for (;;) {  // (2) 리스트 순회
                Thread t = q.thread;
                if (t != null) {
                    q.thread = null;
                    LockSupport.unpark(t);  // (3) Thread 깨우기
                }
                WaitNode next = q.next;
                if (next == null)
                    break;
                q.next = null;  // GC 돕기
                q = next;
            }
            break;
        }
    }
}
```

**(1) 리스트 소유권 획득**

`WAITERS.weakCompareAndSet(this, q, null)`은 "waiters의 현재 값이 q이면 null로 변경"을 원자적으로 수행한다. q는 for 루프 시작 시점의 waiters 값이다. CAS가 성공하면 waiters는 null이 되고, 이제 q가 가리키는 리스트 전체의 소유권을 이 Thread가 획득한 것이다. 다른 Thread가 동시에 노드를 추가하려 해도, waiters는 이미 null이므로 새 리스트가 시작된다. 기존 리스트는 이 Thread만 처리한다.

**(2) 리스트 순회**

내부 for 루프는 리스트를 head부터 끝까지 순회한다. q는 현재 노드를 가리킨다. `Thread t = q.thread`로 현재 노드에 저장된 Thread 참조를 읽는다. `q.thread = null`로 참조를 지워 GC가 Thread 객체를 수거할 수 있게 한다. `WaitNode next = q.next`로 다음 노드를 읽는다. next가 null이면 리스트의 끝이므로 루프를 빠져나온다. 아니면 `q.next = null`로 현재 노드의 next를 끊어 GC를 돕고, `q = next`로 다음 노드로 이동한다.

**(3) Thread 깨우기**

`LockSupport.unpark(t)`가 호출된다. 이 메서드는 t가 park() 상태라면 즉시 깨운다. 내부적으로 OS 커널에 시스템 콜을 보내 해당 Thread를 WAITING에서 RUNNABLE 상태로 전환한다. Thread는 CPU 스케줄링 큐에 다시 추가되며, OS 스케줄러가 CPU 코어를 할당하면 park() 다음 줄부터 실행을 재개한다.

깨어난 Thread는 awaitDone()의 무한 루프로 돌아간다. 루프 시작 부분에서 `int s = state`를 읽는다. 이제 state는 NORMAL이므로 `if (s > COMPLETING)`이 참이 되어 awaitDone()을 빠져나온다. get()으로 돌아가 `return report(s)`를 실행하여 outcome에 저장된 결과를 반환한다.

#### 구체적 실행 흐름 예시

세 개의 Thread가 동시에 get()을 호출하고 한 개의 워커 Thread가 작업을 완료하는 시나리오를 단계별로 추적해보자.

**시간 T1**: 작업이 실행 중이다. state는 NEW다.

**시간 T2**: Thread-1이 future.get()을 호출한다. state가 NEW이므로 awaitDone()에 진입한다. WaitNode q1을 생성한다. q1.thread = Thread-1, q1.next = null이다. `WAITERS.compareAndSet(this, null, q1)`을 호출한다. waiters가 null이므로 성공한다. waiters는 이제 q1을 가리킨다. Thread-1은 LockSupport.park()를 호출하여 블로킹된다.

**시간 T3**: Thread-2가 future.get()을 호출한다. state가 여전히 NEW이므로 awaitDone()에 진입한다. WaitNode q2를 생성한다. q2.thread = Thread-2다. `q2.next = waiters`를 실행하여 q2.next = q1로 설정한다. `WAITERS.compareAndSet(this, q1, q2)`를 호출한다. waiters가 q1이므로 성공한다. waiters는 이제 q2를 가리킨다. q2.next는 q1을 가리킨다. Thread-2는 park()로 블로킹된다.

**시간 T4**: Thread-3도 동일하게 동작한다. WaitNode q3를 생성하고 q3.next = q2로 연결한 후 CAS로 waiters를 q3로 변경한다. Thread-3도 park()로 블로킹된다. 이제 리스트는 q3 → q2 → q1 순서다.

**시간 T5**: 워커 Thread가 callable.call()을 완료하고 set(result)를 호출한다. outcome에 결과를 저장하고 state를 NORMAL로 변경한다. finishCompletion()을 호출한다.

**시간 T6**: finishCompletion() 내부에서 `q = waiters`를 실행하여 q는 q3를 가리킨다. `WAITERS.compareAndSet(this, q3, null)`을 호출하여 waiters를 null로 설정한다. 성공한다. 이제 q3 → q2 → q1 리스트의 소유권을 획득했다.

**시간 T7**: 내부 루프에서 q = q3이다. `Thread t = q3.thread`로 Thread-3 참조를 얻는다. `LockSupport.unpark(Thread-3)`를 호출한다. Thread-3가 깨어난다. `next = q3.next`로 q2를 얻는다. q = q2로 이동한다.

**시간 T8**: q = q2다. `Thread t = q2.thread`로 Thread-2 참조를 얻는다. `LockSupport.unpark(Thread-2)`를 호출한다. Thread-2가 깨어난다. q = q1로 이동한다.

**시간 T9**: q = q1이다. `Thread t = q1.thread`로 Thread-1 참조를 얻는다. `LockSupport.unpark(Thread-1)`를 호출한다. Thread-1이 깨어난다. `next = q1.next`는 null이므로 루프를 빠져나온다.

**시간 T10**: finishCompletion()이 반환된다. set()이 완료된다. 워커 Thread가 run() 메서드를 끝낸다.

**시간 T11**: 깨어난 Thread-1, Thread-2, Thread-3는 각자 awaitDone()의 루프로 돌아간다. state를 읽어 NORMAL을 확인하고 awaitDone()을 빠져나온다. get()에서 report(NORMAL)을 호출하여 outcome을 읽고 결과를 반환받는다. 세 Thread 모두 동일한 결과를 받는다.

#### 동시성 보장: CAS와 volatile의 역할

waiters 리스트에 대한 모든 변경은 CAS로 보호된다. 여러 Thread가 동시에 노드를 추가하려 해도, CAS는 한 번에 하나의 변경만 허용한다. Thread-2와 Thread-3가 동시에 awaitDone()을 실행하여 리스트에 추가하려 하면, 둘 다 `q.next = waiters`로 동일한 head를 읽을 수 있다. 하지만 CAS는 둘 중 하나만 성공시킨다. 실패한 Thread는 루프를 반복하여 최신 head를 다시 읽고 재시도한다. 최종적으로 모든 노드가 리스트에 정확히 추가되며, 아무도 소실되지 않는다.

waiters 필드가 volatile로 선언된 이유는 가시성 보장이다. 워커 Thread가 finishCompletion()에서 waiters를 null로 설정하면, 이 변경이 모든 CPU 코어의 캐시에 즉시 반영된다. 새로운 Thread가 get()을 호출하여 waiters를 읽을 때, 캐시가 아닌 메인 메모리에서 최신 값(null)을 읽는다.

WaitNode의 thread와 next 필드도 volatile이다. finishCompletion()이 q.thread를 읽을 때, 다른 코어에서 awaitDone()이 쓴 최신 값을 본다. q.next를 읽을 때도 마찬가지다. 이는 리스트 순회가 항상 정확한 노드 체인을 따라가도록 보장한다.

#### 설계적 의의: 확장 가능한 1:N 완료 통지

waiters 리스트는 **하나의 작업 완료를 N개의 대기 Thread에게 동시에 통지**하는 메커니즘이다. 이는 Future 인터페이스의 의미론을 정확히 구현한다. 여러 Thread가 동일한 Future에 대해 get()을 호출해도, 모두 동일한 결과를 받고 모두 동시에 진행할 수 있다.

만약 waiters 리스트 없이 단일 대기자만 저장한다면, 두 번째 get() 호출은 실패하거나 잘못된 동작을 초래한다. CountDownLatch 같은 외부 동기화 메커니즘으로 대체할 수 있지만, 이는 추가 객체를 요구하여 메모리 오버헤드와 복잡성을 증가시킨다.

리스트는 필요한 만큼만 노드를 생성한다. 대기자가 없으면 waiters는 null이며 메모리를 소비하지 않는다. 대기자가 10개면 10개의 WaitNode만 생성된다. 작업 완료 시 finishCompletion()이 모든 노드의 참조를 null로 설정하여 GC가 즉시 수거할 수 있게 한다. 이는 블로킹 대기 메커니즘으로서 최소한의 메모리 풋프린트를 유지한다.

---

### 상태 전이: 불변성 보장 메커니즘

FutureTask의 상태는 단방향으로만 전이된다. NEW에서 시작하여 반드시 최종 상태(NORMAL, EXCEPTIONAL, CANCELLED, INTERRUPTED) 중 하나로 종료되며, 절대 되돌아가지 않는다.

정상 완료 경로는 `NEW → COMPLETING → NORMAL`이다. 워커 Thread가 callable.call()을 실행하여 결과를 받으면, 먼저 CAS로 상태를 NEW에서 COMPLETING으로 전이하고, outcome에 결과를 저장한 다음, 최종적으로 NORMAL로 전이한다.

예외 완료 경로는 `NEW → COMPLETING → EXCEPTIONAL`이다. callable.call()에서 예외가 발생하면, 
Throwable 객체를 직접 outcome에 저장하고 상태를 EXCEPTIONAL로 전이한다.

취소 경로는 `NEW → CANCELLED` 또는 `NEW → INTERRUPTING → INTERRUPTED`다. cancel(false)를 호출하면 직접 CANCELLED로 전이하고, cancel(true)를 호출하면 INTERRUPTING을 거쳐 INTERRUPTED로 전이한다.

이 단방향 전이는 **작업의 결과가 한 번 결정되면 절대 변경되지 않는 불변성**을 보장한다. 모든 상태 전이는 CAS 연산으로 이루어져, 오직 한 Thread만 전이에 성공한다. 여러 Thread가 동시에 결과를 설정하려 해도, 첫 번째 Thread만 성공하고 나머지는 실패한다.

---

### 왜 FutureTask는 Thread-Safe여야 하는가

#### 공유 객체의 동시 접근 구조

submit() 메서드가 반환하는 Future 객체는 작업 큐에 삽입된 Runnable 객체와 동일하다. 이 설계가 의미하는 것은, 힙 메모리에 존재하는 단일 FutureTask 인스턴스를 서로 다른 역할의 Thread들이 동시에 접근한다는 것이다.

워커 Thread는 작업 큐에서 이 FutureTask를 꺼내어 run() 메서드를 호출한다. run() 내부에서 callable.call()을 실행하고, 결과를 outcome 필드에 쓰며, state를 NEW에서 NORMAL로 변경한다.

동시에 호출자 Thread는 submit()이 반환한 동일한 FutureTask 참조로 get() 메서드를 호출한다. get() 내부에서 state 필드를 읽어 완료 여부를 확인하고, 완료되지 않았다면 waiters 리스트에 자신을 추가한 후 LockSupport.park()로 블로킹된다. 완료되었다면 outcome 필드를 읽어 결과를 반환한다.

또 다른 Thread가 cancel() 메서드를 호출하면, 이 Thread는 state를 읽어 취소 가능 여부를 확인하고, 취소 가능하면 state를 CANCELLED로 변경하며, runner 필드에 저장된 워커 Thread 참조로 interrupt()를 호출한다.

이 모든 접근은 서로 다른 CPU 코어에서 동시에 발생할 수 있다. 세 개의 Thread가 동일한 FutureTask 객체의 state, outcome, runner, waiters 필드를 동시에 읽고 쓴다.

#### 작업 실행은 단일, 결과 조회는 다중

run() 메서드 자체는 오직 하나의 워커 Thread만 실행한다. run() 메서드 시작 부분의 CAS 연산이 이를 보장한다.

```java
if (state != NEW ||
    !RUNNER.compareAndSet(this, null, Thread.currentThread()))
    return;
```

첫 번째 워커가 RUNNER.compareAndSet을 성공하면 runner 필드에 자신의 Thread 참조가 저장되고, 이후 다른 워커가 같은 FutureTask의 run()을 호출해도 CAS는 실패하여 즉시 반환된다.

하지만 get() 메서드는 여러 Thread가 동시에 호출할 수 있다. 10개의 Thread가 동시에 `future.get()`을 호출하는 것은 정상적인 시나리오다. 각 Thread는 작업 완료를 대기하며, 완료 시점에 모두 동일한 결과를 받아야 한다.

따라서 FutureTask의 동시성 문제는 "여러 워커가 하나의 작업을 중복 실행"하는 것이 아니다. 문제는 **하나의 워커가 필드를 쓰는 동안, 여러 호출자가 동시에 같은 필드를 읽거나 쓰는 것**이다.

#### 동시 접근 시나리오 1: 워커의 쓰기와 호출자의 읽기

워커 Thread(pool-1-thread-1)가 CPU Core 0에서 작업을 실행 중이다. callable.call()이 방금 반환되어 결과값 42를 받았으며, 이제 set(result)를 호출한다.

```java
// 워커 Thread (Core 0)
protected void set(V v) {
    if (STATE.compareAndSet(this, NEW, COMPLETING)) {
        outcome = v;                        // (1) outcome에 결과 쓰기
        STATE.setRelease(this, NORMAL);     // (2) state를 NORMAL로 변경
        finishCompletion();                 // (3) 대기 Thread 깨우기
    }
}
```

동시에 호출자 Thread(main)가 CPU Core 1에서 future.get()을 실행 중이다.

```java
// 호출자 Thread (Core 1)
public V get() throws InterruptedException, ExecutionException {
    int s = state;                          // (A) state 읽기
    if (s <= COMPLETING)                    // (B) 완료 확인
        s = awaitDone(false, 0L);           // (C) 대기
    return report(s);                       // (D) 결과 반환
}
```

만약 state 필드가 일반 필드(non-volatile)라면 다음이 발생한다.

**시간 T1**: 워커가 (1)을 실행하여 `outcome = 42`를 쓴다. 이 쓰기는 Core 0의 L1 캐시에만 반영된다. 메인 메모리로 flush되지 않는다.

**시간 T2**: 워커가 (2)를 실행하여 `state = NORMAL`을 쓴다. 이것도 Core 0의 L1 캐시에만 반영된다.

**시간 T3**: main Thread가 (A)를 실행하여 state를 읽는다. Core 1의 L1 캐시에는 state의 이전 값인 NEW가 캐싱되어 있으므로, main은 NEW를 읽는다.

**시간 T4**: main이 (B)에서 `s <= COMPLETING` 조건을 확인한다. s는 NEW이므로 조건이 참이다. main은 "작업이 아직 완료되지 않았다"고 판단한다.

**시간 T5**: main이 (C)를 실행하여 awaitDone()을 호출한다. 내부에서 WaitNode를 생성하고 waiters 리스트에 추가한 후 LockSupport.park()로 블로킹된다.

**시간 T6**: 워커가 (3)을 실행하여 finishCompletion()을 호출한다. 하지만 이 시점에 waiters 리스트를 보면 비어 있거나 main이 아직 완전히 추가되지 않았다. 워커는 깨울 Thread가 없다고 판단하고 반환된다.

이제 워커는 작업을 완료하고 종료되었다. main은 waiters 리스트에 있지만 아무도 깨우지 않는다. **main Thread는 영원히 park 상태로 남는다.**

state를 volatile로 선언하면 이 문제가 해결된다.

```java
private volatile int state;
```

volatile 쓰기는 메모리 장벽(memory barrier)을 삽입한다. 워커가 `state = NORMAL`을 쓰면, CPU는 이 쓰기 이전의 모든 쓰기(outcome 포함)를 메인 메모리로 flush한다. volatile 읽기도 메모리 장벽을 삽입한다. main이 state를 읽으면, CPU는 L1 캐시를 무효화하고 메인 메모리에서 최신 값을 가져온다. 따라서 main은 항상 워커가 설정한 최신 state 값을 본다.

#### 동시 접근 시나리오 2: 여러 호출자의 waiters 리스트 경쟁

작업이 아직 실행 중일 때 10개의 Thread가 동시에 `future.get()`을 호출한다. 각 Thread는 awaitDone() 내부에서 자신을 담은 WaitNode를 생성하고 이를 waiters 리스트에 추가해야 한다.

waiters는 단일 연결 리스트다. 새 노드를 추가하려면 현재 head를 읽어 새 노드의 next에 연결하고, head를 새 노드로 교체해야 한다. 이것은 read-modify-write 연산이다.

```java
// FutureTask.awaitDone() 내부
WaitNode q = new WaitNode();
q.next = waiters;         // (1) 현재 head 읽기 및 연결
waiters = q;              // (2) head를 새 노드로 교체
```

만약 이 코드가 일반 필드 접근이라면 다음이 발생한다.

**시간 T1**: Thread-1이 (1)을 실행한다. waiters를 읽어 null을 얻는다. q1.next = null로 설정한다.

**시간 T2**: Thread-2도 (1)을 실행한다. waiters를 읽어 여전히 null을 얻는다. q2.next = null로 설정한다.

**시간 T3**: Thread-1이 (2)를 실행한다. `waiters = q1`로 head를 q1으로 설정한다.

**시간 T4**: Thread-2가 (2)를 실행한다. `waiters = q2`로 head를 q2로 덮어쓴다.

이제 waiters는 q2를 가리키고, q2.next는 null이다. **q1이 리스트에서 사라졌다.** q1을 생성한 Thread-1은 리스트에 없으므로, 워커가 finishCompletion()에서 unpark()를 호출해도 Thread-1은 깨어나지 않는다.

FutureTask는 이 문제를 CAS로 해결한다.

```java
WaitNode q = new WaitNode();
if (!WAITERS.weakCompareAndSet(this, q.next = waiters, q)) {
    // 실패 시 재시도
}
```

이 CAS는 "waiters의 현재 값이 q.next와 같을 때만 q로 변경"을 원자적으로 수행한다. CPU의 CMPXCHG 같은 단일 명령어로 구현되어, 읽기-비교-쓰기가 중간에 끊어지지 않는다.

**시간 T1**: Thread-1이 waiters를 읽어 null을 얻고 q1.next = null로 설정한다. CAS를 호출한다. `compareAndSet(waiters, null, q1)`은 "waiters가 null이면 q1로 변경"을 의미한다. waiters는 null이므로 성공한다. waiters는 q1이 된다.

**시간 T2**: Thread-2가 waiters를 읽어 q1을 얻고 q2.next = q1로 설정한다. CAS를 호출한다. `compareAndSet(waiters, q1, q2)`는 "waiters가 q1이면 q2로 변경"을 의미한다. waiters는 q1이므로 성공한다. waiters는 q2가 되고, q2.next는 q1을 가리킨다.

**시간 T3**: Thread-3가 waiters를 읽어 q2를 얻고 q3.next = q2로 설정한다. CAS를 호출한다. 하지만 다른 Thread가 이미 waiters를 변경했다면 CAS는 실패한다. Thread-3는 재시도하여 최신 head를 다시 읽고 CAS를 반복한다.

모든 노드가 리스트에 정확히 추가된다. 아무도 소실되지 않는다.

#### 동시 접근 시나리오 3: 완료와 취소의 경쟁

워커 Thread가 작업을 완료하여 set(result)를 호출하는 동안, 다른 Thread가 cancel(true)를 호출한다. 둘 다 state를 변경하려 한다.

```java
// 워커 Thread
protected void set(V v) {
    if (STATE.compareAndSet(this, NEW, COMPLETING)) {
        outcome = v;
        STATE.setRelease(this, NORMAL);
        finishCompletion();
    }
}

// 취소 Thread
public boolean cancel(boolean mayInterruptIfRunning) {
    if (!(state == NEW && STATE.compareAndSet(this, NEW, 
            mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))
        return false;
    // ...
}
```

두 Thread가 동시에 `STATE.compareAndSet(this, NEW, ...)`를 호출한다. CAS는 원자적 조건부 쓰기를 수행한다. "state의 현재 값이 NEW이면 새 값으로 변경하고 true 반환, 아니면 변경하지 않고 false 반환"을 단일 CPU 명령어로 실행한다.

**경우 1: 워커가 먼저 성공**

워커의 CAS가 먼저 실행되어 state를 NEW에서 COMPLETING으로 변경한다. 이 시점에서 state는 더 이상 NEW가 아니다. 취소 Thread의 CAS가 실행되지만, state가 NEW가 아니므로 조건이 실패한다. CAS는 false를 반환하고 state를 변경하지 않는다. cancel() 메서드는 false를 반환한다. 워커는 계속 진행하여 outcome에 결과를 저장하고 state를 NORMAL로 변경한다. 작업은 정상 완료된다.

**경우 2: 취소가 먼저 성공**

취소 Thread의 CAS가 먼저 실행되어 state를 NEW에서 CANCELLED로 변경한다. 워커의 CAS가 실행되지만, state가 이미 CANCELLED이므로 조건이 실패한다. CAS는 false를 반환한다. set() 메서드의 if 블록이 실행되지 않으므로 outcome에 아무것도 저장되지 않는다. 작업은 취소된다.

**CAS가 보장하는 것은 둘 중 정확히 하나만 성공한다는 것이다.** 작업은 완료되거나 취소되거나 둘 중 하나다. 양쪽 모두 성공하여 결과가 저장되었지만 state는 CANCELLED인 불일치 상태는 절대 발생하지 않는다.

만약 CAS 없이 일반 쓰기를 사용했다면, 워커가 outcome을 쓴 후 state를 COMPLETING으로 쓰는 사이에 취소 Thread가 state를 CANCELLED로 덮어쓸 수 있다. outcome에는 결과가 있지만 state는 CANCELLED인 모순된 상태가 된다.

#### 메모리 순서 보장: setRelease와 acquire

volatile만으로는 부족한 경우가 있다. outcome을 쓰고 state를 쓰는 순서가 보장되지 않으면, 호출자가 state는 NORMAL로 보지만 outcome은 아직 업데이트되지 않은 값을 읽을 수 있다.

FutureTask는 VarHandle의 setRelease와 acquire 의미론을 사용한다.

```java
// 워커 Thread
outcome = result;                    // 일반 쓰기
STATE.setRelease(this, NORMAL);      // release 쓰기

// 호출자 Thread
int s = state;                       // acquire 읽기 (volatile)
if (s == NORMAL)
    return outcome;                  // 일반 읽기
```

**setRelease의 의미는 "이 쓰기 이전의 모든 쓰기가 메모리에 반영된 후에 이 쓰기를 수행"이다.** 워커가 `STATE.setRelease(this, NORMAL)`을 실행하면, CPU는 이 명령 이전에 `outcome = result`가 메모리에 완전히 기록되도록 보장한다. 컴파일러나 CPU가 최적화를 위해 명령어 순서를 재배치하더라도, setRelease는 이 순서를 강제한다.

**acquire 읽기(volatile 읽기)의 의미는 "이 읽기가 완료된 후에 이후의 모든 읽기를 수행"이다.** 호출자가 `int s = state`를 실행하면, 이 읽기가 메모리에서 완료된 후에야 `return outcome`이 실행된다. 따라서 호출자가 state == NORMAL을 확인하면, outcome 읽기는 반드시 워커가 저장한 최신 값을 본다.

이 메커니즘이 없으면 다음이 발생할 수 있다.

**시간 T1**: 워커가 outcome에 결과를 쓴다.

**시간 T2**: CPU가 명령어를 재배치하여 state를 먼저 NORMAL로 쓴다.

**시간 T3**: 호출자가 state를 읽어 NORMAL을 본다.

**시간 T4**: 호출자가 outcome을 읽지만, T1의 쓰기가 아직 캐시에 반영되지 않아 오래된 값을 읽는다.

setRelease는 T2가 T1 이전에 실행되지 않도록 막는다. acquire는 T4가 T3 이전에 실행되지 않도록 막는다. 워커의 쓰기 순서와 호출자의 읽기 순서가 논리적으로 일관되게 유지된다.

---

FutureTask가 volatile, CAS, VarHandle을 조합하여 구현하는 동시성 제어는 단순히 "Thread-Safe 하게 만들기 위한" 것이 아니다. 이것은 **제출한 객체와 반환받은 객체가 동일하다는 설계 결정이 필연적으로 요구하는 구조적 복잡성**이다. 단일 객체를 여러 역할의 Thread가 동시에 접근하는 이상, 이러한 정교한 동기화 메커니즘 없이는 데이터 불일치, deadlock, lost update가 불가피하다.

개발자는 `future.get()`을 호출할 때 이 모든 복잡성을 의식하지 않는다. FutureTask는 멀티코어 환경의 모든 동시성 위험을 내부에 캡슐화하여, 개발자가 단순한 동기 메서드를 호출하는 것처럼 비동기 결과를 안전하게 조회할 수 있게 한다. 이것이 Java 동시성 라이브러리의 설계 철학이며, FutureTask는 그 구현이다.

---

### 작업 실행: run()의 동작

워커 Thread는 작업 큐에서 Runnable을 꺼낸다. 이때 꺼낸 객체가 FutureTask다. 워커 Thread는 이것의 run() 메서드를 호출한다.

```java
public void run() {
    if (state != NEW ||
        !RUNNER.compareAndSet(this, null, Thread.currentThread()))
        return;
    try {
        Callable<V> c = callable;
        if (c != null && state == NEW) {
            V result;
            boolean ran;
            try {
                result = c.call();
                ran = true;
            } catch (Throwable ex) {
                result = null;
                ran = false;
                setException(ex);
            }
            if (ran)
                set(result);
        }
    } finally {
        runner = null;
        int s = state;
        if (s >= INTERRUPTING)
            handlePossibleCancellationInterrupt(s);
    }
}
```

run() 메서드는 먼저 이중 검증을 수행한다. 첫 번째 검증은 `state != NEW`로, 상태가 NEW가 아니면 이미 다른 Thread가 실행했거나 취소되었으므로 즉시 반환한다.

두 번째 검증은 CAS 연산 `RUNNER.compareAndSet(this, null, Thread.currentThread())`다. RUNNER는 VarHandle로, runner 필드에 대한 원자적 연산을 제공한다. 이 CAS는 runner가 null일 때만 현재 Thread로 설정하고 true를 반환한다. 다른 Thread가 이미 runner를 설정했다면 false를 반환하며, 이 경우에도 메서드는 즉시 종료된다.

이 이중 검증은 **실행 권한의 원자적 획득**을 구현한다. 동일한 FutureTask가 우연히 작업 큐에 두 번 삽입되더라도, 오직 첫 번째 워커 Thread만 실행을 진행하고 나머지는 모두 배제된다.

실행 권한을 획득하면 `result = c.call()`을 호출한다. 이것이 개발자가 작성한 람다의 실제 실행 지점이다. 람다 내부의 모든 코드가 이 워커 Thread에서 동기적으로 실행된다. call()이 블로킹되면 워커 Thread도 블로킹된다.

call()이 정상 반환하면 result에 값을 담고 ran을 true로 설정한 후 `set(result)`를 호출한다. 예외가 발생하면 ran을 false로 두고 `setException(ex)`를 호출한다.

finally 블록에서 runner를 null로 초기화한다. 이는 실행이 종료되었음을 표시하며, GC가 Thread 객체를 수거할 수 있게 한다.

### 결과 저장: set()의 원자성

set() 메서드는 정상 완료 시 결과를 저장하는 핵심 메커니즘이다.

```java
protected void set(V v) {
    if (STATE.compareAndSet(this, NEW, COMPLETING)) {
        outcome = v;
        STATE.setRelease(this, NORMAL);
        finishCompletion();
    }
}
```

첫 번째 CAS 연산 `STATE.compareAndSet(this, NEW, COMPLETING)`은 상태를 원자적으로 NEW에서 COMPLETING으로 전이한다. 이 CAS는 "완료 처리의 소유권"을 획득하는 행위다. 만약 다른 Thread(예: cancel()을 호출한 Thread)가 이미 상태를 변경했다면 CAS는 실패하고 메서드는 아무것도 하지 않는다.

CAS가 성공하면 `outcome = v`로 결과를 저장한다. 이 시점에서 state는 COMPLETING이다. COMPLETING 상태의 존재 이유는 **메모리 가시성 보장**이다. outcome에 값을 쓰는 동안 다른 Thread가 state를 보고 NORMAL이라 판단하여 outcome을 읽으면, 아직 완전히 설정되지 않은 값을 읽을 수 있다. COMPLETING은 "결과는 설정 중이지만 아직 읽으면 안 됨"을 의미하는 메모리 장벽이다.

outcome 저장이 완료되면 `STATE.setRelease(this, NORMAL)`로 상태를 NORMAL로 최종 전이한다. 
이 release 쓰기는 outcome 저장이 state 변경 이전에 완료됨을 보장한다.

마지막으로 `finishCompletion()`을 호출하여 대기 중인 모든 Thread를 깨운다.

```java
private void finishCompletion() {
    for (WaitNode q; (q = waiters) != null;) {
        if (WAITERS.weakCompareAndSet(this, q, null)) {
            for (;;) {
                Thread t = q.thread;
                if (t != null) {
                    q.thread = null;
                    LockSupport.unpark(t);
                }
                WaitNode next = q.next;
                if (next == null)
                    break;
                q.next = null;
                q = next;
            }
            break;
        }
    }
    done();
    callable = null;
}
```

finishCompletion()은 waiters 리스트를 순회하며 각 WaitNode의 Thread에 대해 `LockSupport.unpark(t)`를 호출한다. 이것은 블로킹된 Thread를 OS 레벨에서 WAITING 상태에서 RUNNABLE 상태로 전환하는 시스템 콜이다. 깨어난 Thread들은 OS 스케줄러에 의해 다시 실행 가능 큐에 추가된다.

마지막으로 callable을 null로 설정하여, 람다가 참조하는 객체들이 GC에 의해 수거될 수 있게 한다.

### 결과 조회: get()의 블로킹 메커니즘

개발자가 future.get()을 호출하면 먼저 현재 상태를 확인한다.

```java
public V get() throws InterruptedException, ExecutionException {
    int s = state;
    if (s <= COMPLETING)
        s = awaitDone(false, 0L);
    return report(s);
}
```

상태가 COMPLETING 이하(NEW 또는 COMPLETING)면 작업이 아직 완료되지 않았으므로 `awaitDone()`으로 블로킹 대기에 진입한다. COMPLETING보다 크면(NORMAL, EXCEPTIONAL 등) 이미 완료되었으므로 즉시 `report()`로 결과를 반환한다.

awaitDone()은 무한 루프를 실행하며 완료를 대기한다.

```java
private int awaitDone(boolean timed, long nanos)
        throws InterruptedException {
    long startTime = 0L;
    WaitNode q = null;
    boolean queued = false;
    for (;;) {
        int s = state;
        if (s > COMPLETING) {
            if (q != null)
                q.thread = null;
            return s;
        }
        else if (s == COMPLETING)
            Thread.yield();
        else if (Thread.interrupted()) {
            removeWaiter(q);
            throw new InterruptedException();
        }
        else if (q == null) {
            if (timed && nanos <= 0L)
                return s;
            q = new WaitNode();
        }
        else if (!queued)
            queued = WAITERS.weakCompareAndSet(this, q.next = waiters, q);
        else if (timed) {
            // 타임아웃 처리
        }
        else
            LockSupport.park(this);
    }
}
```

루프의 첫 번째 분기는 `s > COMPLETING`으로 완료 확인이다. 작업이 완료되었으면 즉시 상태를 반환한다.

두 번째 분기는 `s == COMPLETING` 처리로, 과도 상태에서는 `Thread.yield()`로 CPU를 양보하고 다음 루프에서 재확인한다. 워커 Thread가 set()을 실행 중이므로 곧 NORMAL로 전이될 것이다.

세 번째 분기는 `Thread.interrupted()` 처리로, 현재 Thread가 인터럽트되었으면 waiters 리스트에서 자신을 제거하고 InterruptedException을 던진다.

네 번째 분기는 `q == null` 처리로, WaitNode를 생성한다. WaitNode 생성자에서 자동으로 thread 필드가 현재 Thread로 설정된다.

다섯 번째 분기는 `!queued` 처리로, WaitNode를 waiters 리스트에 추가한다. `WAITERS.weakCompareAndSet(this, q.next = waiters, q)`는 CAS 연산으로 waiters 필드의 현재 값을 q.next에 설정하고, waiters를 q로 원자적으로 교체한다. 이는 연결 리스트의 헤드에 노드를 추가하는 전형적인 lock-free 알고리즘이다.

마지막 분기는 `LockSupport.park(this)` 호출로 실제 블로킹이다. 이것은 현재 Thread를 OS 레벨에서 WAITING 상태로 전환하는 시스템 콜이다. Thread는 이 시점에서 CPU를 완전히 반납하고, OS 스케줄러는 이 Thread를 실행 가능 큐에서 제거한다. Thread는 누군가 `LockSupport.unpark()`를 호출하거나 인터럽트가 발생하기 전까지 깨어나지 않는다.

워커 Thread가 finishCompletion()에서 unpark()를 호출하면, 블로킹된 Thread는 RUNNABLE 상태로 전환되고 다시 루프를 실행한다. 이번에는 state가 NORMAL이므로 첫 번째 분기에서 루프를 탈출하여 상태를 반환한다.

awaitDone()이 반환한 상태로 `report()` 메서드를 호출한다.

```java
private V report(int s) throws ExecutionException {
    Object x = outcome;
    if (s == NORMAL)
        return (V)x;
    if (s >= CANCELLED)
        throw new CancellationException();
    throw new ExecutionException((Throwable)x);
}
```

상태가 NORMAL이면 outcome을 V 타입으로 캐스팅하여 반환한다. CANCELLED 이상이면 CancellationException을 던지고, EXCEPTIONAL이면 outcome에 저장된 예외를 ExecutionException으로 래핑하여 던진다.

---

## 결론: Future의 설계적 의의와 구조적 한계

Future는 ExecutorService와 결합하여 비동기 작업의 결과 참조를 Java 표준으로 정의했다. Future 인터페이스는 작업 실행과 무관하게 결과 조회만을 명세하며, FutureTask 구현체는 Callable을 Runnable로 변환하면서 결과 저장까지 단일 객체로 통합한다. ExecutorService.submit()은 Callable을 FutureTask로 래핑하여 작업 큐에 넣고, 동일한 객체를 반환함으로써 제출자와 실행자가 같은 객체를 공유한다.

FutureTask는 volatile 필드와 CAS 연산으로 멀티 Thread 안전성을 보장하며, 단방향 상태 전이로 결과의 불변성을 보장한다. LockSupport의 park/unpark를 사용한 이벤트 기반 블로킹은 CPU를 낭비하지 않으면서도 완료 즉시 반응하는 효율적 대기를 구현한다.

하지만 Future는 결과 조회가 필연적으로 블로킹하며, 작업 조합을 선언적으로 표현할 방법이 없고, 완료 시점 콜백을 등록할 메커니즘도 존재하지 않는다. Future는 비동기 작업 결과 참조를 표준화했지만, 비동기 작업 흐름의 조합과 제어는 여전히 개발자의 책임으로 남겨두었다.

---

## 부록: 인터페이스 및 구현체 관계도

### 전체 구조 다이어그램

```
┌─────────────────────────────────────────────────────────────────┐
│                         인터페이스 계층                           │
└─────────────────────────────────────────────────────────────────┘

    ┌──────────────┐              ┌──────────────┐
    │  Runnable    │              │  Callable<V> │
    │              │              │              │
    │ + run()      │              │ + call(): V  │
    └──────┬───────┘              └──────────────┘
           │                              │
           │                              │ (작업 표현)
           │ (실행 가능)                   │
           │                              │
    ┌──────▼──────────────────────────────▼─────────┐
    │            Future<V>                           │
    │                                                │
    │  + get(): V                                    │
    │  + get(timeout): V                             │
    │  + cancel(mayInterrupt): boolean               │
    │  + isCancelled(): boolean                      │
    │  + isDone(): boolean                           │
    └────────────────────┬───────────────────────────┘
                         │
                         │ (결과 참조)
                         │
           ┌─────────────▼─────────────┐
           │   RunnableFuture<V>       │
           │   (extends Runnable,      │
           │    extends Future<V>)     │
           │                           │
           │   + run()                 │
           └─────────────┬─────────────┘
                         │
                         │ (통합 인터페이스)
                         │
┌────────────────────────▼────────────────────────────┐
│                  구현 계층                           │
└─────────────────────────────────────────────────────┘
                         │
           ┌─────────────▼─────────────┐
           │     FutureTask<V>         │
           │   (implements             │
           │    RunnableFuture<V>)     │
           │                           │
           │  - state: int             │
           │  - callable: Callable<V>  │
           │  - outcome: Object        │
           │  - runner: Thread         │
           │  - waiters: WaitNode      │
           │                           │
           │  + run()                  │
           │  + get(): V               │
           │  + cancel(): boolean      │
           └───────────────────────────┘
```

### 인터페이스 관계 명세

#### 1. Runnable 인터페이스

```
역할: 실행 가능한 작업의 최소 계약
특징: 반환값 없음, 체크 예외 불가
제약: void run() - 결과를 전달할 방법이 없음
```

Runnable은 Java 1.0부터 존재한 Thread 작업의 표준이다. ExecutorService의 작업 큐 타입이 `BlockingQueue<Runnable>`이므로, 큐에 삽입되려면 반드시 이 인터페이스를 구현해야 한다.

#### 2. Callable<V> 인터페이스

```
역할: 값을 반환하는 작업의 표현
특징: 제네릭 반환값, 체크 예외 허용
제약: Runnable이 아니므로 작업 큐에 직접 삽입 불가
```

Callable은 Java 5에서 Runnable의 한계를 극복하기 위해 도입되었다. `V call() throws Exception` 시그니처로 결과 반환과 예외 전파가 모두 가능하다. 하지만 Runnable이 아니므로 ExecutorService의 작업 큐에 직접 넣을 수 없다.

#### 3. Future<V> 인터페이스

```
역할: 비동기 작업의 결과 참조
특징: 완료 대기, 결과 조회, 취소 제어
제약: 작업 실행과는 무관, 오직 결과 참조만 담당
```

Future는 "어떻게 실행할 것인가"와 완전히 분리되어 "어떻게 결과를 조회할 것인가"만을 정의한다. 이 인터페이스는 Runnable이나 Callable과 무관하며, 순수하게 결과 핸들의 계약만을 명세한다.

#### 4. RunnableFuture<V> 인터페이스

```
역할: Runnable과 Future의 통합
특징: 실행 가능하면서 동시에 결과 참조 가능
의의: FutureTask가 구현할 통합 계약
```

RunnableFuture는 Runnable과 Future를 모두 상속한다. 이것은 "실행할 수 있고(Runnable) 동시에 결과를 조회할 수 있는(Future)" 객체의 계약이다. 이 인터페이스 자체는 새로운 메서드를 추가하지 않으며, 단지 두 인터페이스를 결합한다.

```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    void run();  // Runnable에서 상속
}
```

### FutureTask 구현체의 역할

FutureTask는 RunnableFuture를 구현하여 다음을 통합한다:

```
1. Callable 저장소      → callable 필드에 작업 보관
2. Runnable 구현       → run() 메서드에서 callable.call() 실행
3. 결과 저장소         → outcome 필드에 반환값 보관
4. Future 구현         → get() 메서드로 outcome 조회
5. 상태 관리           → state 필드로 생명주기 추적
6. Thread 대기 관리    → waiters 리스트로 블로킹 Thread 추적
```

### ExecutorService와의 상호작용 흐름

```
┌──────────────┐
│  개발자      │
└──────┬───────┘
       │
       │ 1. submit(Callable)
       ▼
┌──────────────────────────────────────┐
│     ExecutorService                  │
│                                      │
│  submit(Callable task) {             │
│    FutureTask ftask = new            │
│      FutureTask(task);      ─────┐   │
│    execute(ftask);                │   │
│    return ftask;            ◀─────┘   │
│  }                                    │
└──────┬──────────────────────┬────────┘
       │                      │
       │ 2. offer(ftask)     │ 3. return ftask
       ▼                      ▼
┌──────────────────┐   ┌──────────────┐
│  BlockingQueue   │   │   개발자     │
│  <Runnable>      │   │  (Future 보유)│
│                  │   └──────────────┘
│  [FutureTask]    │
│  [FutureTask]    │
│  [...]           │
└──────┬───────────┘
       │
       │ 4. take()
       ▼
┌──────────────────┐
│  워커 Thread     │
│                  │
│  ftask.run() {   │
│    result =      │
│      callable    │
│        .call();  │
│    outcome =     │
│      result;     │
│    state =       │
│      NORMAL;     │
│    unpark(       │
│      waiters);   │
│  }               │
└──────────────────┘
```

### 객체 생명주기와 상태 전이

```
시간 축:  T0          T1            T2             T3           T4
        생성        제출          실행           완료         조회
         │          │             │              │            │
         ▼          ▼             ▼              ▼            ▼
    
FutureTask  →  workQueue   →   워커가    →    결과      →   get()
생성            삽입            실행         저장           반환
                                           완료 통지
                                           
state:    NEW     NEW         NEW      COMPLETING     NORMAL
                                       → NORMAL
                                       
callable: [λ]     [λ]         [λ]         [λ]          null
outcome:  null    null        null      [결과]        [결과]
runner:   null    null      [Thread]    [Thread]      null
waiters:  null    null        null        null         null
                              ↓
                            [대기중인
                             Thread들]
```

### 메서드 호출 체인

#### 제출 단계

```
개발자.submit(λ)
  └→ ExecutorService.submit(Callable)
       └→ newTaskFor(Callable)
            └→ new FutureTask(Callable)
                 └→ this.callable = Callable
                 └→ this.state = NEW
       └→ execute(FutureTask)
            └→ workQueue.offer(FutureTask)
       └→ return FutureTask
```

#### 실행 단계

```
워커Thread.run()
  └→ workQueue.take()
       └→ FutureTask
            └→ FutureTask.run()
                 └→ RUNNER.compareAndSet(null, currentThread)
                 └→ result = callable.call()
                 └→ set(result)
                      └→ STATE.compareAndSet(NEW, COMPLETING)
                      └→ outcome = result
                      └→ STATE.setRelease(NORMAL)
                      └→ finishCompletion()
                           └→ unpark(waiters)
```

#### 조회 단계

```
개발자.get()
  └→ FutureTask.get()
       └→ if (state <= COMPLETING)
            └→ awaitDone()
                 └→ new WaitNode()
                 └→ WAITERS.compareAndSet(waiters, newNode)
                 └→ LockSupport.park()  ← 블로킹
                 └→ (unpark 되면 깨어남)
                 └→ return state
       └→ report(state)
            └→ return outcome
```

### 핵심 설계 패턴

#### 1. 어댑터 패턴

```
Callable (호환 불가) ─┐
                    └→ FutureTask (어댑터) → Runnable (호환)
Future (결과 참조)   ─┘
```

FutureTask는 Callable을 Runnable로 변환하는 어댑터이면서, 동시에 Future 역할도 수행한다.

#### 2. 프록시 패턴

```
개발자 ─→ Future 인터페이스 ─→ FutureTask (실제 객체)
                                    │
                                    └→ outcome (실제 결과)
```

개발자는 Future 인터페이스를 통해 작업과 상호작용하며, FutureTask는 실제 결과와 상태를 캡슐화한다.

#### 3. 관찰자 패턴 (변형)

```
FutureTask (주체)
    │
    └→ waiters (관찰자 리스트)
         ├→ Thread 1
         ├→ Thread 2
         └→ Thread 3
         
완료 시: 모든 관찰자(대기 Thread)에게 통지 (unpark)
```

FutureTask가 완료되면 waiters 리스트의 모든 Thread에게 완료를 통지한다.

### 타입 계층 정리

```
┌─────────────────────────────────────────┐
│          <<interface>>                  │
│           Runnable                      │
│                                         │
│  + run(): void                          │
└───────────────────┬─────────────────────┘
                    │
                    │ extends
                    │
┌───────────────────▼─────────────────────┐
│          <<interface>>                  │
│         RunnableFuture<V>               │
│    extends Runnable, Future<V>          │
│                                         │
│  + run(): void      (from Runnable)     │
│  + get(): V         (from Future)       │
│  + cancel(): boolean (from Future)      │
│  + isDone(): boolean (from Future)      │
│  + isCancelled(): boolean (from Future) │
└───────────────────┬─────────────────────┘
                    │
                    │ implements
                    │
┌───────────────────▼─────────────────────┐
│          <<class>>                      │
│         FutureTask<V>                   │
│                                         │
│  - state: int                           │
│  - callable: Callable<V>                │
│  - outcome: Object                      │
│  - runner: Thread                       │
│  - waiters: WaitNode                    │
│                                         │
│  + run(): void                          │
│  + get(): V                             │
│  + cancel(boolean): boolean             │
│  + isDone(): boolean                    │
│  + isCancelled(): boolean               │
│  # set(V): void                         │
│  # setException(Throwable): void        │
│  - awaitDone(boolean, long): int        │
│  - finishCompletion(): void             │
└─────────────────────────────────────────┘
```

### 동시성 제어 메커니즘

#### CAS 연산 지점

```
1. runner 설정
   RUNNER.compareAndSet(this, null, currentThread)
   → 실행 권한의 원자적 획득

2. state 전이
   STATE.compareAndSet(this, NEW, COMPLETING)
   → 완료 처리의 원자적 획득

3. waiters 추가
   WAITERS.weakCompareAndSet(this, q.next = waiters, q)
   → 대기 리스트 추가의 원자성
```

#### volatile 필드

```
state    → 모든 Thread에게 완료 상태 가시성 보장
runner   → 실행 중인 Thread 정보 가시성 보장
waiters  → 대기 리스트 변경 가시성 보장
```

#### 메모리 순서 보장

```
set() 메서드:
  1. outcome = result       (일반 쓰기)
  2. STATE.setRelease(NORMAL)  (release 쓰기)
  
get() 메서드:
  1. s = state              (acquire 읽기)
  2. return outcome         (일반 읽기)
  
보장: get()이 NORMAL을 보면, set()의 outcome 쓰기도 반드시 본다
```

이 관계도와 명세를 통해 Future 시스템의 전체 구조와 각 구성 요소 간의 상호작용을 명확히 이해할 수 있다.