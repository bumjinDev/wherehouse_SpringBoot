# CompletableFuture 실무 적용 방법론: 측정 가능한 비동기 전환

## 서론: 성능 개선의 증명 가능성

비동기 프로그래밍을 포트폴리오에 포함할 때 직면하는 근본적 문제는 **"정말로 빨라졌는가"를 객관적으로 증명해야 한다**는 점이다. 단순히 "CompletableFuture를 사용했다"는 진술은 면접관에게 아무런 가치를 전달하지 못한다. 중요한 것은 "순차 실행 대비 몇 ms 단축되었으며, 그 이유는 무엇인가"를 데이터로 입증하는 것이다.

이를 위해서는 세 가지 측정 가능한 지표가 필요하다. 첫째, 전체 응답 시간의 변화다. 둘째, Thread의 상태 변화다. 셋째, 병렬 실행의 실제 발생 여부다. 이 세 지표를 수집하고 분석하는 과정이 내일의 작업 목표다.

---

## 본론: 측정 가능한 비동기 전환의 다섯 단계

### 1단계: Thread Pool의 설계적 결정

#### Executor 크기 산정의 원칙

R-04 최적화는 15개 카테고리의 카카오 API를 병렬로 호출하는 작업이다. 이때 Thread Pool의 크기를 결정하는 것은 단순한 설정이 아니라 **시스템 자원과 외부 의존성의 균형점을 찾는 설계 문제**다.

CPU-bound 작업이라면 Thread 수는 코어 수와 일치해야 한다. 하지만 R-04는 I/O-bound 작업이다. 각 Thread는 네트워크 응답을 기다리며 대부분의 시간을 WAITING 상태로 보낸다. CPU를 소비하지 않으므로, 코어 수보다 많은 Thread를 생성해도 Context Switching 비용이 네트워크 지연 시간에 비해 무시 가능하다.

15개 API를 병렬 호출하려면 최소 15개 Thread가 필요하다. 하지만 주소 변환 API 완료 후 검거율 조회가 시작되므로, 실제 동시 실행 Thread는 최대 14개다 (주소 API 1개 + 편의시설 API 15개 - 의존성 1개). 따라서 **Thread Pool 크기는 15개가 적정**하다.

#### NamedThreadFactory의 필요성

기본 Executors.newFixedThreadPool()은 Thread 이름을 "pool-N-thread-M" 형태로 자동 생성한다. 이것은 로그 분석 시 어떤 Thread가 어떤 작업을 수행했는지 추적을 어렵게 만든다. 

ThreadFactory를 직접 구현하여 Thread 이름에 "API-Worker-1", "API-Worker-2" 같은 의미 있는 접두사를 부여하면, 로그에서 특정 API 호출이 어느 Thread에서 실행되었는지 즉시 식별할 수 있다. 이것은 디버깅과 성능 분석의 효율을 크게 향상시킨다.

### 2단계: 응답 시간 측정의 정밀성

#### 측정 지점의 선정

전체 응답 시간은 Controller 진입부터 응답 반환까지의 전체 구간을 측정해야 한다. 하지만 이것만으로는 불충분하다. **각 단계별 소요 시간을 분해**해야 비동기 전환의 효과를 정확히 파악할 수 있다.

R-04의 측정 지점은 다음과 같다:
- T0: Controller 메서드 진입 시점
- T1: 주소 변환 API 완료 시점
- T2: 편의시설 API 15개 병렬 호출 완료 시점
- T3: 검거율 조회 완료 시점
- T4: 응답 DTO 생성 완료 시점

순차 실행에서는 T1-T0이 주소 API 시간, T2-T1이 편의시설 API 누적 시간, T3-T2가 검거율 조회 시간이다. 병렬 실행에서는 T2-T1이 가장 긴 편의시설 API 시간 하나와 같아진다. **이 차이가 비동기 전환의 실질적 이득**이다.

#### System.nanoTime()의 사용 이유

System.currentTimeMillis()는 시스템 시계에 의존하므로, NTP 동기화나 수동 시간 변경에 영향받는다. 측정 중간에 시계가 조정되면 음수 시간이 나올 수 있다.

System.nanoTime()은 JVM 시작 이후 경과한 나노초를 반환하며, 시스템 시계와 무관하다. 정밀도도 마이크로초 수준이므로, 밀리초 단위 API 응답 시간 측정에 충분하다. **모든 시간 측정은 nanoTime()을 사용해야 정확하다.**

### 3단계: Thread 상태 실측의 방법론

#### ThreadMXBean의 역할

Java Management Extensions(JMX)는 JVM 내부 상태를 모니터링하는 표준 API다. ThreadMXBean은 이 중 Thread 관련 정보를 제공하는 인터페이스로, 현재 실행 중인 모든 Thread의 상태를 조회할 수 있다.

ThreadMXBean.getThreadInfo()는 각 Thread의 ID, 이름, 상태(RUNNABLE, WAITING, TIMED_WAITING 등), CPU 시간, 블로킹 횟수를 반환한다. 이 데이터를 특정 시점에 캡처하면, 그 순간의 Thread Pool 상태를 스냅샷으로 저장할 수 있다.

#### 측정 시점의 전략적 선택

Thread 상태는 지속적으로 변화하므로, 무작위 시점의 스냅샷은 의미가 없다. **측정은 작업의 핵심 구간에서만 수행**해야 한다.

R-04에서는 다음 시점에 Thread 상태를 캡처한다:
- 병렬 작업 시작 직전: 모든 Thread가 WAITING 상태여야 함
- 병렬 작업 진행 중: 15개 Thread가 RUNNABLE 또는 TIMED_WAITING 상태여야 함
- 병렬 작업 완료 직후: 모든 Thread가 다시 WAITING 상태로 복귀해야 함

이 세 스냅샷을 비교하면, 병렬 실행이 실제로 발생했는지 객관적으로 증명할 수 있다.

### 4단계: 비동기 전환의 핵심 패턴

#### 독립 작업의 병렬화 원칙

비동기 전환의 첫 단계는 **의존성 분석**이다. 15개 편의시설 API는 서로 독립적이므로 병렬 실행 가능하다. 하지만 검거율 조회는 주소 변환 API의 결과에 의존하므로, 주소 API 완료 후에만 시작할 수 있다.

CompletableFuture.supplyAsync()는 독립 작업을 별도 Thread에서 시작한다. 15개 API를 각각 supplyAsync()로 시작하면, 15개 Thread가 동시에 네트워크 I/O를 수행한다. 이때 메인 Thread는 블로킹되지 않으며, 즉시 다음 코드로 진행한다.

#### 의존 작업의 체이닝 원칙

검거율 조회는 주소 변환 결과가 필요하므로, thenApplyAsync()로 체이닝한다. 이것은 "주소 API Future가 완료되면, 그 결과를 받아 검거율 조회를 시작하라"는 의미다.

thenApplyAsync()는 Executor를 명시적으로 지정해야 한다. 지정하지 않으면 주소 API를 완료한 Thread가 검거율 조회까지 이어서 실행하는데, 이것은 Thread Pool의 부하 분산을 저해한다. **모든 비동기 작업은 명시적 Executor 지정이 필수**다.

#### 완료 대기의 블로킹 최소화

CompletableFuture.allOf()는 여러 Future가 모두 완료될 때 완료되는 새 Future를 반환한다. allOf().join()을 호출하면, 메인 Thread가 블로킹되어 모든 작업이 끝날 때까지 대기한다.

이 블로킹은 불가피하다. 최종 응답을 생성하려면 모든 API 결과가 필요하기 때문이다. 하지만 **블로킹 시간은 가장 긴 작업 하나의 시간과 같다**. 순차 실행의 누적 시간과 비교하면, 이것이 비동기의 핵심 이득이다.

### 5단계: 측정 결과의 해석과 근거 작성

#### Before/After 데이터의 구조화

성능 개선을 증명하려면 두 가지 데이터 세트가 필요하다. 순차 실행 버전의 측정 결과와 병렬 실행 버전의 측정 결과다. 각 버전은 10회 이상 반복 측정하여 평균과 표준편차를 계산해야 한다. 단일 측정은 네트워크 지연이나 JVM GC 같은 외부 요인에 영향받을 수 있다.

측정 데이터는 다음 형태로 구조화한다:
```
순차 실행:
- 평균 응답 시간: 420ms
- 주소 API: 100ms
- 편의시설 API 합계: 300ms (각 20ms × 15개)
- 검거율 조회: 20ms

병렬 실행:
- 평균 응답 시간: 140ms
- 주소 API: 100ms
- 편의시설 API 최대: 25ms (가장 느린 1개)
- 검거율 조회: 20ms

개선: 420ms → 140ms (280ms 단축, 67% 개선)
```

#### Thread 상태 변화의 시각화

ThreadMXBean으로 수집한 데이터는 표로 정리한다:
```
시점              RUNNABLE  WAITING  TIMED_WAITING
----------------------------------------------
작업 시작 전        1         14         0
병렬 실행 중       15          0         0
작업 완료 후        1         14         0
```

이 표는 "15개 Thread가 동시에 실행되었다"는 직접적 증거다.

#### 개선 원인의 기술적 설명

README에 작성할 설명은 다음 구조를 따른다:

**문제 정의:** R-04 기능은 15개 외부 API를 순차 호출하여 총 420ms가 소요되었다. 각 API는 독립적이므로 병렬 실행 가능하다.

**해결 방법:** CompletableFuture와 15개 Thread Pool을 사용하여 독립 작업을 병렬화했다. 메인 Thread는 블로킹되지 않으며, 워커 Thread들이 동시에 네트워크 I/O를 수행한다.

**측정 결과:** 응답 시간이 420ms에서 140ms로 단축되었다. ThreadMXBean 측정 결과, 병렬 실행 중 15개 Thread가 모두 RUNNABLE 상태였다.

**개선 원인:** 순차 실행은 15개 API 시간을 누적했지만, 병렬 실행은 가장 긴 1개 시간만 소요된다. 280ms 단축은 14개 API의 병렬 실행 효과다.

---

## 결론: 증명 가능한 비동기 전환의 조건

내일의 작업은 단순히 "CompletableFuture를 사용하는 것"이 아니라, **"병렬 실행이 실제로 발생했으며, 그로 인해 응답 시간이 단축되었다는 것을 데이터로 증명하는 것"**이다.

이를 위해 필요한 것은 세 가지다. 첫째, Thread Pool을 적절히 설계하여 15개 작업이 동시에 실행될 수 있는 환경을 만든다. 둘째, System.nanoTime()과 ThreadMXBean으로 응답 시간과 Thread 상태를 정밀하게 측정한다. 셋째, Before/After 데이터를 구조화하여 개선 효과를 명확히 표현한다.

이 세 가지가 갖춰지면, 포트폴리오의 해당 기능은 단순한 기능 나열이 아니라 **"문제를 발견하고, 기술적 해결책을 적용하고, 효과를 검증한 엔지니어링 사례"**가 된다. 면접관은 코드를 보지 않고도 README의 측정 결과만으로 당신의 역량을 평가할 수 있다.

내일 작성할 코드는 이 방법론을 구현하는 도구일 뿐이며, 중요한 것은 **"무엇을 측정하고, 왜 그렇게 측정하며, 결과를 어떻게 해석하는가"**를 이해하는 것이다.

---

## 부록: 실행 체크리스트

### Phase 1: 환경 구성 (30분)

#### 1-1. 의존성 확인
```
□ build.gradle에 spring-boot-starter-actuator 포함 확인
□ Lombok 의존성 확인
□ 프로젝트 빌드 성공 확인
```

#### 1-2. 문서 준비
```
□ Future 완전 설명 문서 출력 또는 화면에 표시
□ CompletableFuture 완전 기술 백서의 "실제 사용 패턴" 섹션 표시
□ 현재 R-04 컨트롤러 코드 열어두기
```

#### 1-3. 측정 기준선 설정
```
□ 현재 순차 실행 코드로 10회 요청 실행
□ 각 요청의 응답 시간을 로그로 기록
□ 평균 응답 시간 계산 (예상: 400-500ms)
□ 기준선 데이터를 별도 파일에 저장
```

---

### Phase 2: Thread Pool 구성 (30분)

#### 2-1. AsyncConfig 클래스 작성
```
□ config 패키지 생성 확인
□ AsyncConfig.java 파일 생성
□ @Configuration 어노테이션 추가
□ ExecutorService Bean 메서드 작성
□ Thread Pool 크기를 15로 설정
□ NamedThreadFactory 내부 클래스 작성
□ Thread 이름 접두사를 "API-Worker"로 설정
□ destroyMethod = "shutdown" 속성 추가
```

#### 2-2. 빌드 및 실행 테스트
```
□ ./gradlew clean build 실행
□ 빌드 에러 없음 확인
□ 애플리케이션 실행
□ 로그에서 "API-Worker" Thread 생성 확인
□ Bean 생성 성공 로그 확인
```

---

### Phase 3: Thread 모니터링 유틸리티 작성 (1시간)

#### 3-1. ThreadMonitor 클래스 작성
```
□ util 패키지 생성
□ ThreadMonitor.java 파일 생성
□ ThreadMXBean 필드 선언
□ captureThreadSnapshot() 메서드 작성
    □ totalThreadCount 측정
    □ daemonThreadCount 측정
    □ peakThreadCount 측정
    □ Thread 상태별 카운트 Map 생성
□ logWorkerThreads() 메서드 작성
    □ API-Worker Thread만 필터링
    □ 각 Thread의 상태 로깅
```

#### 3-2. PerformanceLogger 클래스 작성
```
□ util 패키지에 PerformanceLogger.java 생성
□ 측정 지점별 상수 정의 (T0, T1, T2, T3, T4)
□ startMeasurement() 메서드 작성
□ recordCheckpoint() 메서드 작성
□ finishMeasurement() 메서드 작성
□ 각 구간별 시간 계산 로직 작성
□ 로그 형식 정의 (JSON 또는 구조화된 텍스트)
```

#### 3-3. 유틸리티 테스트
```
□ 간단한 테스트 메서드 작성
□ ThreadMonitor.captureThreadSnapshot() 호출
□ 반환된 Map 데이터 확인
□ PerformanceLogger로 더미 측정 수행
□ 로그 출력 형식 확인
```

---

### Phase 4: 비동기 코드 작성 (2시간)

#### 4-1. 기존 순차 코드 백업
```
□ 현재 R-04 Service 메서드 전체 복사
□ 주석 처리 또는 별도 메서드로 보관
□ Git commit (비동기 전환 전 상태 보존)
```

#### 4-2. CompletableFuture 전환 - 독립 작업
```
□ 주소 변환 API를 supplyAsync()로 래핑
□ ExecutorService를 명시적으로 지정
□ 15개 편의시설 API를 각각 supplyAsync()로 래핑
□ 모든 supplyAsync()에 동일한 executor 지정
□ 각 Future 객체를 변수에 저장
```

#### 4-3. CompletableFuture 전환 - 의존 작업
```
□ 주소 변환 Future에 thenApplyAsync() 체이닝
□ extractGu() 로직을 람다 내부로 이동
□ 검거율 조회를 thenApplyAsync() 내부에서 실행
□ executor를 명시적으로 지정
```

#### 4-4. 완료 대기 및 결과 수집
```
□ 모든 Future 객체를 배열 또는 List로 수집
□ CompletableFuture.allOf() 호출
□ allOf().join()으로 완료 대기
□ 각 Future에서 join()으로 결과 추출
□ 기존과 동일한 DTO 생성 로직 유지
```

#### 4-5. 예외 처리 추가
```
□ 각 supplyAsync() 람다에 try-catch 추가
□ 예외 발생 시 로깅
□ exceptionally() 메서드로 기본값 반환 처리
□ allOf() 이후 각 Future의 예외 확인 로직
```

---

### Phase 5: 성능 측정 통합 (1시간)

#### 5-1. Controller에 측정 코드 삽입
```
□ Controller 메서드 시작 시 PerformanceLogger.start()
□ 주소 API Future 완료 후 recordCheckpoint("T1")
□ 편의시설 API allOf() 완료 후 recordCheckpoint("T2")
□ 검거율 조회 완료 후 recordCheckpoint("T3")
□ DTO 생성 완료 후 recordCheckpoint("T4")
□ return 직전에 finishMeasurement()
```

#### 5-2. Thread 상태 측정 삽입
```
□ allOf() 호출 직전에 ThreadMonitor.captureThreadSnapshot()
□ 결과를 변수에 저장 (beforeSnapshot)
□ allOf().join() 호출
□ join() 직후에 ThreadMonitor.captureThreadSnapshot()
□ 결과를 변수에 저장 (afterSnapshot)
□ 두 스냅샷을 로그로 출력
```

#### 5-3. 로그 레벨 설정
```
□ application.yml에서 로그 레벨 확인
□ com.yourproject 패키지를 DEBUG로 설정
□ ThreadMonitor와 PerformanceLogger를 INFO로 설정
□ 너무 많은 로그가 출력되지 않도록 조정
```

---

### Phase 6: 실행 및 데이터 수집 (1시간)

#### 6-1. 비동기 버전 측정
```
□ 애플리케이션 재시작
□ Postman 또는 curl로 R-04 API 호출
□ 첫 3회는 JVM Warm-up으로 무시
□ 이후 10회 요청 실행
□ 각 요청의 로그 파일 저장
□ 응답 시간 기록
    - T0-T1 (주소 API)
    - T1-T2 (편의시설 API 병렬)
    - T2-T3 (검거율 조회)
    - T0-T4 (전체 시간)
```

#### 6-2. Thread 상태 데이터 수집
```
□ 로그에서 beforeSnapshot 검색
□ 각 Thread 상태 카운트 기록
□ afterSnapshot 검색
□ 각 Thread 상태 카운트 기록
□ RUNNABLE 상태 Thread가 15개인지 확인
```

#### 6-3. 기준선 데이터와 비교
```
□ Phase 1에서 측정한 순차 실행 시간 확인
□ 비동기 실행 시간과 비교
□ 단축된 시간 계산 (ms)
□ 개선율 계산 (%)
□ 예상: 280-300ms 단축, 60-70% 개선
```

---

### Phase 7: 결과 문서화 (1시간)

#### 7-1. README.md 성능 개선 섹션 작성
```
□ "## 성능 최적화" 섹션 추가
□ 문제 정의 작성
    - 순차 실행의 병목
    - 15개 독립 API의 누적 지연
□ 해결 방법 작성
    - CompletableFuture 사용
    - 15개 Thread Pool 구성
    - 병렬 실행 전환
□ 측정 결과 작성
    - Before/After 표 삽입
    - Thread 상태 변화 표 삽입
    - 개선율 명시
□ 기술적 근거 작성
    - 병렬 실행 원리 설명
    - Thread Pool 크기 선정 이유
    - 측정 방법론 설명
```

#### 7-2. 코드 주석 추가
```
□ AsyncConfig 클래스에 Javadoc
    - Thread Pool 크기 선정 근거
    - NamedThreadFactory 사용 이유
□ Service 메서드에 주석
    - 각 supplyAsync() 역할 설명
    - thenApplyAsync() 의존성 설명
    - allOf() 사용 이유 설명
□ ThreadMonitor에 주석
    - 측정 시점 설명
    - 각 메트릭의 의미
```

#### 7-3. 스크린샷 및 로그 파일 첨부
```
□ Postman 응답 시간 스크린샷
□ 로그 파일에서 핵심 부분 발췌
    - PerformanceLogger 출력
    - ThreadMonitor 출력
□ README에 이미지 삽입
□ docs 폴더에 전체 로그 파일 저장
```

---

### Phase 8: 검증 및 마무리 (30분)

#### 8-1. 코드 리뷰
```
□ 모든 supplyAsync()에 executor 지정 확인
□ 예외 처리 누락 확인
□ 자원 해제 (executor.shutdown()) 확인
□ 불필요한 주석 제거
□ 코드 포맷팅 정리
```

#### 8-2. 문서 검증
```
□ README의 측정 결과가 실제 로그와 일치하는지 확인
□ 오타 확인
□ 기술 용어 정확성 확인
□ 그래프나 표의 가독성 확인
```

#### 8-3. Git Commit
```
□ git add .
□ git commit -m "feat: R-04 성능 최적화 - CompletableFuture 병렬 실행"
□ 커밋 메시지에 성능 개선 수치 포함
    - "420ms → 140ms (67% 개선)"
□ git push
```

#### 8-4. 포트폴리오 체크
```
□ GitHub README에서 성능 개선 섹션 렌더링 확인
□ 이미지가 정상 표시되는지 확인
□ 코드 블록이 올바르게 표시되는지 확인
□ 전체 README 흐름 재검토
```

---

## 최종 점검 사항

### 필수 산출물 확인
```
□ AsyncConfig.java (Thread Pool 설정)
□ ThreadMonitor.java (Thread 상태 측정)
□ PerformanceLogger.java (응답 시간 측정)
□ 비동기 전환된 Service 코드
□ README.md 성능 개선 섹션
□ 측정 로그 파일
□ Before/After 응답 시간 데이터
□ Thread 상태 변화 데이터
```

### 검증 질문 리스트
```
□ Thread Pool 크기는 15개인가?
□ 모든 비동기 작업에 executor를 명시했는가?
□ 응답 시간이 실제로 단축되었는가?
□ Thread 상태가 병렬 실행을 증명하는가?
□ 예외 처리가 누락된 부분은 없는가?
□ README가 면접관이 이해하기 쉬운가?
□ 측정 방법론이 명확히 설명되어 있는가?
□ 개선 원인이 기술적으로 정확한가?
```

### 면접 대비 자가 질문
```
□ "왜 Thread Pool 크기를 15로 했나요?"
    → I/O-bound 작업, 15개 독립 API, Context Switching 비용 무시 가능
    
□ "thenApply와 thenApplyAsync의 차이는?"
    → 실행 Thread 차이, Executor 지정 필요성
    
□ "allOf().join()이 블로킹인데 비동기의 의미가 있나요?"
    → 블로킹 시간이 가장 긴 작업 1개와 같음, 순차 누적 대비 개선
    
□ "Thread 상태를 어떻게 측정했나요?"
    → ThreadMXBean, getThreadInfo(), 세 시점 스냅샷
    
□ "성능이 개선되지 않는다면 어떻게 디버깅하나요?"
    → Thread Dump, 로그 분석, 실제 병렬 실행 확인
```

---

## 시간 배분 가이드

```
총 소요 시간: 약 7-8시간

Phase 1: 환경 구성          30분
Phase 2: Thread Pool 구성   30분
Phase 3: 모니터링 유틸리티  1시간
Phase 4: 비동기 코드 작성   2시간
Phase 5: 성능 측정 통합     1시간
Phase 6: 실행 및 데이터 수집 1시간
Phase 7: 결과 문서화        1시간
Phase 8: 검증 및 마무리     30분
```

이 체크리스트를 순서대로 진행하면, 내일 하루 안에 측정 가능한 성능 개선을 포트폴리오에 포함할 수 있다.