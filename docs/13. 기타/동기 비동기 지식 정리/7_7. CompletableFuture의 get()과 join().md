# CompletableFuture의 두 가지 대기 메커니즘: get()과 join()의 설계 철학과 내부 구현

## 서장: 비동기 프로그래밍의 근본적 모순

비동기 프로그래밍은 작업의 병렬 실행을 통해 대기 시간을 제거하는 것을 목표로 한다. 그러나 최종적으로는 작업의 결과를 수집해야 하므로 어느 시점에서는 완료를 확인해야 한다. 이 동기화 지점에서 CompletableFuture는 get()과 join()이라는 두 가지 메서드를 제공한다. 두 메서드가 공존하는 이유는 Java 5의 Future 인터페이스 계약과 Java 8의 함수형 프로그래밍 요구사항이 서로 다른 설계 원칙을 요구하기 때문이다.

## 1부: 개념적 토대

### 비동기 작업 완료의 두 가지 철학

Java 5에서 도입된 Future 인터페이스는 비동기 작업의 결과를 표현하는 최초의 표준화된 방법이었다. 이 인터페이스는 get() 메서드를 통해 명시적 예외 처리를 요구했다. 모든 잠재적 오류 상황 - 작업의 실패, 외부 중단 요청, 무한 대기 - 을 checked exception으로 표현하여 컴파일 시점에 처리를 강제했다.

Java 8에서 등장한 CompletableFuture는 Future 인터페이스를 구현하면서 동시에 새로운 메서드를 추가했다. get() 메서드는 Future 인터페이스의 계약을 구현하기 위해 유지되었고, 새로 추가된 join() 메서드는 다른 설계 원칙을 구현했다. join()은 checked exception을 제거하고, 인터럽트를 무시하며, 타임아웃을 지원하지 않는다.

### 동기화 지점의 필연성과 제어권의 문제

모든 비동기 시스템에는 동기화 지점이 필요하다. 이 지점에서 제어권 처리 방식이 두 메서드의 핵심 차이다. get() 메서드는 호출자에게 완전한 제어권을 제공한다. 인터럽트로 중단 가능하고, 타임아웃으로 대기를 제한할 수 있으며, 각 예외 상황을 구분하여 처리할 수 있다. join()은 작업 완료를 보장하는 방식으로 설계되었다. 시작하면 완료까지 대기하며, 외부 중단 신호를 처리하지 않는다.

이러한 차이는 프로그램 실행 흐름의 제어 방식에 대한 서로 다른 접근법을 반영한다. get()은 호출자가 실행 흐름을 제어하는 명령형 프로그래밍 모델을, join()은 시스템이 실행을 보장하는 선언형 프로그래밍 모델을 각각 구현한다.

## 2부: Future 인터페이스와 get() 메서드의 역사적 맥락

### Future 인터페이스의 탄생 배경

2004년, Java 5의 java.util.concurrent 패키지는 Doug Lea의 주도로 만들어진 동시성 프레임워크였다. 멀티코어 프로세서의 보편화와 함께 병렬 처리를 위한 표준화된 추상화가 필요했다. Future 인터페이스는 이러한 요구사항을 충족시키기 위해 설계되었다.

Future의 설계는 방어적 프로그래밍 원칙을 따랐다. 네트워크 통신, 데이터베이스 쿼리, 파일 I/O 같은 불확실한 작업들을 다루기 위해, 모든 가능한 실패 시나리오를 명시적으로 모델링했다. InterruptedException은 작업의 취소를, ExecutionException은 작업 자체의 실패를, TimeoutException은 시간 제한 초과를 각각 표현했다.

### get() 메서드의 설계 원칙

get() 메서드는 세 가지 핵심 원칙을 구현한다. 첫째, "명시적 오류 처리"다. checked exception을 통해 개발자가 실패 가능성을 잊을 수 없도록 한다. 둘째, "협조적 중단"이다. 인터럽트 메커니즘을 통해 장시간 실행되는 작업을 안전하게 중단할 수 있다. 셋째, "제한된 대기"다. 타임아웃을 통해 무한 대기의 위험을 제거한다.

이러한 원칙들은 엔터프라이즈 환경의 요구사항을 반영한다. 트랜잭션 처리 시스템, 웹 서버, 데이터베이스 연결 풀 등은 모두 자원의 효율적 사용과 장애 상황의 빠른 복구를 요구한다. get() 메서드는 이러한 요구사항을 충족시키기 위해 설계되었다.

### CompletableFuture에서의 get() 구현

CompletableFuture는 Future 인터페이스를 구현하면서도, 내부적으로는 훨씬 정교한 메커니즘을 사용한다. 단순한 블로킹 대기가 아닌, 적응형 대기 전략을 구현한다. 초기에는 스핀 대기로 CPU를 활용하고, 이후 점진적으로 무거운 블로킹으로 전환한다. 이는 짧은 대기와 긴 대기 모두에 대해 최적의 성능을 제공한다.

## 3부: join() 메서드의 등장과 함수형 프로그래밍의 요구

### Java 8과 패러다임의 전환

2014년 출시된 Java 8은 Java 언어에 중요한 변화를 가져왔다. 람다 표현식, 스트림 API, 메서드 레퍼런스 등 함수형 프로그래밍 기능이 도입되었다. 이러한 변화는 기존의 명령형 API들과 구조적 불일치를 발생시켰고, CompletableFuture는 이러한 불일치를 해결해야 했다.

함수형 프로그래밍에서 함수는 부수 효과 없이 동작해야 한다. checked exception은 이러한 요구사항과 맞지 않는다. 람다 표현식 내에서 try-catch를 작성해야 한다면, 함수형 프로그래밍의 간결성이 손상된다. 또한 함수 조합(function composition)이 복잡해진다.

### join()의 설계 결정

join() 메서드는 세 가지 주요 설계 결정을 구현했다. 첫째, checked exception을 완전히 제거했다. 모든 예외를 CompletionException이라는 unchecked exception으로 포장한다. 둘째, 인터럽트를 처리하지 않는다. 외부의 중단 요청이 와도 작업이 완료될 때까지 대기한다. 셋째, 타임아웃을 지원하지 않는다. 대기를 시작하면 완료까지 계속한다.

이러한 결정들은 함수형 파이프라인의 결정론적 실행을 보장하기 위한 것이다. 스트림 처리나 CompletableFuture 체인에서 중간 단계가 예측 불가능하게 중단되면, 전체 연산의 일관성이 보장되지 않는다.

### 인터럽트 불감증의 의미론

join()이 인터럽트를 무시한다는 것은 InterruptedException을 던지지 않는다는 의미를 넘어선다. 더 복잡한 메커니즘이 작동한다. 인터럽트 신호가 오면 join()은 이를 감지하지만, 대기를 중단하지는 않는다. 대신 스레드의 인터럽트 상태를 보존하여, join() 호출이 끝난 후 이후 코드가 이를 확인할 수 있도록 한다. 이는 현재는 중단할 수 없지만 나중에 처리 가능하도록 하는 설계다.

## 4부: 내부 구현의 심층 분석

### CompletableFuture의 상태 모델

CompletableFuture의 모든 동작은 단일 volatile Object result 필드를 중심으로 한다. 이 필드는 세 가지 상태를 표현한다. null은 미완료를, 실제 값은 정상 완료를, AltResult 래퍼는 예외나 취소를 의미한다. 이 단순한 상태 모델이 복잡한 비동기 연산을 가능하게 하는 기반이다.

상태 전환은 compare-and-swap(CAS) 연산으로 원자적으로 수행된다. 한 번 완료된 future는 절대 다시 미완료 상태로 돌아갈 수 없다. 이 불변성이 동시성 환경에서의 안전성을 보장한다.

### waitingGet() 메서드의 4단계 적응형 대기 전략

get()과 join()은 모두 내부적으로 waitingGet() 메서드를 사용하지만, 파라미터가 다르다. get()은 interruptible=true로, join()은 false로 호출한다. 이 단일 불린 값이 전혀 다른 동작을 만들어낸다.

**1단계: 스핀 대기 (Spin-Wait)**

처음 약 256회의 루프 동안은 스핀 대기를 수행한다. 매 루프마다 result 필드를 확인하고, Thread.onSpinWait()를 호출한다. 이는 CPU에게 "지금은 대기 중"임을 알리는 힌트로, 현대 프로세서의 전력 관리와 하이퍼스레딩 최적화에 도움이 된다. 이 단계에서 get()은 매번 인터럽트를 확인하지만, join()은 확인하지 않는다.

```java
private Object waitingGet(boolean interruptible) {
    int spins = SPINS;  // 약 256
    Object r;
    
    while ((r = result) == null) {
        if (spins > 0) {
            if (interruptible && Thread.interrupted()) {
                throw new InterruptedException();  // get()만 여기서 탈출
            }
            Thread.onSpinWait();  // CPU 최적화 힌트
            spins--;
        }
        // 다음 단계로...
    }
}
```

**2단계: Signaller 객체 생성**

스핀 대기가 소진되면 실제 블로킹을 위한 준비를 시작한다. Signaller는 ForkJoinPool.ManagedBlocker를 구현하는 특별한 객체로, 블로킹 정보와 인터럽트 처리 정책을 캡슐화한다.

```java
static final class Signaller extends Completion
                            implements ForkJoinPool.ManagedBlocker {
    final boolean interruptible;  // get()은 true, join()은 false
    final Thread thread;
    long nanos;  // 타임아웃용
    final long deadline;
    
    Signaller(boolean interruptible, long nanos, long deadline) {
        this.thread = Thread.currentThread();
        this.interruptible = interruptible;
        this.nanos = nanos;
        this.deadline = deadline;
    }
}
```

**3단계: 스택 푸시 시도**

Signaller를 CompletableFuture의 completion 스택에 푸시한다. 이는 Treiber 스택이라는 lock-free 자료구조를 사용한다. CAS 연산으로 동시성을 제어하므로, 실패할 수 있다. 실패하면 다음 루프에서 재시도한다.

```java
final boolean tryPushStack(Completion c) {
    Completion h = stack;
    c.lazySetNext(h);  // 현재 top을 next로
    return UNSAFE.compareAndSwapObject(this, STACK, h, c);  // CAS
}
```

**4단계: 관리된 블로킹 (Managed Blocking)**

ForkJoinPool.managedBlock()을 통해 실제 블로킹에 들어간다. 이는 단순한 블로킹이 아니다. ForkJoinPool이 워커 스레드가 블로킹될 때 풀의 목표 병렬성을 유지하기 위해 보상 스레드를 생성할 수 있다.

```java
public boolean block() {
    while (!isReleasable()) {
        if (interruptible && Thread.interrupted()) {
            throw new InterruptedException();  // get()의 탈출 경로
        } else {
            LockSupport.park(this);  // 실제 블로킹
            // join()은 인터럽트로 깨어나도 다시 park()
        }
    }
    return true;
}
```

### LockSupport.park()의 깨어남 조건과 인터럽트 처리

LockSupport.park()는 Java의 가장 저수준 스레드 대기 메커니즘이다. 세 가지 조건에서 반환된다: unpark() 호출, 인터럽트 발생, 또는 스퓨리어스 웨이크업. park()는 인터럽트로 인해 반환되어도 InterruptedException을 던지지 않는다.

get()과 join()의 차이는 park()에서 반환된 후의 처리 방식이다. get()은 인터럽트 상태를 확인하고 즉시 InterruptedException을 던진다. join()은 인터럽트를 무시하고 result가 여전히 null이면 다시 park()를 호출한다. 이 과정에서 인터럽트 플래그는 계속 true로 유지된다.

### 예외 처리와 포장 메커니즘

작업 실행 중 발생한 예외는 AltResult 객체에 포장되어 result 필드에 저장된다. get()과 join()은 이를 추출할 때 다른 타입으로 재포장한다.

```java
// get()의 예외 처리
private static <T> T reportGet(Object r)
        throws InterruptedException, ExecutionException {
    if (r instanceof AltResult) {
        Throwable x = ((AltResult)r).ex;
        if (x instanceof CancellationException)
            throw (CancellationException)x;  // 그대로 전파
        throw new ExecutionException(x);  // checked로 포장
    }
    return (T)r;
}

// join()의 예외 처리
private static <T> T reportJoin(Object r) {
    if (r instanceof AltResult) {
        Throwable x = ((AltResult)r).ex;
        if (x instanceof CancellationException)
            throw (CancellationException)x;  // 그대로 전파
        if (x instanceof CompletionException)
            throw (CompletionException)x;  // 이미 포장된 경우
        throw new CompletionException(x);  // unchecked로 포장
    }
    return (T)r;
}
```

ExecutionException은 checked exception으로서 명시적 처리를 강제한다. CompletionException은 unchecked exception으로서 투명한 전파를 허용한다. 이 차이가 두 메서드의 사용성을 크게 좌우한다.

### 타임아웃 메커니즘의 정밀한 구현

get(long timeout, TimeUnit unit)은 정확한 타임아웃을 보장하기 위해 System.nanoTime()을 사용한다. 이는 시스템 시간 변경에 영향받지 않는 단조 시계(monotonic clock)다.

```java
public T get(long timeout, TimeUnit unit) throws ... {
    long nanos = unit.toNanos(timeout);
    long deadline = System.nanoTime() + nanos;  // 절대 시점
    
    Signaller q = new Signaller(true, nanos, deadline);
    
    while (result == null) {
        // 매번 남은 시간 재계산
        nanos = deadline - System.nanoTime();
        if (nanos <= 0L) {
            throw new TimeoutException();
        }
        // nanos만큼만 대기
        LockSupport.parkNanos(this, nanos);
    }
}
```

스퓨리어스 웨이크업에도 정확한 타임아웃을 보장하기 위해, 매번 깨어날 때마다 남은 시간을 재계산한다.

## 5부: ForkJoinPool과의 협조적 상호작용

### Work-Stealing과 보상 메커니즘

ForkJoinPool은 work-stealing 알고리즘을 사용하는 특별한 스레드 풀이다. 각 워커 스레드는 자신의 작업 큐를 가지며, 작업이 없으면 다른 워커의 큐에서 작업을 훔쳐온다. 이는 부하 분산을 자동화하지만, 워커가 블로킹되면 문제가 발생한다.

managedBlock()은 이 문제를 해결한다. 워커가 블로킹되려 할 때, 풀의 목표 병렬성(target parallelism)을 유지하기 위해 새로운 워커를 생성하거나 대기 중인 워커를 활성화한다. 이를 보상 메커니즘(compensation mechanism)이라 한다.

```java
final boolean tryCompensate(WorkQueue w) {
    int pc = parallelism;  // 목표 병렬성
    int ac = (int)(ctl >> AC_SHIFT) + pc;  // 활성 워커 수
    int tc = (short)(ctl >> TC_SHIFT) + pc;  // 전체 워커 수
    
    if (ac < pc && tc < MAX_CAP) {
        // 활성 워커가 부족하면 새 워커 생성
        tryAddWorker(c);
        return true;
    }
    // 또는 대기 중인 워커 활성화...
}
```

### 데드락 방지와 재진입 문제

CompletableFuture 체인에서 한 작업이 같은 풀의 다른 작업을 기다릴 때 데드락이 발생할 수 있다. 예를 들어:

```java
CompletableFuture<Integer> f1 = CompletableFuture.supplyAsync(() -> {
    // 워커 스레드 W1에서 실행
    CompletableFuture<Integer> f2 = CompletableFuture.supplyAsync(() -> 42);
    return f2.get();  // W1이 블로킹되면서 f2를 실행할 워커가 없음!
});
```

managedBlock()은 이를 감지하고 보상 워커를 생성하여 데드락을 방지한다. W1이 블로킹되면 새로운 워커 W2가 생성되어 f2를 실행한다.

## 6부: 함수형 프로그래밍과의 통합

### 람다 표현식과 checked exception의 구조적 충돌

Java 8의 함수형 인터페이스들은 checked exception을 선언하지 않는다. 이는 의도적인 설계 결정이었다. checked exception은 함수 조합을 복잡하게 만들고, 타입 시스템을 복잡하게 한다.

```java
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);  // throws 절이 없음
}
```

이로 인해 get()을 람다 내에서 사용하려면 번거로운 예외 처리가 필요하다:

```java
// get()을 사용한 스트림 처리 - 매우 복잡
List<Result> results = futures.stream()
    .map(f -> {
        try {
            return f.get();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        } catch (ExecutionException e) {
            throw new RuntimeException(e);
        }
    })
    .collect(Collectors.toList());

// join()을 사용한 스트림 처리 - 간결
List<Result> results = futures.stream()
    .map(CompletableFuture::join)  // 메서드 레퍼런스 가능
    .collect(Collectors.toList());
```

### 참조 투명성과 결정론적 실행

함수형 프로그래밍의 핵심 원칙 중 하나는 참조 투명성(referential transparency)이다. 같은 입력에 대해 항상 같은 출력을 보장해야 한다. join()의 인터럽트 불감증은 이를 보장한다.

인터럽트로 중간에 중단될 수 있다면, 같은 CompletableFuture 체인이 실행 환경에 따라 다른 결과를 낳을 수 있다. join()은 이를 방지하여 전체가 성공하거나 전체가 실패하는 all-or-nothing 의미론을 구현한다.

### 모나드적 연산과 예외 전파

CompletableFuture는 모나드(Monad) 패턴을 구현한다. thenApply(), thenCompose(), thenCombine() 등의 메서드들은 모나드 연산자다. 이러한 연산들에서 예외는 값처럼 전파되어야 한다.

join()이 CompletionException을 사용하는 것은 이러한 투명한 전파를 가능하게 한다. 예외가 체인을 따라 자연스럽게 전파되며, 최종 소비자가 이를 처리한다. checked exception은 이러한 흐름을 방해한다.

## 7부: 성능 최적화와 메모리 모델

### volatile 읽기의 비용과 최적화

result 필드의 volatile 선언은 가시성을 보장하지만 성능 비용이 있다. 모든 읽기에서 메모리 배리어가 실행되어, CPU 캐시의 효율성이 떨어진다.

CompletableFuture는 이를 최적화하기 위해 한 번 읽은 값을 지역 변수에 캐싱한다:

```java
Object r;
if ((r = result) == null) {  // volatile 읽기 1회
    while (r == null) {
        // r 재사용으로 volatile 읽기 최소화
        performWaitingLogic();
        r = result;  // 필요할 때만 다시 읽기
    }
}
return processResult(r);  // 캐싱된 값 사용
```

### CAS 연산과 캐시 라인 최적화

Completion 스택 조작에 사용되는 CAS 연산은 CPU 캐시 라인 단위로 동작한다. false sharing을 방지하기 위해, 자주 변경되는 필드들을 같은 캐시 라인에 배치하고, 읽기 전용 필드들은 분리한다.

```java
// 핫 필드들 - 자주 변경됨
volatile Object result;
volatile Completion stack;

// 64바이트 패딩 (캐시 라인 크기)
long p0, p1, p2, p3, p4, p5, p6, p7;

// 콜드 필드들 - 거의 변경 안 됨
static final boolean USE_COMMON_POOL;
```

### 스핀 대기의 적응형 조정

스핀 횟수는 시스템 특성에 따라 동적으로 조정될 수 있다. 단일 코어에서는 스핀이 무의미하므로 0으로, 멀티코어에서는 CPU 수와 현재 부하를 고려하여 결정한다.

```java
static final int SPINS = (Runtime.getRuntime().availableProcessors() > 1) ?
                        1 << 8 : 0;  // 멀티코어: 256, 단일코어: 0
```

## 8부: 실전 적용 가이드

### 선택 기준 결정 트리

어떤 메서드를 선택할지는 작업의 특성과 실행 환경에 따라 결정된다.

**get()을 선택해야 하는 경우:**

1. **외부 시스템과의 통신**: 네트워크, 데이터베이스, 파일 시스템 등 제어할 수 없는 요소가 개입할 때
2. **사용자 상호작용**: 취소 가능성이 있는 UI 작업, 웹 요청 처리
3. **자원 제약 환경**: 스레드 풀이 제한적이거나 메모리가 부족한 상황
4. **명시적 오류 처리가 필요한 경우**: 감사(audit), 규정 준수가 중요한 시스템

**join()을 선택해야 하는 경우:**

1. **함수형 파이프라인**: 스트림 처리, CompletableFuture 체인
2. **내부 계산 작업**: 외부 의존성 없는 순수 연산
3. **트랜잭션 일관성**: 모든 작업이 완료되어야 하는 배치 처리
4. **테스트 코드**: 간단명료한 검증 로직

### 일반적인 함정과 해결책

**함정 1: join() 후 인터럽트 상태 누수**

join()은 인터럽트를 무시하지만 플래그는 유지한다. 이후 블로킹 작업에서 예상치 못한 InterruptedException이 발생할 수 있다.

```java
// 문제 상황
CompletableFuture<Data> future = loadDataAsync();
Data data = future.join();  // 인터럽트 플래그 유지됨
saveToDatabase(data);  // 내부 Thread.sleep()에서 즉시 예외!

// 해결 방법
Data data = future.join();
if (Thread.interrupted()) {  // 플래그 확인 및 클리어
    // 적절한 처리 또는 플래그 복원
    Thread.currentThread().interrupt();
}
saveToDatabase(data);
```

**함정 2: get()의 인터럽트 상태 복원 누락**

InterruptedException을 잡은 후 인터럽트 상태를 복원하지 않으면, 상위 코드가 인터럽트를 인지하지 못한다.

```java
// 잘못된 패턴
try {
    result = future.get();
} catch (InterruptedException e) {
    logger.error("Interrupted");  // 플래그 소실!
}

// 올바른 패턴
try {
    result = future.get();
} catch (InterruptedException e) {
    logger.error("Interrupted");
    Thread.currentThread().interrupt();  // 플래그 복원
    return defaultValue;
}
```

**함정 3: 부적절한 컨텍스트에서의 사용**

외부 시스템과 통신하면서 join()을 사용하거나, 함수형 파이프라인에서 get()을 사용하는 것은 각각의 장점을 포기하는 것이다.

```java
// 나쁜 예: 외부 API 호출에 join() 사용
CompletableFuture<Response> apiCall = callExternalApi();
Response response = apiCall.join();  // 타임아웃 없이 무한 대기 위험

// 좋은 예: 타임아웃 있는 get() 사용
try {
    Response response = apiCall.get(30, TimeUnit.SECONDS);
} catch (TimeoutException e) {
    return cachedResponse();
}

// 나쁜 예: 스트림에서 get() 사용
futures.stream()
    .map(f -> {
        try { return f.get(); }  // 장황한 예외 처리
        catch (Exception e) { throw new RuntimeException(e); }
    })
    .collect(Collectors.toList());

// 좋은 예: join() 사용
futures.stream()
    .map(CompletableFuture::join)  // 간결한 메서드 레퍼런스
    .collect(Collectors.toList());
```

### 고급 패턴과 최적화

**패턴 1: 타임아웃 있는 join() 구현**

join()에 타임아웃을 추가하고 싶다면, orTimeout()과 조합할 수 있다:

```java
public static <T> T joinWithTimeout(CompletableFuture<T> future, 
                                   long timeout, TimeUnit unit) {
    return future.orTimeout(timeout, unit).join();
}
```

**패턴 2: 인터럽트 감지하는 join()**

join() 후 인터럽트 상태를 자동으로 처리하는 래퍼:

```java
public static <T> T joinInterruptibly(CompletableFuture<T> future) {
    T result = future.join();
    if (Thread.interrupted()) {
        throw new InterruptedException("Interrupted during join");
    }
    return result;
}
```

**패턴 3: 선택적 복구 전략**

작업 특성에 따라 get()과 join()을 선택적으로 사용:

```java
public <T> T await(CompletableFuture<T> future, boolean critical) {
    if (critical) {
        // 중요 작업: 인터럽트 무시
        return future.join();
    } else {
        // 일반 작업: 취소 가능
        try {
            return future.get();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new CancellationException("Interrupted");
        } catch (ExecutionException e) {
            throw new CompletionException(e.getCause());
        }
    }
}
```

## 결론: 이중 구조의 필요성

CompletableFuture가 get()과 join() 두 메서드를 모두 제공하는 것은 서로 다른 프로그래밍 패러다임과 사용 사례를 지원하기 위한 설계다. 각 메서드는 특정 요구사항에 최적화되어 있다.

get()은 전통적인 동시성 프로그래밍의 요구사항을 충족한다. 명시적 오류 처리, 협조적 중단, 제한된 대기 등 엔터프라이즈 Java 환경에서 축적된 패턴들을 구현한다. 외부 시스템과 상호작용하는 경계에서 필수적인 기능들을 제공한다.

join()은 함수형 프로그래밍 모델을 지원한다. 순수성, 조합 가능성, 참조 투명성 등 함수형 프로그래밍의 요구사항을 충족한다. 내부 로직을 간결하게 표현하는 데 적합하다.

두 메서드의 공존은 Java가 기존 코드베이스와의 호환성을 유지하면서 새로운 프로그래밍 모델을 지원하는 방법을 보여준다. 개발자는 각 상황에 맞는 메서드를 선택할 수 있으며, 필요시 두 가지를 혼용할 수도 있다.

get()과 join()의 차이를 이해하는 것은 API 사용법을 넘어 동시성 프로그래밍의 본질과 함수형 프로그래밍의 원칙을 이해하는 것이다. 이러한 이해를 바탕으로 더 안정적이고 유지보수 가능한 비동기 시스템을 구축할 수 있다.