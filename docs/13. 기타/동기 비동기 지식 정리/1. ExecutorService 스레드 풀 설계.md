# ExecutorService 완전 통합 문서

## 서론: 직접 스레드 생성의 구조적 문제

### 전통적 방식의 한계

Java 초기에는 비동기 작업을 실행하려면 개발자가 직접 `new Thread(runnable).start()`를 호출해야 했다. 이 방식은 간단해 보이지만, 실무에서는 치명적인 문제를 유발했다.

### 문제 1: 스레드 생성 비용

스레드 생성은 OS 커널에 시스템 콜을 요청하는 과정이다. Linux에서는 `pthread_create`, Windows에서는 `CreateThread` 같은 커널 함수를 호출한다. 이 과정에서 다음이 발생한다. 커널이 새 스레드를 위한 스택 메모리를 할당한다(기본 1MB). 스레드 컨텍스트(레지스터, 프로그램 카운터, 스택 포인터)를 초기화한다. 스케줄러에 새 스레드를 등록한다. 이 모든 과정이 수 밀리초를 소비한다. 10밀리초만 소요되는 작업을 위해 스레드를 생성하면, 작업 자체보다 스레드 생성이 더 비싸다.

### 문제 2: 무제한 스레드 생성

웹 서버에 동시 요청 1000개가 들어오면 어떻게 되는가? 각 요청마다 스레드를 생성하면, 1000개의 OS 스레드가 생성된다. 각 스레드는 최소 1MB 스택을 소비하므로, 1GB 메모리가 순식간에 소진된다. CPU 코어는 8개인데 1000개 스레드가 경쟁하면, 컨텍스트 스위칭 오버헤드로 인해 전체 시스템 성능이 급격히 저하된다.

### 문제 3: 생명주기 관리 복잡성

스레드가 예외로 종료되면 누가 처리하는가? 작업 완료 후 스레드를 정리해야 하는데 깜빡하면? 애플리케이션 종료 시 실행 중인 스레드를 안전하게 종료하려면 어떻게 하는가? 이 모든 것을 개발자가 직접 코드로 구현해야 한다.

**ExecutorService는 이 세 가지 문제를 해결하기 위해 Java 5에서 도입된 스레드 풀 관리 추상화다.** 개발자는 더 이상 스레드를 직접 생성하지 않으며, "작업"만 제출하면 프레임워크가 알아서 스레드 풀에서 실행한다.

---

## ExecutorService의 정의와 본질

### ExecutorService가 무엇인가

ExecutorService는 **Java의 인터페이스**다. `java.util.concurrent.ExecutorService`라는 전체 경로를 가지며, JDK 5부터 도입되었다. 인터페이스이므로 그 자체로는 인스턴스화할 수 없으며, 구현체가 필요하다. 가장 일반적인 구현체는 ThreadPoolExecutor다.

이 인터페이스의 본질은 **"개발자가 직접 스레드를 생성하고 관리하는 부담을 제거하고, 작업만 제출하면 알아서 실행해주는 서비스"**다.

### ExecutorService 구현체의 실제 구조

`Executors.newFixedThreadPool(3)`을 호출하면, 내부적으로 ThreadPoolExecutor 객체가 생성된다. 이 객체는 다음을 포함한다.

**워커 스레드 배열**: 실제로는 HashSet으로 관리되는 Worker 객체들의 집합이다. 각 Worker는 Thread 객체를 포함하며, 이 Thread는 OS 스레드와 1:1로 매핑된다. `newFixedThreadPool(3)`을 호출하면 3개의 OS 스레드가 생성되며, 각 스레드는 생성 즉시 "작업을 기다리는 루프"에 진입한다.

**작업 큐**: BlockingQueue<Runnable> 타입의 필드다. 기본적으로 LinkedBlockingQueue가 사용되며, 이는 무제한 크기의 FIFO 큐다.(별도의 설정을 하지 않는다면 무제한 큐) 개발자가 `executor.execute(runnable)`을 호출하면, 이 runnable 객체는 이 큐에 삽입된다. 워커 스레드들은 이 큐에서 작업을 꺼내어 실행한다.

**스레드 풀 설정**: corePoolSize(최소 스레드 수), maximumPoolSize(최대 스레드 수), keepAliveTime(유휴 스레드 유지 시간) 같은 설정값들이 저장된다.(기본값 혹은 옵션 설정) newFixedThreadPool은 core와 maximum을 동일하게 설정하므로, 스레드 수가 고정된다.

---

## 본론: ExecutorService의 핵심 메커니즘

### 1. 스레드 풀: 스레드의 재사용

ExecutorService의 가장 일반적인 구현체인 ThreadPoolExecutor는 "스레드 풀"을 유지한다. 스레드 풀은 미리 생성된 워커 스레드들의 집합이며, 이 스레드들은 애플리케이션 시작 시점에 한 번만 생성되고, 이후 계속 재사용된다.

```java
ExecutorService executor = Executors.newFixedThreadPool(3); // ThreadPoolExecutor 구현체 반환.
```

이 코드가 실행되면 정확히 무슨 일이 일어나는가?

#### 단계 1: ThreadPoolExecutor 객체 생성

`Executors.newFixedThreadPool(3)`은 실제로는 다음 코드의 축약형이다.

```java
new ThreadPoolExecutor(
    3,                              // corePoolSize: 최소 스레드 수
    3,                              // maximumPoolSize: 최대 스레드 수
    0L,                             // keepAliveTime: 유휴 시간
    TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue<>()     // workQueue: 작업 큐
)
```

이 객체가 생성되면 내부에 두 가지 핵심 구조가 만들어진다.

#### 단계 2: 워커 스레드 배열 생성

ThreadPoolExecutor는 내부에 `HashSet<Worker>`라는 필드를 가진다. Worker는 실 작업 단위인 Thread 객체를 감싼 래퍼 클래스다. corePoolSize가 3이므로, 3개의 Worker 객체가 생성되고, 각 Worker는 실제 OS 스레드를 생성한다. 이 시점에서 `pthread_create` 같은 시스템 콜이 3번 호출되며, 3개의 네이티브 스레드가 OS 커널에 등록된다.

생성된 3개의 스레드는 즉시 "작업 대기 루프"에 진입한다. 이 루프는 다음과 같다.

```java
// Worker 스레드의 실제 로직 (단순화)
while (스레드 종료 안 됨) {
    Runnable task = workQueue.take();  // 작업 큐에서 꺼내기 (블로킹)
    task.run();                        // 작업 실행
}
```

`workQueue.take()`는 블로킹 메서드다. 큐가 비어 있으면, 이 메서드는 반환하지 않고 스레드를 대기 상태로 전환한다. 내부적으로 `LockSupport.park()`를 호출하여 스레드를 OS 레벨에서 WAITING 상태로 만든다. 이 상태에서 스레드는 CPU를 전혀 사용하지 않는다.

#### 단계 3: 작업 큐 생성

LinkedBlockingQueue가 생성된다. 이것은 무제한 크기의 FIFO 큐다. 개발자가 제출하는 모든 작업(Runnable 객체)은 이 큐에 삽입된다. 이 큐는 생산자-소비자 패턴의 핵심이다. 개발자(생산자)는 작업을 큐에 넣고, 워커 스레드(소비자)는 큐에서 작업을 꺼내어 실행한다.

#### 스레드 재사용의 의미

이 메커니즘의 핵심은 **스레드가 한 번 생성된 후 절대 파괴되지 않고 계속 재사용**된다는 것이다.

```java
for (int i = 0; i < 100; i++) {
    executor.execute(() -> performTask());
}
```

이 코드를 실행하면, 100개의 작업이 제출되지만 스레드는 여전히 3개다. 3개의 워커 스레드가 100개의 작업을 번갈아가며 처리한다. 각 스레드는 작업 하나를 완료한 후 즉시 다음 작업을 큐에서 꺼내어 실행한다. 스레드 생성 비용은 애플리케이션 시작 시 단 한 번만 발생하며, 이후 모든 작업은 기존 스레드를 재사용한다.

이로써 **스레드 생성 비용이 작업 처리 경로에서 완전히 제거**된다.

---

### 2. 작업 큐: 제출과 실행의 분리

ExecutorService는 "작업 제출"과 "작업 실행"을 시간적으로 분리한다. 개발자가 `executor.execute(runnable)`을 호출하면, 이 Runnable 객체는 내부 작업 큐에 삽입된다. 작업 큐는 전형적인 생산자-소비자 패턴의 큐이며, 대부분의 구현에서 LinkedBlockingQueue가 사용된다.

작업 제출자(예: HTTP 요청 처리 스레드)는 Runnable을 큐에 넣는 순간 즉시 반환된다. 실제 작업 실행은 워커 스레드가 알아서 처리한다. 워커 스레드는 큐를 지속적으로 모니터링하며, 새 작업이 도착하면 깨어나서 실행한다. 큐가 비어 있으면 `LockSupport.park()`를 통해 OS 레벨에서 대기 상태로 전환되어, CPU를 전혀 소비하지 않는다.

이 분리는 **비동기성의 첫 번째 구현**이다. 작업을 제출하는 행위 자체가 블로킹되지 않으므로, 제출자 스레드(main 스레드 등)는 즉시 다른 일을 할 수 있다. 실제 작업 실행은 워커 스레드의 독립적인 실행으로 이루어진다.

---

### 3. 리소스 제한: Bounded Parallelism

ExecutorService의 세 번째 핵심은 **병렬성을 명시적으로 제한**한다는 것이다. `newFixedThreadPool(3)`은 최대 3개의 작업만 동시에 실행할 수 있다. 4번째 작업이 제출되면, 이 작업은 큐에서 대기하며, 기존 작업 중 하나가 완료되어야 실행된다.

이 제한이 갖는 의미는 명확하다. 요청이 1000개 들어와도, 실제로 실행되는 작업은 최대 3개다. 나머지 997개는 큐에서 대기한다. 따라서 메모리 소비는 "큐 크기 + 3개 스레드의 스택"으로 제한되며, 무제한 스레드 생성으로 인한 시스템 고갈이 원천적으로 방지된다.

단, 이는 처리량(throughput)을 제한한다는 의미이기도 하다. 3개 스레드가 모두 블로킹 I/O로 대기 중이라면, 새로운 작업은 기존 작업이 완료될 때까지 실행조차 시작되지 못한다. 이것이 블로킹 I/O 환경에서 스레드 풀 크기를 신중하게 결정해야 하는 이유다.

---

### 4. 워커 스레드의 실행 루프

워커 스레드가 실제로 하는 일은 다음과 같다. 스레드가 생성되면 무한 루프에 진입한다. 루프 안에서 작업 큐의 `take()` 메서드를 호출한다. 이 메서드는 블로킹 호출이므로, 큐가 비어 있으면 스레드는 대기 상태로 전환된다. 누군가 새 작업을 큐에 넣으면, 대기 중인 워커 스레드 중 하나가 깨어난다. 깨어난 스레드는 Runnable을 꺼내어 `run()` 메서드를 호출한다. 이 호출은 동기적이며, run()이 반환될 때까지 워커 스레드는 해당 작업에 전념한다. 만약 run() 내부에서 네트워크 I/O 같은 블로킹 작업이 있다면, 워커 스레드는 OS 레벨에서 블로킹되어 CPU를 소비하지 않는다. run()이 반환되면, 워커 스레드는 다시 큐에서 다음 작업을 가져오는 루프 시작점으로 돌아간다.

이 루프는 `executor.shutdown()`이 호출될 때까지 계속된다. shutdown 호출 시, 워커 스레드들은 큐의 남은 작업을 모두 처리한 후 루프를 빠져나오고 종료된다.

---

## 작업 제출: execute()의 동작

개발자가 작업을 제출하면 무슨 일이 일어나는가?

```java
executor.execute(() -> {
    System.out.println("작업 실행");
});
```

### 단계 1: Runnable 객체 래핑

람다 표현식 `() -> { System.out.println("작업 실행"); }`은 Runnable 인터페이스의 인스턴스로 변환된다. 이것은 일반 Java 객체이며, 메모리의 힙 영역에 할당된다.

### 단계 2: 작업 큐에 삽입

`executor.execute(runnable)`이 호출되면, 이 Runnable 객체는 workQueue에 삽입된다.

```java
// ThreadPoolExecutor.execute()의 핵심 로직 (단순화)
public void execute(Runnable command) {
    workQueue.offer(command);  // 큐에 삽입
}
```

`offer()` 메서드는 즉시 반환된다. 큐가 무제한 크기이므로 삽입은 항상 성공한다. 이 시점에서 `execute()` 메서드는 반환되며, 호출자 스레드는 즉시 다음 코드로 진행한다. **작업은 아직 실행되지 않았다.** 단지 큐에 들어갔을 뿐이다.

### 단계 3: 대기 중인 워커 스레드 깨우기

큐에 새 작업이 삽입되면, 대기 중인 워커 스레드 중 하나가 깨어난다. 내부적으로 `LockSupport.unpark(thread)`가 호출되어, WAITING 상태의 스레드를 RUNNABLE 상태로 전환한다. OS 스케줄러는 이 스레드를 실행 가능 큐에 추가하고, CPU 코어가 가용해지면 실행한다.

### 단계 4: 워커 스레드의 작업 실행

깨어난 워커 스레드는 `workQueue.take()`에서 반환받은 Runnable을 실행한다.

```java
Runnable task = workQueue.take();  // 큐에서 꺼냄
task.run();                        // 실행
```

`task.run()`은 동기 호출이다. 이 메서드가 반환될 때까지 워커 스레드는 해당 작업에 전념한다. 만약 run() 내부에서 네트워크 I/O 같은 블로킹 작업이 있다면, 워커 스레드는 OS 레벨에서 블로킹되어 CPU를 소비하지 않는다. run()이 반환되면, 워커 스레드는 다시 루프 시작점으로 돌아가 `workQueue.take()`를 호출하여 다음 작업을 기다린다.

---

## submit() : 결과 추적 메커니즘

### execute()와 submit()의 구조적 차이점

`execute()`는 작업을 제출하지만 그 작업의 결과나 완료 상태를 추적할 방법을 제공하지 않는다. 작업이 예외를 던져도 호출자는 이를 알 수 없으며, 작업이 언제 완료되었는지도 확인할 수 없다. 이는 "fire-and-forget(발사 후 망각)" 패턴으로, 작업 제출과 그 결과에 대한 관심사를 완전히 분리한다.

하지만 실무에서는 작업의 결과값을 받아야 하거나, 작업이 성공적으로 완료되었는지 확인해야 하는 경우가 빈번하다. 데이터베이스 쿼리 결과, HTTP 응답 본문, 계산된 집계 값 등을 워커 스레드로부터 받아야 한다. 이를 위해 ExecutorService는 `submit()` 메서드를 제공한다.

```java
Future<Integer> future = executor.submit(() -> {
    return expensiveComputation();
});
Integer result = future.get();  // 작업 완료 대기 및 결과 획득
```

`submit()`의 핵심은 **작업 실행과 결과 추적을 분리하면서도, 호출자가 필요한 시점에 결과에 접근할 수 있는 참조 핸들을 제공**한다는 것이다.

---

### Callable과 Runnable의 타입 시스템 차이

`execute()`는 Runnable만 받지만, `submit()`은 Callable과 Runnable 모두를 받는다.

```java
// Runnable: 반환값 없음
public interface Runnable {
    void run();
}

// Callable: 반환값과 예외 선언
public interface Callable<V> {
    V call() throws Exception;
}
```

Runnable의 `run()` 메서드는 void를 반환하므로, 작업이 계산한 결과를 호출자에게 전달할 방법이 없다. 공유 변수에 쓰는 방식은 가능하지만, 이는 스레드 안전성 문제를 야기하고 코드를 복잡하게 만든다.

Callable의 `call()` 메서드는 제네릭 타입 V를 반환하며, checked exception을 선언할 수 있다. 이는 작업이 실패할 수 있음을 타입 시스템 수준에서 명시적으로 표현한다. 작업의 결과와 예외를 모두 캡슐화할 수 있는 구조다.

---

### FutureTask: 작업과 결과의 결합

`submit(Callable<T> task)`가 호출되면, ExecutorService는 내부적으로 이 Callable을 **FutureTask**로 래핑한다.

```java
// ExecutorService.submit()의 내부 구조 (단순화)
public <T> Future<T> submit(Callable<T> task) {
    RunnableFuture<T> ftask = new FutureTask<>(task);
    execute(ftask);  // FutureTask를 작업 큐에 삽입
    return ftask;    // Future 참조 반환
}
```

FutureTask는 특수한 클래스다. Runnable과 Future 인터페이스를 동시에 구현한다.

```java
public class FutureTask<V> implements RunnableFuture<V> {
    private volatile int state;      // 작업 상태 (NEW, COMPLETING, NORMAL, EXCEPTIONAL)
    private Callable<V> callable;    // 실제 작업
    private Object outcome;          // 결과 또는 예외
    private volatile Thread runner;  // 실행 중인 워커 스레드
    
    public void run() {
        // 워커 스레드가 호출
        V result = callable.call();
        set(result);  // outcome 필드에 결과 저장
    }
    
    public V get() throws InterruptedException, ExecutionException {
        // 호출자 스레드가 호출
        awaitDone();  // 완료될 때까지 대기
        return outcome;
    }
}
```

이 설계의 핵심은 **하나의 객체가 두 가지 역할을 동시에 수행**한다는 것이다. Runnable로서 워커 스레드에 의해 실행되고, Future로서 호출자 스레드에게 결과 접근 인터페이스를 제공한다.

---

### 작업 제출과 실행의 상세 흐름

#### 단계 1: FutureTask 생성 및 큐 삽입

호출자 스레드(예: main)가 `submit()`을 호출한다.

```java
Future<Integer> future = executor.submit(() -> compute());
```

ExecutorService는 람다를 Callable로 변환하고, 이를 FutureTask로 래핑한다. 이 FutureTask 객체는 힙 메모리에 할당되며, 다음 필드들을 가진다.

- `callable`: 실제 작업 람다 참조
- `state`: NEW (아직 실행 안 됨)
- `outcome`: null (아직 결과 없음)
- `runner`: null (아직 실행 스레드 없음)

이 FutureTask는 내부적으로 `execute(ftask)`를 통해 작업 큐에 삽입된다. 이 시점에서 `submit()`은 즉시 반환되며, main 스레드는 FutureTask에 대한 Future 참조를 받는다.

#### 단계 2: 워커 스레드의 작업 실행

큐에서 대기하던 워커 스레드(예: pool-1-thread-1)가 FutureTask를 꺼내어 `run()` 메서드를 호출한다.

```java
// 워커 스레드가 실행
FutureTask ftask = workQueue.take();
ftask.run();  // 동기 호출
```

FutureTask의 `run()` 메서드 내부에서 다음이 발생한다.

```java
public void run() {
    this.runner = Thread.currentThread();  // 워커 스레드 기록
    try {
        V result = callable.call();  // 실제 작업 실행
        set(result);                 // 결과 저장
    } catch (Throwable ex) {
        setException(ex);            // 예외 저장
    }
}

private void set(V v) {
    this.outcome = v;
    this.state = NORMAL;  // 상태를 완료로 변경
    finishCompletion();   // 대기 중인 스레드들 깨우기
}
```

`callable.call()`이 값을 반환하면, 이 값은 FutureTask의 `outcome` 필드에 저장된다. 동시에 `state`가 NORMAL로 변경되며, `finishCompletion()`이 호출되어 이 결과를 기다리고 있는 모든 스레드를 깨운다.

#### 단계 3: 호출자 스레드의 결과 획득

main 스레드가 `future.get()`을 호출한다.

```java
Integer result = future.get();  // 블로킹 대기
```

`get()` 메서드는 FutureTask의 상태를 확인한다. 상태가 아직 NEW나 COMPLETING이라면, 현재 스레드를 대기 큐에 추가하고 `LockSupport.park()`를 호출하여 OS 레벨에서 WAITING 상태로 전환한다. 워커 스레드가 작업을 완료하여 `finishCompletion()`을 호출하면, 대기 중인 main 스레드가 `LockSupport.unpark()`로 깨어난다. 깨어난 main 스레드는 `outcome` 필드를 읽어 결과를 반환받는다.

```java
public V get() throws InterruptedException, ExecutionException {
    int s = state;
    if (s <= COMPLETING)
        s = awaitDone(false, 0L);  // 완료될 때까지 park
    return report(s);  // outcome 반환
}

private V report(int s) throws ExecutionException {
    Object x = outcome;
    if (s == NORMAL)
        return (V)x;  // 정상 결과 반환
    if (s >= CANCELLED)
        throw new CancellationException();
    throw new ExecutionException((Throwable)x);  // 예외 전달
}
```

---

### 예외 처리의 구조적 차이

`execute()`로 제출된 작업이 예외를 던지면, 이 예외는 워커 스레드의 UncaughtExceptionHandler로 전달된다. 기본적으로 이는 System.err로 스택 트레이스를 출력하지만, 호출자는 이를 감지할 방법이 없다.

```java
executor.execute(() -> {
    throw new RuntimeException("오류 발생");  
    // 워커 스레드에서 예외 발생, main은 모름
});
```

`submit()`으로 제출된 작업이 예외를 던지면, 이 예외는 FutureTask의 `outcome` 필드에 저장된다. 상태는 EXCEPTIONAL로 변경되며, 호출자가 `get()`을 호출할 때 ExecutionException으로 래핑되어 재전달된다.

```java
Future<?> future = executor.submit(() -> {
    throw new RuntimeException("오류 발생");
});

try {
    future.get();
} catch (ExecutionException e) {
    Throwable cause = e.getCause();  // 원본 RuntimeException 획득
}
```

이는 **예외를 스레드 경계를 넘어 전달**할 수 있게 한다. 워커 스레드에서 발생한 예외가 호출자 스레드로 투명하게 전파되며, 호출자는 마치 동일 스레드에서 발생한 예외처럼 처리할 수 있다.

---

### submit(Runnable)의 특수한 동작

`submit()`은 Runnable도 받을 수 있다.

```java
Future<?> future = executor.submit(() -> {
    System.out.println("작업 실행");
});
future.get();  // 반환값은 null, 단지 완료 대기용
```

이 경우 내부적으로 Runnable을 Callable로 어댑트한다.

```java
// Executors.callable() 내부
static <T> Callable<T> callable(Runnable task, T result) {
    return () -> {
        task.run();
        return result;  // 고정된 결과값 반환
    };
}
```

이 어댑터는 Runnable의 `run()`을 실행한 후 null(또는 지정된 결과값)을 반환한다. `Future<?>`의 `get()`은 작업의 완료를 보장하지만, 의미 있는 결과값을 제공하지는 않는다. 이는 "작업이 끝났는지만 확인하고 싶을 때" 유용하다.

---

### 설계적 의의: 동기성과 비동기성의 조화

`submit()`과 Future는 **비동기 실행과 동기적 결과 획득을 조화**시킨다. 작업 제출은 논블로킹이며, 워커 스레드가 독립적으로 실행한다. 하지만 호출자는 필요한 시점에 `get()`을 호출하여 블로킹 방식으로 결과를 기다릴 수 있다.

이 이중성은 Java의 전형적인 설계 철학을 보여준다. 완전한 비동기(콜백 기반)도 아니고, 완전한 동기(직접 실행)도 아닌, 중간 지점에서 개발자에게 선택권을 준다. 작업은 비동기로 실행되지만, 결과는 동기적 API로 접근한다.

이 패턴의 한계는 `get()`이 호출자 스레드를 블로킹한다는 것이다. 서버 환경에서 HTTP 요청 처리 스레드가 `future.get()`을 호출하면, 그 스레드는 워커의 작업 완료까지 블로킹되어 다른 요청을 처리할 수 없다. 이는 CompletableFuture와 리액티브 스트림 같은 논블로킹 완료 통지 메커니즘이 등장한 배경이다.

---

## 생명주기 관리와 종료 메커니즘

애플리케이션 종료 시 ExecutorService를 정상적으로 종료해야 한다.

```java
executor.shutdown();  // 새 작업 거부, 기존 작업 완료 대기
executor.awaitTermination(60, TimeUnit.SECONDS);  // 최대 60초 대기
```

`shutdown()` 호출 시 다음이 일어난다. 새 작업 제출을 거부한다. `execute()` 호출 시 RejectedExecutionException이 발생한다. 큐에 남아 있는 작업들은 계속 처리된다. 모든 작업이 완료되면 워커 스레드들이 루프를 빠져나와 종료된다.

이 메커니즘은 개발자가 직접 스레드를 관리할 때 발생하는 "좀비 스레드" 문제를 해결한다. 프레임워크가 모든 스레드의 생명주기를 추적하고 정상 종료를 보장한다.

---

## 결론: ExecutorService가 제공하는 설계적 의의

ExecutorService는 스레드 관리의 복잡성을 개발자로부터 프레임워크로 이전했다. 개발자는 더 이상 "몇 개의 스레드를 생성할 것인가", "스레드를 언제 종료할 것인가"를 고민하지 않는다. 대신 "스레드 풀 크기는 얼마로 할 것인가"라는 설계 결정만 내리면, 나머지는 프레임워크가 담당한다.

이 추상화가 갖는 아키텍처적 의의는, **동시성 프로그래밍의 관심사가 "스레드 생명주기 관리"에서 "작업 단위 설계"로 이동**했다는 것이다. 스레드는 더 이상 개발자가 명시적으로 다루는 대상이 아니며, 시스템 리소스를 효율적으로 사용하기 위한 프레임워크 내부 구현 세부사항으로 캡슐화되었다.

단, ExecutorService는 여전히 블로킹 I/O를 전제로 설계되었다는 한계가 있다. 워커 스레드가 네트워크 응답을 기다리며 블로킹되는 동안, 해당 스레드는 다른 작업을 처리할 수 없다. 따라서 I/O 바운드 애플리케이션에서는 스레드 풀 크기를 충분히 크게 설정해야 하며, 이는 결국 메모리 소비와 컨텍스트 스위칭 비용을 증가시킨다. 이 한계를 극복하는 것이 Reactor Netty 같은 non-blocking I/O 프레임워크의 목표다.

---

## 구글링 키워드

```
java executorservice tutorial
java thread pool explained
executorservice vs thread
how to use executorservice java
java executorservice examples
executorservice shutdown properly
```

---

## 실용 문서 링크

**1. Baeldung - ExecutorService 완전 가이드**
```
https://www.baeldung.com/java-executor-service-tutorial
```
실전 예제 중심으로 설명. newFixedThreadPool, submit, shutdown 사용법을 코드와 함께 제공.

**2. Jakob Jenkov - Java ExecutorService**
```
http://tutorials.jenkov.com/java-util-concurrent/executorservice.html
```
그림과 함께 스레드 풀 개념 설명. 워커 스레드와 작업 큐의 관계를 시각화.

**3. Vogella - Java Concurrency 튜토리얼**
```
https://www.vogella.com/tutorials/JavaConcurrency/article.html
```
독일 개발자가 작성한 종합 가이드. ExecutorService 섹션에서 실무 패턴 제공.

**4. DigitalOcean - ExecutorService 가이드**
```
https://www.digitalocean.com/community/tutorials/java-executor-service
```
초보자 친화적 설명. 각 메서드의 용도를 간단한 예제로 설명.