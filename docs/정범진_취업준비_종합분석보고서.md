# 정범진 취업 준비 현황 종합 분석 보고서

---

## 제1장 서론: 현재 상황 진단

### 1.1 분석 대상자 프로필

정범진은 27세의 한국방송통신대학교 컴퓨터과학과 재학생으로, Java Spring Boot 기반 백엔드 개발자를 목표로 취업을 준비하고 있다. 주요 기술 역량은 동시성 제어, 데이터베이스 최적화, 캐싱 전략 설계이며, 워터월시스템즈에서 10개월간 DLP 솔루션 기술지원 업무를 수행한 경력이 있다.

### 1.2 현재 직면한 문제

서류 전형에서 반복적으로 탈락하고 있다. 동일한 프로젝트(Wherehouse)를 수행한 팀원 이재서는 서류를 통과하고 면접까지 도달하는 반면, 정범진은 서류 단계에서 탈락이 반복된다. 이 차이의 원인을 분석하고 해결 방향을 제시하는 것이 본 보고서의 목적이다.

### 1.3 분석 범위

본 보고서는 다음 영역을 분석한다: 기술 역량의 깊이와 넓이, 포트폴리오 프로젝트 상세 분석, 서류 전형 메커니즘과 탈락 원인, 시장 요구사항과의 적합성, 경쟁 구도(2년차 개발자, 이재서와의 비교), 심리적 상태와 행동 패턴, 종합 진단 및 권장 방향.

---

## 제2장 기술 역량 분석

### 2.1 현재 보유 역량: 깊이(Depth) 영역

#### 2.1.1 동시성 제어

정범진은 4가지 동시성 제어 메커니즘(IF-ELSE, Synchronized, ReentrantLock, Semaphore)에 대한 심층 분석을 수행했다. 200개 스레드, 2,000건 요청 기반 부하 테스트 환경을 구축하고, System.nanoTime() 기반 나노초 정밀도 측정 시스템을 개발하여 미세한 동시성 현상을 관찰했다.

핵심 성과는 다음과 같다. Semaphore가 Synchronized 대비 15% 빠른 성능(413.1μs vs 486.4μs)을 실증적으로 검증했다. ReentrantLock 대비 6배 빠른 성능(413.1μs vs 2,464.7μs)을 확인했다. 정원 초과 방지 0% 오류율을 달성하여 비즈니스 규칙 100% 준수를 검증했다.

4가지 규칙 기반 Python 분석 스크립트를 개발하여 체계적인 검증 도구 체계를 구축했다. 규칙 1은 값 불일치(Lost Update), 규칙 2는 경합 발생(Contention Detection), 규칙 3은 정원 초과(Capacity Exceeded), 규칙 4는 상태 전이 오류(State Transition Error)를 탐지한다.

Semaphore의 계층적 일관성 모델을 새롭게 실증했다. 1단계 비즈니스 규칙은 100% 완벽 보장되고, 2단계 동시 실행은 48.7% 활용률로 성능 최적화되며, 3단계 내부 데이터 일관성은 부분적 보장으로 트레이드오프를 관리한다. 기존의 "성능 vs 안전성" 이분법을 넘어선 제3의 패러다임을 제시했다.

#### 2.1.2 데이터베이스 최적화

Oracle 동적 성능 뷰(V$SQL, V$SYSSTAT, V$SQL_PLAN)를 활용한 실행계획 분석 역량을 보유하고 있다. N+1 쿼리 문제를 Bulk Fetch로 해결한 후, IN절 1,000개 제한에 대응하는 Chunking 전략을 개발했다.

N+1 최적화 성과를 보면, 원본(Origin) 방식은 25회 순차 호출로 5,531ms가 소요되었다. Bulk Fetch 적용 후 1회 호출로 변경되었으나 6,001ms로 오히려 증가했다. Chunk 61 적용 후 9회 분할 호출로 4,434ms를 달성하여 Origin 대비 19.8% 개선, Bulk 대비 26.1% 개선을 이루었다.

3가지 Chunk 크기(1000, 22, 61) 비교 실험을 통해 Full Scan 전환 임계점을 검증했다. Chunk 1000은 TABLE ACCESS FULL 실행계획으로 Cost 191, 응답 시간 178ms를 기록했다. Chunk 22는 INDEX UNIQUE SCAN으로 Cost 27이지만 Connection 경합 심각(waiting ≥7 비율 47.9%)했다. Chunk 61은 INDEX UNIQUE SCAN으로 Cost 68, 심각 경합 비율 0%, 응답 시간 318ms로 확장성과 안정성의 균형점을 달성했다.

Hard Parse와 Soft Parse의 차이를 이해하고, Library Cache 재사용 전략을 설계했다. Bulk Fetch 적용 시 20개 요청이 20개의 서로 다른 SQL_ID를 생성하여 Library Cache 재사용이 전무했던 문제를 Chunk 크기 고정을 통해 SQL 템플릿을 통일하여 해결했다.

#### 2.1.3 캐싱 전략

Redis를 활용한 CQRS + Write-Through 캐시 아키텍처를 설계했다. 배치 처리(Command 경로)에서는 Oracle에 원본 데이터를 저장하고 Redis에 동기화한다. 실시간 조회(Query 경로)에서는 Redis Sorted Set을 활용하여 O(log N) 범위 검색을 수행한다.

Redis 데이터 구조별 활용을 보면, Sorted Set은 안전성/편의성 점수 기반 범위 검색에 사용하고, Hash는 매물 상세 정보 저장에 사용하며, Set 교집합 연산(SINTER)은 다중 조건 필터링에 활용한다.

이원화 캐시 전략을 적용하여 전체 지도 데이터는 24시간 TTL로, 선택 지역 데이터는 1시간 TTL로 관리한다. 캐싱 적용 후 평균 응답 속도 35% 단축, SQL 쿼리 호출 99% 감소를 달성했다.

#### 2.1.4 비동기 처리

CompletableFuture + 전용 I/O ThreadPool(20개)을 활용한 병렬 처리를 구현했다. Kakao Map API 15개 카테고리 순차 호출 시 1,324ms가 소요되던 것을 병렬화하여 367ms로 72.3% 단축했다.

#### 2.1.5 인증/보안

JWT + HttpOnly Cookie + HTTPS 기반 Stateless 인증 시스템을 구현했다. Spring Security FilterChain을 경로별로 분리하고, AuthenticationEntryPoint와 AccessDeniedHandler를 커스터마이징하여 인증/인가 실패 시나리오를 체계적으로 제어했다. XSS 방어(HttpOnly 쿠키), CSRF 방어(SameSite 속성), CSP 헤더 설정을 통한 보안 강화를 달성했다.

### 2.2 부족한 영역: 넓이(Breadth) 영역

#### 2.2.1 테스트 코드

포트폴리오 전체에서 JUnit, Mockito, 통합 테스트에 대한 언급이 없다. JMeter를 활용한 부하 테스트는 수행했으나, 이는 단위 테스트/통합 테스트와는 다른 영역이다.

현대 백엔드 개발에서 테스트 코드 작성 능력은 거의 필수로 취급된다. 면접에서 "테스트 코드를 어떻게 작성하는가"라는 질문은 높은 확률로 등장한다. 부트캠프 출신 지원자들은 대부분 JUnit + Mockito를 사용한 서비스 레이어 테스트, @SpringBootTest를 사용한 통합 테스트 정도는 포트폴리오에 포함하고 있다.

필요한 최소 구현 범위는 서비스 레이어 단위 테스트(Mockito로 Repository 모킹), 동시성 로직 테스트(CountDownLatch로 멀티스레드 테스트), 통합 테스트(@SpringBootTest)이다.

#### 2.2.2 Docker/컨테이너화

Docker, Docker Compose 사용에 대한 언급이 없다. 컨테이너화는 현대 백엔드 개발의 사실상 표준이다. 로컬 개발 환경 구성, 배포 환경 일관성 유지, Kubernetes로의 확장 등 모든 영역의 기반이 된다.

"이 프로젝트를 어떻게 실행하나요?"라는 질문에 "로컬에 Oracle과 Redis를 설치하고..."라고 답하면, 현대적인 개발 환경에 대한 이해가 부족해 보일 수 있다. README에 docker-compose up 한 줄로 실행 가능하다고 적혀 있으면 인상이 다르다.

필요한 최소 구현 범위는 Dockerfile(멀티스테이지 빌드), docker-compose.yml(애플리케이션 + Oracle/Redis), README에 docker-compose up으로 실행하는 방법 명시이다.

#### 2.2.3 CI/CD 파이프라인

GitHub Actions, Jenkins, GitLab CI 등 CI/CD 도구 사용에 대한 언급이 제한적이다. 실무에서 코드를 머지하면 자동으로 테스트가 실행되고, 통과하면 스테이징/프로덕션에 배포되는 파이프라인이 표준이다.

Jenkins + EC2 배포 경험이 있으나, GitHub Actions로 간단한 CI 파이프라인(빌드 + 테스트 실행)을 구성한 포트폴리오가 더 일반적이다. 고급 지원자는 Docker 이미지 빌드 + ECR 푸시 + ECS 배포까지 자동화한 경우도 있다.

#### 2.2.4 클라우드(AWS)

AWS EC2, RDS, S3, Lambda 등 클라우드 서비스 사용 경험이 명시적으로 드러나지 않는다. 대부분의 기업이 AWS, GCP, Azure 중 하나 이상을 사용한다. 클라우드 환경에 대한 기본적인 이해가 있으면 온보딩이 빠르다.

AWS 프리티어를 활용하여 EC2에 배포하고, RDS로 DB를 관리하고, S3에 정적 파일을 저장하는 구성은 부트캠프 출신 지원자들 사이에서 흔하다.

#### 2.2.5 메시지 큐

Kafka, RabbitMQ, Redis Pub/Sub 같은 메시지 브로커 경험이 없다. CompletableFuture로 비동기 처리를 했지만, 이는 단일 애플리케이션 내 비동기이지 시스템 간 비동기가 아니다. 마이크로서비스 아키텍처에서 서비스 간 통신, 이벤트 소싱, 비동기 작업 처리에 메시지 큐가 사용된다.

#### 2.2.6 모니터링/로깅

Prometheus, Grafana, ELK Stack 등 모니터링/로깅 도구 사용 경험이 없다. System.nanoTime() 기반 자체 측정 시스템을 구축한 것은 인상적이지만, 실무에서는 Micrometer + Prometheus로 커스텀 메트릭을 구성하고 Grafana 대시보드를 구축하는 것이 표준이다.

#### 2.2.7 API 문서화

Swagger UI, OpenAPI 스펙 작성에 대한 언급이 없다. 프론트엔드 개발자, 외부 클라이언트와 협업할 때 API 문서화는 필수다. Swagger 적용은 Spring Boot에서 의존성 추가와 어노테이션 몇 개로 가능하므로 비용 대비 효과가 좋다.

#### 2.2.8 분산 환경

모든 프로젝트가 단일 서버 환경이다. Semaphore 기반 동시성 제어는 JVM 내부에서만 작동한다. 서버가 2대가 되는 순간 이 설계는 무너진다. 면접에서 "이 Semaphore 기반 동시성 제어가 서버 2대에서도 작동하나요?"라는 질문이 나올 수 있다. 정직한 답은 "작동하지 않습니다"이고, 후속 답변으로 "Redis 기반 분산 락(Redisson)이나 DB 비관적 락을 사용해야 합니다"를 준비해야 한다.

### 2.3 기술 역량 종합 평가

정범진의 포트폴리오는 특정 영역(동시성 제어, DB 최적화)에서 2년차 평균을 상회한다. 대부분의 2년차 개발자가 실무에서 이 수준의 깊이로 파고들 기회가 없기 때문이다. 실무는 "동작하면 됨"의 압박 하에서 진행되므로, 4가지 동기화 메커니즘을 나노초 단위로 비교 분석하는 여유가 없다.

반면, 시장의 70~80%가 요구하는 Docker, AWS, CI/CD, 테스트 코드, MySQL/PostgreSQL에는 투자가 없다. 이건 "이 역량이 중요하지 않다"는 판단이 아니라, 학습 시간 배분의 결과다. 하지만 결과적으로, 포트폴리오가 시장의 주류 요구사항과 어긋나는 형태가 되었다.

---

## 제3장 포트폴리오 프로젝트 상세 분석

### 3.1 Wherehouse: 서울시 1인가구 주거지 추천 서비스

#### 3.1.1 프로젝트 개요

MZ세대 1인 가구 750만 시대에 주거 선택 시 정보 부재 문제를 해결하기 위한 서비스다. 안전성(CCTV, 범죄율)과 편의성(편의점, 약국 등) 기반으로 서울시 행정구 단위 주거지를 추천한다.

기술 스택은 Java 17, Spring Boot 3.x, Oracle Database, Redis, Jenkins, Docker이다. 개발 기간은 2023년 11월부터 2024년 3월까지 약 5개월이다.

#### 3.1.2 시스템 아키텍처

CQRS + Hybrid Storage 전략을 적용했다. Command 경로(배치)에서는 국토부 API에서 데이터를 수집하여 Oracle에 저장하고 Redis에 동기화한다. Query 경로(실시간)에서는 Redis Sorted Set을 활용하여 O(log N) 범위 검색을 수행하고, Zero DB 조회로 RTT를 최소화한다.

Write-Through 캐시 패턴을 적용하여 Oracle과 Redis 간 즉시 일관성을 보장한다. 배치 처리 시 Oracle 저장과 동시에 Redis에 동기화하여 캐시 정합성 문제를 해결했다.

#### 3.1.3 트러블슈팅 #1: 외부 API 병목 해결

문제는 Kakao Map API 15개 카테고리를 순차 호출하여 1,324ms가 소요되는 것이었다. 원인은 I/O 바운드 작업임에도 순차 처리로 인한 대기 시간 누적이었다.

해결책으로 CompletableFuture + 전용 I/O ThreadPool(20개)로 병렬화했다. 성과는 367ms로 72.3% 단축이었다.

#### 3.1.4 트러블슈팅 #2: N+1 쿼리 최적화

문제는 25개 행정구별 순차 조회로 인한 N+1 패턴 발생이었다. 25회 순차 호출로 5,531ms가 소요되었다.

1차 시도로 Bulk Fetch를 적용했으나 6,001ms로 오히려 증가했다. 원인 분석 결과, IN절 바인드 변수 개수가 가변적(54~1,000개)이어서 매 요청마다 Hard Parse가 발생했다. 20개 요청이 20개의 서로 다른 SQL_ID를 생성하여 Library Cache 재사용이 전무했다.

2차 시도로 Chunk 61 적용하여 4,434ms를 달성했다. Origin 대비 19.8% 개선, Bulk 대비 26.1% 개선이었다. Chunk 크기 고정으로 SQL 템플릿을 통일하여 Soft Parse를 유도했다.

#### 3.1.5 트러블슈팅 #3: Oracle IN절 Chunking 최적화

3가지 Chunk 크기(1000, 22, 61) 비교 실험을 수행했다. V$SQL_PLAN 실행계획 분석 결과, Chunk 1000은 TABLE ACCESS FULL로 전환되어 Cost 191이었다. Chunk 22/61은 INLIST ITERATOR + INDEX UNIQUE SCAN으로 Cost 27/68이었다.

Connection Pool 경합 분석 결과, Chunk 22는 HikariCP waiting 상태 최대 10, 심각 경합 비율(≥7) 47.9%였다. Chunk 61은 waiting 최대 4, 심각 경합 비율 0%였다.

최적 균형점으로 Chunk 61을 선정했다. Index Scan 유지(확장성)와 경합 해소(안정성)를 동시에 달성했다. 응답 시간은 Chunk 1000(178ms)보다 느리지만(318ms), Full Scan은 데이터 증가 시 O(N) 선형 저하되고 Index Scan은 O(log N)을 유지하므로 장기적 확장성을 선택했다.

#### 3.1.6 트러블슈팅 #4: Redis 기반 실시간 검색 엔진

Redis Sorted Set을 활용하여 안전성/편의성 점수 기반 범위 검색을 O(log N)으로 수행한다. ZRANGEBYSCORE 명령으로 점수 범위 필터링, SINTER 명령으로 다중 조건 교집합 연산을 수행한다.

성과는 Zero DB 조회로 RDB 부하 제거, 평균 응답 시간 35% 단축, SQL 쿼리 호출 99% 감소였다.

### 3.2 실시간 채팅 서비스

#### 3.2.1 프로젝트 개요

WebSocket + Redis 기반 실시간 채팅 서비스로, 동시성 제어와 Race Condition 해결을 핵심 목표로 한다. 단순 채팅 구현이 아닌 구조적 문제 해결이 목표였다.

기술 스택은 Java, Spring Boot, WebSocket, Redis, Semaphore이다.

#### 3.2.2 시스템 아키텍처

2-Phase Entry 아키텍처를 설계했다. Phase 1(Permit 획득)에서 SemaphoreRegistry가 동시성 제어를 담당하고, Phase 2(Session 등록)에서 ChatSessionRegistry가 세션 관리를 담당한다. 이 분리를 통해 관심사를 명확히 구분하고 각 단계의 실패를 독립적으로 처리할 수 있다.

핵심 클래스 구조는 SemaphoreRegistry(동시성 제어 permit 관리), ChatSessionRegistry(세션/상태 통합 관리), ChatTextWebSocketHandler(WebSocket 연결/해제), HighPrecisionTimestamp(나노초 정밀 측정)로 구성된다.

#### 3.2.3 동시성 제어 설계

기존 IF-ELSE 기반 동시성 제어에서 발생한 4가지 문제를 해결했다.

규칙 1 값 불일치(Lost Update)는 check-then-act 패턴의 비원자성으로 인해 currentCount 값이 실제와 불일치하는 문제였다. 규칙 2 경합 발생(Contention Detection)은 동일 시점에 동일 자원에 대한 다중 접근이 발생하는 문제였다. 규칙 3 정원 초과(Capacity Exceeded)는 최대 인원 10명 제한이 무시되는 문제였다. 규칙 4 상태 전이 오류(State Transition Error)는 JOIN → LEAVE 순서가 보장되지 않는 문제였다.

Semaphore.tryAcquire() 기반 원자적 제어를 도입하여 규칙 3(정원 초과)을 0%로 완벽 해결했다. 규칙 1, 2, 4는 Semaphore의 설계 철학상 "오류"가 아닌 "의도된 동시 실행 패턴"으로 재해석했다. 이것이 계층적 일관성 모델의 핵심이다.

#### 3.2.4 세션 누수 방지

문제는 WebSocket 비정상 종료 시 세션이 정리되지 않아 permit 누수가 발생하는 것이었다. 클라이언트가 연결을 끊어도 서버에서 세션이 유지되어 정원이 점진적으로 감소했다.

해결책으로 TTL 기반 자동 정리 메커니즘을 구현했다. 주기적 스케줄러가 만료 세션을 탐지하고 정리한다. afterConnectionClosed 핸들러에서 permit 반환을 보장한다.

### 3.3 동시성 테스트 보고서

#### 3.3.1 프로젝트 개요

4가지 동시성 제어 방식의 안전성과 성능을 정량적으로 분석하여 Semaphore의 계층적 일관성 모델을 실증 검증한 기술 분석 프로젝트다. 2025년 7월 약 4주간 수행했다.

#### 3.3.2 나노초 정밀도 측정 시스템

System.nanoTime() 기반 고정밀 측정 시스템을 개발했다. 기존 밀리초 단위로는 포착 불가능한 미세한 동시성 현상을 관찰할 수 있다. 15% 성능 차이까지 정확히 측정할 수 있는 측정 정밀도를 확보했다.

테스트 환경은 200개 스레드, 2,000건 요청, 49.5% 목표 성공률 조건이다. 각 요청의 대기 시간, 실행 시간, 총 처리 시간을 나노초 단위로 기록한다.

#### 3.3.3 4가지 규칙 기반 Python 분석 스크립트

각 동시성 제어 방식의 고유 특성을 정확히 측정하기 위한 맞춤형 분석 도구를 개발했다. 규칙 1(Lost Update) 탐지기는 예상 카운트와 실제 카운트의 불일치를 검출한다. 규칙 2(Contention) 탐지기는 동일 bin 내 중복 접근을 검출한다. 규칙 3(Capacity Exceeded) 탐지기는 정원 초과 이벤트를 검출한다. 규칙 4(State Transition) 탐지기는 JOIN/LEAVE 순서 위반을 검출한다.

Excel 다중 시트 자동 생성 시스템을 구축하여 Overall_Summary, Per_Room_Stats, Per_Bin_Stats, Per_Thread_Details 등 재현 가능한 분석 워크플로우를 확립했다.

#### 3.3.4 성능 비교 결과

성공 케이스 처리 시간(평균)을 보면, Semaphore는 413.1μs로 기준이 된다. Synchronized는 486.4μs로 Semaphore 대비 15% 느리다. ReentrantLock은 2,464.7μs로 6배 느리다. IF-ELSE는 189.0μs로 가장 빠르지만 동시성 제어가 없다.

실패 케이스 처리 시간(총합)을 보면, Semaphore는 980,716.9μs이다. ReentrantLock은 4,304,135.2μs로 Semaphore 대비 4.4배 느리다. Semaphore의 tryAcquire 패턴이 즉각적인 실패 처리를 통해 시스템 안정성을 확보한다.

규칙 위반율을 보면, IF-ELSE는 규칙 1~4 모두 위반 발생한다. Synchronized는 규칙 3(정원 초과) 0% 달성, 그러나 "비생산적 점유" 문제 발생한다. ReentrantLock은 규칙 3(정원 초과) 0% 달성, 그러나 성능 저하 심각하다. Semaphore는 규칙 3(정원 초과) 0% 달성, 성능 최적화 달성이다.

#### 3.3.5 계층적 일관성 모델

Semaphore의 3단계 일관성 보장 체계를 규명했다.

1단계 비즈니스 규칙(정원 초과 방지)은 100% 완벽 보장된다. tryAcquire()의 CAS 기반 원자적 연산으로 달성한다.

2단계 동시 실행(Contention)은 48.7% 활용률로 성능 최적화된다. "오류"가 아닌 "의도된 동시 실행 패턴"으로 재정의했다.

3단계 내부 데이터 일관성(Lost Update, State Transition)은 부분적 보장으로 트레이드오프를 관리한다. 필요 시 AtomicInteger 등 추가 동기화로 보완 가능하다.

기존의 "완벽한 일관성 vs 성능" 이분법을 넘어선 제3의 패러다임을 제시했다. 비즈니스 요구에 따른 유연한 일관성 수준 선택이 가능하다.

---

## 제4장 서류 전형 메커니즘 분석

### 4.1 서류 검토자의 정체와 제약 조건

대부분의 기업에서 서류 1차 검토는 HR 담당자가 수행한다. 개발팀 리드나 CTO가 아니다. HR 담당자는 다음과 같은 제약 하에서 일한다.

시간 제약을 보면, 채용 공고 하나에 수백 개의 이력서가 들어온다. 담당자 한 명이 하루에 검토할 수 있는 이력서 수는 제한적이다. 이력서 하나당 평균 검토 시간은 30초~2분 사이로 알려져 있다. 이 시간 안에 36페이지짜리 동시성 테스트 보고서를 읽을 수 없다.

기술적 배경 부재를 보면, HR 담당자는 대부분 비개발직군 출신이다. "Semaphore가 Synchronized보다 15% 빠르다"는 문장의 의미를 평가할 역량이 없다. 그들이 할 수 있는 건 "Spring Boot 사용 여부", "프로젝트 개수", "GitHub 링크 유무" 같은 체크리스트 기반 검토다.

평가 기준의 표준화를 보면, 대기업일수록 채용 프로세스가 표준화되어 있다. 주관적 판단을 최소화하고 객관적 지표(학력, 자격증, 경력 연수)로 1차 필터링을 한다. 이건 공정성을 위한 것이기도 하고, 대량의 지원자를 효율적으로 처리하기 위한 것이기도 하다.

### 4.2 필터링의 순서와 구조

서류 전형은 대략 다음 순서로 진행된다.

1단계 자격 요건 충족 여부에서 약 90%가 탈락한다. 학력 요건 충족 여부, 전공 관련성, 필수 기술 스택 보유 여부, 경력 요건 충족 여부(신입의 경우 인턴/프로젝트 경험)를 검토한다. 이 단계에서 대부분의 탈락이 발생한다. 포트폴리오 내용은 이 단계에서 검토되지 않거나, "있다/없다" 수준으로만 확인된다.

2단계 상대 평가에서 상위 후보를 선별한다. 1단계를 통과한 지원자들 중에서 면접 대상을 선별한다. 이 단계에서 포트폴리오 내용이 일부 고려될 수 있지만, 여전히 학력, 인턴 경험, 수상 경력 같은 객관적 지표가 우선한다.

3단계 기술 검토는 일부 기업만 수행한다. 기술팀 리드가 포트폴리오를 검토하는 단계다. 모든 기업이 이 단계를 두지는 않는다. 있더라도 2단계를 통과한 소수의 후보에 대해서만 수행된다.

### 4.3 정범진의 서류가 탈락하는 지점

정범진의 이력서가 1단계 필터에서 어떻게 처리되는지 시뮬레이션하면 다음과 같다.

자격 요건 체크리스트를 보면, 학력은 4년제 대학 재학(방통대)으로 "졸업 예정자 아님" 또는 "비주류 학교"로 분류될 가능성이 있다. 전공은 컴퓨터공학으로 충족한다. 기술 스택은 Java, Spring Boot, JPA, Redis로 충족한다. 인턴/실무 경험은 없어서 미충족이다. 관련 자격증은 있다. 포트폴리오는 있어서 충족하지만 내용은 미검토된다.

HR 담당자 입장에서 이 체크리스트를 보면, "인턴 경험 없음"이라는 항목에서 우선순위가 낮아진다. 동일한 체크리스트에서 인턴 경험이 있는 지원자가 있다면, 그 지원자가 먼저 선택된다. 포트폴리오의 기술적 깊이는 이 판단에 거의 영향을 미치지 않는다.

### 4.4 포트폴리오 품질과 서류 통과율의 비선형 관계

포트폴리오 품질과 서류 통과 확률 사이에는 수확 체감(Diminishing Returns) 관계가 존재한다.

구간 A에서 B로의 전환, 즉 포트폴리오가 아예 없는 상태에서 "뭐라도 있는" 상태로 전환하면 서류 통과 확률이 급격히 상승한다. 많은 기업이 "포트폴리오 필수"를 자격 요건으로 두기 때문이다.

구간 B에서 C로의 전환, 즉 CRUD 수준에서 기술적 깊이가 있는 수준으로 전환하면 서류 통과 확률이 상승하지만, 기울기가 완만해진다. 1단계 필터에서 포트폴리오 "내용"이 아닌 "유무"만 체크되는 경우가 많기 때문이다.

구간 C에서 D로의 전환, 즉 이미 충분한 수준에서 더 높은 수준으로 전환하면 서류 통과 확률 상승폭이 미미해진다. 36페이지 보고서를 72페이지로 늘려도, HR 담당자는 여전히 읽지 않는다.

정범진의 현재 위치는 구간 C다. 동시성 제어의 본질적 이해, V$SQL 기반 실행계획 분석, 정량적 검증은 "CRUD 수준"을 넘어섰다. 문제는 구간 C에서 구간 D로 가는 투자 대비 효과가 낮다는 것이다.

같은 시간을 투자할 때, 포트폴리오에 분산 락 구현, Kafka 도입, Kubernetes 배포 등을 추가하는 것보다, 100개 기업에 추가 지원하는 것이 면접 기회를 더 많이 확보할 수 있다.

### 4.5 포트폴리오가 직접 평가되는 예외 상황

다음 상황에서는 포트폴리오 품질이 서류 통과에 직접적으로 영향을 미친다.

기술 중심 소규모 스타트업의 경우, CTO나 테크 리드가 직접 서류를 검토한다. GitHub 코드를 직접 읽고 평가한다. 이 경우 기술적 깊이가 차별화 포인트가 된다.

개발자 커뮤니티 기반 채용의 경우, 블라인드, LinkedIn, 개발자 밋업 등에서 직접 연락이 온다. 포트폴리오나 기술 블로그를 보고 연락하는 것이므로 기술적 깊이가 중요하다.

내부 추천의 경우, 재직자가 이력서를 직접 전달하고 추천한다. HR 필터를 우회하므로 포트폴리오가 제대로 평가받는다.

이 세 경우가 아니면, 대부분의 정형화된 채용 프로세스에서 포트폴리오 품질은 서류 통과에 제한적인 영향을 미친다.

---

## 제5장 시장 적합성 분석

### 5.1 채용 공고의 실제 키워드 분석

원티드, 프로그래머스, 잡코리아에서 "백엔드 신입" 또는 "백엔드 주니어"로 검색하면 반복적으로 등장하는 요구사항이 있다.

거의 모든 공고에 있는 것은 Java/Spring Boot, RDBMS(MySQL/PostgreSQL), REST API 설계, Git이다.

70~80% 공고에 있는 것은 Docker, AWS(EC2, RDS, S3), CI/CD(GitHub Actions, Jenkins), JPA/Hibernate, 테스트 코드 작성이다.

40~60% 공고에 있는 것은 Redis, Kafka/RabbitMQ, Kubernetes, MSA 경험, TypeScript/Node.js(풀스택 포지션)이다.

10~20% 공고에 있는 것은 동시성 제어, DB 성능 최적화, 실행계획 분석, Oracle이다.

### 5.2 정범진의 역량과 시장 요구의 겹침

거의 모든 공고 요구사항인 Java/Spring Boot, RDBMS, REST API, Git은 충족한다.

70~80% 공고 요구사항을 보면, Docker는 부재, AWS는 부재, CI/CD는 부재, JPA는 충족, 테스트 코드는 부재다.

40~60% 공고 요구사항을 보면, Redis는 충족, Kafka는 부재, K8s는 부재, MSA는 부재다.

10~20% 공고 요구사항을 보면, 동시성 제어는 매우 강함, DB 최적화는 매우 강함, Oracle은 충족이다.

정범진의 포트폴리오는 10~20% 공고에서만 요구하는 역량에 극도로 강하고, 70~80% 공고에서 요구하는 역량에 공백이 있다.

### 5.3 이재서 포트폴리오와의 비교

같은 Wherehouse 프로젝트의 팀원인 이재서의 포트폴리오와 비교하면 차이가 명확해진다.

학력 상태를 보면, 이재서는 학점은행제 학사 완료이고 정범진은 방송통신대 재학 중이다.

기술 범위를 보면, 이재서는 풀스택(FE+BE+Infra+AI)이고 정범진은 백엔드 집중이다.

프로젝트 수를 보면, 이재서는 4개(2개 중단/진행 중)이고 정범진은 2개(완료)다.

기술 트렌드를 보면, 이재서는 React, TypeScript, AI, MCP이고 정범진은 Java/Spring, Oracle, Redis다.

클라우드를 보면, 이재서는 AWS(EC2, RDS) 경험 있고 정범진은 없다.

Docker를 보면, 이재서는 있고 정범진은 없다.

이재서의 포트폴리오를 한 문장으로 요약하면 "다양한 기술을 빠르게 습득하여 동작하는 서비스를 만들어본 사람"이다. 정범진의 포트폴리오를 한 문장으로 요약하면 "특정 기술 영역을 극도로 깊이 파고들어 본질을 이해한 사람"이다.

대부분의 웹 백엔드 채용 공고가 전자에 가까운 인재를 찾고 있다.

### 5.4 서류 통과 차이의 구조적 원인

이재서가 서류를 통과하는 핵심 이유는 기술적 깊이가 아니다. 채용 공고의 체크리스트에 더 많은 항목이 체크되기 때문이다.

이재서 이력서를 30초 스캔하면 "Spring Boot 체크, React 체크, TypeScript 체크, AWS 체크, Docker 체크, AI 경험 체크, 프로젝트 4개 체크, 학사 완료 체크 → 면접 볼 만하다"가 된다.

정범진 이력서를 30초 스캔하면 "Spring Boot 체크, Oracle은 왜 MySQL이 아니지, Redis 체크, 동시성 제어는 이게 뭐지, 프로젝트 2개는 부족, 재학 중은 불확실 → 보류/탈락"이 된다.

이건 정범진의 실력이 이재서보다 떨어져서가 아니다. 서류 심사라는 필터의 작동 방식이 "깊이"보다 "넓이"에 유리하게 설계되어 있기 때문이다.

### 5.5 Oracle 중심 전략의 문제

Oracle은 현재 웹 백엔드 시장에서 비주류다. Oracle을 주력으로 사용하는 곳은 금융권, 대기업 SI, 공공기관으로 한정된다. 스타트업과 IT 서비스 기업 대부분은 PostgreSQL 또는 MySQL(Aurora)을 사용한다. 클라우드 네이티브 환경에서 Oracle은 라이선스 비용과 운영 복잡성 때문에 기피 대상이다.

포트폴리오에서 보여주는 Oracle 최적화 역량(V$SQL, V$SQL_PLAN 분석) 자체는 훌륭하지만, 이 역량이 "전이 가능한 DB 성능 분석 역량"으로 읽히기보다 "Oracle 특화 인력"으로 읽힐 위험이 있다.

실제로 V$SQL로 실행계획을 분석하는 방법론은 MySQL의 EXPLAIN이나 PostgreSQL의 EXPLAIN ANALYZE에도 적용 가능하다. 문제는 포트폴리오가 이 "전이 가능성"을 보여주지 않는다는 것이다.

### 5.6 단일 서버 환경의 한계

모든 프로젝트가 단일 서버 환경이다. Semaphore 기반 동시성 제어는 JVM 내부에서만 작동한다. 서버가 2대가 되는 순간 이 설계는 무너진다.

면접관의 예상 질문은 "이 Semaphore 기반 동시성 제어가 서버 2대에서도 작동하나요?"이다. 정직한 답은 "작동하지 않습니다"이다. 후속 질문은 "그러면 어떻게 해야 하나요?"이다. 필요한 답은 "Redis 기반 분산 락(Redisson)이나 DB 비관적 락을 사용해야 합니다"이다.

이 후속 질문에 대한 답변이 포트폴리오에서도, 학습 이력에서도 드러나지 않는다.

---

## 제6장 경쟁 구도 분석

### 6.1 현재 취업 시장의 구조적 변화

2020~2021년은 IT 채용 호황기였다. 코로나 팬데믹으로 디지털 전환이 가속화되면서 개발자 수요가 급증했다. 스타트업들이 대규모 투자를 받고 공격적으로 채용했다.

2022년 하반기부터 상황이 반전됐다. 금리 인상으로 투자 시장이 얼어붙었다. 스타트업 펀딩이 급감했고, 많은 기업이 채용을 중단하거나 구조조정을 시작했다.

2023~2024년은 "개발자 겨울"이라 불렸다. 채용 공고 수가 급감했고, 공고당 지원자 수는 급증했다.

2025년 현재, 시장이 일부 회복되고 있다는 신호가 있지만, 2020~2021년 수준으로 돌아가지는 않았다. 채용 기준이 전반적으로 상향 평준화된 상태가 "뉴노멀"이 되었다.

신입 채용 구조의 변화를 보면, 과거(2020~2021년)에는 신입 채용 규모가 대기업 수백 명, 중견기업 수십 명이었다. 요구 수준은 기본 CS 지식 + 프로젝트 1~2개 + 알고리즘이었다. 경쟁률은 수십 대 일이었다. 입사 후 3~6개월 교육 프로그램을 제공했다. 현재(2024~2025년)에는 신입 채용 규모가 대기업 수십 명, 중견기업 소수 또는 없다. 요구 수준은 인턴 경험 + 실무 수준 프로젝트 + 협업 경험 + 알고리즘이다. 경쟁률은 수백 대 일이다. 즉시 전력감을 선호하고 교육 비용을 최소화한다.

경력자의 하향 지원 현상도 발생하고 있다. 경력 1~2년차 개발자들도 이직이 어려워졌다. 경력직 채용이 줄면서, 일부는 더 낮은 연봉의 포지션이나 신입급 포지션에 지원하기 시작했다. 기업 입장에서는 같은 비용으로 실무 경험이 있는 사람을 뽑을 수 있으니 선호하게 된다. 신입 공고에 지원한 100명 중 10~20명이 실제로는 경력 1~2년차인 상황이 발생한다.

### 6.2 2년차 개발자의 일반적 역량 프로필

경력 2년차 백엔드 개발자가 일반적으로 갖추고 있는 것을 분석하면 다음과 같다.

실무 경험에서 오는 것으로는 실제 서비스 운영 경험(트래픽 대응, 장애 처리), 팀 협업 경험(코드 리뷰, 스프린트, 기획/디자인과 협업), 레거시 코드 유지보수 경험, 프로덕션 배포 경험(CI/CD, 롤백, 모니터링), 온콜/장애 대응 경험, 비즈니스 요구사항을 기술로 번역하는 경험이 있다.

기술적 역량으로는 Spring Boot, JPA 실무 수준, RDBMS 쿼리 최적화 기초, Redis 캐싱 기본 활용, Docker, Kubernetes 기초, AWS 주요 서비스 사용 경험, 테스트 코드 작성(커버리지 관리), Git 브랜치 전략, PR 프로세스가 있다.

부족한 것(아직 2년차라서)으로는 시스템 설계 전체를 주도하는 경험, 대규모 트래픽 아키텍처 설계, 주니어 멘토링, 기술 의사결정 주도가 있다.

### 6.3 정범진 vs 2년차 비교

정범진이 우위에 있는 영역은 동시성 제어 이해(대부분의 2년차가 synchronized 이상을 모름), DB 최적화 경험(V$SQL 분석은 DBA 영역, 신입이 거의 안 함), 문제 해결의 체계성(문제 인식 → 원인 분석 → 해결 → 검증), 정량적 분석 역량(나노초 단위 측정, 2,000건 동시 요청 테스트)이다.

2년차가 우위에 있는 영역은 실제 서비스 운영 경험, 팀 협업 경험, 장애 대응 경험, Docker/K8s 경험, CI/CD 경험, AWS 경험, 테스트 코드 경험이다.

채용 담당자 관점에서 보면, 넓이가 넓고 깊이가 얕은 지원자는 "당장 투입 가능해 보이지만, 어려운 문제를 해결할 수 있을지 의문"이다. 넓이가 좁고 깊이가 깊은 지원자(정범진)는 "기본기는 탄탄해 보이지만, 현대적인 개발 환경에 적응할 수 있을지 의문"이다.

### 6.4 2년차와 경쟁해서 이길 수 있는 조건

정범진이 2년차 경력자를 이기려면 다음 조건이 충족되어야 한다.

첫째, 채용 의사결정자가 기술적 깊이를 평가할 수 있는 개발자여야 한다. HR이 1차 필터를 하고 끝나면 정범진의 강점이 평가되지 않는다.

둘째, 해당 포지션이 기술적으로 도전적인 문제를 다뤄야 한다. CRUD 위주의 업무라면 2년차의 실무 경험이 더 가치 있다. 동시성 제어, 성능 최적화가 중요한 포지션이라면 정범진의 깊이가 가치 있다.

셋째, 기업이 "가르칠 의지"가 있어야 한다. 협업 경험, DevOps 지식 부족을 입사 후 채울 수 있다고 판단하는 기업이어야 한다.

넷째, 경쟁 상대인 2년차가 "그냥 2년 다닌" 수준이어야 한다. 2년 동안 깊이 있는 경험을 쌓은 2년차와 비교하면 정범진이 밀린다. 2년 동안 CRUD만 반복한 2년차와 비교하면 정범진이 이길 수 있다.

### 6.5 현실적 확률 추정

100개 기업에 지원했을 때 예상되는 분포를 분석하면 다음과 같다.

대기업(10% 비율)은 서류 통과 확률 5%, 면접 합격 확률 30%로 최종 합격 기대 0.15건이다. 중견기업(30% 비율)은 서류 통과 확률 10%, 면접 합격 확률 30%로 최종 합격 기대 0.9건이다. 기술중심 스타트업(20% 비율)은 서류 통과 확률 20%, 면접 합격 확률 40%로 최종 합격 기대 1.6건이다. 일반 스타트업(25% 비율)은 서류 통과 확률 15%, 면접 합격 확률 25%로 최종 합격 기대 0.9건이다. SI/SM(15% 비율)은 서류 통과 확률 25%, 면접 합격 확률 40%로 최종 합격 기대 1.5건이다.

100개 지원 시 예상 최종 합격은 약 5건이다. 이 숫자가 의미하는 것은 기회는 있다는 것이다. 하지만 많은 탈락을 경험해야 한다. 100개 지원해서 5개 합격이면 95번 탈락한다. 그 95번 중 대부분은 서류에서 탈락한다.

---

## 제7장 심리적 상태 분석

### 7.1 현재 관찰되는 행동 패턴

정범진은 예전과 달리 개발을 "게으름 피우면서" 피하고 있다고 진술했다. 과거에는 자발적으로 36페이지 동시성 테스트 보고서를 작성하고, 나노초 단위 측정 시스템을 구현하고, V$SQL 분석을 수행했다. 이 정도의 집요함을 가진 사람이 갑자기 "게을러졌다"는 것은 설명력이 약하다. 무언가가 변한 것이다.

### 7.2 학습된 무력감(Learned Helplessness)

Martin Seligman의 학습된 무력감 이론에 따르면, 반복적으로 통제 불가능한 부정적 결과를 경험하면, 실제로 통제 가능한 상황에서도 시도를 포기하게 된다.

정범진의 상황에 대입하면 다음과 같다. 반복적 부정 경험으로 서류 탈락이 계속된다. 포트폴리오를 개선해도, 이력서를 수정해도, 결과가 바뀌지 않는다. 통제 불가능성 인식으로 "내가 아무리 노력해도 학력, 나이, 경력이라는 필터를 넘을 수 없다"는 인식이 형성된다. 일반화로 서류 탈락이라는 특정 영역의 실패가 "개발 자체"로 일반화된다. "서류가 안 되니까 → 개발을 더 해봐야 소용없다 → 개발을 안 하게 된다"의 과정이다.

이 과정이 의식적으로 일어나지 않는다. 본인은 그냥 "게으름을 피운다"고 느끼지만, 실제로는 "노력과 결과 사이의 연결고리가 끊어진 상태"다.

### 7.3 목표-행동 연결의 붕괴

개발을 하는 이유는 두 가지로 나뉜다. 내적 동기는 "이 문제가 궁금해서", "이걸 이해하고 싶어서", "만드는 게 재미있어서"다. 외적 동기는 "이걸 하면 취업에 도움이 되니까", "포트폴리오를 채워야 하니까"다.

정범진의 과거 작업물을 보면, 내적 동기가 강했던 사람이다. "Semaphore가 왜 빠른지 궁금해서" 나노초 측정 시스템을 만든 것이지, "이걸 포트폴리오에 넣으면 취업에 유리하니까" 만든 것이 아니다.

전환 과정을 보면, 1단계에서 개발이 재미있어서 자연스럽게 깊이 있는 프로젝트를 했다. 2단계에서 취업 준비를 시작하며 "이 포트폴리오로 취업할 수 있을까?"라는 질문이 생겼다. 3단계에서 피드백을 받으며 "시장에 맞지 않는다", "Docker를 추가해라", "AWS를 배워라" 등의 조언을 듣고 개발의 목적이 "궁금해서"에서 "취업에 유리하니까"로 이동했다. 4단계에서 서류 탈락이 반복되며 "취업에 유리하니까"라는 동기가 "해봐야 소용없다"로 전환되었다. 5단계에서 내적 동기도 외적 동기도 남지 않아 개발을 "피하게" 되었다.

이 과정에서 정범진이 잃어버린 것은 "개발 실력"이 아니라 "개발을 하는 이유"다.

### 7.4 인지적 회피(Cognitive Avoidance)

정범진이 현재 직면한 상황은 불확실성이 극도로 높다. 서류를 내면 통과할지, 면접을 보면 붙을지, 이 방향이 맞는지, 언제 취업할 수 있을지 모두 모른다.

인간의 뇌는 불확실성을 싫어한다. 확실한 실패보다 불확실한 결과가 더 불안하다. 이 불안을 다루는 가장 쉬운 방법은 회피다. 개발을 안 하면 포트폴리오를 안 만들고, 포트폴리오를 안 만들면 지원을 안 하고, 지원을 안 하면 탈락도 안 한다. 탈락하지 않으면 "나는 아직 실패하지 않았다"라는 모호한 안전감이 유지된다.

"게으름을 피운다"는 자기 인식 자체가 자기 보호 메커니즘일 수 있다. "나는 게을러서 안 하는 것이다" → "하면 할 수 있는데 안 하는 것이다" → "내 능력의 문제가 아니다"의 인식이다. 이것은 "내가 최선을 다했는데도 안 되면 어떡하지?"라는 두려움을 회피하는 방법이다.

### 7.5 자기 강화적 악순환

이 상태가 자기 강화적 악순환을 만든다. 서류 탈락 → "해봐야 소용없다" → 개발 회피 → 포트폴리오 정체 → 경쟁력 하락 → 서류 탈락 → "역시 소용없다" → 더 강한 회피의 순환이다.

시간이 지날수록 이 순환이 강해진다. 7개월 공백이 이미 발생했다는 것이 이 순환이 진행 중임을 보여준다.

### 7.6 대처 방법

첫째, 개발의 동기를 재설정해야 한다. "취업을 위한 개발"이 동기를 파괴했다면, 잠시 취업과 분리된 개발을 해볼 필요가 있다. "이걸 하면 포트폴리오에 도움이 될까?"를 먼저 생각하지 말고, 예전처럼 "이게 궁금하다"에서 출발하는 것이다. 현재 상태에서 "취업을 위한 개발"을 억지로 하면 품질도 낮고 지속도 안 된다.

둘째, 행동 단위를 극도로 작게 쪼개야 한다. "Docker를 배워야 한다", "MySQL로 마이그레이션해야 한다"는 큰 과제다. 큰 과제는 회피를 유발한다. 대신 "오늘은 Dockerfile 한 줄만 쓴다" 정도가 실행 가능한 단위다. 한 줄을 쓰면 두 줄을 쓰게 되고, 두 줄이 열 줄이 되는 경우가 많다. 핵심은 "했다"는 사실이 학습된 무력감의 고리를 끊는다는 것이다.

셋째, 결과가 아닌 과정을 측정해야 한다. "서류 통과 여부"는 정범진이 통제할 수 없다. 통제할 수 없는 것에 성공 기준을 두면 무력감이 강화된다. 통제할 수 있는 것은 "오늘 코드를 몇 줄 썼는가", "이번 주에 몇 개 기업에 지원했는가", "면접 예상 질문 몇 개를 준비했는가"다. 이런 과정 지표에 집중하면 "해봐야 소용없다"는 인식이 약화된다.

넷째, 전문적 도움의 가능성을 열어둬야 한다. 학습된 무력감이 장기화되면 우울감으로 전이될 수 있다. 현재 상태가 단순한 "슬럼프"인지, 더 깊은 심리적 문제로 발전하고 있는지는 본인이 가장 잘 판단할 수 있다. 일상생활(수면, 식사, 대인관계)에도 영향이 가고 있다면, 상담을 받아보는 것이 실질적으로 도움이 된다.

---

## 제8장 종합 진단 및 권장 방향

### 8.1 핵심 진단

정범진의 기술 역량은 특정 영역(동시성 제어, DB 최적화)에서 신입 평균을 크게 상회하며, 일부 영역에서는 2년차 평균을 넘어선다. 문제는 이 역량의 분포가 시장 수요의 분포와 어긋난다는 것이다.

시장의 80%가 요구하는 것(Docker, AWS, CI/CD, MySQL/PostgreSQL, 테스트)에 투자가 없고, 시장의 10~20%만 요구하는 것(동시성 제어, Oracle 최적화)에 집중적으로 투자했다.

서류 전형의 1단계 필터는 포트폴리오 "내용"이 아닌 "유무"와 객관적 지표(학력, 경력, 자격증)로 작동한다. 정범진의 포트폴리오는 이미 "있고 충분한 수준"이므로, 이 필터를 통과하지 못하는 원인은 포트폴리오가 아니다.

현재의 심리 상태는 반복적 서류 탈락에 대한 정상적인 반응이다. "게으름"이 아니라 "학습된 무력감"으로 이해해야 한다.

### 8.2 권장 행동: 단기(1~2주)

첫째, 기존 프로젝트에 최소한의 넓이를 추가해야 한다. Wherehouse 또는 실시간 채팅 서비스에 테스트 코드를 추가한다(JUnit + Mockito, 1~2일 소요). Dockerfile + docker-compose.yml을 작성한다(1일 소요). README에 docker-compose up으로 실행하는 방법을 명시한다.

둘째, Oracle → MySQL/PostgreSQL 전이 가능성을 보여줘야 한다. 기존 Oracle 분석 역량을 MySQL이나 PostgreSQL에 적용한 사례를 추가한다. EXPLAIN ANALYZE 기반 쿼리 최적화 경험을 포트폴리오에 추가한다.

### 8.3 권장 행동: 중기(1~3개월)

첫째, 타겟 기업을 재설정해야 한다. 대기업/중견기업 비중을 줄이고, 기술 중심 스타트업 비중을 늘린다. 기술 블로그가 있는 스타트업, CTO/테크 리드가 채용에 직접 관여하는 스타트업, 채용 공고에 "기술적 도전"을 명시한 곳을 집중 공략한다.

둘째, 서류 필터를 우회하는 경로를 만들어야 한다. 개발자 밋업/컨퍼런스에서 직접 네트워킹한다. LinkedIn에서 스타트업 CTO에게 직접 메시지를 보낸다. 개발자 커뮤니티(OKKY, 디스코드)에서 채용 정보를 수집한다.

셋째, 지원 횟수를 관리해야 한다. 최소 50~100개 기업에 지원한다. 주당 10~15개씩 7~10주 동안 지원한다. 기업별 맞춤 지원서가 합격 확률을 높인다.

### 8.4 권장 행동: 면접 대비

첫째, 분산 환경 질문에 대비해야 한다. "이 Semaphore 기반 동시성 제어가 서버 2대에서도 작동하나요?"라는 질문에 대해 "작동하지 않습니다. 분산 환경에서는 Redis 기반 분산 락(Redisson)이나 DB 비관적 락을 사용해야 합니다"라는 답변을 준비한다.

둘째, Oracle → 범용 DB 전이 역량을 강조해야 한다. V$SQL 분석 방법론이 MySQL EXPLAIN, PostgreSQL EXPLAIN ANALYZE에도 적용 가능함을 설명할 준비를 한다.

셋째, 협업 경험 부재를 보완해야 한다. "협업 경험이 없지만, 학습 의지와 구체적 계획이 있다"는 메시지를 준비한다.

### 8.5 기대치 조정

첫 직장에 대한 기대를 조정해야 한다. 네카라쿠배 입사 확률은 매우 낮다. 연봉은 시장 평균 이하일 수 있다. 기술적 도전은 보장되지 않는다(CRUD 위주일 수 있다).

수용해야 할 것은 많은 탈락(90% 이상), 긴 취업 기간(3~6개월 이상), 첫 직장이 이상적이지 않을 가능성이다.

포기하면 안 되는 것은 기술적 성장 가능성이 있는 회사 선택, 최소한의 자존감(탈락이 역량 부족 때문만은 아님)이다.

### 8.6 최종 결론

기회는 있다. 0%가 아니다. 10~20% 정도의 확률로 면접 기회가 주어지고, 그중 일부에서 합격할 수 있다. 100번 지원하면 3~8개의 오퍼를 받을 수 있다.

포트폴리오의 기술적 깊이는 이미 충분하다. 지금 필요한 것은 "깊이를 더하는 것"이 아니라 "최소한의 넓이를 추가하고, 그 무기를 쓸 기회를 만드는 것"이다.

현재의 심리 상태를 "의지력 부족"으로 해석하지 않아야 한다. 이것은 상황에 대한 정상적인 심리적 반응이다. 의지력의 문제로 프레이밍하면 자기 비난이 추가되어 악순환이 가속화된다.

기회는 있다. 다만 그 기회를 잡으려면 시간, 노력, 그리고 탈락에 대한 내성이 필요하다.

---

## 부록 A: 일과 구조 권장안

평일 일과를 다음과 같이 구성할 수 있다. 09:00~12:00(3시간)은 코딩테스트 메인 시간이다. 12:00~13:00은 점심 시간이다. 13:00~16:00(3시간)은 CS 면접 준비 시간이다. 16:15~18:00은 서브 세션으로 초기에는 코딩테스트 추가, 2단계 이후에는 테스트 코드(JUnit/Mockito) 학습이다. 18:00~18:30은 구두 연습 시간이다. 저녁에는 운동 3~4시간을 한다.

주말에 파트타임이 있으면 쉬고, 없으면 주간 복기 + 휴식 1일을 갖는다. 깊이 파기는 자제하고 면접 3분 설명 기준으로 학습한다.

## 부록 B: 확인 필요 사항

Wherehouse 프로젝트에서 @Transactional 자기호출(self-invocation) 프록시 우회 문제가 있다. ETL 배치에서 롤백/트랜잭션 누락을 경험했다. Spring AOP 트랜잭션 전파 학습이 필요하다.

## 부록 C: 넓이 공백 우선순위

1순위는 테스트코드(JUnit/Mockito)다. 2순위는 CS 면접 기본(IoC/DI/AOP, HashMap 내부, 인덱스 원리, HTTP 상세, REST)이다. 3순위는 Spring 3대장 구두 설명이다. 4순위는 MySQL 경험 확보다. 후순위는 Swagger, 메시지큐, 모니터링이다.

---

*본 보고서는 2026년 2월 17일 기준으로 작성되었으며, 지금까지의 모든 대화 내용을 종합하여 분석한 결과물이다.*
