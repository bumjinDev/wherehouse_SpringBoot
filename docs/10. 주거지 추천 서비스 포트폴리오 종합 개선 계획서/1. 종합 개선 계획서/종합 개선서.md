# 포트폴리오 종합 개선 계획서

## 프로젝트 목표

현재 포트폴리오를 '기능 구현 목록'에서 '데이터 기반의 문제 해결 사례집'으로 전환한다. 단순한 '구현 완료' 증명을 넘어 '성능 개선과 문제 해결' 능력을 데이터로 입증하는 것을 목표로 한다.

## 성능 분석 방법론

### 1. 부하 테스트 (JMeter): 시스템 레벨 성능 측정

아키텍처 레벨의 성능 분석을 통해 사용자 요청이 네트워크를 타고 들어와 컨트롤러, 서비스, DB/Redis를 거쳐 다시 응답으로 나갈 때까지의 전체 여정(End-to-End) 성능을 측정한다.

**측정 대상:** API 응답 시간(Latency), 초당 처리량(TPS), 에러율

**측정 목표:** 
- 시스템이 동시 사용자 100명을 안정적으로 처리할 수 있는지 검증
- 배치 아키텍처 도입으로 인한 성능 개선 효과를 정량적으로 증명

**분석 관점:** 아무리 내부 코드가 효율적이어도 DB 커넥션 풀 부족이나 불필요한 네트워크 호출이 많으면 시스템 전체 성능이 저하된다. 부하 테스트를 통해 병목 지점이 코드, 인프라, 아키텍처 중 어디에 있는지 식별한다.

### 2. 알고리즘 시간 복잡도 (Big O): 코드 레벨 효율성 분석

특정 메서드나 로직이 데이터 양 증가에 따라 어떻게 성능이 변화하는지 성장률을 예측한다.

**분석 대상:** for 루프, 데이터 조회 방식 등 핵심 로직의 효율성

**분석 목표:** 현재는 데이터가 적어 빠르지만, 데이터가 대용량이 되어도 성능을 유지할 수 있는지 확장성을 검증한다.

**적용 예시:**
- calculateDistrictScoresAndSort 메서드: 여러 지역구의 매물 점수를 계산하고 정렬하는 로직의 시간 복잡도를 분석한다. 모든 매물을 메모리에 올린 뒤 이중 루프를 돌린다면 O(N²)이 될 수 있으며, 이를 어떻게 개선했는지 문서화한다.
- Redis 조회 로직: Redis의 Sorted Set에서 rangeByScore를 사용하는 것은 시간 복잡도가 O(log(N) + M)이다 (N은 전체 멤버 수, M은 반환되는 멤버 수). 사용 기술의 내부 동작과 시간 복잡도에 대한 이해를 코드 주석으로 문서화한다.

### 3. 구현 전략 및 우선순위

**접근 방식 비교:**
- 동시성 테스트: Race Condition이라는 명확한 문제를 파고들어 제어된 환경에서 원리를 증명하는 방식
- 성능 종합 분석: 시스템 전체를 보고 여러 지표(CPU, Memory, Latency, TPS)를 종합하여 병목을 찾아내는 방식으로, 여러 요소가 얽혀있어 원인 특정이 더 복잡함

**우선순위 설정:**

**1순위 (핵심 과제):** 부하 테스트(JMeter)를 통한 'Before & After' 성능 비교 분석. 현재 포트폴리오에서 가장 부족한 정량적 근거를 보완하여 최대 효과를 얻을 수 있는 작업이다.

**2순위 (추가 개선):** 핵심 로직(점수 계산 및 정렬)에 대한 시간 복잡도 계산 및 문서화. 코드 주석으로 "이 메서드의 시간 복잡도는 O(N*log(N))이며, 그 이유는..." 과 같이 기록하여 별도 보고서 없이도 코드 리뷰어에게 깊이 있는 분석 능력을 보여준다.

## 핵심 실행 계획

### 1순위 과제: 주거지 추천 서비스 성능 개선 증명 프로젝트

현재 포트폴리오의 주요 약점인 '성능 개선 주장에 대한 데이터 근거 부재'를 해결하는 최우선 과제이다.

#### 1단계: 성능 비교를 위한 대조군 구현

**구현 내용:** 현재 배치/Redis 아키텍처를 사용하지 않는 단순 버전의 추천 서비스 로직을 구현한다. 기존 Service 로직을 복제하여 DB 직접 조회 부분만 수정한다.

**목표:** 성능 비교 측정을 위한 '개선 전' 버전을 확보한다.

#### 2단계: 부하 테스트 시나리오 설계 및 실행

**구현 내용:** JMeter를 사용하여 전세/월세 추천 API에 동시 사용자 100명이 요청하는 시나리오를 설계한다.

**목표:** '개선 전' 버전과 '개선 후(현재)' 버전에 동일한 부하를 가하여 객관적인 성능 데이터를 수집한다.

#### 3단계: 성과 측정 및 문서화

**측정 지표:**
- 평균 응답 시간 (ms): 사용자 요청 후 응답 완료까지 소요 시간
- 처리량 (TPS): 시스템이 초당 처리할 수 있는 요청 수
- 에러율 (%): 부하 상황에서 실패하는 요청의 비율

**문서화 목표:** GitHub README와 포트폴리오에 'Before vs After' 비교표와 그래프를 추가하여 아키텍처 개선을 통한 구체적인 성능 향상 수치(예: 응답 시간 95% 단축, 에러율 0% 달성)를 데이터로 입증한다.

### 2순위 과제: 사용자 리뷰/평점 기능 구현

데이터베이스 및 JPA 활용 능력을 심화하여 보여주기 위한 기능 확장 과제이다.

#### 1단계: 데이터 모델링 및 엔티티 설계

**구현 내용:** 사용자(Member), 건물(Building), 리뷰(Review) 간의 관계를 정의하고, @OneToMany, @ManyToOne을 사용하여 JPA 엔티티를 설계한다. ERD를 업데이트한다.

**목표:** 복합적인 데이터 연관관계 설계 능력을 실증한다.

#### 2단계: Repository 및 JPQL 쿼리 작성

**구현 내용:** 단순 findById를 넘어 '건물의 평균 평점과 리뷰 수를 함께 조회'하는 등의 비즈니스 로직을 처리하기 위해 JOIN, GROUP BY, 집계 함수가 포함된 JPQL 쿼리를 구현한다.

**목표:** ORM 심화 활용 및 데이터 가공 능력을 입증한다.

#### 3단계: Service 및 API 구현

**구현 내용:** @Transactional을 적용하여 리뷰 작성/삭제의 데이터 정합성을 보장하는 서비스 로직과 관련 RESTful API를 개발한다.

**목표:** 트랜잭션 관리 및 API 설계 능력을 실증한다.

### 추가 개선 과제: 시간 복잡도 문서화

**구현 내용:** 핵심 로직(점수 계산 정렬 로직, 리뷰 조회 로직 등)의 코드에 시간 복잡도(Big O Notation) 분석을 주석으로 추가한다.

```java
// 이 로직은 N개의 지역구와 M개의 매물을 순회하므로 시간 복잡도는 O(N*M)입니다.
```

**목표:** 코드 구현을 넘어 효율성과 확장성까지 고려하는 개발자임을 보여준다.

## 의도적 병목 현상 설계 전략

단순한 '개선 전' 버전 구현을 넘어 아키텍처 실패 시나리오를 의도적으로 설계하여 현재 아키텍처의 설계 근거를 강화하는 전략이다.

### 전략적 가치

#### 1. 문제 정의 능력 입증

단순한 문제 해결을 넘어 "특정 아키텍처 선택 시 발생할 수 있는 병목 현상"을 사전에 정의하고 이를 데이터로 증명한다. 시스템의 잠재적 리스크를 예측하고 방어적 설계를 수행하는 역량을 보여준다.

#### 2. 기술 선택 근거 명확화

"배치 시스템을 선택한 이유"에 대한 완벽한 답변 근거를 마련한다. 실시간 외부 API 호출과 DB 집계 쿼리 실행 방식이 예측 불가능한 응답 지연과 DB 부하를 유발하는 안티패턴임을 인식하고, 이를 해결하기 위해 배치/실시간 아키텍처 분리를 선택했다는 설계 의도를 명확히 한다.

#### 3. 기술 보고서 수준의 포트폴리오 구성

이 접근을 통해 주거지 추천 서비스 포트폴리오를 "실시간 추천 API의 병목 현상 분석 및 아키텍처 개선 사례 연구"라는 완결된 기술 문서로 구성한다. 동시성 분석에서 보여준 체계적이고 분석적인 접근을 다른 프로젝트에서도 일관되게 적용할 수 있음을 입증한다.

### 의도적 병목 설계 구현 방안

'개선 전(Before)' 버전 구현 시 다음과 같은 비효율적 로직을 의도적으로 포함한다.

#### 1. 외부 API 실시간 호출 설계

**구현 방식:** 사용자 요청마다 서비스 로직 내에서 for 루프를 통해 국토교통부 API를 직접 호출하여 매물 정보를 실시간으로 가져온다.

**검증 목표:** 외부 API의 응답 지연(Network Latency)과 예측 불가능성(장애, Rate Limit)이 실시간 서비스 전체 성능에 미치는 영향을 측정한다.

#### 2. 반복적인 DB 집계 쿼리 설계

**구현 방식:** BatchScheduler에서 사전 계산하던 '안전성 점수' 관련 로직(crimeRepository.findCrimeCount() 등)을 API 요청 시마다 DB에서 직접 실행하도록 변경한다.

**검증 목표:** 동시 요청 집중 시 무거운 집계 쿼리가 DB에 가하는 직접적 부하로 인한 커넥션 풀 고갈 및 전체 시스템 처리량 급락 현상을 재현한다.

#### 3. 애플리케이션 메모리 내 데이터 처리 설계

**구현 방식:** Redis의 Sorted Set을 사용하지 않고, 특정 지역구의 모든 매물 데이터를 DB에서 List 형태로 전체 조회한 후, 자바 애플리케이션 메모리 내에서 stream().filter().sorted() 등으로 가격/평수 조건을 필터링하고 정렬한다.

**검증 목표:** 데이터 증가에 따른 애플리케이션의 CPU와 메모리 사용량 급증 및 GC(Garbage Collection) 부담 가중으로 인한 응답 지연 문제를 실증한다.

## 결론

위 세 가지 과제를 순차적으로 완료하면 포트폴리오는 기술적 깊이(동시성), 아키텍처 설계 및 검증 능력(성능 측정), 데이터베이스 활용 능력(리뷰 기능)을 모두 갖춘 균형 잡힌 결과물로 완성된다. 

의도적으로 설계된 비효율적 버전을 통해 현재 아키텍처가 단순한 기능 구현이 아닌 깊이 있는 성능 고려와 설계 사고의 산물임을 역설적으로 증명할 수 있다.