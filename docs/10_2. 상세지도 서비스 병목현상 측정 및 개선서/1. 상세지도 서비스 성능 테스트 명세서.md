# 상세지도 서비스 성능 테스트 명세서
## Performance Test Specification

**문서 정보**
- 문서 유형: 성능 테스트 명세서 (Performance Test Specification)
- 문서 버전: 2.1
- 작성일: 2025-01-23
- 작성자: 정범진
- 프로젝트: Wherehouse 위치 기반 정보 분석 서비스 성능 최적화

---

## 목차

1. [개요](#1-개요)
2. [측정 대상 시스템 상세](#2-측정-대상-시스템-상세)
3. [성능 목표](#3-성능-목표)
4. [계측 요구사항](#4-계측-요구사항)

---

## 1. 개요

### 1.1. 테스트 목적 및 배경

**비즈니스 요구사항:**
`POST /api/location-analysis` API는 사용자가 지도상의 임의 좌표를 클릭했을 때, 해당 위치 주변의 안전 인프라(CCTV, 파출소)와 편의시설 정보를 분석하여 실시간으로 제공하는 핵심 기능이다.

**현재 문제:**
API 응답 시간이 1~2초 수준으로 관찰되어, 실시간 지도 상호작용이 요구되는 서비스의 UX 목표치를 하회하고 있다.

**테스트 목적:**
본 명세서는 성능 병목을 데이터 기반으로 정밀하게 식별하고, 아키텍처 및 코드 수준의 개선을 통해 정의된 성능 목표를 달성하기 위한 측정 기준을 정의한다.

---

### 1.2. 측정 대상 시스템

**대상 API:**
- Endpoint: `POST /api/location-analysis`
- Controller: `LocationAnalysisController.analyzeLocation()`
- Service: `LocationAnalysisServiceImpl.analyzeLocation()`

**대상 컴포넌트:**
- `LocationAnalysisServiceImpl`: 메인 비즈니스 로직
- `GeohashService`: Geohash 기반 공간 분할
- `CctvGeoRepository`: CCTV 데이터 조회
- `PoliceOfficeGeoRepository`: 파출소 데이터 조회
- `ArrestRateRepository`: 검거율 데이터 조회
- `KakaoApiService`: 카카오맵 외부 API 연동
- `RedisSingleDataService`: Redis 캐시 연동

**기술 스택:**
- Backend: Spring Boot 3.2.x, Java 17
- Database: MySQL 8.0
- Cache: Redis 7.x
- External API: Kakao Maps REST API

---

### 1.3. 측정 범위

#### 1.3.1. 범위 내 (In-Scope)

**전체 트랜잭션 측정:**
- HTTP 요청 수신 ~ 응답 반환까지 전체 시간

**단계별 측정 (R-01 ~ R-07):**
- 각 처리 단계의 시작 시간 및 종료 시간
- 단계별 실행 결과 데이터 (Result DTO)

**세부 동작 측정 (Action 레벨):**
- DB 쿼리 실행 시간
- Redis 캐시 조회/쓰기 시간
- 외부 API 호출 시간
- In-Memory 필터링 루프 시간

**컨텍스트 정보:**
- TraceId (단일 요청 추적)
- Thread 정보
- 계층 정보 (Controller, Service, Repository, ApiClient)

#### 1.3.2. 범위 외 (Out-of-Scope)

- 프론트엔드(JSP, JavaScript) 렌더링 시간
- 카카오맵 API 서버 내부 처리 시간
- 네트워크 지연 시간 (클라이언트 ↔ 서버)
- 다른 API 엔드포인트
- 배치 프로세스

---

## 2. 측정 대상 시스템 상세

### 2.1. 시스템 아키텍처 개요

```
[Client]
   ↓ HTTP POST /api/location-analysis
[LocationAnalysisController]
   ↓
[LocationAnalysisServiceImpl] ← 메인 측정 대상
   ├─ R-01: 9-Block 그리드 계산
   ├─ R-02: 캐시 조회 (L1/L2)
   ├─ R-03: DB 조회 (CCTV)
   ├─ R-04: 외부 API 호출 (주소, 편의시설, 검거율)
   ├─ R-05: 데이터 통합 및 필터링 (CCTV, 파출소, 편의시설)
   ├─ R-06: 점수 계산 (안전성, 편의성)
   └─ R-07: 응답 생성 및 캐싱
```

**데이터 흐름:**
1. 사용자 좌표 입력
2. Geohash 기반 9개 격자 계산
3. 캐시 조회 → 미스 시 DB 조회
4. 외부 API 병렬 호출
5. 반경 필터링 및 점수 계산
6. 최종 응답 생성 및 캐시 저장

---

### 2.2. 처리 흐름 (R-01 ~ R-07)

#### R-01: 9-Block 그리드 범위 계산

**책임:** 사용자 좌표를 중심으로 Geohash 기반 9개 격자 ID 생성

**처리 로직:**
1. 입력 좌표 → 7자리 Geohash 인코딩 (중심 격자)
2. `GeohashService.calculate9BlockGeohashes()` 호출
3. 중심 + 인접 8개 = 총 9개 격자 ID 반환

**설계 근거:**
- 7자리 Geohash: 약 150m × 150m 격자
- 9-Block: 약 450m × 450m 영역 (사용자 반경 500m 포함)

**계측 대상:**
- Step: `R-01`
- Action: `calculate9BlockGeohashes`

---

#### R-02: 단계별 캐시 조회

**책임:** 2단계 캐싱 전략으로 이전 처리 결과 재사용

**처리 로직:**

**1차 캐시 (L1) - 전체 DTO 캐시:**
- Key: `dto:{centerGeohashId}`
- Value: `LocationAnalysisResponseDTO` (JSON)
- TTL: 5분
- 히트 시: R-03 ~ R-07 스킵

**2차 캐시 (L2) - 격자별 컴포넌트 캐시:**
- L1 미스 시 실행
- 9개 격자별 CCTV 데이터 조회
- Key: `data:{geohashId}:cctv`
- Value: `List<CctvGeo>` (JSON)
- TTL: 24시간

**설계 근거:**
- L1: 동일 좌표 반복 클릭 대응
- L2: 인접 좌표 클릭 시 DB 부하 감소

**계측 대상:**
- Step: `R-02`
- Action: 
  - `L1_Cache_Get`: L1 단일 조회
  - `L2_Cache_MGet`: L2 9개 격자 순회 조회
- **핵심 지표:** `l2CacheTotalDurationNs`

---

#### R-03: 데이터베이스 조회

**책임:** L2 캐시 미스 격자에 대해 DB에서 CCTV 조회 후 캐시 저장

**처리 로직:**
1. 캐시 히트 데이터 결과 객체에 추가
2. CCTV DB 조회: `cctvGeoRepository.findByGeohashIdIn(cctvMisses)`
3. 격자별 그룹화
4. L2 캐시 쓰기 (각 격자별 순차 저장)

**DB 인덱스:**
- `IDX_CCTV_GEO_GEOHASH` (B-Tree)

**계측 대상:**
- Step: `R-03`
- Action:
  - `DB_findCctvByGeohashIdIn`: CCTV 쿼리
  - `L2_Cache_MSet`: L2 캐시 쓰기 루프

---

#### R-04: 외부 API 호출

**책임:** 카카오맵 API 및 내부 DB를 통한 주소/편의시설/검거율 조회

**처리 로직:**

**1. 주소 변환 (Kakao Reverse Geocoding):**
- 좌표 → 도로명/지번 주소
- 캐시 키: `address:{latitude}:{longitude}`
- TTL: 24시간

**2. 편의시설 검색 (Kakao Local Search):**
- 15개 카테고리 장소 검색
- 캐시 키: `amenity:{latitude}:{longitude}:{radius}`
- TTL: 24시간

**3. 검거율 조회 (내부 DB):**
- 주소 '구' 추출 → `ArrestRateRepository` 조회
- 캐시 키: `arrest_rate:{구이름}`
- TTL: 24시간

**설계 근거:**
- 순차 실행으로 각 작업의 순수 시간 측정
- 측정 후 비동기화 검토

**계측 대상:**
- Step: `R-04`
- Action:
  - `Async_Kakao_Address_DB_ArrestRate`: 주소 + 검거율
  - `Async_Kakao_Amenity`: 편의시설

---

#### R-05: 데이터 통합 및 필터링

**책임:** 9-Block 과다 데이터를 사용자 반경(500m)으로 정밀 필터링

**처리 로직:**

**1. CCTV 필터링:**
- 9개 격자 CCTV 통합
- Haversine 거리 계산
- 반경 내 CCTV만 선택

**2. 파출소 조회:**
- Native Query로 최근접 파출소 1개 조회
- Repository: `policeOfficeGeoRepository.findNearestPoliceStations()`
- 쿼리: `ST_Distance_Sphere` 함수 사용
- **현재 문제:** 공간 인덱스 미사용 → Full Table Scan

**3. 편의시설 필터링:**
- 15개 카테고리별 거리 계산
- 반경 내 장소 필터링 및 정렬
- `AmenityDetailDto` 생성

**계측 대상:**
- Step: `R-05`
- Action:
  - `Filter_CCTV`: CCTV 필터링 루프
  - `DB_findNearestPoliceStation`: 파출소 쿼리
  - `Filter_Amenity`: 편의시설 필터링 루프
- **핵심 지표:** `policeQueryDurationNs`

---

#### R-06: 최종 점수 계산

**책임:** 안전성 점수 및 편의성 점수 계산

**처리 로직:**

**1. 안전성 점수 (0~100):**
- 파출소 거리 점수 (30%)
- CCTV 개수 점수 (40%)
- 검거율 점수 (30%)
- 가중 평균 계산

**2. 편의성 점수 (0~100):**
- 15개 카테고리별 점수 계산
- 카테고리별 가중치 적용
- 평균 산출

**3. 종합 점수:**
- `(안전성 + 편의성) / 2`

**계측 대상:**
- Step: `R-06`
- Action:
  - `calculateSafetyScore`
  - `calculateConvenienceScore`

---

#### R-07: 최종 응답 생성 및 캐싱

**책임:** 응답 DTO 조립 및 L1 캐시 저장

**처리 로직:**
1. `LocationAnalysisResponseDTO` 조립
   - 좌표, 주소, 점수
   - CCTV/파출소/편의시설 상세
   - 추천사항 및 경고사항
2. L1 캐시 저장
   - Key: `dto:{centerGeohashId}`
   - JSON 직렬화 후 Redis 저장
   - TTL: 5분

**계측 대상:**
- Step: `R-07`
- Action:
  - `buildFinalResponse`: DTO 조립
  - `L1_Cache_Set`: L1 캐시 쓰기

---

### 2.3. 예상 병목 지점 (B-01 ~ B-05)

#### B-01: 파출소 Native Query Full Table Scan

**위치:** R-05, `policeOfficeGeoRepository.findNearestPoliceStations()`

**원인:**
- `ST_Distance_Sphere` 함수 사용
- 공간 인덱스 미설정 → 전체 테이블 스캔

**영향도:** 최대 (전체 응답 시간의 50~80% 예상)

**검증 방법:**
- 쿼리 실행 계획 분석
- `policeQueryDurationNs` 측정값 확인

**개선 방향:**
- 쿼리 실행 계획 분석을 통한 인덱스 미사용 원인 파악
- 공간 데이터 최적화 방안 검토

---

#### B-02: 외부 API 직렬 대기

**위치:** R-04, `performExternalApiCalls()`

**원인:**
- 주소 변환, 편의시설 조회, 검거율 조회 순차 실행
- 각 대기 시간 누적

**영향도:** 중간

**검증 방법:**
- 각 API별 `executionTimeNs` 집계
- 전체 R-04 시간과 비교

**개선 방향:**
- 독립적 작업의 병렬 실행 가능성 검토
- `CompletableFuture` 적용 시 효과 분석

---

#### B-03: Redis L2 캐시 N+1 조회

**위치:** R-02, L2 캐시 조회 for 루프

**원인:**
- 9개 격자 순차 조회
- 각 조회마다 네트워크 RTT 발생

**영향도:** 중간

**검증 방법:**
- `l2CacheTotalDurationNs` 측정
- 단일 조회 평균 시간 × 9회와 비교

**개선 방향:**
- Redis Pipeline 또는 MGET 명령 적용 가능성 검토

---

#### B-04: Redis L2 캐시 N+1 쓰기

**위치:** R-03, L2 캐시 쓰기 for 루프

**원인:**
- 각 격자별 순차 저장
- 각 저장마다 네트워크 RTT 발생

**영향도:** 낮음 (캐시 미스 시에만 발생)

**검증 방법:**
- L2 캐시 쓰기 Action 시간 측정
- 캐시 미스 시나리오 집중 분석

**개선 방향:**
- Redis Pipeline 또는 MSET 명령 적용 가능성 검토

---

#### B-05: In-Memory 필터링 루프

**위치:** R-05, CCTV 및 편의시설 필터링

**원인:**
- Haversine 거리 계산 순차 반복
- 수백 개 데이터 처리

**영향도:** 낮음

**검증 방법:**
- `Filter_CCTV`, `Filter_Amenity` Action 시간 측정
- 데이터 개수별 선형성 확인

**개선 방향:**
- 병렬 스트림 처리 검토
- DB 레벨 공간 필터링 가능성 검토

---

## 3. 성능 목표

### 3.1. Success Criteria

부하 시나리오 조건 하에서 시스템은 다음 목표를 만족해야 한다:

| 지표 | 목표치 | 측정 방법 |
|------|--------|----------|
| 평균 응답 시간 | 500ms 이하 | 전체 요청의 산술 평균 |
| 95th Percentile | 1,000ms 이하 | 상위 5% 제외한 최대값 |
| 처리량 (TPS) | 50 이상 | 초당 처리 가능한 요청 수 |
| 에러율 | 0.1% 미만 | (실패 요청 / 전체 요청) × 100 |

**목표 근거:**
- 500ms: 실시간 지도 UX 임계값
- 1,000ms: 95% 사용자 만족도 보장
- 50 TPS: 예상 피크 트래픽 대응
- 0.1%: 안정성 기준

---

### 3.2. 병목 식별 원칙

다음 원칙에 따라 핵심 병목 구간을 식별한다:

**1. 상대적 비중 기준:**
- 전체 응답 시간 대비 비정상적으로 높은 비율을 차지하는 구간

**2. 절대적 지연 기준:**
- 각 R-Step 및 Action의 기능 복잡도 대비 과도한 실행 시간을 보이는 구간

**3. 개선 가능성 기준:**
- 측정된 지연이 아키텍처/쿼리/알고리즘 개선을 통해 단축 가능한 구간

**측정 후 분석 절차:**
실제 측정 데이터를 수집한 후, 성능 분석 보고서에서 다음을 수행한다:
- 각 R-Step별 정상 실행 시간 범위 설정 (기능 복잡도 고려)
- 실측값과 정상 범위 비교를 통한 병목 구간 확정
- 병목별 개선 우선순위 및 목표 수치 설정

---

## 4. 계측 요구사항

### 4.1. 측정 필수 데이터 항목

모든 측정 로그는 다음 데이터를 포함해야 한다:

**기본 메타데이터:**
- `timestamp`: 로그 발생 시각 (ISO 8601)
- `nanoTime`: 경과 시간 측정용 나노초 값
- `traceId`: 단일 HTTP 요청 추적 ID
- `thread`: 스레드 이름

**분류 정보:**
- `eventType`: 로그 유형 (고정값: "PERFORMANCE")
- `layer`: 아키텍처 계층 (Service, Repository, ApiClient)
- `class`: 클래스명
- `method`: 메서드명

**측정 정보:**
- `step`: R-01 ~ R-07 식별자
- `action`: 구체적 동작 이름
- `status`: START 또는 END
- `duration_ns`: 경과 시간 (나노초, END만)
- `duration_ms`: 경과 시간 (밀리초, END만)

**결과 정보:**
- `resultData`: Result DTO 객체 (JSON 직렬화)

---

### 4.2. PerformanceLogger 설계

**목적:**
비즈니스 로직의 가독성을 해치지 않고 성능 로그를 기록하는 전담 유틸리티

**주요 메서드:**

```java
public static PerformanceLogger start(
    String step,      // R-01 ~ R-07
    String action,    // 구체적 동작 이름
    String layer,     // Service, Repository, ApiClient
    String className, // 클래스명
    String methodName // 메서드명
)

public void setResultData(Object resultDto) // Result DTO 주입
public void end() // 종료 로그 출력 및 duration 계산
```

**로깅 타이밍:**
- START 로그: `start()` 호출 시 즉시 출력
- END 로그: `end()` 호출 시 출력

**시간 측정 방식:**
- `System.nanoTime()` 기반 단조 증가(monotonic) 시간 사용
- OS 시간 변경에 영향받지 않는 정밀 측정

**사용 예시:**

```java
PerformanceLogger perfLogger = PerformanceLogger.start(
    "R-03", 
    "performDatabaseQuery", 
    "Service", 
    "LocationAnalysisServiceImpl", 
    "performDatabaseQuery"
);

try {
    // 비즈니스 로직 수행
    R03DbResult result = performDatabaseQuery(cacheResult);
    
    perfLogger.setResultData(result);
    return result;
} finally {
    perfLogger.end();
}
```

---

### 4.3. Result DTO 체계

각 R-Step은 실행 결과를 구조화된 DTO에 저장하여 로그에 포함한다.

**명명 규칙:**
- 메인: `R{N}{Domain}Result` 
  - 예: `R02CacheResult`, `R03DbResult`
- 서브: `R{N}{SubDomain}Result` 
  - 예: `R02L1CacheResult`, `R03CctvQueryResult`

**주요 Result DTO 목록:**

| Step | 메인 DTO | 서브 DTO |
|------|----------|----------|
| R-01 | `R01GridResult` | `R01GeohashCalculationResult` |
| R-02 | `R02CacheResult` | `R02L1CacheResult`, `R02L2CacheResult` |
| R-03 | `R03DbResult` | `R03CctvQueryResult`, `R03CacheWriteResult` |
| R-04 | `R04ApiResult` | `R04AddressApiResult`, `R04AmenityApiResult`, `R04ArrestRateResult` |
| R-05 | `R05FilterResult` | `R05CctvFilterResult`, `R05PoliceQueryResult`, `R05AmenityFilterResult` |
| R-06 | `R06ScoreResult` | `R06SafetyScoreResult`, `R06ConvenienceScoreResult` |
| R-07 | `R07ResponseResult` | `R07CacheWriteResult` |

**DTO 설계 원칙:**
- 입력 파라미터, 출력 결과, 실행 상태, 에러 메시지 포함
- 측정 시간 필드 명명: `{동작}DurationNs` (나노초 단위)
- Boolean 플래그: `isSuccess`, `hit`, `found` 등
- 중첩된 서브 DTO를 통한 계층적 구조 지원

**예시 - R02CacheResult:**

```java
public class R02CacheResult {
    private R02L1CacheResult l1CacheResult;
    private R02L2CacheResult l2CacheResult;
    private boolean l1Hit;
    private long totalDurationNs;
}

public class R02L2CacheResult {
    private int totalBlocks;           // 9
    private int hitBlocks;             // 캐시 히트 격자 수
    private int missBlocks;            // 캐시 미스 격자 수
    private long l2CacheTotalDurationNs; // 핵심 측정값
    private List<CctvGeo> cachedCctvList;
}
```

---

### 4.4. 로그 포맷 표준

**JSON 구조:**

```json
{
    "timestamp": "2025-01-23T10:30:01.123Z",
    "nanoTime": 1578394726583100,
    "traceId": "a1b2c3d4",
    "thread": "http-nio-8080-exec-1",
    "eventType": "PERFORMANCE",
    "step": "R-03",
    "layer": "Service",
    "class": "LocationAnalysisServiceImpl",
    "method": "performDatabaseQuery",
    "action": "performDatabaseQuery",
    "status": "END",
    "duration_ns": 123000000,
    "duration_ms": 123,
    "resultData": {
        "cctvQueryResult": {
            "queriedBlocks": 5,
            "totalCctvCount": 142,
            "queryDurationNs": 35000000
        },
        "cacheWriteResult": {
            "writtenBlocks": 5,
            "writeDurationNs": 88000000
        }
    }
}
```

**필드 상세 정의:**

| 필드 | 타입 | 설명 | 생성 방법 |
|------|------|------|----------|
| `timestamp` | String | 사람을 위한 시각 (ISO 8601) | `System.currentTimeMillis()` |
| `nanoTime` | Long | 기계를 위한 경과 시간 측정용 | `System.nanoTime()` |
| `traceId` | String | 단일 HTTP 요청 추적 ID | MDC 자동 주입 |
| `thread` | String | 스레드 이름 | `Thread.currentThread().getName()` |
| `eventType` | String | 로그 분류 (고정: "PERFORMANCE") | 하드코딩 |
| `step` | String | R-01 ~ R-07 | 파라미터 |
| `layer` | String | 계층 (Service/Repository/ApiClient) | 파라미터 |
| `class` | String | 클래스명 | 파라미터 |
| `method` | String | 메서드명 | 파라미터 |
| `action` | String | 구체적 동작 이름 | 파라미터 |
| `status` | String | "START" 또는 "END" | 자동 설정 |
| `duration_ns` | Long | 경과 시간 (나노초) | END 시 계산 |
| `duration_ms` | Long | 경과 시간 (밀리초) | END 시 계산 |
| `resultData` | Object | Result DTO 직렬화 | `setResultData()` |

---

### 4.5. TraceId 발급 및 전파

**구현 방식:**
- `TraceIdFilter` 구현 (OncePerRequestFilter 상속)
- HTTP 요청 시작 시 UUID 기반 8자리 traceId 생성
- SLF4J MDC에 저장: `MDC.put("traceId", traceId)`
- 요청 종료 시 정리: `MDC.clear()`

**효과:**
- 동일 요청에서 발생한 모든 로그에 traceId 자동 포함
- 동시 요청 환경에서 요청별 로그 그룹화 가능
- 단일 트랜잭션의 전체 흐름 재구성 가능

**TraceId 생성 규칙:**
- 포맷: 8자리 영숫자 (예: `a1b2c3d4`)
- 생성 시점: HTTP 요청 수신 직후
- 전파 범위: 해당 요청 처리 전체 생명주기

---

### 4.6. 시간 측정 정밀도

**currentTimeMillis vs nanoTime 비교:**

| 구분 | currentTimeMillis | nanoTime |
|------|-------------------|----------|
| 목적 | 현재 시각 (Wall-Clock) | 경과 시간 측정 |
| 기준점 | UTC 1970-01-01 00:00:00 | JVM 시작 시점 (임의) |
| 특징 | NTP 동기화로 역행 가능 | 단조 증가 보장 |
| 정밀도 | 밀리초 (ms) | 나노초 (ns) |
| 용도 | 로그 타임스탬프 | 성능 측정 |

**적용 원칙:**
- `timestamp`: 사람이 읽는 시각 정보 (`System.currentTimeMillis()` 기반)
- `nanoTime`: 기계가 계산하는 경과 시간 (`System.nanoTime()` 기반)
- `duration_ns`: `(endNanoTime - startNanoTime)` 계산

**장점:**
- 나노초 단위 정밀 측정
- OS 시간 변경에 영향받지 않는 신뢰성
- 밀리초 미만 작업도 정확히 측정 가능

---

## 5. 문서 버전 관리

| 버전 | 날짜 | 작성자 | 변경 내역 |
|------|------|--------|----------|
| 1.0 | 2025-10-20 | 정범진 | 초안 작성 (성능 테스트 계획서) |
| 2.0 | 2025-01-23 | 정범진 | 전면 리라이팅 (성능 테스트 요구사항 명세서) |
| 2.1 | 2025-01-23 | 정범진 | 문서 재구성 (성능 테스트 명세서) - 요구사항 + 시스템 구조 + 계측 설계 통합 |

---

**문서 종료**