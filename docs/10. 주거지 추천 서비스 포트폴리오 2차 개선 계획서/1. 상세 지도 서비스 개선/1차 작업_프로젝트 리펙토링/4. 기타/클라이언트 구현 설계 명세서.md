# 클라이언트 구현 설계 명세서

**문서 버전:** 1.0  
**작성일:** 2025-10-10  
**프로젝트명:** 위치 기반 생활 안전·편의 분석 시스템 - 클라이언트 리팩토링

---

## 목차

1. 개요
2. 기존 코드 분석 (AS-IS)
3. 새로운 설계 명세 (TO-BE)
4. 파일별 구현 가이드
5. 데이터 바인딩 명세
6. 예외 처리 전략
7. 구현 우선순위 및 마이그레이션 계획
8. 테스트 시나리오
9. 부록

---

## 1. 개요

### 1.1. 문서 목적

본 문서는 서버 중심 아키텍처 전환에 따라 클라이언트(JavaScript)의 역할을 **표현 계층(Presentation Layer)**으로 재정의하고, 기존의 분산된 비즈니스 로직을 제거하여 단일 통합 API와 통신하는 구조로 리팩토링하기 위한 구현 가이드를 제공한다.

### 1.2. 리팩토링의 핵심 목표

| 목표 | 설명 | 기대 효과 |
|------|------|-----------|
| 네트워크 호출 최소화 | 4-5회의 개별 API 호출을 1회의 통합 API 호출로 축소 | 응답 속도 개선, 네트워크 비용 절감 |
| 비즈니스 로직 제거 | 점수 계산, 데이터 조합 로직을 서버로 완전 이전 | 클라이언트 코드 복잡도 감소 |
| 관심사의 분리 | 클라이언트는 오직 UI 표현만 담당 | 유지보수성 향상, 다중 플랫폼 확장 가능 |
| 단일 진실 공급원 | 서버가 제공하는 완성된 DTO만 신뢰 | 데이터 일관성 보장 |

### 1.3. 역할 재정의

서버 설계 명세서(문서 3)의 "1.2. 역할 분담 설계"에 따라 클라이언트의 책임은 다음과 같이 제한된다:

**클라이언트가 하는 일:**
- 사용자의 지도 클릭 이벤트 감지
- 클릭된 좌표를 단일 API(POST /api/location-analysis)로 전송
- 서버로부터 완성된 LocationAnalysisResponseDTO 수신
- 수신한 DTO의 각 필드를 해당 UI 요소(텍스트, 그래프, 마커)에 직접 바인딩

**클라이언트가 하지 않는 일:**
- ❌ 점수 계산 (안전성, 편의성, 종합)
- ❌ 여러 API 결과의 조합
- ❌ 외부 API(카카오맵) 직접 호출
- ❌ 비즈니스 규칙 적용 (가중치, 임계값 등)

---

## 2. 기존 코드 분석 (AS-IS)

### 2.1. 현재 파일 구조 및 역할

| 파일명 | 현재 역할 | 주요 기능 | 문제점 |
|--------|-----------|-----------|--------|
| mouseEvent.js | 지도 클릭 이벤트 총괄 제어 | - 4개 이상의 개별 API 호출 조율<br>- Promise.all로 결과 취합<br>- 점수 계산 함수 호출 | Chatty Client 패턴<br>비즈니스 로직 포함 |
| score.js | 안전성 점수 계산 | - saftyScore() 함수<br>- 콜백 기반 점수 산출 | 비즈니스 로직이 클라이언트에 존재<br>서버로 이전 필수 |
| policeOffice.js | 파출소 데이터 조회 및 표시 | - fetch("./information/dist")<br>- Polyline으로 거리 계산<br>- 파출소 마커 표시 | 개별 API 호출 (삭제 대상) |
| cctv.js | CCTV 데이터 조회 | - fetch("./information/cctv")<br>- 반경 내 CCTV 개수 집계 | 개별 API 호출 (삭제 대상) |
| amenity.js | 편의시설 조회 | - 카카오맵 API 직접 호출 (ps.categorySearch)<br>- 15개 카테고리 순회<br>- 점수 계산 로직 포함 | API 키 노출 위험<br>비즈니스 로직 포함 |
| graph.js | 그래프 시각화 | - moveGraph() 함수<br>- 점수에 따라 그래프 너비 조절 | 유지 가능 (순수 UI 로직) |
| marker.js | 핀 마커 표시 | - 클릭 위치에 마커 생성 | 유지 가능 |
| circle.js | 반경 서클 표시 | - 500m 반경 원 표시 | 유지 가능 |
| panel.js | 정보 패널 토글 | - 좌측 패널 열기/닫기 | 유지 가능 |
| polygonView.js | 자치구 폴리곤 표시 | - 지역구 경계 표시 | 유지 가능 |
| emoji.js | 물음표 아이콘 툴팁 | - 마우스오버 툴팁 표시 | 유지 가능 |
| getAddress.js | 좌표 → 주소 변환 | - (코드 미제공, 추정) | 서버로 이전됨 (삭제) |

### 2.2. 기존 데이터 흐름 (AS-IS)

```
[사용자 지도 클릭]
    ↓
[mouseEvent.js가 감지]
    ↓
┌─────────────────────────────────────┐
│ 병렬로 4-5개 API 호출               │
├─────────────────────────────────────┤
│ 1. fetch("./information/dist")      │ ← policeOffice.js
│ 2. fetch("./information/cctv")      │ ← cctv.js
│ 3. fetch("./information/rate")      │ ← mouseEvent.js
│ 4. ps.categorySearch() × 15회       │ ← amenity.js (카카오맵)
│ 5. 주소 변환 API                    │ ← getAddress.js
└─────────────────────────────────────┘
    ↓
[클라이언트에서 데이터 조합]
    ↓
[클라이언트에서 점수 계산]
 - distScore = (1/Math.log(result+150))/0.2
 - cctvScore = Math.min(result/300, 1)
 - 안전성 점수 = distScore*60 + cctvScore*30 + arrestRate*10
 - 편의성 점수 = Σ(개수/15 * 가중치)
    ↓
[그래프 및 UI 업데이트]
```

### 2.3. 기존 코드의 구체적 문제점

#### 2.3.1. mouseEvent.js의 복잡성

현재 코드 구조:

```javascript
kakao.maps.event.addListener(map, 'click', function(mouseEvent) {
    var latlng = mouseEvent.latLng;
    
    // 문제 1: 여러 개별 API 호출
    var promises = [];
    promises.push(new Promise((resolve) => {
        saftyScore([distFunction, cctvFunction, arrestRateFunction], latlng, (results) => {
            // 문제 2: 클라이언트에서 점수 계산
            var value = results[0]*60 + results[1]*30 + results[2]*10;
            moveGraph(safty, value);
            resolve(value);
        });
    }));
    
    promises.push(new Promise((resolve) => {
        amenity_toMouseEvent(latlng, (result) => {
            moveGraph(conv, result);
            resolve(result);
        });
    }));
    
    // 문제 3: 종합 점수도 클라이언트에서 계산
    Promise.all(promises).then((results) => {
        var value = (results[0]+results[1])/2;
        moveGraph(total, value);
    });
});
```

**문제점:**
- 복잡한 비동기 제어: 다수의 Promise와 콜백 중첩
- 비즈니스 로직 노출: 가중치 60%, 30%, 10%가 하드코딩됨
- 에러 처리 부재: 일부 API 실패 시 대응 불가

#### 2.3.2. amenity.js의 보안 취약점

현재 코드:

```javascript
var ps = new kakao.maps.services.Places(map);  // API 키가 JSP에 노출

var categoryData = {
    'SW8': { weight: 10, minCount: 1 },
    'CS2': { weight: 10 },
    // ... 가중치가 클라이언트에 하드코딩
};

for (var key in categoryData) {
    promises.push(placesSearch(key, searchOption));  // 15회 호출
}

// 점수 계산도 클라이언트에서 수행
score += (parseInt(data.length) / 15) * categoryData[category].weight;
```

**문제점:**
- API 키 노출: informationPage.jsp에 카카오맵 API 키가 평문으로 노출됨
- 비즈니스 규칙 노출: 편의성 점수 계산 공식이 클라이언트에 노출됨
- 성능 이슈: 15개 카테고리에 대해 순차적으로 API 호출

#### 2.3.3. 점수 계산 로직의 중복과 불일치 위험

안전성 점수 (mouseEvent.js):

```javascript
function distFunction(latlng, callback) {
    getLength_toMouseEvent(latlng, (result) => {
        var distScore;
        if (result < 1000) { 
            distScore = (1 / Math.log(result + 150))/0.2; 
        }
        // ... 복잡한 로그 함수 계산
        callback(distScore);
    });
}
```

이 로직이 서버에도 구현되어야 하는데, 클라이언트와 서버의 공식이 불일치할 위험이 있다.

### 2.4. 파일별 수정/삭제/유지 분류

| 파일명 | 조치 | 이유 |
|--------|------|------|
| mouseEvent.js | 대폭 수정 | 단일 fetch로 축소, 비즈니스 로직 제거 |
| score.js | 완전 삭제 | 점수 계산이 서버로 이전되어 불필요 |
| policeOffice.js | 부분 수정 | fetch 호출 제거, 마커 표시 기능만 유지 |
| cctv.js | 완전 삭제 | 서버 응답에 CCTV 데이터 포함되어 불필요 |
| amenity.js | 완전 삭제 | 서버가 편의시설 조회 담당 |
| getAddress.js | 완전 삭제 | 서버가 주소 변환 담당 |
| graph.js | 유지 | 순수 UI 로직, 입력값만 변경 |
| marker.js | 유지 | 지도 마커 표시는 클라이언트 책임 |
| circle.js | 유지 | 반경 서클 표시는 클라이언트 책임 |
| panel.js | 유지 | UI 토글 로직 |
| polygonView.js | 유지 | 지역구 경계 표시 |
| emoji.js | 유지 | 툴팁 표시 |

---

## 3. 새로운 설계 명세 (TO-BE)

### 3.1. 새로운 데이터 흐름 (TO-BE)

```
[사용자 지도 클릭]
    ↓
[mouseEvent.js가 감지]
    ↓
[단일 API 호출]
POST /api/location-analysis
{
  "latitude": 37.5665,
  "longitude": 126.9780,
  "radius": 500
}
    ↓
[서버에서 모든 처리 완료]
 - 병렬 데이터 조회
 - 점수 계산
 - 추천 근거 생성
    ↓
[완성된 LocationAnalysisResponseDTO 수신]
{
  "analysisStatus": "SUCCESS",
  "safetyScore": { "total": 85, ... },
  "convenienceScore": { "total": 72, ... },
  "overallScore": 78,
  "recommendations": [...],
  ...
}
    ↓
[클라이언트는 단순 UI 바인딩만 수행]
 - response.safetyScore.total → #safty 그래프
 - response.convenienceScore.total → #conv 그래프
 - response.overallScore → #total 그래프
 - response.recommendations → 추천 근거 목록 표시
```

### 3.2. 핵심 설계 원칙

#### 3.2.1. 단일 진실 공급원 (Single Source of Truth)

클라이언트는 서버가 제공한 데이터만을 신뢰하며, 어떠한 추가 계산이나 검증도 수행하지 않는다.

```javascript
// ❌ 잘못된 예: 클라이언트에서 재계산
const clientCalculated = (response.safetyScore.total + response.convenienceScore.total) / 2;

// ✅ 올바른 예: 서버 제공 값을 그대로 사용
const overallScore = response.overallScore;
```

#### 3.2.2. 선언적 UI 바인딩 (Declarative UI Binding)

복잡한 조건문 없이, DTO의 필드와 DOM 요소를 직접 매핑한다.

```javascript
// ✅ 선언적 바인딩
function updateUI(response) {
    document.querySelector("#distance").textContent = response.safetyScore.policeDistance + ' M';
    document.querySelector("#cctvPcs").textContent = response.safetyScore.cctvCount + ' 개';
    
    moveGraph(document.querySelector("#safty"), response.safetyScore.total);
    moveGraph(document.querySelector("#conv"), response.convenienceScore.total);
    moveGraph(document.querySelector("#total"), response.overallScore);
}
```

#### 3.2.3. 중앙화된 에러 처리

모든 API 호출 에러는 단일 지점에서 처리한다.

```javascript
fetch('/api/location-analysis', {...})
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        if (data.analysisStatus === 'SUCCESS') {
            updateUI(data);
        } else if (data.analysisStatus === 'PARTIAL_SUCCESS') {
            updateUI(data);
            showWarnings(data.warnings);
        } else {
            showError('해당 위치의 정보를 분석할 수 없습니다.');
        }
    })
    .catch(error => {
        console.error('API 호출 실패:', error);
        showError('서버와 통신 중 오류가 발생했습니다.');
    });
```

### 3.3. API 통신 명세

#### 3.3.1. 요청 (Request)

**Endpoint:** POST /api/location-analysis  
**Headers:**
- Content-Type: application/json

**Request Body:**

```json
{
  "latitude": 37.5665,
  "longitude": 126.9780,
  "radius": 500
}
```

**JavaScript 구현:**

```javascript
async function analyzeLocation(latitude, longitude) {
    const requestBody = {
        latitude: latitude,
        longitude: longitude,
        radius: 500  // 고정값 또는 사용자 설정값
    };
    
    const response = await fetch('/api/location-analysis', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
    });
    
    return await response.json();
}
```

#### 3.3.2. 응답 (Response)

**성공 응답 (HTTP 200):**

```json
{
  "analysisStatus": "SUCCESS",
  "coordinate": {
    "latitude": 37.5665,
    "longitude": 126.9780
  },
  "address": {
    "roadAddress": "서울특별시 중구 세종대로 110",
    "jibunAddress": "서울특별시 중구 태평로1가 31"
  },
  "safetyScore": {
    "total": 85,
    "policeDistance": 450,
    "cctvCount": 23,
    "arrestRate": 0.87
  },
  "convenienceScore": {
    "total": 72,
    "amenityDetails": [
      {
        "categoryCode": "CS2",
        "categoryName": "편의점",
        "count": 8,
        "closestDistance": 120,
        "places": [...]
      }
    ]
  },
  "overallScore": 78,
  "recommendations": [
    "반경 500m 내 CCTV 23대 설치되어 야간 안전성 우수",
    "지하철역 도보 3분 거리로 대중교통이 편리합니다"
  ],
  "warnings": []
}
```

**부분 성공 응답 (HTTP 200):**

```json
{
  "analysisStatus": "PARTIAL_SUCCESS",
  "safetyScore": { "total": 85, ... },
  "convenienceScore": null,
  "overallScore": null,
  "warnings": [
    "편의시설 정보를 불러오지 못해 편의성 점수는 계산되지 않았습니다."
  ]
}
```

**실패 응답 (HTTP 400):**

```json
{
  "errorCode": "INVALID_PARAMETER",
  "message": "latitude 파라미터는 -90과 90 사이의 값이어야 합니다."
}
```

---

## 4. 파일별 구현 가이드

### 4.1. mouseEvent.js (핵심 변경)

#### 4.1.1. 변경 전 (AS-IS)

```javascript
// 기존: 복잡한 다중 API 호출 및 점수 계산
kakao.maps.event.addListener(map, 'click', function(mouseEvent) {
    var latlng = mouseEvent.latLng;
    
    var promises = [];
    
    // 안전성 점수 계산
    promises.push(new Promise((resolve) => {
        saftyScore([distFunction, cctvFunction, arrestRateFunction], latlng, (results) => {
            var safty = document.querySelector("#safty");
            var value = results[0]*60 + results[1]*30 + results[2]*10;  // 클라이언트에서 계산
            moveGraph(safty, value);
            resolve(value);
        });
    }));
    
    // 편의성 점수 계산
    promises.push(new Promise((resolve) => {
        amenity_toMouseEvent(latlng, (result) => {
            var conv = document.querySelector("#conv");
            moveGraph(conv, result);
            resolve(result);
        });
    }));
    
    // 종합 점수 계산
    Promise.all(promises).then((results) => {
        var total = document.querySelector("#total");
        var value = (results[0]+results[1])/2;  // 클라이언트에서 계산
        moveGraph(total, value);
    });
});
```

#### 4.1.2. 변경 후 (TO-BE)

```javascript
// 신규: 단일 API 호출 및 단순 UI 바인딩
import { marker_toMouseEvent } from "./marker.js";
import { circle_toMouseEvent } from "./circle.js";
import { moveGraph } from "./graph.js";
import { displayArea } from "./polygonView.js";

kakao.maps.event.addListener(map, 'click', async function(mouseEvent) {
    const latlng = mouseEvent.latLng;
    const level = map.getLevel();
    
    // 1. 지도 UI 요소 업데이트 (기존 로직 유지)
    if (level > 2) {
        circle_toMouseEvent(latlng);
    }
    if (level > 3) {
        viewGu(latlng);
    }
    marker_toMouseEvent(latlng);
    map.panTo(latlng);
    
    // 2. 단일 통합 API 호출
    try {
        const response = await analyzeLocation(latlng.Ma, latlng.La);
        
        // 3. 응답 상태에 따른 처리
        if (response.analysisStatus === 'SUCCESS') {
            updateCompleteUI(response);
        } else if (response.analysisStatus === 'PARTIAL_SUCCESS') {
            updatePartialUI(response);
            showWarnings(response.warnings);
        } else {
            showAnalysisFailedMessage();
        }
        
    } catch (error) {
        console.error('위치 분석 API 호출 실패:', error);
        showErrorMessage('서버와 통신 중 오류가 발생했습니다.');
    }
});

// 통합 API 호출 함수
async function analyzeLocation(latitude, longitude) {
    const response = await fetch('/api/location-analysis', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            latitude: latitude,
            longitude: longitude,
            radius: 500
        })
    });
    
    if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    return await response.json();
}

// UI 업데이트 함수 (완전 성공)
function updateCompleteUI(response) {
    // 주소 정보
    document.querySelector("#addr").textContent = response.address.roadAddress;
    document.querySelector(".detailAddr").innerHTML = 
        `도로명 : ${response.address.roadAddress}<br>지번 : ${response.address.jibunAddress}`;
    
    // 안전성 상세 정보
    document.querySelector("#distance").textContent = response.safetyScore.policeDistance + ' M';
    document.querySelector("#cctvPcs").textContent = response.safetyScore.cctvCount + ' 개';
    
    // 그래프 업데이트 (서버에서 계산된 점수를 그대로 사용)
    moveGraph(document.querySelector("#safty"), response.safetyScore.total);
    moveGraph(document.querySelector("#conv"), response.convenienceScore.total);
    moveGraph(document.querySelector("#total"), response.overallScore);
    
    // 편의시설 정보 표시
    displayAmenities(response.convenienceScore.amenityDetails);
    
    // 추천 근거 표시
    displayRecommendations(response.recommendations);
}

// UI 업데이트 함수 (부분 성공)
function updatePartialUI(response) {
    // 가용한 데이터만 표시
    if (response.safetyScore) {
        document.querySelector("#distance").textContent = response.safetyScore.policeDistance + ' M';
        document.querySelector("#cctvPcs").textContent = response.safetyScore.cctvCount + ' 개';
        moveGraph(document.querySelector("#safty"), response.safetyScore.total);
    } else {
        document.querySelector("#distance").textContent = '- M';
        document.querySelector("#cctvPcs").textContent = '- 개';
    }
    
    if (response.convenienceScore) {
        moveGraph(document.querySelector("#conv"), response.convenienceScore.total);
        displayAmenities(response.convenienceScore.amenityDetails);
    } else {
        document.querySelector("#conv").style.width = '0%';
        clearAmenities();
    }
    
    // 종합 점수는 null일 수 있음
    if (response.overallScore !== null) {
        moveGraph(document.querySelector("#total"), response.overallScore);
    } else {
        document.querySelector("#total").style.width = '0%';
    }
}

// 편의시설 표시 함수
function displayAmenities(amenityDetails) {
    if (!amenityDetails || amenityDetails.length === 0) {
        clearAmenities();
        return;
    }
    
    // 최대 5개까지 표시
    amenityDetails.slice(0, 5).forEach((amenity, index) => {
        const element = document.querySelector(`#each${index + 1}`);
        element.textContent = amenity.categoryName;
        element.style.color = '#3a80e9';
        
        // 클릭 이벤트: 해당 카테고리의 장소들을 지도에 마커로 표시
        element.onclick = () => displayAmenityMarkers(amenity.places);
    });
}

// 추천 근거 표시 함수
function displayRecommendations(recommendations) {
    const container = document.querySelector("#link");  // 추천 근거 표시 영역
    container.innerHTML = '';
    
    recommendations.forEach(text => {
        const li = document.createElement('li');
        li.textContent = text;
        li.style.fontSize = '0.9rem';
        li.style.marginBottom = '8px';
        container.appendChild(li);
    });
}

// 경고 메시지 표시
function showWarnings(warnings) {
    if (!warnings || warnings.length === 0) return;
    
    const message = warnings.join('\n');
    alert(`⚠️ 일부 정보 조회 실패\n\n${message}`);
}

// 에러 메시지 표시
function showErrorMessage(message) {
    alert(`❌ 오류 발생\n\n${message}`);
}

// 분석 불가 메시지 표시
function showAnalysisFailedMessage() {
    alert('❌ 분석 불가\n\n해당 위치의 정보를 분석할 수 없습니다.\n다른 위치를 선택해 주세요.');
}

// 자치구 표시 (기존 로직 유지)
function viewGu(latlng) {
    // response.address에서 구 이름 추출
    // 또는 별도 함수로 분리
}
```

#### 4.1.3. 주요 변경 사항

| 항목 | 변경 전 | 변경 후 |
|------|---------|---------|
| API 호출 횟수 | 4-5회 (개별 엔드포인트) | 1회 (통합 엔드포인트) |
| 점수 계산 | 클라이언트에서 수행 | 서버 응답값을 그대로 사용 |
| 에러 처리 | 개별 API별 처리 | 중앙화된 try-catch |
| 코드 라인 수 | 약 150줄 | 약 100줄 |
| 외부 의존성 | score.js, amenity.js 등 | graph.js, marker.js만 |

### 4.2. graph.js (유지, 입력 데이터만 변경)

#### 4.2.1. 현재 코드

```javascript
function moveGraph(e, value) {
    e.style.width = value + "%";
    
    if (Math.round(parseFloat(e.style.width)) < 30) {
        e.style.backgroundColor = '#1c498d';
    } else if (Math.round(parseFloat(e.style.width)) >= 70) {
        e.style.backgroundColor = '#6da7ff';
    } else {
        e.style.backgroundColor = '#4082e6';
    }
}

export { moveGraph }
```

#### 4.2.2. 변경 사항

**변경 없음.** 이 파일은 순수 UI 로직으로, 점수값(0-100)을 받아 그래프의 너비와 색상을 조절하는 역할만 수행한다. 입력값의 출처(클라이언트 계산 → 서버 응답)만 변경되며, 함수 자체는 그대로 사용한다.

**사용 방법:**

```javascript
// 변경 전: 클라이언트에서 계산한 값
moveGraph(document.querySelector("#safty"), calculatedScore);

// 변경 후: 서버 응답값
moveGraph(document.querySelector("#safty"), response.safetyScore.total);
```

### 4.3. marker.js (유지)

#### 4.3.1. 현재 코드

```javascript
var marker = new kakao.maps.Marker({ 
    position: map.getCenter(),
    zIndex: 3
});

function marker_toMouseEvent(latlng) {
    marker.setMap(map);
    marker.setPosition(latlng);
}

export {marker_toMouseEvent, marker}
```

#### 4.3.2. 변경 사항

**변경 없음.** 클릭한 위치에 마커를 표시하는 순수 UI 로직으로, 그대로 유지한다.

### 4.4. circle.js (유지)

#### 4.4.1. 현재 코드

```javascript
var circle = new kakao.maps.Circle({
    position: map.getCenter(),
    radius: 500,
    strokeWeight: 3,
    strokeColor: '#0B5ED7',
    strokeOpacity: 0.7,
    strokeStyle: 'dashed',
    fillColor: '#0B5ED7',
    fillOpacity: 0.1,
    zIndex: 1
});

function circle_toMouseEvent(latlng) {
    circle.setMap(map);
    circle.setPosition(latlng);
}

export {circle_toMouseEvent, circle}
```

#### 4.4.2. 변경 사항

**변경 없음.** 500m 반경 서클을 표시하는 순수 UI 로직으로, 그대로 유지한다.

### 4.5. panel.js (유지)

**변경 없음.** 좌측 정보 패널의 열기/닫기 토글 기능으로, UI 로직이므로 그대로 유지한다.

### 4.6. polygonView.js (유지)

**변경 없음.** 자치구 경계를 폴리곤으로 표시하는 기능으로, 그대로 유지한다. 단, 주소 정보는 서버 응답의 response.address에서 가져온다.

### 4.7. emoji.js (유지)

**변경 없음.** 물음표 아이콘의 툴팁 표시 기능으로, 그대로 유지한다.

### 4.8. score.js (완전 삭제)

#### 4.8.1. 삭제 이유

```javascript
// 기존 코드
function saftyScore(callbacks, latlng, finalCallback) {
    const results = [];
    let count = 0;
  
    callbacks.forEach((callback, index) => {
      callback(latlng, (result) => {
        results[index] = result;
        count++;
  
        if (count === callbacks.length) {
          finalCallback(results);
        }
      });
    });
}
```

이 파일은 점수 계산을 조율하는 역할을 수행했으나, 서버로 모든 점수 계산 로직이 이전되어 더 이상 필요하지 않다.

#### 4.8.2. 마이그레이션 체크리스트

- [ ] mouseEvent.js에서 `import { saftyScore } from "./score.js"` 제거
- [ ] informationPage.jsp에서 `<script type="module" src="<c:url value="/js/score.js"/>">` 제거
- [ ] score.js 파일 삭제

### 4.9. policeOffice.js (부분 수정)

#### 4.9.1. 변경 전 (AS-IS)

```javascript
// 파출소 마커 표시 (유지)
fetch("./information/policeOffice", {
    method: "get",
    headers: {
        "Content-Type": "application/json",
    },
})
    .then(response => response.json())
    .then(result => {
        for (var policeOffice of result) {
            var imageSrc = "./images/police_office_icon.png";
            var imageSize = new kakao.maps.Size(52, 52);
            var markerImage = new kakao.maps.MarkerImage(imageSrc, imageSize);
            var marker = new kakao.maps.Marker({
                map: map,
                position: new kakao.maps.LatLng(policeOffice.latitude, policeOffice.longitude),
                title: policeOffice.address,
                image: markerImage,
                opacity: 0.9,
                zIndex: 2
            });
        }
    });

// 거리 계산 (삭제 대상)
function getLength_toMouseEvent(latlng, callback) {
    fetch("./information/dist?latitude=" + latlng.Ma + "&longitude=" + latlng.La, {
        method: "get",
        headers: {
            "Content-Type": "application/json",
        },
    })
        .then(response => response.json())
        .then(result => {
            var polyline = new kakao.maps.Polyline({
                path: [
                    new kakao.maps.LatLng(result.latitude, result.longitude),
                    new kakao.maps.LatLng(latlng.Ma, latlng.La)
                ],
                strokeWeight: 0
            });
            callback(polyline.getLength());
        });	
}

export {getLength_toMouseEvent}
```

#### 4.9.2. 변경 후 (TO-BE)

```javascript
// 파출소 마커 표시 (유지)
fetch("./information/policeOffice", {
    method: "get",
    headers: {
        "Content-Type": "application/json",
    },
})
    .then(response => response.json())
    .then(result => {
        for (var policeOffice of result) {
            var imageSrc = "./images/police_office_icon.png";
            var imageSize = new kakao.maps.Size(52, 52);
            var markerImage = new kakao.maps.MarkerImage(imageSrc, imageSize);
            var marker = new kakao.maps.Marker({
                map: map,
                position: new kakao.maps.LatLng(policeOffice.latitude, policeOffice.longitude),
                title: policeOffice.address,
                image: markerImage,
                opacity: 0.9,
                zIndex: 2
            });
        }
    });

// getLength_toMouseEvent 함수 삭제
// export 구문 삭제
```

#### 4.9.3. 주요 변경 사항

- **유지:** 파출소 마커를 지도에 표시하는 로직 (지도 초기화 시 실행)
- **삭제:** getLength_toMouseEvent() 함수 - 거리 계산은 서버에서 수행
- **삭제:** export 구문

### 4.10. cctv.js (완전 삭제)

#### 4.10.1. 삭제 이유

```javascript
// 기존 코드 (전체 삭제 대상)
function getCCTV_toMouseEvent(latlng, callback) {
    fetch("./information/cctv?latitude=" + latlng.Ma + "&longitude=" + latlng.La, {
        method: "get",
        headers: {
            "Content-Type": "application/json",
        },
    })
        .then(response => response.json())
        .then(result => {
            callback(result.length);  // CCTV 개수만 반환
        });
}
```

이 파일은 CCTV 개수를 조회하는 역할만 수행했으나, 서버 응답 response.safetyScore.cctvCount에 이미 포함되어 불필요하다.

#### 4.10.2. 마이그레이션 체크리스트

- [ ] mouseEvent.js에서 `import { getCCTV_toMouseEvent } from "./cctv.js"` 제거
- [ ] informationPage.jsp에서 `<script type="module" src="<c:url value="/js/cctv.js"/>">` 제거
- [ ] cctv.js 파일 삭제

### 4.11. amenity.js (완전 삭제)

#### 4.11.1. 삭제 이유

```javascript
// 기존 코드 (전체 삭제 대상)
var ps = new kakao.maps.services.Places(map);

var categoryData = {
    'SW8': { data: [], weight: 10, minCount: 1 },
    'CS2': { data: [], weight: 10 },
    // ... 비즈니스 규칙이 클라이언트에 노출
};

function amenity_toMouseEvent(latlng, callback){
    // 카카오맵 API 직접 호출 (보안 문제)
    for (var key in categoryData) {
        promises.push(placesSearch(key, searchOption));
    }
    
    // 점수 계산 (비즈니스 로직)
    score += (parseInt(data.length) / 15) * categoryData[category].weight;
}
```

이 파일은 다음의 문제를 가지고 있어 완전 삭제한다:
- **API 키 노출:** 카카오맵 API를 클라이언트에서 직접 호출
- **비즈니스 로직 노출:** 편의성 점수 계산 공식과 가중치가 하드코딩됨
- **서버 중복:** 서버가 동일한 작업을 수행하므로 불필요

#### 4.11.2. 대체 방안

편의시설 마커 표시 기능이 필요한 경우, 서버 응답의 response.convenienceScore.amenityDetails[].places를 사용하여 새로운 함수를 작성한다.

```javascript
// 신규 작성: amenityMarker.js
var amenityMarkers = [];

function displayAmenityMarkers(places) {
    // 기존 마커 제거
    clearAmenityMarkers();
    
    // 서버 응답의 places 배열을 사용하여 마커 표시
    places.forEach(place => {
        var imageSrc = "./images/amenity_icon.png";
        var imageSize = new kakao.maps.Size(18, 26);
        var markerImage = new kakao.maps.MarkerImage(imageSrc, imageSize);
        
        var marker = new kakao.maps.Marker({
            map: map,
            position: new kakao.maps.LatLng(place.latitude, place.longitude),
            title: place.name,
            image: markerImage,
            zIndex: 1
        });
        
        amenityMarkers.push(marker);
    });
}

function clearAmenityMarkers() {
    amenityMarkers.forEach(marker => marker.setMap(null));
    amenityMarkers = [];
}

export { displayAmenityMarkers, clearAmenityMarkers };
```

#### 4.11.3. 마이그레이션 체크리스트

- [ ] mouseEvent.js에서 `import { amenity_toMouseEvent } from "./amenity.js"` 제거
- [ ] informationPage.jsp에서 `<script type="module" src="<c:url value="/js/amenity.js"/>">` 제거
- [ ] amenity.js 파일 삭제
- [ ] (선택) 편의시설 마커 표시가 필요한 경우 amenityMarker.js 신규 작성

### 4.12. getAddress.js (완전 삭제)

#### 4.12.1. 삭제 이유

이 파일은 좌표를 주소로 변환하는 역할을 수행했으나, 서버의 F006 기능(주소 변환 서비스)으로 이전되어 불필요하다. 서버 응답의 response.address에 이미 도로명/지번 주소가 포함되어 있다.

#### 4.12.2. 마이그레이션 체크리스트

- [ ] mouseEvent.js에서 관련 import 제거
- [ ] informationPage.jsp에서 해당 script 태그 제거
- [ ] getAddress.js 파일 삭제 (코드 미제공으로 추정)

---

## 5. 데이터 바인딩 명세

### 5.1. DTO 필드 → DOM 요소 매핑 테이블

| 서버 응답 필드 | DOM 선택자 | 바인딩 방식 | 예시 |
|---------------|-----------|------------|------|
| address.roadAddress | #addr | textContent | "서울특별시 중구 세종대로 110" |
| address.roadAddress | .detailAddr | innerHTML | "도로명 : ...<br>지번 : ..." |
| address.jibunAddress | .detailAddr | innerHTML | (도로명과 함께 표시) |
| safetyScore.policeDistance | #distance | textContent + " M" | "450 M" |
| safetyScore.cctvCount | #cctvPcs | textContent + " 개" | "23 개" |
| safetyScore.total | #safty (그래프) | moveGraph() | 그래프 너비 85% |
| convenienceScore.total | #conv (그래프) | moveGraph() | 그래프 너비 72% |
| overallScore | #total (그래프) | moveGraph() | 그래프 너비 78% |
| convenienceScore.amenityDetails[0-4].categoryName | #each1 ~ #each5 | textContent | "편의점", "카페", ... |
| recommendations[] | #link (목록) | 동적 <li> 생성 | "반경 500m 내 CCTV..." |
| warnings[] | alert() | 경고 메시지 표시 | "편의시설 정보 조회 실패" |

### 5.2. 바인딩 함수 구현

#### 5.2.1. 주소 정보 바인딩

```javascript
function bindAddressInfo(address) {
    if (!address) {
        document.querySelector("#addr").textContent = "주소 정보 없음";
        document.querySelector(".detailAddr").innerHTML = "도로명 : -<br>지번 : -";
        return;
    }
    
    document.querySelector("#addr").textContent = address.roadAddress || "주소 정보 없음";
    document.querySelector(".detailAddr").innerHTML = 
        `도로명 : ${address.roadAddress || '-'}<br>지번 : ${address.jibunAddress || '-'}`;
}
```

#### 5.2.2. 안전성 정보 바인딩

```javascript
function bindSafetyInfo(safetyScore) {
    if (!safetyScore) {
        document.querySelector("#distance").textContent = "- M";
        document.querySelector("#cctvPcs").textContent = "- 개";
        moveGraph(document.querySelector("#safty"), 0);
        return;
    }
    
    document.querySelector("#distance").textContent = safetyScore.policeDistance + ' M';
    document.querySelector("#cctvPcs").textContent = safetyScore.cctvCount + ' 개';
    moveGraph(document.querySelector("#safty"), safetyScore.total);
}
```

#### 5.2.3. 편의성 정보 바인딩

```javascript
function bindConvenienceInfo(convenienceScore) {
    if (!convenienceScore) {
        clearAmenities();
        moveGraph(document.querySelector("#conv"), 0);
        return;
    }
    
    moveGraph(document.querySelector("#conv"), convenienceScore.total);
    
    const amenityDetails = convenienceScore.amenityDetails || [];
    amenityDetails.slice(0, 5).forEach((amenity, index) => {
        const element = document.querySelector(`#each${index + 1}`);
        element.textContent = amenity.categoryName;
        element.style.color = '#3a80e9';
        
        // 클릭 시 해당 카테고리의 장소 마커 표시
        element.onclick = () => {
            displayAmenityMarkers(amenity.places);
            updateTip(amenity.categoryName, amenity.closestDistance);
        };
    });
    
    // 5개 미만인 경우 나머지 슬롯 초기화
    for (let i = amenityDetails.length; i < 5; i++) {
        document.querySelector(`#each${i + 1}`).textContent = '-';
    }
}

function clearAmenities() {
    for (let i = 1; i <= 5; i++) {
        document.querySelector(`#each${i}`).textContent = '-';
        document.querySelector(`#each${i}`).style.color = '#3a80e9';
    }
}

function updateTip(categoryName, distance) {
    const tip = document.querySelector(".tip");
    tip.innerHTML = `*가장 가까운 ${categoryName}까지 ${distance}m 입니다.`;
}
```

#### 5.2.4. 종합 점수 바인딩

```javascript
function bindOverallScore(overallScore) {
    if (overallScore === null || overallScore === undefined) {
        moveGraph(document.querySelector("#total"), 0);
        return;
    }
    
    moveGraph(document.querySelector("#total"), overallScore);
}
```

#### 5.2.5. 추천 근거 바인딩

```javascript
function bindRecommendations(recommendations) {
    const container = document.querySelector("#link");
    container.innerHTML = '';
    
    if (!recommendations || recommendations.length === 0) {
        const li = document.createElement('li');
        li.textContent = '추천 정보가 없습니다.';
        li.style.fontSize = '0.9rem';
        li.style.color = '#999';
        container.appendChild(li);
        return;
    }
    
    recommendations.forEach(text => {
        const li = document.createElement('li');
        li.textContent = '✓ ' + text;
        li.style.fontSize = '0.9rem';
        li.style.marginBottom = '8px';
        li.style.lineHeight = '1.4';
        container.appendChild(li);
    });
}
```

#### 5.2.6. 통합 바인딩 함수

```javascript
function updateCompleteUI(response) {
    bindAddressInfo(response.address);
    bindSafetyInfo(response.safetyScore);
    bindConvenienceInfo(response.convenienceScore);
    bindOverallScore(response.overallScore);
    bindRecommendations(response.recommendations);
}
```

---

## 6. 예외 처리 전략

### 6.1. 예외 상황 분류

| 예외 유형 | 발생 조건 | HTTP 코드 | analysisStatus | 클라이언트 처리 |
|----------|----------|-----------|----------------|----------------|
| 네트워크 오류 | 서버 미응답, 타임아웃 | - | - | catch 블록에서 처리 |
| 파라미터 오류 | 잘못된 좌표값 | 400 | - | 에러 메시지 표시 |
| 부분 성공 | 일부 데이터 조회 실패 | 200 | PARTIAL_SUCCESS | 가용 데이터 표시 + 경고 |
| 분석 불가 | 핵심 데이터 조회 실패 | 200 | ANALYSIS_FAILED | 분석 불가 메시지 표시 |
| 서버 오류 | 내부 서버 오류 | 500 | - | 일반 오류 메시지 표시 |

### 6.2. 예외 처리 코드

#### 6.2.1. 네트워크 오류 처리

```javascript
try {
    const response = await fetch('/api/location-analysis', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ latitude, longitude, radius: 500 })
    });
    
    if (!response.ok) {
        if (response.status === 400) {
            const error = await response.json();
            throw new Error(`잘못된 요청: ${error.message}`);
        } else if (response.status === 500) {
            throw new Error('서버 내부 오류가 발생했습니다.');
        } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
    }
    
    const data = await response.json();
    handleResponse(data);
    
} catch (error) {
    console.error('위치 분석 실패:', error);
    
    if (error.name === 'TypeError' && error.message.includes('fetch')) {
        showErrorMessage('네트워크 연결을 확인해주세요.');
    } else {
        showErrorMessage(error.message || '알 수 없는 오류가 발생했습니다.');
    }
}
```

#### 6.2.2. analysisStatus에 따른 분기 처리

```javascript
function handleResponse(data) {
    switch (data.analysisStatus) {
        case 'SUCCESS':
            updateCompleteUI(data);
            break;
            
        case 'PARTIAL_SUCCESS':
            updatePartialUI(data);
            if (data.warnings && data.warnings.length > 0) {
                showWarnings(data.warnings);
            }
            break;
            
        case 'ANALYSIS_FAILED':
            clearAllUI();
            showAnalysisFailedMessage();
            break;
            
        default:
            console.error('알 수 없는 analysisStatus:', data.analysisStatus);
            showErrorMessage('응답 형식이 올바르지 않습니다.');
    }
}
```

#### 6.2.3. 경고 메시지 표시 (PARTIAL_SUCCESS)

```javascript
function showWarnings(warnings) {
    const message = warnings.join('\n• ');
    
    alert(`⚠️ 일부 정보 조회 실패\n\n• ${message}\n\n가용한 정보만 표시됩니다.`);
}
```

#### 6.2.4. UI 초기화 함수

```javascript
function clearAllUI() {
    document.querySelector("#addr").textContent = "지도를 클릭 해 주세요.";
    document.querySelector(".detailAddr").innerHTML = "도로명 : -<br>지번 : -";
    document.querySelector("#distance").textContent = "- M";
    document.querySelector("#cctvPcs").textContent = "- 개";
    
    moveGraph(document.querySelector("#safty"), 0);
    moveGraph(document.querySelector("#conv"), 0);
    moveGraph(document.querySelector("#total"), 0);
    
    clearAmenities();
    document.querySelector("#link").innerHTML = '';
}
```

---

## 7. 구현 우선순위 및 마이그레이션 계획

### 7.1. 단계별 마이그레이션 전략

#### Phase 1: 준비 단계 (1일)

**목표:** 서버 API 통신 확인 및 기본 구조 구축

| 작업 | 담당 | 우선순위 |
|------|------|---------|
| 서버 통합 API 엔드포인트 동작 확인 | 백엔드 | 최우선 |
| mouseEvent.js 백업 생성 | 프론트 | 최우선 |
| 신규 analyzeLocation() 함수 작성 및 테스트 | 프론트 | 최우선 |

**체크리스트:**
- [ ] POST /api/location-analysis 엔드포인트가 정상 응답하는지 Postman으로 확인
- [ ] 응답 DTO 구조가 설계 명세서와 일치하는지 확인
- [ ] 기존 mouseEvent.js를 mouseEvent.js.backup으로 복사

#### Phase 2: 핵심 기능 전환 (2일)

**목표:** 단일 API 호출 및 기본 UI 바인딩 구현

| 작업 | 세부 내용 | 예상 시간 |
|------|----------|----------|
| mouseEvent.js 리팩토링 | - 개별 API 호출 제거<br>- 단일 fetch 구현<br>- 기본 UI 바인딩 함수 작성 | 4시간 |
| 바인딩 함수 작성 | - bindAddressInfo()<br>- bindSafetyInfo()<br>- bindConvenienceInfo() | 3시간 |
| 예외 처리 구현 | - try-catch 블록<br>- analysisStatus 분기 처리 | 2시간 |
| 기능 테스트 | - 정상 케이스<br>- 부분 성공 케이스 | 2시간 |

**체크리스트:**
- [ ] 지도 클릭 시 1회의 API 호출만 발생하는지 네트워크 탭에서 확인
- [ ] 안전성 점수, 편의성 점수, 종합 점수가 그래프에 정상 표시되는지 확인
- [ ] CCTV 개수, 파출소 거리가 정보 패널에 정상 표시되는지 확인

#### Phase 3: 파일 정리 및 최적화 (1일)

**목표:** 불필요한 파일 제거 및 코드 최적화

| 작업 | 세부 내용 |
|------|----------|
| 파일 삭제 | score.js, cctv.js, amenity.js, getAddress.js |
| import 정리 | mouseEvent.js에서 삭제된 파일들의 import 제거 |
| JSP 파일 수정 | informationPage.jsp에서 삭제된 파일들의 script 태그 제거 |
| policeOffice.js 수정 | getLength_toMouseEvent() 함수 및 export 제거 |

**체크리스트:**
- [ ] 브라우저 콘솔에 "Module not found" 에러가 없는지 확인
- [ ] 페이지 로딩 속도가 개선되었는지 확인 (불필요한 JS 파일 제거로 인한 효과)

#### Phase 4: 추가 기능 및 개선 (1일)

**목표:** 편의시설 마커 표시 등 부가 기능 구현

| 작업 | 세부 내용 |
|------|----------|
| amenityMarker.js 신규 작성 | 서버 응답의 places 배열로 마커 표시 기능 |
| 추천 근거 표시 | #link 영역에 동적 리스트 생성 |
| 로딩 인디케이터 | API 호출 중 로딩 스피너 표시 |

**체크리스트:**
- [ ] 편의시설 카테고리 클릭 시 해당 장소들이 지도에 마커로 표시되는지 확인
- [ ] 추천 근거가 #link 영역에 리스트로 표시되는지 확인
- [ ] API 호출 중 로딩 인디케이터가 표시되고, 완료 후 사라지는지 확인

---

## 8. 부록

### 8.1. 용어 정의

| 용어 | 정의 |
|------|------|
| DTO (Data Transfer Object) | 서버와 클라이언트 간 데이터 전송을 위한 객체 |
| Chatty Client | 클라이언트가 서버에 과도하게 많은 요청을 보내는 안티패턴 |
| Single Source of Truth | 데이터의 신뢰할 수 있는 단일 출처 원칙 |
| Presentation Layer | UI 표현만 담당하는 계층, 비즈니스 로직 미포함 |
| Declarative Binding | 선언적 방식으로 데이터와 UI를 연결하는 패턴 |

### 8.2. 참조 문서

| 문서명 | 설명 | 경로/링크 |
|--------|------|----------|
| 서버 설계 명세서 | 통합 API 엔드포인트 상세 명세 | 문서 3 |
| API 명세서 | LocationAnalysisResponseDTO 구조 | 서버 문서 참조 |
| 카카오맵 API 문서 | 지도 API 사용법 | https://apis.map.kakao.com |

---

## 문서 개정 이력

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|----------|
| 1.0 | 2025-10-10 | 개발팀 | 최초 작성 |

---