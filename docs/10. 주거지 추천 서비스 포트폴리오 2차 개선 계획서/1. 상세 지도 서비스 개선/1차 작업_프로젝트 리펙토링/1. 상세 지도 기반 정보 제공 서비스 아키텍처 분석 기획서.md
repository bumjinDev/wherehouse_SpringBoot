# 상세 지도 기반 정보 제공 서비스 아키텍처 분석 기획서

## 프로젝트 개요

**목표**: 데이터 부족함  
**핵심 질문**: "사용자는 클릭한 위치의 안전성과 편의성을 어떻게 파악하는가?"  
**접근 방식**: 다중 API 호출 기반 클라이언트 중심 데이터 처리 방식

---

## 현재 상태 분석

### 기존 아키텍처 분석

**컨트롤러 구조**
- `InformationController`: 4개의 개별 GET 엔드포인트로 데이터 분산 제공
- `/information/policeOffice`: 전체 파출소 목록 반환
- `/information/dist`: 특정 좌표 기준 가장 가까운 파출소 정보 반환
- `/information/cctv`: 특정 좌표 반경 내 CCTV 목록 반환
- `/information/rate`: 주소 기반 지역 평점(검거율) 정보 반환
- 각 엔드포인트는 `@RequestParam`으로 좌표 또는 주소 파라미터 수신

**서비스 레이어 구조**
- `InfoService`: 4개의 개별 데이터 조회 메서드 구현
- `getListPO()`: 전체 파출소 목록 조회
- `getClosestPO(latitude, longitude)`: 최단 거리 파출소 계산
- `getListCCTV(latitude, longitude)`: 반경 기반 CCTV 조회
- `getRate(address)`: 주소 기반 평점 조회
- 각 메서드는 독립적으로 Repository 계층 호출

**데이터베이스 구조**
- `police_office` 테이블: 주소, 위도, 경도 정보 저장
- `cctv` 테이블: 번호, 주소, 위도, 경도, 카메라 대수 정보 저장
- `addr_rate` 테이블: 주소별 평점(검거율) 정보 저장
- MyBatis Mapper 인터페이스로 데이터 접근 처리

**클라이언트 구조**
- `mouseEvent.js`: 지도 클릭 이벤트 총괄 제어 모듈
- `policeOffice.js`: 파출소 거리 정보 요청 및 마커 표시
- `cctv.js`: CCTV 목록 요청 및 마커 표시
- `amenity.js`: 카카오맵 API 직접 호출하여 편의시설 조회
- `score.js`: 안전성 점수 계산 로직 포함
- `graph.js`: 점수 시각화 처리
- `marker.js`, `circle.js`: 지도 UI 요소 관리

### 기존 비즈니스 로직의 상세 분석

**클라이언트 측 데이터 처리 흐름**
```javascript
// 1단계: 지도 클릭 이벤트 발생
kakao.maps.event.addListener(map, 'click', function(mouseEvent) {
    var latlng = mouseEvent.latLng;
    
    // 2단계: 개별 API 호출 (병렬)
    - getLength_toMouseEvent(latlng)    // 파출소 거리
    - getCCTV_toMouseEvent(latlng)      // CCTV 목록
    - amenity_toMouseEvent(latlng)      // 편의시설 (외부 API)
    - getAddr_toMouseEvent(latlng)      // 주소 변환 후 평점 조회
    
    // 3단계: 클라이언트에서 점수 계산
    saftyScore([distFunction, cctvFunction, arrestRateFunction], ...)
    
    // 4단계: 그래프 시각화
    moveGraph(safty, value)
    moveGraph(conv, value)
    moveGraph(total, value)
});
```

**안전성 점수 계산 로직 (mouseEvent.js)**
```javascript
// 거리 점수 계산
if (result < 1000) { 
    distScore = (1 / Math.log(result + 150))/0.2; 
}
else if (result < 1743 && result >= 1000) { 
    distScore = (1 / Math.log(result - 850))/0.5; 
}
else { 
    distScore = (1 / Math.log(result - 1700)); 
}

// CCTV 점수 계산
cctvScore = Math.min(result/300, 1);

// 최종 안전성 점수
value = distScore*60 + cctvScore*30 + arrestRate*10;
```

**편의성 점수 계산 로직 (amenity.js)**
```javascript
// 15개 카테고리별 가중치 적용
categoryData = {
    'SW8': { weight: 10, minCount: 1 },  // 지하철역
    'CS2': { weight: 10 },                // 편의점
    'FD6': { weight: 10 },                // 음식점
    // ... 총 15개 카테고리
};

// 점수 계산
score += (parseInt(data.length) / 15) * categoryData[category].weight;
if (categoryData[category].minCount && data.length > minCount) {
    score += minCount;
}
```

### 기존 로직의 구체적 문제점

| 구현 부분 | 현재 로직 | 문제점 | 비즈니스 영향 |
|-----------|-----------|--------|---------------|
| **API 호출 구조** | 클라이언트가 4개 이상의 개별 API 호출 | 네트워크 왕복 과다, Chatty Client 패턴 | 응답 지연, 네트워크 비용 증가 |
| **비즈니스 로직 위치** | 점수 계산 로직이 클라이언트(mouseEvent.js, score.js)에 존재 | 관심사 분리 원칙 위배, 로직 재사용 불가 | 모바일 등 다른 클라이언트 확장 불가 |
| **점수 계산 방식** | 하드코딩된 가중치 (`distScore*60 + cctvScore*30`) | 가중치 변경 시 클라이언트 배포 필요 | 비즈니스 규칙 변경 유연성 부족 |
| **외부 API 의존성** | 카카오맵 API를 클라이언트에서 직접 호출 | 외부 API 장애 시 클라이언트 에러, API 키 노출 | 보안 취약, 장애 전파 |
| **데이터 조합 책임** | 클라이언트가 원본 데이터(Raw Data)를 수신하여 조합 | 클라이언트 로직 복잡도 증가 | 유지보수 어려움, 버그 발생 가능성 증가 |
| **에러 처리** | 개별 API 호출별 독립적 에러 처리 | 부분 실패 시 일관성 없는 결과 표시 | 사용자 경험 저하 |
| **캐싱 전략** | 없음 (매번 새로운 요청) | 동일 위치 재클릭 시 중복 조회 | 서버 부하, 응답 속도 저하 |
| **마법 숫자** | `result < 1000`, `result/300`, `weight: 10` 등 하드코딩 | 의미 불명확, 변경 시 추적 어려움 | 코드 가독성 저하, 유지보수 비용 증가 |

### 기존의 기술적 한계점

**데이터 모델 제약**
- VO 클래스가 단순 getter/setter만 제공, 비즈니스 로직 없음
- 좌표 기반 거리 계산이 클라이언트 측에서 Polyline으로 처리됨
- CCTV 개수 합산, 편의시설 개수 집계 등 집계 연산이 클라이언트에서 수행됨

**쿼리 로직 문제**
- Repository 인터페이스만 존재, 실제 SQL 쿼리 내용 확인 불가
- 좌표 기반 반경 검색의 성능 최적화 여부 불명
- 대량 데이터 조회 시 페이징 처리 없음

**확장성 제약**
- 새로운 안전 요소(가로등, 비상벨 등) 추가 시 클라이언트 전체 수정 필요
- 점수 계산 알고리즘 변경 시 배포 비용 발생
- 다른 플랫폼(모바일 앱)에서 동일 로직 재사용 불가능

**성능 문제**
- 지도 클릭마다 최소 4-5회 네트워크 요청 발생
- 카카오맵 API 호출이 15개 카테고리에 대해 순차 실행 (`Promise.all`로 병렬 처리하나 여전히 다수 호출)
- 마커 생성/삭제가 매 클릭마다 반복되어 메모리 부담

### 개선 목표

**1차 목표: 아키텍처 리팩토링**
- 클라이언트의 데이터 조합 책임을 서버로 이전
- 단일 통합 API 엔드포인트 구축
- 비즈니스 로직의 서버 측 중앙화

**2차 목표: 성능 고도화**  
- 네트워크 호출 횟수 최소화 (N회 → 1회)
- 서버 측 캐싱 전략 도입
- 데이터베이스 쿼리 최적화

---

## 새로운 비즈니스 로직 설계

### 통합 API 방식 상세 설명

**단일 진입점 설계**
사용자가 지도를 클릭하면 클라이언트는 좌표 정보만을 담아 하나의 통합 API 엔드포인트(`POST /api/location-analysis`)로 요청을 전송한다. 서버는 이 단일 요청을 받아 내부적으로 필요한 모든 데이터를 조회하고 계산하여 완성된 응답 객체를 반환한다.

**서버 측 데이터 처리 흐름**
1. 좌표 수신 및 검증
2. 병렬 데이터 조회 (파출소, CCTV, 주소 변환, 평점, 편의시설)
3. 서버 내부에서 점수 계산 (안전성, 편의성, 종합)
4. 통합 DTO 구성 및 반환

**클라이언트 역할 변경**
기존의 "데이터 요청 → 수신 → 계산 → 표시" 프로세스를 "데이터 요청 → 수신 → 표시"로 단순화한다. 클라이언트는 더 이상 비즈니스 로직을 수행하지 않고 오직 UI 바인딩만 담당한다.

### 핵심 비즈니스 규칙

**통합 데이터 모델 (LocationAnalysisResponseDTO)**
```
{
  "coordinate": { "latitude": 37.xxx, "longitude": 127.xxx },
  "address": { "roadAddress": "...", "jibunAddress": "..." },
  "safetyScore": {
    "total": 85,
    "policeDistance": 450,
    "cctvCount": 23,
    "arrestRate": 0.87
  },
  "convenienceScore": {
    "total": 72,
    "nearestSubway": { "name": "신촌역", "distance": 320 },
    "amenities": [...]
  },
  "overallScore": 78,
  "recommendations": ["반경 500m 내 CCTV 23대 설치", "...]
}
```

**점수 계산 규칙 서버화**
현재 클라이언트에 하드코딩된 점수 계산 로직을 서버의 전략 패턴 기반 계산기로 이전한다. 각 요소별 가중치와 계산 공식을 데이터베이스 또는 설정 파일로 외부화하여 유연성을 확보한다.

**캐싱 전략**
동일 좌표에 대한 반복 요청을 방지하기 위해 서버 측에서 캐싱을 적용한다. 좌표 기반 해시키로 일정 시간(예: 5분) 동안 계산 결과를 메모리에 보관한다.

---

## 구현해야 할 핵심 기능

### 1. 통합 API 엔드포인트 구축

**단일 요청 처리 컨트롤러**
기존의 4개 분산 엔드포인트를 대체하는 단일 POST 엔드포인트를 신설한다. 클라이언트로부터 좌표 정보를 포함한 요청 DTO를 수신하고, 서비스 계층에서 처리된 통합 응답 DTO를 반환한다.

**요청 DTO 설계**
```
LocationAnalysisRequestDTO {
  double latitude;
  double longitude;
  int radius = 500;  // 기본값
}
```

**응답 DTO 설계**
안전성 점수, 편의성 점수, 종합 점수, 상세 근거 메시지, 주소 정보, 편의시설 목록 등 클라이언트가 필요로 하는 모든 데이터를 포함하는 완전한 형태의 응답 객체를 설계한다.

### 2. 서비스 계층 통합 로직 구현

**병렬 데이터 조회 처리**
기존의 순차적 Repository 호출 방식을 병렬 처리로 전환한다. `CompletableFuture` 또는 `@Async`를 활용하여 파출소, CCTV, 평점 정보를 동시에 조회하여 응답 시간을 단축한다.

**점수 계산 서비스 구현**
```
SafetyScoreCalculator {
  calculateDistanceScore(double distance)
  calculateCctvScore(int cctvCount)
  calculateArrestRateScore(double rate)
  calculateTotalSafetyScore(...)
}

ConvenienceScoreCalculator {
  calculateAmenityScore(List<Amenity> amenities)
  calculateSubwayScore(int distance)
  calculateTotalConvenienceScore(...)
}
```

**외부 API 통합 (카카오맵)**
클라이언트에서 직접 호출하던 카카오맵 API를 서버 측 RestTemplate 또는 WebClient로 이전한다. API 키를 서버 환경 변수로 보호하고, 에러 처리를 중앙화한다.

### 3. 데이터 접근 계층 최적화

**단일 쿼리 조회 최적화**
데이터 부족함

**공간 인덱스 활용**
데이터 부족함

### 4. 클라이언트 리팩토링

**mouseEvent.js 단순화**
```javascript
// Before: 4-5개 개별 API 호출 + 점수 계산
kakao.maps.event.addListener(map, 'click', async function(mouseEvent) {
    const response = await fetch('/api/location-analysis', {
        method: 'POST',
        body: JSON.stringify({
            latitude: mouseEvent.latLng.Ma,
            longitude: mouseEvent.latLng.La
        })
    });
    const data = await response.json();
    
    // 단순 UI 바인딩만 수행
    updateUI(data);
});
```

**score.js 제거**
점수 계산 로직이 서버로 이전되므로 클라이언트의 score.js 파일 전체를 제거하거나 단순 UI 헬퍼 함수만 남긴다.

**graph.js 역할 제한**
서버로부터 받은 최종 점수값을 그대로 그래프 너비로 변환하는 순수 시각화 로직만 유지한다.

---

## UI/UX 연동 방식 및 정보 표시 전략

### 단일 응답 기반 정보 표시

**좌측 정보 패널**
서버 응답의 `safetyScore`, `convenienceScore`, `overallScore` 필드값을 직접 읽어와 그래프 너비를 설정한다. 더 이상 클라이언트에서 계산이나 조합 작업을 수행하지 않는다.

**상세 정보 섹션**
- CCTV 개수: `data.safetyScore.cctvCount` 직접 표시
- 파출소 거리: `data.safetyScore.policeDistance` 직접 표시
- 주소 정보: `data.address.roadAddress` 직접 표시
- 편의시설 목록: `data.convenienceScore.amenities` 배열 순회하여 표시

**마커 및 서클 표시**
기존 로직 유지. 단, 마커 위치와 서클 반경은 서버 응답의 검증된 좌표값을 사용한다.

### 추천 근거 표시

**근거 메시지 생성**
서버 응답의 `recommendations` 배열에 사전 생성된 추천 근거 문구가 포함되어 있다. 클라이언트는 이를 그대로 화면에 나열한다.

예시:
```
data.recommendations = [
  "반경 500m 내 CCTV 23대 설치되어 야간 안전성 우수",
  "가장 가까운 파출소까지 450m로 치안 접근성 양호",
  "지하철역 도보 5분 거리로 대중교통 편리"
]
```

**에러 및 경고 메시지**
서버에서 일부 데이터 조회 실패 시 응답 DTO에 경고 메시지 포함. 클라이언트는 이를 사용자에게 안내한다.

---

## 구현 기능 목록 및 상세 설계

### 핵심 구현 기능 목록

| 기능 ID | 기능명 | 설명 | 입력 | 출력 | 기술적 요구사항 |
|---------|--------|------|------|------|----------------|
| **F001** | 통합 API 엔드포인트 | 단일 POST 요청으로 모든 정보 제공 | 위도, 경도, 반경 | LocationAnalysisResponseDTO | Spring MVC, JSON 직렬화 |
| **F002** | 병렬 데이터 조회 | 파출소, CCTV, 평점 정보 동시 조회 | 좌표 정보 | 3개 데이터셋 | CompletableFuture 또는 @Async |
| **F003** | 안전성 점수 계산 서비스 | 거리, CCTV, 검거율 기반 점수 산출 | 원본 데이터 | 안전성 점수 객체 | 전략 패턴, 가중치 외부화 |
| **F004** | 편의성 점수 계산 서비스 | 편의시설 개수 및 거리 기반 점수 산출 | 편의시설 목록 | 편의성 점수 객체 | 카테고리별 가중치 설정 |
| **F005** | 카카오맵 API 서버 통합 | 외부 API 호출을 서버로 이전 | 좌표, 반경, 카테고리 | 편의시설 목록 | RestTemplate/WebClient, API 키 보호 |
| **F006** | 주소 변환 서비스 | 좌표를 도로명/지번 주소로 변환 | 위도, 경도 | 주소 문자열 | 카카오맵 Geocoding API |
| **F007** | 추천 근거 생성기 | 점수 기반 추천 이유 문구 자동 생성 | 계산된 점수들 | 추천 근거 문자열 배열 | 템플릿 기반 메시지 생성 |
| **F008** | 응답 캐싱 | 동일 좌표 재요청 시 캐시 반환 | 좌표 해시키 | 캐시된 응답 DTO | Spring Cache 또는 Redis |
| **F009** | 클라이언트 단순화 | 비즈니스 로직 제거, UI 바인딩만 수행 | 서버 응답 DTO | 화면 갱신 | Fetch API, DOM 조작 |
| **F010** | 에러 처리 중앙화 | 부분 실패 시에도 가용 정보 반환 | 각 조회 결과 | 경고 포함 응답 | try-catch, Optional 활용 |

### 세부 기능 설계

**F001: 통합 API 엔드포인트**
- 엔드포인트: `POST /api/location-analysis`
- 요청 DTO: `{ latitude: double, longitude: double, radius: int }`
- 응답 DTO: 안전성/편의성/종합 점수, 주소, 편의시설 목록, 추천 근거, 경고 메시지
- 검증: 좌표 범위 검증, 반경 최대값 제한

**F002: 병렬 데이터 조회**
- 구현 방식: `CompletableFuture.allOf()` 사용
- 조회 대상: 파출소 거리, CCTV 목록, 주소별 평점, 편의시설
- 타임아웃: 각 조회당 최대 3초, 전체 최대 5초
- 실패 처리: 부분 실패 시에도 가용한 데이터로 응답 구성

**F003: 안전성 점수 계산 서비스**
- 거리 점수: 로그 함수 기반 변환 (기존 로직 이전)
- CCTV 점수: 300대 기준 정규화
- 검거율 점수: 평점 직접 사용
- 가중치: 거리 60%, CCTV 30%, 검거율 10%
- 최종 점수: 0-100 범위로 정규화

**F004: 편의성 점수 계산 서비스**
- 카테고리별 가중치 적용 (지하철역 10점, 편의점 10점, ...)
- 개수 기반 점수 + 최소 개수 충족 보너스
- 최종 점수: 0-100 범위로 정규화

**F005: 카카오맵 API 서버 통합**
- WebClient 비동기 호출 구현
- API 키를 환경 변수 또는 설정 파일로 관리
- 15개 카테고리 병렬 조회
- 응답 캐싱 (카테고리별 5분)

**F006: 주소 변환 서비스**
- 카카오맵 Geocoding API 호출
- 좌표 → 도로명/지번 주소 변환
- 실패 시 좌표값 그대로 반환

**F007: 추천 근거 생성기**
- 안전성 우수: "반경 500m 내 CCTV {count}대 설치"
- 편의성 우수: "지하철역 도보 {distance}m 거리"
- 파출소 근접: "가장 가까운 파출소까지 {distance}m"
- 템플릿 기반 메시지 조합

**F008: 응답 캐싱**
- 캐시 키: 좌표 해시 (소수점 4자리 반올림)
- 캐시 TTL: 5분
- 캐시 무효화: 데이터 업데이트 시
- 구현: Spring Cache Abstraction 또는 Redis

**F009: 클라이언트 단순화**
- mouseEvent.js: 단일 fetch 호출 + UI 업데이트만 수행
- score.js: 제거 또는 UI 헬퍼로 축소
- 개별 API 호출 함수 제거 (policeOffice.js, cctv.js 일부 로직)
- graph.js: 서버 점수값 직접 반영

**F010: 에러 처리 중앙화**
- 각 데이터 조회 실패 시 null 대신 Optional 반환
- 부분 실패 시에도 가용 데이터로 응답 구성
- 응답 DTO에 warnings 필드 추가
- 예시: `warnings: ["CCTV 정보 조회 실패", ...]`

---