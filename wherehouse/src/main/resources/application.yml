spring:
  application:
    name: wherehouse

  # 데이터베이스 연결 설정
  datasource:
    # [수정: P6Spy 적용] JDBC 드라이버 교체 (Driver Wrapping)
    # 기술적 원리: JDBC 인터페이스 구현체를 P6Spy로 교체(Swap)하여 SQL 실행 흐름을 제어합니다.
    # 기존 'oracle.jdbc.OracleDriver' 대신 'P6SpyDriver'가 애플리케이션의 연결 요청을 1차적으로 수신(Intercept)합니다.
#    driver-class-name: com.p6spy.engine.spy.P6SpyDriver

    # [수정: P6Spy 적용] 프로토콜 식별자 변경
    # URL 스키마에 'p6spy'를 추가하여 Java DriverManager가 P6Spy 드라이버를 선택하도록 강제합니다.
    # P6Spy는 내부적으로 'p6spy' 문자열을 제거한 원본 URL을 파싱하여 실제 DB와 연결을 맺습니다.
#    url: jdbc:p6spy:oracle:thin:@127.0.0.1:1521:xe # Oracle SID 기반 URL (로컬 서버)
    url: jdbc:oracle:thin:@127.0.0.1:1521:xe
#    url: jdbc:oracle:thin:@61.75.54.208:1521:xe # Minipc
    username: SCOTT
    password: ${ORACLE_PASSWORD}  # 환경변수에서 로드

    # HikariCP 커넥션 풀 설정
    hikari:
      auto-commit: false
      idle-timeout: 30000
      max-lifetime: 1800000
      # 추가: 커넥션이 끊기지 않도록 주기적으로 신호 전송 (10초)
      keepalive-time: 10000
      # 수정: 실제 로직 수행 시간을 고려하여 임계값 조정 (예: 60초)
      leak-detection-threshold: 60000
      maximum-pool-size: 6
      # [수정] Direct Buffer Memory OOM 해결
      # 기존: SDU 2MB, RECV/SEND_BUF 4MB → 커넥션 6개 기준 ~60MB Direct Memory 점유
      # 변경: SDU 32KB, RECV/SEND_BUF 64KB → 커넥션 6개 기준 ~0.75MB Direct Memory 점유
      # 로컬 개발 환경의 일반 OLTP 쿼리에서는 기본값으로 충분하며,
      # 대용량 LOB/bulk select가 아닌 이상 과도한 버퍼는 Netty Direct Memory와 충돌함
      data-source-properties:
        oracle.net.SDU: 32768            # 32KB (기존 2MB)
        oracle.net.RECV_BUF_SIZE: 65536  # 64KB (기존 4MB)
        oracle.net.SEND_BUF_SIZE: 65536  # 64KB (기존 4MB)
    dbcp2:
      validation-query: SELECT 1


  # Redis 연결 설정
  data:
    redis:
      host: 61.75.54.208 # MiniPc
#      host: 127.0.0.1  # Local(no 127.0.0.1)
#      host: 43.202.178.156 # (aws - 확인 완료)
      port: 6379
      password: ${REDIS_PASSWORD} #MiniPC / Local 은 패스워드 없음
      timeout: 10s
      connect-timeout: 10s    # 이거 추가
      lettuce:
        pool:
          # [수정] Direct Buffer Memory OOM 해결
          # Lettuce는 Netty 기반이므로 커넥션마다 Direct Buffer 청크(4MB)를 할당함
          # max-active: 100이면 최악의 경우 400MB Direct Memory 필요 → -Xmx256m 환경에서 즉시 OOM
          # 로컬 개발 환경에서는 8개면 충분함
          max-active: 8     # 동시에 처리 가능한 최대 요청 개수 (기존 100)
          max-idle: 4        # 최대 유휴 커넥션 개수 (기존 50)
          min-idle: 2        # 최소 유휴 커넥션 개수 (기존 10)
          max-wait: -1ms     # 무제한 대기 설정 (-1ms)
          time-between-eviction-runs: 10s  # 유휴 커넥션 정리 주기 (10초)

  # Jackson JSON 처리 설정 (추가)
  jackson:
    # ========== JSON 직렬화/역직렬화 핵심 설정 ==========

    # 프로퍼티 명명 전략: Java camelCase를 JSON snake_case로 변환
    # 예: budgetMin(Java) → budget_min(JSON)
    # CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES도 동일한 효과
    property-naming-strategy: SNAKE_CASE

    # null 값 처리: null인 필드는 JSON 응답에서 제외
    # 장점: 응답 크기 감소, 클라이언트 파싱 간소화
    # 단점: 클라이언트가 null과 누락을 구분할 수 없음
    default-property-inclusion: NON_NULL

    # 날짜/시간 기본 포맷 설정 (문자열로 변환될 때 사용)
    date-format: "yyyy-MM-dd HH:mm:ss"
    time-zone: Asia/Seoul

    # ========== JSON → Java 객체 변환 (Deserialization) 설정 ==========
    deserialization:
      # 알 수 없는 프로퍼티 처리: true이면 에러 발생, false면 무시
      # true 권장 이유: 잘못된 요청 데이터 조기 발견, API 계약 명확화
      # 동작: 클라이언트가 {"unknownField": "value"} 보내면 400 에러 응답
      fail-on-unknown-properties: true

      # 빈 문자열을 null로 변환하지 않음
      # false: ""와 null을 구분해서 처리
      # true: ""를 null로 자동 변환
      accept-empty-string-as-null-object: false

      # 빈 배열/컬렉션을 null로 변환하지 않음
      accept-empty-array-as-null-object: false

    # ========== Java 객체 → JSON 변환 (Serialization) 설정 ==========
    serialization:
      # 날짜를 timestamp(숫자) 대신 문자열로 출력
      # false: "2024-03-15 10:30:45" (가독성 좋음)
      # true: 1710472245000 (숫자 timestamp)
      write-dates-as-timestamps: false

      # 빈 객체 직렬화 실패 무시
      # false: 빈 객체도 {}로 정상 출력
      # true: 빈 객체 직렬화 시 에러 발생
      fail-on-empty-beans: false

      # Map을 정렬된 순서로 출력 (디버깅 시 유용)
      order-map-entries-by-keys: true

  # JPA/Hibernate 설정
  jpa:
    hibernate:
      ddl-auto: none # 개발 환경에서는 update, 운영 환경에서는 none 추천
    properties:
      hibernate:
        dialect: org.hibernate.dialect.OracleDialect # Hibernate Dialect 설정
        format_sql: true # SQL 포맷 정리
        default_batch_fetch_size: 50 # Batch Fetch 최적화
        jdbc.fetch_size: 100 # JDBC fetch size 설정
        cache.use_query_cache: false # Hibernate Query 캐시 비활성화
        physical_naming_strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl # Naming Strategy 설정
    open-in-view: false # Lazy Loading 오류 방지 (OSIV OFF)

  # Spring MVC 설정
  mvc:
    view:
      prefix: /WEB-INF/view/
      suffix: .jsp

    # URL 패턴 매칭 전략 설정
    pathmatch:
      # ANT 패턴 매처 사용 (/api/test/** 같은 패턴 지원)
      matching-strategy: ANT_PATH_MATCHER

  # 멀티파트 파일 업로드 설정
  servlet:
    multipart:
      max-file-size: 10MB      # 단일 파일 최대 크기
      max-request-size: 10MB   # 전체 요청 최대 크기

# [추가] P6Spy 상세 로깅 설정 (p6spy-spring-boot-starter)
# 가로챈(Intercepted) SQL 정보를 콘솔에 어떻게 출력할지 정의합니다.
#decorator:
#  datasource:
#    p6spy:
#      enable-logging: false # 로깅 활성화 (운영 환경에서는 false 권장)
#      multiline: true      # SQL을 보기 좋게 줄바꿈(Pretty Print)하여 출력
#      logging: slf4j       # Spring Boot의 기본 로깅 시스템(Logback)에 출력을 위임

# 서버 설정
server:
  tomcat:
    threads:
      max: 200
  port: 8185
  servlet:
    context-path: /wherehouse # 이 설정은 내장 톰켓 환경에서만 유효하며 외장 톰켓 환경에서는 server.xml을 따르거나 /opt /tomcat/webapps 내 실제 .war 로 배포된 결과의 디렉토리 이름을 따름.

  # HTTP 에러 응답 설정
  error:
    # validation 에러 메시지를 응답에 포함
    include-message: always
    # binding 에러 상세 정보 포함 (개발 환경에서 유용)
    include-binding-errors: always

# API 지점 설정
# Kakao API 설정
kakao:
  api:
    sdk-key: ${KAKAO_API_KEY}
    javascript-key: ${KAKAO_JAVASCRIPT_KEY}

# 국토부 API 설정
molit:
  rent-api:
    base-url: https://apis.data.go.kr/1613000/RTMSDataSvcAptRent

# 로깅 설정
logging:
  file:
#    name: log/wherehouse.log  # 프로젝트 루트 디렉토리를 기준으로 상대경로로써 로그 파일 위치 설정
    name: /opt/tomcat/logs/wherehouse.log  # 배포 위치
  level:
    root: info
    com.zaxxer.hikari.pool: DEBUG
    com.zaxxer.hikari.HikariConfig: DEBUG
    io.lettuce.core: WARN
#    io.lettuce.core: info
# 로그 출력 형식 설정
  pattern:
    console: "%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"

# ========== Jackson 설정이 실제 동작하는 시점 ==========
#
# 1. 요청 처리 시 (JSON → Java 객체)
#    - 클라이언트가 JSON 요청 전송
#    - Jackson이 deserialization 설정에 따라 변환
#    - fail-on-unknown-properties: true 설정으로 잘못된 필드 차단
#    - @Valid 어노테이션이 Bean Validation 실행
#    - 검증 실패 시 MethodArgumentNotValidException 발생
#
# 2. 응답 처리 시 (Java 객체 → JSON)
#    - Controller에서 응답 객체 반환
#    - Jackson이 serialization 설정에 따라 JSON 변환
#    - property-naming-strategy: SNAKE_CASE로 필드명 변환
#    - default-property-inclusion: NON_NULL로 null 필드 제외
#    - write-dates-as-timestamps: false로 날짜를 문자열 형태로 출력
#
# 3. 에러 발생 지점
#    - JSON 파싱 에러: HttpMessageNotReadableException
#    - Bean Validation 에러: MethodArgumentNotValidException
#    - 모든 예외는 GlobalExceptionHandler가 처리하여 일관된 에러 응답 제공